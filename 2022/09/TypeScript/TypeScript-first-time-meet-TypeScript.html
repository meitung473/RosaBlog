<!DOCTYPE html><html lang="zh-TW"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/shan-logo-appletouch.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/shan-logo.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/shan-logo-16X16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><script class="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"blog.rosa.tw",root:"/",scheme:"Gemini",version:"8.0.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,"Pisces | Gemini":240},copycode:!0,bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"buttons",active:!0,storage:!0,lazyload:!0,nav:{disqus:{text:"留言區",order:-1}},"Available values":"disqus"},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"fadeInDown",post_body:"fadeInDown",coll_header:"fadeInLeft",sidebar:"fadeInUp"}},prism:!1,i18n:{placeholder:"搜尋...",empty:"We didn't find any results for the search: ${query}",hits_time:"${hits} results found in ${time} ms",hits:"${hits} results found"},path:"search.xml",localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-S8ZEBJDRWG"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-S8ZEBJDRWG")</script><meta name="description" content="影片連結 :  Live 🔴: TypeScript Crash Course with Matt Pocock - YouTube  摘要 跟著 Matt Pocock 從基礎學習 TypeScript。一直都想學習 TypeScript，我只知道他是有型別的 JavaScript，避免 JavaScript 包山包海亂變形的詭異問題。 擇日不如撞日，剛好 vscode 官方熱騰騰的教學出來"><meta property="og:type" content="article"><meta property="og:title" content="筆記 | TypeScript - 初探 TypeScript"><meta property="og:url" content="https://blog.rosa.tw/2022/09/TypeScript/TypeScript-first-time-meet-TypeScript"><meta property="og:site_name" content="健忘雜記"><meta property="og:description" content="影片連結 :  Live 🔴: TypeScript Crash Course with Matt Pocock - YouTube  摘要 跟著 Matt Pocock 從基礎學習 TypeScript。一直都想學習 TypeScript，我只知道他是有型別的 JavaScript，避免 JavaScript 包山包海亂變形的詭異問題。 擇日不如撞日，剛好 vscode 官方熱騰騰的教學出來"><meta property="og:locale" content="zh_TW"><meta property="og:image" content="https://i.imgur.com/U9tQhV3.png"><meta property="og:image" content="https://i.imgur.com/Oo0jcFb.png"><meta property="og:image" content="https://i.imgur.com/lrmjp2a.png"><meta property="og:image" content="https://i.imgur.com/5iQbhoa.png"><meta property="og:image" content="https://i.imgur.com/upuhvfl.png"><meta property="og:image" content="https://i.imgur.com/Bm3d7Ul.png"><meta property="article:published_time" content="2022-09-06T20:25:55.000Z"><meta property="article:modified_time" content="2022-09-08T01:27:09.407Z"><meta property="article:author" content="Rosa Hong"><meta property="article:tag" content="TypeScript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://i.imgur.com/U9tQhV3.png"><link rel="canonical" href="https://blog.rosa.tw/2022/09/TypeScript/TypeScript-first-time-meet-TypeScript.html"><script class="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-TW"}</script><title>筆記 | TypeScript - 初探 TypeScript | 健忘雜記</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-S8ZEBJDRWG"></script><script>if(CONFIG.hostname===location.hostname){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-S8ZEBJDRWG")}</script><noscript><style>body{margin-top:2rem}.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header,.use-motion .sidebar{visibility:visible}.use-motion .footer,.use-motion .header,.use-motion .site-brand-container .toggle{opacity:initial}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line{transform:scaleX(1)}.search-pop-overlay,.sidebar-nav{display:none}.sidebar-panel{display:block}</style></noscript><link rel="alternate" href="/atom.xml" title="健忘雜記" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切換導航欄"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">健忘雜記</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">紀錄學習與生活</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首頁</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 標籤<span class="badge">27</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分類<span class="badge">18</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 歸檔<span class="badge">59</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜尋</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜尋..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目錄</li><li class="sidebar-nav-overview"> 本站概要</li></ul><section class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%98%E8%A6%81-6"><span class="nav-number">1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E4%BD%9C%E6%A5%AD"><span class="nav-number">2.</span> <span class="nav-text">前置作業</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B0%A1%E5%96%AE%E8%AA%8D%E8%AD%98-TypeScript"><span class="nav-number">3.</span> <span class="nav-text">簡單認識 TypeScript</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%9E%E9%8C%AF%E8%AA%A4%E6%89%BE%E8%A8%8A%E6%81%AF"><span class="nav-number">4.</span> <span class="nav-text">從錯誤找訊息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TypeScript-error-Translator"><span class="nav-number">5.</span> <span class="nav-text">TypeScript error Translator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%AD%A3%E9%8C%AF%E8%AA%A4-%E6%AD%A3%E7%A2%BA%E6%8C%87%E5%87%BA%E5%9E%8B%E5%88%A5"><span class="nav-number">6.</span> <span class="nav-text">修正錯誤 : 正確指出型別</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TS-%E7%82%BA%E4%BB%80%E9%BA%BC%E5%9C%A8-function-%E8%A3%A1%E4%B8%8D%E6%9C%83%E8%87%AA%E5%8B%95%E6%8C%87%E5%90%91%E6%AD%A3%E7%A2%BA%E7%9A%84%E5%9E%8B%E5%88%A5"><span class="nav-number">7.</span> <span class="nav-text">TS 為什麼在 function 裡不會自動指向正確的型別 ?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%B0%88%E6%A1%88%E4%B8%AD%E6%89%BE%E5%87%BA%E8%A6%81%E4%BF%AE%E6%AD%A3%E7%9A%84-TS-%E6%AA%94%E6%A1%88"><span class="nav-number">8.</span> <span class="nav-text">在專案中找出要修正的 TS 檔案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%BD%E4%BD%BF%E7%94%A8-any-%E6%9C%83%E6%80%8E%E9%BA%BC%E6%A8%A3%E5%97%8E"><span class="nav-number">9.</span> <span class="nav-text">都使用 any 會怎麼樣嗎 ?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E9%BA%BC%E6%99%82%E5%80%99%E7%94%A8-any"><span class="nav-number">9.1.</span> <span class="nav-text">什麼時候用 any ?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%9C%E5%85%85-any-v-s-unknown"><span class="nav-number">9.2.</span> <span class="nav-text">補充 : any v.s unknown</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TS-%E5%9C%A8-runtime-%E4%B8%AD%E4%B8%8D%E6%9C%83%E6%9C%89%E4%BB%BB%E4%BD%95%E4%BD%9C%E7%94%A8"><span class="nav-number">10.</span> <span class="nav-text">TS 在 runtime 中不會有任何作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E5%82%B3%E5%80%BC%E5%8A%A0%E4%B8%8A%E5%9E%8B%E5%88%A5"><span class="nav-number">11.</span> <span class="nav-text">回傳值加上型別</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E4%BB%B6%E7%9A%84%E5%9E%8B%E5%88%A5-Object-type"><span class="nav-number">12.</span> <span class="nav-text">物件的型別 (Object type)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#type"><span class="nav-number">12.1.</span> <span class="nav-text">type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inline-arguments"><span class="nav-number">12.2.</span> <span class="nav-text">inline arguments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interface"><span class="nav-number">12.3.</span> <span class="nav-text">Interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%9C%E5%85%85-type-v-s-Interface"><span class="nav-number">12.4.</span> <span class="nav-text">補充 : type v.s Interface</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E4%BB%B6%E8%A7%A3%E6%A7%8B%E5%AE%9A%E7%BE%A9%E5%9E%8B%E5%88%A5"><span class="nav-number">13.</span> <span class="nav-text">物件解構定義型別</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#optional"><span class="nav-number">14.</span> <span class="nav-text">optional</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E4%BB%B6%E7%9A%84%E5%9E%8B%E5%88%A5"><span class="nav-number">14.1.</span> <span class="nav-text">物件的型別</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%83%E6%95%B8%E5%9E%8B%E5%88%A5"><span class="nav-number">14.2.</span> <span class="nav-text">參數型別</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A0%90%E8%A8%AD%E5%80%BC%E4%B8%8D%E8%83%BD%E8%88%87-optional-%E5%90%8C%E6%99%82%E5%AD%98%E5%9C%A8"><span class="nav-number">14.2.1.</span> <span class="nav-text">預設值不能與 optional 同時存在</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%80%8B-optional-%E5%8F%83%E6%95%B8"><span class="nav-number">14.2.2.</span> <span class="nav-text">多個 optional 參數</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E9%A4%98%E5%8F%83%E6%95%B8-rest-parameter"><span class="nav-number">15.</span> <span class="nav-text">函式中的其餘參數 (rest parameter)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Type-assertion-v-s-Type-annotation"><span class="nav-number">16.</span> <span class="nav-text">Type assertion v.s Type annotation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scope-%E7%9A%84%E5%95%8F%E9%A1%8C"><span class="nav-number">17.</span> <span class="nav-text">Scope 的問題</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Discriminated-Unions-%E9%81%B8%E6%93%87%E4%B8%80%E5%80%8B"><span class="nav-number">18.</span> <span class="nav-text">Discriminated Unions (|) : 選擇一個</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%9C%E5%85%85-Enum-%E6%9E%9A%E8%88%89"><span class="nav-number">18.1.</span> <span class="nav-text">補充 : Enum 枚舉</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-%E7%9A%84%E5%85%A9%E7%A8%AE%E7%94%A8%E6%B3%95"><span class="nav-number">19.</span> <span class="nav-text">Array 的兩種用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E9%9B%86%E5%9E%8B%E5%88%A5-Intersection-Types-%E5%90%88%E4%BD%B5%E5%A4%A7%E6%B3%95"><span class="nav-number">20.</span> <span class="nav-text">交集型別 Intersection Types (&amp;) : 合併大法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%9C%E5%85%85-interface-%E7%9A%84-extends-v-s-Intersection-Types"><span class="nav-number">20.1.</span> <span class="nav-text">補充 : interface 的 extends v.s Intersection Types</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B5%84%E5%90%88%E6%8A%80-Intersection-Types-Discriminated-Unions"><span class="nav-number">21.</span> <span class="nav-text">組合技 Intersection Types + Discriminated Unions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E6%8B%86%E8%A7%A3"><span class="nav-number">21.1.</span> <span class="nav-text">再拆解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A2%AB%E6%8F%90%E5%88%B0%E4%BD%86%E6%B2%92%E8%A7%A3%E7%AD%94-decorator"><span class="nav-number">22.</span> <span class="nav-text">被提到但沒解答 : @decorator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%89%A9%E4%B8%8B%E7%9A%84%E9%A1%8C%E7%9B%AE"><span class="nav-number">23.</span> <span class="nav-text">解剩下的題目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#09-10-%E5%9E%8B%E5%88%A5%E6%96%B7%E8%A8%80-Type-Assertion"><span class="nav-number">23.1.</span> <span class="nav-text">09 &amp; 10 型別斷言 Type Assertion</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#09-promises-problem"><span class="nav-number">23.1.1.</span> <span class="nav-text">09 promises problem</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A3%9C%E5%85%85-%E4%BB%80%E9%BA%BC%E6%98%AF%E6%B3%9B%E5%9E%8B-Generics"><span class="nav-number">23.1.2.</span> <span class="nav-text">補充 : 什麼是泛型 (Generics) ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-Set-Problem"><span class="nav-number">23.1.3.</span> <span class="nav-text">10 Set Problem</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-Records"><span class="nav-number">23.2.</span> <span class="nav-text">11 Records</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-1-Bracket-notation"><span class="nav-number">23.2.1.</span> <span class="nav-text">解法 1 : Bracket notation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-2-inline-%E5%AF%AB%E6%B3%95"><span class="nav-number">23.2.2.</span> <span class="nav-text">解法 2 : inline 寫法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-3-Records"><span class="nav-number">23.2.3.</span> <span class="nav-text">解法 3 : Records</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E9%99%90%E7%B8%AE-Narrowing-typeof-guards"><span class="nav-number">23.3.</span> <span class="nav-text">12 限縮 Narrowing + typeof guards</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-try-catch-%E4%B8%AD%E7%9A%84%E9%8C%AF%E8%AA%A4%E8%99%95%E7%90%86"><span class="nav-number">23.4.</span> <span class="nav-text">13 try catch 中的錯誤處理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-1-Type-Assertion"><span class="nav-number">23.4.1.</span> <span class="nav-text">解法 1 : Type Assertion</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-2-any"><span class="nav-number">23.4.2.</span> <span class="nav-text">解法 2 : any</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95-3-instance-of"><span class="nav-number">23.4.3.</span> <span class="nav-text">解法 3 : instance of</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-extends-interface-%E7%89%A9%E4%BB%B6%E6%93%B4%E5%85%85"><span class="nav-number">23.5.</span> <span class="nav-text">14 extends : interface 物件擴充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-intersection-%E7%89%A9%E4%BB%B6%E4%BA%A4%E9%9B%86%E5%90%88%E4%BD%B5"><span class="nav-number">23.6.</span> <span class="nav-text">15 intersection : 物件交集合併</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-omit-and-pick"><span class="nav-number">23.7.</span> <span class="nav-text">16 omit and pick</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-function-types"><span class="nav-number">23.8.</span> <span class="nav-text">17 function types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-Promise-function"><span class="nav-number">23.9.</span> <span class="nav-text">18 Promise function</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B8%BD%E7%B5%90-22"><span class="nav-number">24.</span> <span class="nav-text">總結</span></a></li></ol></div></section><section class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Rosa Hong" src="/images/RosaBlog-LOGO.png"><p class="site-author-name" itemprop="name">Rosa Hong</p><div class="site-description" itemprop="description">菜鳥起飛中</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">59</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">分類</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">27</span> <span class="site-state-item-name">標籤</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/meitung473" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;meitung473" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a></span><span class="links-of-author-item"><a href="mailto:a8870506@gmail.com" title="聯絡我 → mailto:a8870506@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span><span class="links-of-author-item"><a href="https://www.facebook.com/yanshan.hong1" title="Rosa Hong → https:&#x2F;&#x2F;www.facebook.com&#x2F;yanshan.hong1" rel="noopener" target="_blank"><i class="fa fa-facebook fa-fw"></i></a></span></div></section></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-TW"><link itemprop="mainEntityOfPage" href="https://blog.rosa.tw/2022/09/TypeScript/TypeScript-first-time-meet-TypeScript"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/RosaBlog-LOGO.png"><meta itemprop="name" content="Rosa Hong"><meta itemprop="description" content="菜鳥起飛中"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="健忘雜記"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 筆記 | TypeScript - 初探 TypeScript</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">發表於</span> <time title="創建時間：2022-09-07 04:25:55" itemprop="dateCreated datePublished" datetime="2022-09-07T04:25:55+08:00">2022-09-07</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分類於</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Front-end/" itemprop="url" rel="index"><span itemprop="name">Front-end</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Front-end/TypeScript/" itemprop="url" rel="index"><span itemprop="name">TypeScript</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="文章字數"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">文章字數：</span> <span>27k</span></span><span class="post-meta-item" title="所需閱讀時間"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">所需閱讀時間 &asymp;</span> <span>24 分鐘</span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>影片連結 : <a href="https://www.youtube.com/watch?v=p6dO9u0M7MQ&amp;t">Live 🔴: TypeScript Crash Course with Matt Pocock - YouTube</a></p></blockquote><h2 id="摘要-6">摘要</h2><p>跟著 Matt Pocock 從基礎學習 TypeScript。一直都想學習 TypeScript，我只知道他是有型別的 JavaScript，避免 JavaScript 包山包海亂變形的詭異問題。</p><p>擇日不如撞日，剛好 <code>vscode</code> 官方熱騰騰的教學出來，那就直接來學習吧 ! 😄</p><p>影片有練習的專案，就不偷渡了，有興趣可以到影片連結下載。<br> 除了初階，更前些時段有出進階的講座 : <a href="https://www.youtube.com/watch?v=hBk4nV7q6-w">LIVE 🔴: TypeScript tips and Tricks with Matt - YouTube</a></p><span id="more"></span><h2 id="前置作業">前置作業</h2><p>專案是使用測試的方式來檢測每個檔案測驗是否通過，所以要先把專案的架構裝好，專案是使用 <code>yarn</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br></pre></td></tr></table></figure><p>要測試是否通過，就會跳出測試結果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yarn</span> exercise <span class="number">01</span> </span><br></pre></td></tr></table></figure><h2 id="簡單認識-TypeScript">簡單認識 TypeScript</h2><p>TypeScript 是一個討厭的英語老師🤣，它會一直糾正你的文法 (型別) 錯誤😡，只要錯了老師就會畫紅線。</p><p>開發者的任務就是把錯誤給正確地糾正過來，當個好學生。</p><h2 id="從錯誤找訊息">從錯誤找訊息</h2><p>當中在編輯器出現紅線，錯誤顯示 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Parameter</span> <span class="string">&#x27;a&#x27;</span> implicitly has an <span class="string">&#x27;any&#x27;</span> type.</span><br></pre></td></tr></table></figure><blockquote><p>編輯器不知道 a 到底是什麼類型，自動加註隱性類型 “any”</p></blockquote><p>英文老師說你有錯😡，叫你改。</p><h2 id="TypeScript-error-Translator">TypeScript error Translator</h2><p>錯誤看不懂嗎 ? 沒關係，Matt 竟然做了一個友善版的錯誤顯示，叫 <strong>TypeScript Error Translator</strong>，用 Extension 就可以安裝。</p><p>👉 Extension 連結 : <a href="https://marketplace.visualstudio.com/items?itemName=mattpocock.ts-error-translator">TypeScript Error Translator - Visual Studio Marketplace</a></p><p><img data-src="https://i.imgur.com/U9tQhV3.png" alt="搭拉 ! 用白話的方式告訴我們錯誤"></p><h2 id="修正錯誤-正確指出型別">修正錯誤 : 正確指出型別</h2><p>以 01 題為例，JavaScript 的數字類型只有 number ，我們要用 <code>number</code>，來辨別 a 、 b 的型別</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addTwoNumbers</span> = (<span class="params">a:<span class="built_in">number</span>, b:<span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="TS-為什麼在-function-裡不會自動指向正確的型別">TS 為什麼在 function 裡不會自動指向正確的型別 ?</h2><p>問題點在於 <strong>開發者知道自己丟進去的 function 參數是什麼型別，那為什麼我們還要特別替參數加上型別 ?</strong></p><p>可以想像 TS 在 function 加上型別是幫助函式進行 <strong>推理</strong>，我們知道 <strong>加號</strong> 是運算子，不只是數字，而 <code>+</code> 在不同的型別會有不同結果 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能等於 數字 相加</span></span><br><span class="line">(a : <span class="built_in">number</span>, b : <span class="built_in">number</span>)</span><br><span class="line">a + b = <span class="number">1</span> + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能等於 字串 相加</span></span><br><span class="line">(a : <span class="built_in">string</span>, b : <span class="built_in">string</span>)</span><br><span class="line">a + b = firstName + lastName</span><br></pre></td></tr></table></figure><p>從這裡就可以知道 <em>如果沒有型別</em>，function 會依靠輸入的型別會跑出兩種結果，與其等到跑出結果再糾正，不如在進入運算前就指出錯誤。</p><p>那為什麼 <strong>宣告變數</strong> 不用加入型別呢 ?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 我們不用這樣</span></span><br><span class="line"><span class="keyword">const</span> firstName : string = <span class="string">&#x27;Rosa&#x27;</span></span><br></pre></td></tr></table></figure><p>在建立時已經把 string 的型別分配給 <code>firstName</code> ， TS 知道它一開始就有類別。</p><p>function 就如上面所說，不知道 <strong>將來的輸入來源</strong> 來自什麼，所以一開始我們在限制輸入的型別，讓 TS 也能推理出我們預期的輸出的型別。</p><h2 id="在專案中找出要修正的-TS-檔案">在專案中找出要修正的 TS 檔案</h2><ul><li>測試專案中的所有的 <code>.ts</code> 檔是否通過 :</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn tsc</span><br></pre></td></tr></table></figure><ul><li>單個檔案編譯</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yarn</span> tsc 〔檔名〕</span><br></pre></td></tr></table></figure><p><code>npm</code> 也是一樣的，如果是裝 global 可以直接 <code>tsc</code> 使用 command line 執行；如果是裝在專案內部則加上 <code>npx tsc</code></p><h2 id="都使用-any-會怎麼樣嗎">都使用 any 會怎麼樣嗎 ?</h2><p><code>any</code> 是一個危險的型別 😡 ，可以的話盡量不用，可以從 3 個方向來看為什麼 :</p><ol><li>純輸出值</li><li>指派給新的變數的函式輸出值</li><li>新產生的變數型別，使用 prototype function 不會顯示，或者錯誤也不會提醒🤔</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addTwoNumbers</span> = (<span class="params">a:<span class="built_in">any</span>, b:<span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 1. 隨便亂填編輯器也不管你</span></span><br><span class="line"><span class="title function_">addTwoNumbers</span>(<span class="string">&#x27;123&#x27;</span>+[])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. num 也會變成 any</span></span><br><span class="line"><span class="keyword">const</span> string1 = <span class="title function_">addTwoNumbers</span>(<span class="string">&#x27;123&#x27;</span>+[])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 想要使用內建 method 沒有任何提示或錯誤</span></span><br><span class="line">string1.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>非預期的輸出，vscode 不知道我們要什麼東西</li><li>變數在宣告時 TS 就能知道型別，在 <code>any</code> 的情況下，由於輸入是隨意的，變數接收的輸出變得非預期，結果也變 <code>any</code></li><li>當我們打出 <code>num.</code> 的時候，不會有任何提示函式，因為 TS 不知道型別對應不到內建 method 。 <code>num</code> 被定義為 any ，沒有任何內建函式可使用</li></ol><p><img data-src="https://i.imgur.com/Oo0jcFb.png" alt="字串沒有跳出任何型別有關的 method😵|400x280"><br> 在有明確的型別狀況下，vscode 會跳出對應型別的 method， any 使得 vscode 不知道該怎麼辦。除非編譯執行後才能知道結果，TS 如果好好的寫型別，在開發階段都能矯正這些問題了。</p><h3 id="什麼時候用-any">什麼時候用 any ?</h3><p>如果很明確知道輸入與輸出的型別，就不該使用。越邏輯底層的 function 越不該使用，因為 TS 的型別就像瀑布流一樣，會被往下傳遞，試想一下如果是用 any ，瀑布流的型別簡直變成土石流等級，什麼都夾什麼都不奇怪。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addTwoNumbers</span> = (<span class="params">a: <span class="built_in">number</span>, b:<span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// number + number，vscode 會推理出回傳是 number</span></span><br><span class="line"><span class="keyword">const</span> newNumber = <span class="title function_">addTwoNumbers</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">multiple</span> = (<span class="params"><span class="built_in">number</span> : <span class="built_in">number</span></span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">number</span> * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number 為輸入，其回傳也是 number </span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">multiple</span>(newNumber)</span><br></pre></td></tr></table></figure><p>以上面的例子，一開始就已知道型別，使得整個邏輯就知道輸入與最終輸出的型別，在呼叫時如果我們填寫到錯誤型別的值，TS 也能夠提醒我們。如果都用 <code>any</code> ，就沒有老師會糾正，錯誤率可能會提高😵。</p><p>其實影片沒有很明確提到 any 的使用情境，只有說到非常複雜的情況才可能用 any 🤔<br> 官方也有提及，在開發合併不同專案初期可以使用來避免非預期狀況，不然就像跟用了<code>@ts-ignore</code> 一樣的效果，再者應該使用 <code>unknown</code>。</p><p>👉 官方連結 <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#any">TypeScript: Documentation - Do’s and Don’ts</a></p><h3 id="補充-any-v-s-unknown">補充 : any v.s unknown</h3><p>any 跟 <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown">unknown</a> 很像，unknown 是 any 的安全版，那安全在哪呢 ?</p><p>any 也是任何變數或參數沒有定義的情況下的預設值，any 型別使用任何屬性或方法都可以通過，TS 不會理你，但 <code>unknown</code> 就不行了 :<br> <img data-src="https://i.imgur.com/lrmjp2a.png" alt="any 沒有錯誤，unknown 就有|300x140"></p><h2 id="TS-在-runtime-中不會有任何作用">TS 在 runtime 中不會有任何作用</h2><p>事實上 TS 最終編譯出來還是長的跟 JavaScript 一模一樣 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addTwoNumbers = (<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>:<span class="built_in">number</span>) :<span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>編譯後 :</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addTwoNumbers</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一開始可能會覺得既然產出有沒有 TS 都一樣，那為什麼要 TS 🤷‍♀️。</p><blockquote><p>TypeScript adds additional syntax to JavaScript to support a tighter integration with your editor. <strong>Catch errors early in your editor.</strong> — TypeScript</p></blockquote><p>TS 幫助在 <strong>開發階段</strong> 早點發現問題，減少 runtime 發生錯誤，不只如此也可以提升開發品質。用影片 “英文老師” 的概念來說 : 「嚴師出高徒」 🤣</p><p>如果真的想要忽略 TS 的強硬指定，可以加上 <code>ignore</code>，通常會加上 lint 工具，可以加上 rules 顯示如果使用 ignore 要出現 warn 提示</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addTwoNumbers</span> = (<span class="params">a: <span class="built_in">number</span>, b:<span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line"><span class="title function_">addTwoNumbers</span>(<span class="string">&#x27;123243terqadfa&#x27;</span>,[]) <span class="comment">// 🤪 不會有任何問題</span></span><br></pre></td></tr></table></figure><p>即使我們有定義型別，但因為加上 ignore ，TS 的檢查會跳過這個呼叫的 function，就跟 <code>any</code> 的作用差不多。</p><h2 id="回傳值加上型別">回傳值加上型別</h2><p>在參數括號後面加上型別</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (param) : type</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addTwoNumbers = (<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>:<span class="built_in">number</span>) : <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ❌ 回傳值為字串是會跳出錯誤的</span></span><br><span class="line">  <span class="keyword">return</span> (a + b).<span class="title function_">toString</span>() </span><br><span class="line">  <span class="comment">// ✅ 回傳值一定要是 number</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Number</span>(a + b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一開始指定也並免我們寫出非輸出的型別。</p><p>相關題是 08 題，不過這題有點奇妙，解決的辦法 2 是完全沒填入東西🤔</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeUser = ():<span class="function"><span class="params">User</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;rosa&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;hong&#x27;</span>,</span><br><span class="line">    <span class="attr">role</span>:<span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    <span class="attr">posts</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        id : <span class="number">2</span>,</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我在想 Matt 是不是在指 <code>return</code> 可填可不填🤔，果然是 <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#return-type-annotations">官方的 Handbook</a> 給出了答案 :</p><blockquote><p>Much like variable type annotations, you usually don’t need a return type annotation because TypeScript will infer the function’s return type based on its return statements.</p></blockquote><p>跟宣告變數的型別一樣的道理，不用特別給予回傳值的型別，TS 根據 return 值會自己推理 return 的型別。</p><h2 id="物件的型別-Object-type">物件的型別 (Object type)</h2><p>01 題著重在函式的 Primitive type 的 <em>參數</em>。 因為參數的輸入值來源是隨意的，沒有定義型別可能導致非預期的輸出。</p><p>02 題是講解 Object type 的參數，由於 object type 對應不同的 key-value 需要個別定義。有 3 種用法，影響的是 TS 會顯示不同的提示 :</p><ol><li>type</li><li>inline type</li><li>interface</li></ol><h3 id="type">type</h3><p><code>type</code> 不只可以運用在 Primitive type 上，也可以使用在 Object</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Param</span> = &#123;</span><br><span class="line">  first : <span class="built_in">number</span>;</span><br><span class="line">  second : <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addTwoNumbers = (<span class="attr">params</span>:<span class="title class_">Param</span>) : <span class="function"><span class="params">number</span>=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> params.<span class="property">first</span> + params.<span class="property">second</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ✅ </span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">addTwoNumbers</span>(&#123;first : <span class="number">1</span>,second : <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure><p>輸入型別錯誤的訊息 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(property) second: number</span><br><span class="line">Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><h3 id="inline-arguments">inline arguments</h3><p>把內容給拆開寫在同一行 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addTwoNumbers</span> = (<span class="params">params: &#123; first: <span class="built_in">number</span>; second: <span class="built_in">number</span>;&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> params.<span class="property">first</span> + params.<span class="property">second</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>變得不易讀又冗長😵</p><p>輸入型別錯誤的訊息，跟 type 一樣 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(property) second: number</span><br><span class="line">Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><p>可以說 <code>type</code> 是把型別打包提出去，使程式碼更易讀。</p><h3 id="Interface">Interface</h3><p>只能用在物件上 (Object/Class)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AddTwoNumbersArgs</span> &#123;</span><br><span class="line">  <span class="attr">first</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">second</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addTwoNumbers</span> = (<span class="params">params: AddTwoNumbersArgs</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> params.<span class="property">first</span> + params.<span class="property">second</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>輸入型別錯誤的訊息，interface 用 <code>obj.a</code> 這種方式說明 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(property) AddTwoNumbersArgs.second: number</span><br><span class="line">Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><p>type 跟 interface 在 object type <em>應用</em> 上是差不多的，不過他們在某些情境上還是有差別。</p><h3 id="補充-type-v-s-Interface">補充 : type v.s Interface</h3><blockquote><p>文章連結 :</p><ol><li><a href="https://ithelp.ithome.com.tw/articles/10224646">【Day 19】TypeScript 介面(Interface) v.s. 型別別名(Type Alias)</a></li><li><a href="https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#useful-table-for-types-vs-interfaces">Typing Component Props | React TypeScript Cheatsheets</a></li></ol></blockquote><p>從上面看來，可以知道 :</p><ul><li>interface 只能用在物件上</li><li>type 是 Primitive 與 Object type 都可以使用</li></ul><p>細節還有很多小不同，關注在應用上 :</p><ol><li>單純表示靜態格式資料概念時使用 type，重複多方利用時使用 interface</li><li>若原始資料型別、列舉 (Enum) 和元組 (Tuple) 型別和複合型別，只能使用 type 進行宣告</li><li>Interface 和 Type 可以混用擴展</li></ol><ul><li>不希望再被擴充或靜態的型別格式就應該用 type 宣告 type，藉由 union 或 intersection 達成擴展</li><li>之後被擴充或多方利用，宣告成 interface，藉由 extends 去達成擴展</li></ul><p>另一個比較實際的問題就是 <a href="https://github.com/microsoft/TypeScript/wiki/Performance#preferring-interfaces-over-intersections">效能</a>，結論是 interface 會比 type alias 好 。</p><h2 id="物件解構定義型別">物件解構定義型別</h2><p>在 React 是透過 props 來傳遞資料，通常使用時會直接解構</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Compoment</span> = (<span class="params">&#123;count&#125;</span>)=&gt;&#123;</span><br><span class="line">  <span class="comment">// 等同於 const &#123;count&#125; = props</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解構好用到無處不在，再加上 TS 時會長怎樣呢 ? 先從一般的 JS 看起，把上面的例子改成解構式 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ❌ 錯誤 必須遵守 left hand side，分開寫不會被當作混和成物件的型別 </span></span><br><span class="line"><span class="comment">  (parameter) number: any.Duplicate identifier &#x27;number&#x27;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addTwoNumbers</span> = (<span class="params">&#123;first:<span class="built_in">number</span>,second:<span class="built_in">number</span>&#125;</span>)=&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> first + second</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ✅ 正確</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addTwoNumbers = (&#123;first,second&#125;:&#123;<span class="attr">first</span>:<span class="built_in">number</span>,<span class="attr">second</span>:<span class="built_in">number</span>&#125;) : <span class="function"><span class="params">number</span>=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> first + second</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>結構變得冗長且難讀😵，在如果有多個屬性就會很痛苦，所以通常會提出來</p><ul><li>改用 interface 會是比較好的選擇 :</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AddTwoNumbersArgs</span> &#123;</span><br><span class="line">  first : <span class="built_in">number</span>;</span><br><span class="line">  second : <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ❌ 必須遵守 left hand side，分開寫不會被當作混和成物件的型別</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addTwoNumbers</span> = (<span class="params">&#123;first:<span class="built_in">number</span>,second:<span class="built_in">number</span>&#125; : AddTwoNumbersArgs</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ✅ OK</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addTwoNumbers</span> = (<span class="params">&#123;first,second&#125; : AddTwoNumbersArgs</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>錯誤訊息，會正確地告訴我們某物件型別的 key 是否錯誤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(property) AddTwoNumbersArgs.first: number</span><br><span class="line">Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><p>在 React 可能會看到</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inline </span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Compoment</span> = (<span class="params">&#123;count&#125; : &#123;count : <span class="built_in">number</span>&#125;</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或是 type</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Props</span>&#123;</span><br><span class="line">  children? : <span class="title class_">React</span>.<span class="property">ReactNode</span>;</span><br><span class="line">  count : <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Compoment</span> = (<span class="params">&#123;count&#125; : Props</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface 也是可以，兩者的差別可以看 : <a href="https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#useful-table-for-types-vs-interfaces">Typing Component Props | React TypeScript Cheatsheets</a> 。</p><p>文章有提及 <em>建議</em> 的原則 :</p><ul><li><strong>interface</strong> 較適合用在封裝、第三方套件程式碼，擴展的其內部的類型</li><li><strong>type</strong> 較適合 React Component 中的 props 與 state ，保持一致性與更嚴謹的限制</li></ul><p>不過最終目的都是確保一致性，事實上並沒有限制一定要 type 還是 interface。</p><h2 id="optional">optional</h2><p>利用問號 <code>？</code> 來表示有沒有存在，跟 JavaScript 中的 optional chaining 一樣，可以 <a href="https://blog.rosa.tw/2022/06/JavaScript/JavaScript-null-undefined-operator">參考我之前的筆記</a></p><ul><li>檢查 middle 是否存在沒有就…</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  first : <span class="string">&#x27;rosa&#x27;</span>,</span><br><span class="line">  last : <span class="string">&#x27;hong&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mid = person?.<span class="property">middle</span> || <span class="string">&#x27;no&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="物件的型別">物件的型別</h3><p>範例 03 ，如果呼叫函式時其中的參數是不一定要輸入的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等同於 inline 的 &#123; first: string; last?: string &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  first : <span class="built_in">string</span>;</span><br><span class="line">  last? : <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getName</span> = (<span class="params">params: &#123; first: <span class="built_in">string</span>; last?: <span class="built_in">string</span> &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (params.<span class="property">last</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;params.first&#125;</span> <span class="subst">$&#123;params.last&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> params.<span class="property">first</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ✅ OK</span></span><br><span class="line"><span class="title function_">getName</span>(&#123;<span class="attr">first</span>:<span class="string">&#x27;rosa&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">❌ 缺少 first</span></span><br><span class="line"><span class="comment">Property &#x27;first&#x27; is missing in type &#x27;&#123; last: string; &#125;&#x27; but required in type &#x27;&#123; first: string; last?: string | undefined; &#125;&#x27;.ts(2345)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> name1 = <span class="title function_">getName</span>(&#123;<span class="attr">last</span>:<span class="string">&#x27;hong&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>沒有 optional <code>?</code> 的 key 一定要輸入，老師叫你填就要填😡</p><h3 id="參數型別">參數型別</h3><p>範例 04 ，跟 03 有 87% 相似🤔</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getName</span> = (<span class="params">first: <span class="built_in">string</span>, last?: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (last) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 第二個參數沒有也不會有問題</span></span><br><span class="line"><span class="keyword">const</span> name1 = <span class="title function_">getName</span>(<span class="string">&#x27;rosa&#x27;</span>); <span class="comment">// rosa</span></span><br><span class="line"><span class="keyword">const</span> name2 = <span class="title function_">getName</span>(<span class="string">&#x27;rosa&#x27;</span>,<span class="string">&#x27;hong&#x27;</span>) <span class="comment">// rosa hong</span></span><br></pre></td></tr></table></figure><blockquote><p>如果想要參數具有預設值呢 ?</p></blockquote><h4 id="預設值不能與-optional-同時存在">預設值不能與 optional 同時存在</h4><p><strong>預設值不能同時使用 optional</strong>，既然是 <strong>預設值</strong> TS 會覺得這裡不會是 <code>undefined</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ❌ 參數不能同時擁有問號跟初始值</span></span><br><span class="line"><span class="comment">(parameter) last: string | undefined</span></span><br><span class="line"><span class="comment">Parameter cannot have question mark and initializer.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getName</span> = (<span class="params">first :<span class="built_in">string</span>, last?: <span class="built_in">string</span> = <span class="string">&#x27;123&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (last) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如同變數一開始就已經賦值了，TS 是知道這裡具有型別而且有值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> last  = <span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="多個-optional-參數">多個 optional 參數</h4><p>如果第一個參數為 optional，後面的參數是必要的，會發生錯誤。等同於第一個參數傳入 undefined，沒什麼意義😑</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ❌ 第一個跟傳遞 undefined 同等意義，TS 不喜歡這樣，因為沒意義</span></span><br><span class="line"><span class="comment">(parameter) last: string</span></span><br><span class="line"><span class="comment">A required parameter cannot follow an optional parameter.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getName</span> = (<span class="params">first? : <span class="built_in">string</span> , last: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (last) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 沒什麼意義😑</span></span><br><span class="line"><span class="keyword">const</span> name1 = <span class="title function_">getName</span>(<span class="literal">undefined</span>,<span class="string">&#x27;hong&#x27;</span>)</span><br></pre></td></tr></table></figure><p>撇除第一個刻意 optional ，也可以有多個參數 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getName</span> = (<span class="params">first : <span class="built_in">string</span> , middle?: <span class="built_in">string</span>,last?: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (last) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 跳過某值一樣是 undefined</span></span><br><span class="line"><span class="keyword">const</span> name1 = <span class="title function_">getName</span>(<span class="string">&#x27;rosa&#x27;</span>,<span class="literal">undefined</span>,<span class="string">&#x27;hong&#x27;</span>)</span><br></pre></td></tr></table></figure><p>不過用這種方式時應該都會選擇用 <strong>物件</strong> 的方式傳入，因為直接傳入還得要完全照順序，用物件就不用了🤔，也不用傳什麼 <code>undefined</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  first : <span class="built_in">string</span>;</span><br><span class="line">  middle?:<span class="built_in">string</span>;</span><br><span class="line">  last?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getName</span> = (<span class="params">&#123;first,middle,last&#125; : Person</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (last) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> name1 = <span class="title function_">getName</span>(&#123;<span class="attr">first</span>: <span class="string">&#x27;rosa&#x27;</span>,<span class="attr">last</span>:<span class="string">&#x27;hong&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="函式中的其餘參數-rest-parameter">函式中的其餘參數 (rest parameter)</h2><p>optional 是在知道有多少個有無必要的輸入值使用，如果本身不知道到底有多少個輸入，rest parameter 提供參數更彈性的方式，把後面 <code>...</code> 的部份算做 <strong>一組</strong> 陣列來看待。</p><p>對 TS 來說就是一個 Array ，但是陣列內容是不得而知的，因此要為內部的集合定義 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getName</span> = (<span class="params">frist:<span class="built_in">string</span>,...otherName :<span class="built_in">string</span>[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [frist,...otherName].<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ✅</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">getName</span>(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;fewfwe&#x27;</span>,<span class="string">&#x27;fewfwe&#x27;</span>,<span class="string">&#x27;13412fsa&#x27;</span>)</span><br><span class="line"><span class="comment">// ❌ 1234 不是 string</span></span><br><span class="line"><span class="keyword">const</span> result2 = <span class="title function_">getName</span>(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;fewfwe&#x27;</span>,<span class="string">&#x27;fewfwe&#x27;</span>,<span class="number">1234</span>)</span><br></pre></td></tr></table></figure><h2 id="Type-assertion-v-s-Type-annotation">Type assertion v.s Type annotation</h2><blockquote><p>文章參考 : 這要付費 <a href="https://medium.com/@bsalwiczek/type-annotation-vs-assertion-in-typescript-one-important-difference-4f4df715b5fe">Type Annotation vs Assertion in Typescript — one important difference</a></p></blockquote><p><code>timecode : 47 min</code> ，寫筆記有點忘在哪，所標一下。相關題是 05 題。</p><ul><li>從這個例子可以感受到 <code>as</code> 跟直接 <code>type</code> 哪裡有不一樣 :</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  first : <span class="built_in">number</span>,</span><br><span class="line">  second : <span class="built_in">number</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ❌ 報錯，少了 first</span></span><br><span class="line"><span class="keyword">const</span> john : <span class="title class_">User</span> = &#123;</span><br><span class="line">  second : <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ✅ 沒問題</span></span><br><span class="line"><span class="keyword">const</span> rosa = &#123;</span><br><span class="line">  first : <span class="number">3</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="title class_">User</span></span><br></pre></td></tr></table></figure><ul><li><strong>Type annotation</strong> : <code>value : type</code>。 永遠都只能叫這個 type，非常硬性的。</li><li><strong>Type assertion</strong> : <code>value as type</code>。 轉變 (cast) 成這個型別的，但比較像之後在檢查。</li></ul><p>雖然看起來沒差🤔，但在實際上錯誤訊息是 annotation 會在宣告的時後就被阻止，也就是開發階段就知道，而 assertion 則是編譯過後才會被阻止 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Human</span> = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">spokenLanguage</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> human = &#123; <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">spokenLanguage</span>: <span class="string">&quot;English&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">human2</span>: <span class="title class_">Human</span> = human; <span class="comment">// ❌ 還沒編譯這裡就出現錯誤</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(human2.<span class="property">name</span>.<span class="title function_">toUpperCase</span>()); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> human3 = human <span class="keyword">as</span> <span class="title class_">Human</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(human3.<span class="property">name</span>.<span class="title function_">toUpperCase</span>()); <span class="comment">// ❌ 執行到這行報錯</span></span><br></pre></td></tr></table></figure><p>影片中的說法蠻好笑的， 直接 <code>type</code> 就像是老師逼你一定要做對，<code>as</code> 是你告訴老師說你會做啦，但是藉口很多，老師只好無奈答應。另一個說法是 as 就像 CSS 到處加 <code>!important</code> 把舊有的 type 覆蓋過去。</p><p>另外 <code>as</code> 不能用在 exact type，比如已經知道它是 number 還硬要掰成 string :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ❌ Conversion of type &#x27;number&#x27; to type &#x27;string&#x27; may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to &#x27;unknown&#x27; first.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span> <span class="keyword">as</span> <span class="built_in">string</span></span><br></pre></td></tr></table></figure><h2 id="Scope-的問題">Scope 的問題</h2><blockquote><p>文章連結 : <a href="https://www.typescriptlang.org/docs/handbook/variable-declarations.html#block-scoping">Block-scoping</a></p></blockquote><p><code>timecode : 48:44</code>，這題一開始我不知道為什麼要講這個🤔，更像是 JavaScript 的基礎，也就是 Scope 跟 Scope chain 的問題 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">defaultUser</span>:<span class="title class_">User</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getUserId</span> = (<span class="params">user:User</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> user.<span class="property">id</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ❌ let defaultUser: User</span></span><br><span class="line"><span class="comment">  Variable &#x27;defaultUser&#x27; is used before being assigned.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">getUserId</span>(defaultUser) <span class="comment">// 稱做 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 測試資料，但 getUserId 沒有出現錯誤，稱做 2</span></span><br><span class="line"><span class="title function_">it</span>(<span class="string">&quot;Should get the user id&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">expect</span>(<span class="title function_">getUserId</span>(defaultUser)).<span class="title function_">toEqual</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>1 之所以會出現錯誤，是常見的 let/const 在還沒賦值之前，就使用到值的 TDZ (Temporal Dead Zone)，一般的 JavaScript 在執行過後才會出錯，TS 這時候就很聰明的幫我們抓到了。</p><p>2 為什麼沒有呢 ? 因為它被 block 包住 <code>&#123; &#125;</code>，已經是另一個泛為了。 1 是暴露在全域，因此就已知 <code>defaultUser</code> 是 <code>unassigned</code>，而我們也知道 let/const 的 scope 是以 block 為限， 2 之所以沒有出現錯誤，因為這裡的輸入值 <code>defaultUser</code> 可能在同一個 block 或是 scope chain 上的某個 <code>defaultUser</code>，這已經不是編譯前能夠執行的，TS 不會主動找 scope chain 上的，所以就不會出現錯誤。</p><h2 id="Discriminated-Unions-選擇一個">Discriminated Unions (|) : 選擇一個</h2><p>範例 06 ，使用 <code>｜</code> (OR) 來讓 type 有不同的 <strong>值</strong> 可選擇，作為種類的提示字元很好用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">role</span>: <span class="string">&quot;admin&quot;</span> | <span class="string">&quot;user&quot;</span> | <span class="string">&quot;super-admin&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://i.imgur.com/5iQbhoa.png" alt="內部都是 string ，只要打出引號編輯器會自己跳出選項"><br> 刻意讓 <code>role : '123'</code>，沒有值被包含在內的情況會提示 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(property) User.role: &quot;admin&quot; | &quot;user&quot; | &quot;super-admin&quot;</span><br><span class="line">How do we ensure that role is only one of:</span><br><span class="line">  - &#x27;admin&#x27;</span><br><span class="line">  - &#x27;user&#x27;</span><br><span class="line">  - &#x27;super-admin&#x27;</span><br></pre></td></tr></table></figure><h3 id="補充-Enum-枚舉">補充 : Enum 枚舉</h3><p>Enum 跟 <code>｜</code> 非常類似，但差別在於 Enum 是真的會在 runtime 產生物件，而 <code>｜</code> 不會。<br> TT 沒有東西產生；EE 有產生物件。<br> <img data-src="https://i.imgur.com/upuhvfl.png" alt="範例來自 : https://stackoverflow.com/questions/40275832/typescript-has-unions-so-are-enums-redundant"></p><p>影片中 Matt 說實際上很少用到，並沒有特別解說，還說 TS 開發團隊可能很後悔出這個🤣。不過我查了一下，Enum 適合用在管理多組常數，我第一直覺想到 redux 中的 <code>action.type</code>。以往會將 reducer 的 action 拆出去 <code>action.type</code> 避免打字出現錯誤。</p><p>用上面的例子改，role 其實可以被窮舉出有多少身分，這些是固定的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Role</span>&#123;</span><br><span class="line">  admin,</span><br><span class="line">  user,</span><br><span class="line">  [<span class="string">&#x27;super-admin&#x27;</span>] <span class="comment">// 斜槓的問題，利用 Symbol 的方式解決</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">role</span>: <span class="title class_">Role</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">defaultUser</span>: <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Pocock&quot;</span>,</span><br><span class="line">  <span class="attr">role</span>: <span class="title class_">Role</span>.<span class="property">admin</span> <span class="comment">// 👉 這裡的 role 是數字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>role 只要透過已存在的 <code>Role</code> 物件去尋找就可以了。<br> <img data-src="https://i.imgur.com/Bm3d7Ul.png" alt="用物件的形式賦值"><br> Enum 還提供另一種功能，<a href="https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings">Reverse mappings</a>，可以得出字串字 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Role</span>&#123;</span><br><span class="line">  admin,</span><br><span class="line">  user ,</span><br><span class="line">  [<span class="string">&#x27;super-admin&#x27;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user  = <span class="title class_">Role</span>.<span class="property">user</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">defaultUser</span>: <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Pocock&quot;</span>,</span><br><span class="line">  <span class="attr">role</span>: <span class="title class_">Role</span>[user] <span class="comment">// 👉 user 是數字去往回找 Role[0]</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(defaultUser.<span class="property">role</span>) <span class="comment">// &#x27;user&#x27;</span></span><br></pre></td></tr></table></figure><p>有人是提到這樣會產生新的物件對效能上有差別，如果要節省 JavaScript 大小不如用 <code>|</code> 🤔。</p><p>另一個實用的例子就是 神 Q 超人大大有提到的 Response status codes : <a href="https://medium.com/enjoy-life-enjoy-coding/typescript-%E5%96%84%E7%94%A8-enum-%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BC%8F%E7%9A%84%E5%8F%AF%E8%AE%80%E6%80%A7-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-feat-javascript-b20d6bbbfe00">TypeScript | 善用 Enum 提高程式的可讀性 - 基本用法 feat. JavaScript</a>。</p><h2 id="Array-的兩種用法">Array 的兩種用法</h2><p>07 題， posts 是陣列類型的寫法，裡面裝 type Post 物件類型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">role</span>: <span class="string">&quot;admin&quot;</span> | <span class="string">&quot;user&quot;</span> | <span class="string">&quot;super-admin&quot;</span>;</span><br><span class="line">  <span class="attr">posts</span>: <span class="title class_">Post</span>[]; <span class="comment">// ✅ 可以這樣</span></span><br><span class="line">  <span class="attr">posts</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Post</span>&gt;; <span class="comment">// ✅ 也可以這樣</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">defaultUser</span>: <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Pocock&quot;</span>,</span><br><span class="line">  <span class="attr">role</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">  <span class="attr">posts</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;How I eat so much cheese&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>Post[]</code> 是 <code>Array&lt;Post&gt;</code> 的簡寫。</li></ul><h2 id="交集型別-Intersection-Types-合併大法">交集型別 Intersection Types (&amp;) : 合併大法</h2><blockquote><p>文章參考 : <a href="https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types">Intersection Types</a></p></blockquote><p>以 06 題為例，interface 直接把 role 屬性寫在裡面，還有其他的寫法</p><ul><li><strong>interface 合併</strong> (<a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces">Merging Interfaces</a>) : 除了建立在新的類型 (extends) 擴展，也可以從 “自己” 作為接口擴展，如果插入是 key 一定要是唯一值 (unique)，而且同一種 key 定義到不同型別會產生錯誤</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span>&#123;</span><br><span class="line">  role : <span class="string">&quot;admin&quot;</span> | <span class="string">&quot;user&quot;</span> | <span class="string">&quot;super-admin&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>&amp; ─ Intersection Types : 用於合併 type 或 interface 給新的 type 。 type 也可以定義物件型別。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125; &amp; &#123;</span><br><span class="line">  role : <span class="string">&quot;admin&quot;</span> | <span class="string">&quot;user&quot;</span> | <span class="string">&quot;super-admin&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以原本 06 為 interface ，也可以合併 interface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BaseUser</span>&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = <span class="title class_">BaseUser</span> &amp; &#123;</span><br><span class="line">  role : <span class="string">&quot;admin&quot;</span> | <span class="string">&quot;user&quot;</span> | <span class="string">&quot;super-admin&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接把 role 焊在裡面是一樣的，但是 role 是獨立的 type，讓型別在設定時可以更彈性。</p><ul><li>再獨立出來 :</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125; &amp; &#123;</span><br><span class="line">  role : <span class="title class_">Role</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Role</span> = <span class="string">&quot;admin&quot;</span> | <span class="string">&quot;user&quot;</span> | <span class="string">&quot;super-admin&quot;</span>;</span><br></pre></td></tr></table></figure><p>如此一來上半部就是固定的模板， <code>&amp;</code> 之後的就像疊加上去的，如果要加什麼東西也可以在 <code>&amp;</code> 上去 。</p><h3 id="補充-interface-的-extends-v-s-Intersection-Types">補充 : interface 的 extends v.s Intersection Types</h3><blockquote><p>文章參考 :</p><ol><li><a href="https://stackoverflow.com/questions/52681316/difference-between-extending-and-intersecting-interfaces-in-typescript">types - Difference between extending and intersecting interfaces in TypeScript? - Stack Overflow</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/2/objects.html#interfaces-vs-intersections">Interfaces vs. Intersections</a></li><li><a href="https://stackoverflow.com/questions/67498054/extends-vs-intersection-in-typescript">javascript - Extends vs Intersection in Typescript - Stack Overflow</a></li></ol></blockquote><p>兩者的目的很像，主要是看自己應用的習慣，官方說到最大的差別是錯誤的處理 : <strong>同樣的 key 怎麼辦 ?</strong> extends 會出現錯誤，但 type 使用 <code>&amp;</code> 的不會。</p><ol><li>type 交集兩個 interface 並不會變 interface ，一樣是 type。 A 跟 B 一樣會產生交集。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> B&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> C = A &amp; B</span><br></pre></td></tr></table></figure></li><li>interface extends 的 key 型別如果有用多個值差集，只能從中繼承，不能有額外的型別；type 就沒那麼嚴格，雖然是交集，但沒有的也不會出錯。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ✅ ok </span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Child1</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ❌ 出現錯誤，boolean 並不在 Parent.x 裡面</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Child2</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123; </span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">string</span> | <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ✅ 不會怎樣，只是做交集，並沒有繼承建立新的插進去</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectedChild</span> = <span class="title class_">Parent</span> &amp; &#123;<span class="attr">x</span>: <span class="built_in">string</span> | <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IntersectedChildX</span> = <span class="title class_">IntersectedChild</span>[<span class="string">&#x27;x&#x27;</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>記住，interface 之不能直接做交集 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 不會有這樣的東西</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span>&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125; &amp; &#123;</span><br><span class="line">  role : ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="組合技-Intersection-Types-Discriminated-Unions">組合技 Intersection Types + Discriminated Unions</h2><p>以 06 題為例，可以把 role 當成附加 key ，定義不同的物件內容 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125; &amp;( &#123;</span><br><span class="line">  <span class="attr">role</span>: <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">  adminPassword : <span class="built_in">string</span>; </span><br><span class="line">&#125; | &#123;</span><br><span class="line">  role : <span class="string">&quot;user&quot;</span>;</span><br><span class="line">&#125; |&#123;</span><br><span class="line">  role : <span class="string">&#x27;super-admin&#x27;</span>;</span><br><span class="line">  <span class="attr">superadminPassword</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>記得 <code>&amp;</code> 後面的括號包起來，視為一整組。</p></blockquote><p>如此一來在 User 使用時， role 可以根據填入的字串決定哪種 password。填入 <code>&quot;user&quot;</code> 則不用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ No error</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Rosa</span> :<span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;rosa&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;hong&#x27;</span>,</span><br><span class="line">  <span class="attr">role</span>: <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ❌</span></span><br><span class="line"><span class="comment">Property &#x27;adminPassword&#x27; is missing in type &#x27;&#123; id: number; firstName: string; lastName: string; role: &quot;admin&quot;; &#125;&#x27; but required in type &#x27;&#123; role: &quot;admin&quot;; adminPassword: string; &#125;&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Rosa</span> :<span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;rosa&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;hong&#x27;</span>,</span><br><span class="line">  <span class="attr">role</span>: <span class="string">&quot;admin&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一來可以按照 role 的不同訂定不同的 key。</p><h3 id="再拆解">再拆解</h3><p><code>timecode : 58:50、59:14</code> ，源於影片最後一題，這也是我覺得蠻實用的一個，幾乎把 type 能切就切。</p><p>把上面 <code>&amp;</code> 之後的部份另外提出成 type ，並且個別用物件 bracket notation 分配給 Role :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> =  &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125; &amp; <span class="title class_">UserRoleAttributes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集的原因，role 是會被提出來，像數學的結合律🤔 </span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserRoleAttributes</span> = | </span><br><span class="line">&#123;</span><br><span class="line">  role : <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">  <span class="attr">adminpassword</span>:<span class="built_in">string</span>;</span><br><span class="line">&#125; |&#123;</span><br><span class="line">  role : <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125; | &#123;</span><br><span class="line">  role : <span class="string">&quot;super-admin&quot;</span>;</span><br><span class="line">  <span class="attr">superpassword</span>: <span class="built_in">string</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 bracket notation 拿到物件屬性，也就是 &quot;admin&quot; | &quot;user&quot; | &quot;super-admin&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Role</span> = <span class="title class_">UserRoleAttributes</span>[<span class="string">&quot;role&quot;</span>]</span><br></pre></td></tr></table></figure><p>我覺得這個概念應該是 Role 原本用字串串起來，方便開發 IDE 提示，但是當我們用 <code>&amp;</code> 串在一起之後，反而沒辦法獨立出來，如果其他地方也有要使用到 <code>Role</code>，豈不就要另外建立嗎 ?</p><p>回到型別也會瀑布流這點， <code>UserRoleAttributes</code> 提出來之後，它就是一個物件，差集的部份是每個都有 role 這個 key ，雖然不能 <code>UserRoleAttributes.role</code> ，Object 還有 bracket notation 可以用字串方式取得值，Role 就可以再被提出來。</p><h2 id="被提到但沒解答-decorator">被提到但沒解答 : @decorator</h2><p>在影片中是被提問的，講者說這很少用到🤔。<br> 目前還是實驗性功能，<a href="https://www.typescriptlang.org/docs/handbook/decorators.html#introduction">官網</a>是說用主要用在類別 (Class)，可以參考莫大這片文章 : <a href="https://oldmo860617.medium.com/%E5%8D%81%E5%88%86%E9%90%98%E5%B8%B6%E4%BD%A0%E4%BA%86%E8%A7%A3-typescript-decorator-48c2ae9e246d">十分鐘帶你了解 TypeScript Decorator. 什麼是 Decorator ?</a> 。</p><p>decorator 的用處是在不修改原程式碼的狀況下，在執行原函式的前後做一些特定的操作，同時也把可以重複使用的邏輯切分出去。</p><p>很好!現在的我看不懂🤪，不過應該是用在物件導向開發上有不少幫助，<a href="https://github.com/tc39/proposal-decorators">這項更能未來很可能納為 JavaScript 標準之一</a> 。</p><h2 id="解剩下的題目">解剩下的題目</h2><p>影片到第 07 題就沒了，不過專案的題目有到 18 題，一邊看 handbook 來學習💪</p><h3 id="09-10-型別斷言-Type-Assertion">09 &amp; 10 型別斷言 Type Assertion</h3><h4 id="09-promises-problem">09 promises problem</h4><p>有一些 TS 沒辦法辨別出來的類型，例如 DOM 節點對於 TS 指能辨別到 <code>HTMLElement</code>，如果是更詳細的資訊 (如來自於 <code>HTMLCanvasElement</code> ) 是沒辦法被辨別的。用 Type Assertion 可以手動添加一個值的型別。</p><p>型別斷言有兩種形式 :</p><ul><li><code>&lt;Type&gt;value</code></li><li><code>value as &lt;Type&gt;</code></li></ul><p>在 09 題，data 所回傳的是 Promise 的陣列物件 (await 的緣故)，內涵多個物件的結構，用 <code>LukeSkywalker</code> 定義好型別加上去 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchLukeSkywalker = <span class="keyword">async</span> (): <span class="title class_">Promise</span>&lt;<span class="title class_">LukeSkywalker</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://swapi.dev/api/people/1&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">json</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>解法 2 是在 return 時直接使用 <code>as</code></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> data <span class="keyword">as</span> <span class="title class_">LukeSkywalker</span>;</span><br></pre></td></tr></table></figure><p>我又查了 Handbook， <a href="https://www.typescriptlang.org/docs/handbook/2/objects.html#the-array-type">Handbook 提到</a> :</p><blockquote><p>Modern JavaScript also provides other data structures which are generic, like <code>Map&lt;K, V&gt;</code>, <code>Set&lt;T&gt;</code>, and <code>Promise&lt;T&gt;</code>. All this really means is that because of how Map, Set, and Promise behave, they can work with any sets of types.</p></blockquote><p>泛型類別的資料結構，最常見的就是 Array， <code>[]</code> 有時不只包含一種型別，利用泛型可以讓 TS 在使用時去推斷 <code>Array&lt;T&gt;</code> T 的型別。 Map 、 Set 以及 Promise 也可以用這種方式。</p><ul><li>第一次嘗試用泛型🤔</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchLukeSkywalker = <span class="keyword">async</span> &lt;T&gt;(): <span class="title class_">Promise</span>&lt;T&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://swapi.dev/api/people/1&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">json</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 呼叫時帶入型別</span></span><br><span class="line"><span class="keyword">const</span> result = fetchLukeSkywalker&lt;<span class="title class_">LukeSkywalker</span>&gt;()</span><br></pre></td></tr></table></figure><p>我想用這樣可以讓參數帶入特別的網址，更彈性的帶入指定的型別🤔，後來查一查真的有這些使用方法 :</p><ul><li>這篇提到 any 的部分應該改為 unknown，避免發生呼叫函式方法錯誤的問題 : <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/pull/36868#issuecomment-512989650">Node-Fetch: Generic for “body”.json() method</a></li><li>實際上別人問的問題 : <a href="https://stackoverflow.com/questions/41103360/how-to-use-fetch-in-typescript">promise - How to use fetch in TypeScript - Stack Overflow</a></li></ul><p>應用在 React 上的例子可以參考 Kent.C.Dodds 的文章 : <a href="https://kentcdodds.com/blog/using-fetch-with-type-script">Using fetch with TypeScript</a></p><h4 id="補充-什麼是泛型-Generics">補充 : 什麼是泛型 (Generics) ?</h4><blockquote><p>文章參考 : <a href="https://willh.gitbook.io/typescript-tutorial/advanced/generics?q=Promise">泛型 - TypeScript 新手指南</a></p></blockquote><p>泛型（Generics）是指在定義函式、介面或類別的時候，不預先指定具體的型別，而 <strong>在使用的時候再指定型別的一種特性</strong>。</p><p>關於泛型我也不太了解，簡單來說型別不用再一開始就提供型別，而是有用到時在賦予就好。就像 fetch 的例子，回傳值照理來說是 <code>Promise&lt;any&gt;</code> ，無法固定一種型別內容，如果要根據網址來動態辨別資料型別，泛型就是個很好的小幫手。</p><h4 id="10-Set-Problem">10 Set Problem</h4><p>跟 Promise 的解法一樣，只是不在函式中，而是一般的變數</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> guitarists = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure><p>Set 可以看做是一種 type ，<code>Set&lt;Type&gt;</code> ，而 <code>&lt;Type&gt;</code> 是一種型別模板， 每一個 Set 內部都會被定義 string 的型別。</p><p>在 interface 或 type (Type aliases) 也都能使用，利用 <code>type</code> 產生的可以更加彈性用在 Primitive type 中。 (這句好像怪怪的)</p><h3 id="11-Records">11 Records</h3><p>Records 是 TypeScript 提供內部一些幫助轉換型別的方法，稱做 <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html">Utility Types</a> 工具型別。可以看到每一個 Utility 都接收 Type 並且產生另一種 Type。跟 function 很像對吧， <code>Type = f(type)</code> 🤔</p><p>11 題，可以看到都有用到 <code>id</code> 這個 property，但是 id 是輸入來的，並非已被定義的 property</p><h4 id="解法-1-Bracket-notation">解法 1 : Bracket notation</h4><p>物件造訪有兩種方式 :</p><ol><li>熟悉的 dot notation : <code>obj.a</code></li><li>可以輸入字串字或數字的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#bracket_notation">Bracket notation</a> : <code>obj['0']</code> or <code>obj['rosa']</code></li></ol><p>既然 id 是任意的，dot 只適合固定已知的 property，所以用 bracket</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Cache</span> = &#123;</span><br><span class="line">  [<span class="attr">id</span>: <span class="built_in">string</span>] : <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createCache</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">cache</span>:<span class="title class_">Cache</span> = &#123;&#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解法-2-inline-寫法">解法 2 : inline 寫法</h4><p>跟上面的一樣，只是在原地拆開</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">createCache</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">cache</span>:&#123;</span><br><span class="line">    [<span class="attr">id</span>: <span class="built_in">string</span>] : <span class="built_in">string</span></span><br><span class="line">  &#125; = &#123;&#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解法-3-Records">解法 3 : Records</h4><p>用法 : <code>Record&lt;Keys, Type&gt;</code> 。 一次指定 key 跟 value 的型別</p><p>此外也可以做物件 key-value 的組合方法，官方的提供的範例 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CatInfo 物件的 type</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CatInfo</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">breed</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CatName 的 type</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CatName</span> = <span class="string">&quot;miffy&quot;</span> | <span class="string">&quot;boris&quot;</span> | <span class="string">&quot;mordred&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record 使其對應一起</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">cats</span>: <span class="title class_">Record</span>&lt;<span class="title class_">CatName</span>, <span class="title class_">CatInfo</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">miffy</span>: &#123; <span class="attr">age</span>: <span class="number">10</span>, <span class="attr">breed</span>: <span class="string">&quot;Persian&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">boris</span>: &#123; <span class="attr">age</span>: <span class="number">5</span>, <span class="attr">breed</span>: <span class="string">&quot;Maine Coon&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">mordred</span>: &#123; <span class="attr">age</span>: <span class="number">16</span>, <span class="attr">breed</span>: <span class="string">&quot;British Shorthair&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">cats.<span class="property">boris</span>;</span><br></pre></td></tr></table></figure><p>如此一來 key 就被限制在 <code>CatName</code> 的範圍裡，新增減少都不行，info 也是要照格式填。</p><p>回到練習題 11，key-value 配對，我們只要填上 key-value 的型別就完成了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">cache</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; = &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="12-限縮-Narrowing-typeof-guards">12 限縮 Narrowing + typeof guards</h3><blockquote><p>文章參考 : <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards">TypeScript: Documentation - Narrowing</a></p></blockquote><p>Unions ( <code>|</code> ) 的使用除了多個字串，讓我們在編輯器上直接做快速選擇之外，如果放多種不同型別，會有排序定型別、限縮型別的效果 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">coerceAmount</span> = (<span class="params">amount: <span class="built_in">number</span> | &#123; amount: <span class="built_in">number</span> &#125;</span>) =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>參數 <code>amount</code> 允許輸入兩種型別，分別是 number 跟 object 。在 JavaScript 中如果要知道值得型別會使用 <code>typeof</code> ，除了幾個比較特例的 Array 或 null ，大部分的型別都是可以被辨別出來的。</p><p>變數使用 ( <code>|</code> ) 之後在內部要再用 <code>typeof</code> 幫助我們更精準判斷其型別，TS 稱做 <strong>typeof<br> type guards</strong>， 以 12 題的解法加上 <code>typeof</code> 判斷限制。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">coerceAmount</span> = (<span class="params">amount: <span class="built_in">number</span> | &#123; amount: <span class="built_in">number</span> &#125;</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> amount === <span class="string">&#x27;number&#x27;</span>) <span class="keyword">return</span> amount</span><br><span class="line">    <span class="keyword">return</span> amount.<span class="property">amount</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>別忘了 <code>typeof</code> 回傳值是 string</p></blockquote><p><code>typeof</code> 適合拿來用在基本型別與 object 、 function ，其他的 null 、0 (數字/字串)、<code>NaN</code> 等都有對應的方式解決，可以參考官方的 handbook。</p><h3 id="13-try-catch-中的錯誤處理">13 try catch 中的錯誤處理</h3><p>13 題是 try…catch 錯誤很常見的情形 ， <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Error#error_types">e 是錯誤 ( Error ) 的物件，是一個泛型</a>，簡單來說不能很確定他的型別，這時候要 e 怎麼定義呢 ?</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">tryCatchDemo</span> = (<span class="params">state: <span class="string">&quot;fail&quot;</span> | <span class="string">&quot;succeed&quot;</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">&quot;fail&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Failure!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> e.<span class="property">message</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解法-1-Type-Assertion">解法 1 : Type Assertion</h4><p>已知他是個 Error 物件，並不在一般的型別裡面。我們可以用型別斷言 (Type Assertion) 來幫助辨別更細節的類型，例如 : Error 可能是 <code>DOMException</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 用 as </span></span><br><span class="line">  <span class="keyword">return</span> (e <span class="keyword">as</span> <span class="title class_">Error</span>).<span class="property">message</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 要變成這樣也是可以🤔 (?)</span></span><br><span class="line">  <span class="keyword">return</span> (&lt;<span class="title class_">Error</span>&gt;e).<span class="property">message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咦 ? 為什麼不是寫在參數 <code>e</code> 旁邊呢 ?</p><blockquote><p>文章參考 : <a href="https://kentcdodds.com/blog/get-a-catch-block-error-message-with-typescript">Get a catch block error message with TypeScript</a></p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ❌ interface Error</span></span><br><span class="line"><span class="comment">Catch clause variable type annotation must be &#x27;any&#x27; or &#x27;unknown&#x27; if specified.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">catch</span> (e : <span class="title class_">Error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> e.<span class="property">message</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>結果會發生錯誤，Error 也不再 TS 辨識的型別裡面，<code>Error</code> 就被當作型別 (type/interface)，實際上是 <code>catch(e)</code> 這裡就被判別為 Error ，太早了，JS 會跳出錯誤。</p><h4 id="解法-2-any">解法 2 : any</h4><p>我覺得更像是某種逃避/忽略手段🤣。不過這樣的情形不少見，例如 : 跟 fetch 回傳 Promise 拿來回的資料也是泛型，因此有的人處理會是 <code>Promise&lt;any&gt;</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (e : <span class="built_in">any</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> e.<span class="property">message</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法-3-instance-of">解法 3 : instance of</h4><blockquote><p>文章參考 : <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#instanceof-narrowing">instance of narrowing</a></p></blockquote><p>跟上面提及的 Narrowing 是同一組，只是更細微的找尋 prototype chain 上的 instance，例如 : <code>Object.prototype</code> 是一切的起源，但是 string 、 number 等這些東西也有是在型別包裹器的 chain 上，JS 找鏈上的規則是找到就停，因此 string 會停留在 <code>String.prototype</code> ，讓 string 可以用類似物件使用 method。</p><p>instance of 可以在更細分不同的 Error 型別，或者就拿它來判斷是不是 Error 的一種</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">Error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> e.<span class="property">message</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 MDN 也有提到這部分 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch#conditional_catch-blocks">try…catch - JavaScript | MDN</a>， 用 instance of 區分不同的 Error。</p><h3 id="14-extends-interface-物件擴充">14 extends : interface 物件擴充</h3><p>14 題就是把相同的型別邏輯拉出來，相關使用的都用繼承，沒什麼難度</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserBase</span> &#123;</span><br><span class="line">  id : <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">UserBase</span>&#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Post</span> <span class="keyword">extends</span> <span class="title class_">UserBase</span>&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">body</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Comment</span> <span class="keyword">extends</span> <span class="title class_">UserBase</span>&#123;</span><br><span class="line">  <span class="attr">comment</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-intersection-物件交集合併">15 intersection : 物件交集合併</h3><p>交集 <code>&amp;</code> 可以讓 <code>type</code> 合併， 15 題可以看到多了 <code>posts</code> key，在回傳的部分可以加上 type :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getDefaultUserAndPosts = (): <span class="title class_">User</span> &amp; &#123;<span class="attr">posts</span>: <span class="title class_">Post</span>[]&#125; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&quot;Pocock&quot;</span>,</span><br><span class="line">    <span class="attr">posts</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;How I eat so much cheese&quot;</span>,</span><br><span class="line">        <span class="attr">body</span>: <span class="string">&quot;It&#x27;s pretty edam difficult&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這邊用一行解決，以可以另外提出 <code>type XX = User &amp; &#123;posts: Post[]&#125;</code>，另外用 <code>as</code> 也是種解法，但不是那麼直覺。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type 提出來</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserwPosts</span> = <span class="title class_">User</span> &amp; &#123;<span class="attr">posts</span>: <span class="title class_">Post</span>[]&#125; </span><br><span class="line"><span class="comment">// as </span></span><br><span class="line"><span class="keyword">return</span> &#123;...&#125; <span class="keyword">as</span> (<span class="title class_">User</span> &amp; &#123;<span class="attr">posts</span>: <span class="title class_">Post</span>[]&#125;) </span><br></pre></td></tr></table></figure><h3 id="16-omit-and-pick">16 omit and pick</h3><blockquote><p>文章參考 : <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys">Omit &amp; Pick</a></p></blockquote><p>除了 Record ，<code>Omit</code> 跟 <code>Pick</code> 都是 Utility type 之一，我覺得跟 <code>Array.filter</code> 一樣。</p><ul><li><code>Omit&lt;Type,Keys&gt;</code> : 忽略</li><li><code>Pick&lt;Type, Keys&gt;</code> : 挑出需要的</li></ul><p>一開始我想說怎麼不要用 <code>optional</code> 呢 🤔 ? 結果是不行的，因為它不是真的消失在這個 type 裡面，只是把 id 看做 <code>undefined</code>。</p><p>Omit 跟 Pick 後面傳入的 keys 可以多個字串，要使用差集 ( <code>|</code> )，就像漏斗一樣，把結果給篩出來 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要 id</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">User</span>,<span class="string">&quot;id&quot;</span>&gt;;</span><br><span class="line"><span class="comment">// 要 firstName &amp; lastName</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">User</span>, <span class="string">&quot;firstName&quot;</span> | <span class="string">&quot;lastName&quot;</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="17-function-types">17 function types</h3><blockquote><p>文章參考 : <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#function-type-expressions">Function Type Expressions</a></p></blockquote><p>17 是非常實用的一題，很常在參數傳入 callback function 來達成非同步的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dosomething</span> = (<span class="params">cb</span>) =&gt;&#123;</span><br><span class="line">  <span class="title function_">cb</span>() </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>為 function 加上型別最基本的長相 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(param : <span class="keyword">type</span>) =&gt; <span class="built_in">void</span> </span><br></pre></td></tr></table></figure><ul><li><code>void</code> : 沒有回傳值或 <code>undefined</code> 的情況。</li><li>如果有傳入參數一定要填有參數名，不能只有型別 <code>(string) =&gt; void</code>，這樣會是指 <code>string : any</code> ， 變數 string 的型別是 any。</li></ul><p>17 題的解法 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">addListener</span> = (<span class="params">onFocusChange:(isFocused : <span class="built_in">boolean</span>)=&gt;<span class="built_in">void</span> </span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;focus&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">onFocusChange</span>(<span class="literal">true</span>); <span class="comment">// 👉 沒有回傳只有呼叫，傳入一個參數</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 另一種就是把他提出來</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FocusListener</span> = <span class="function">(<span class="params">isFocused : <span class="built_in">boolean</span></span>)=&gt;</span><span class="built_in">void</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addListener</span> = (<span class="params">onFocusChange : FocusListener</span>) =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="18-Promise-function">18 Promise function</h3><p>Promise 的泛型已經在 09 題有提過，18 題加了點難度，結合 async/await 。</p><p>async 是一個 function 的形式，並且回傳 Promise 物件 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">createThenGetUser</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createThenGetUser</span> = <span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><p>內部可以用 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/await">await</a> 等待 Promise 物件的回傳值，如果把回傳值傳給另一個 promise 會拿到解析過的值。 <code>createUser</code> 與 <code>getUser</code> 是一個 function 回傳 Promise</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 實際上 createUser、getUser 長這樣，幫它加上 type</span></span><br><span class="line"><span class="keyword">const</span> createUser = () : <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt; =&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getUser = (<span class="attr">id</span>:<span class="built_in">string</span>) :<span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt; =&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放在參數變成 function 的格式再慢慢填回去 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由於 userId 是 string 確定了 Promise 的泛型為 string</span></span><br><span class="line">createUser : <span class="function">()=&gt;</span> <span class="built_in">void</span></span><br><span class="line">createUser : <span class="function">()=&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// userId 是參數，並且回傳 user 是 User type</span></span><br><span class="line">getUser : <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">getUser : <span class="function">(<span class="params">id : <span class="built_in">string</span></span>) =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="title class_">User</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>放回去結果就是 :</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createThenGetUser = <span class="keyword">async</span> (</span><br><span class="line">  <span class="attr">createUser</span>: <span class="function">()=&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;,</span><br><span class="line">  <span class="attr">getUser</span>: <span class="function">(<span class="params">id : <span class="built_in">string</span></span>) =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="title class_">User</span>&gt;</span><br><span class="line">  ): <span class="title class_">Promise</span>&lt;<span class="title class_">User</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">userId</span>: <span class="built_in">string</span> = <span class="keyword">await</span> <span class="title function_">createUser</span>();</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="title function_">getUser</span>(userId);</span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="總結-22">總結</h2><p>寫的時候跟拼拼圖一樣，這篇變得非常雜燴，我不認為是好筆記，當作資訊索引吧 🤔。</p><ul><li>TS 定義型別的好處是提早在編譯之前就可以發現錯誤，提高開發時的效率</li><li>定義型別可以有 3 種方式 :<ol><li><strong>inline</strong> : 在值的後面加上冒號與型別 <code>(a : number)</code></li><li><strong>type</strong> : Primitive type 、Object type 都可以使用</li><li><strong>interface</strong> : 僅用於物件類型 (Object/Class)，可以使用 extends 繼承</li></ol></li><li><code>?</code> optional type 用來選擇性的值，<code>value?: type</code></li><li><code>|</code> (OR) 符號是有兩種作用<ol><li>如果是型別 (type)，按照排序與變數使用時的邏輯限縮型別。<code>string | number</code></li><li>如果是多個字串，IDE 會提示的字可選擇，避免打錯字。<code>&quot;rosa&quot;|&quot;john&quot;|&quot;tofu&quot;</code></li></ol></li><li><code>&amp;</code> (AND) 符號是對 types 或 interface 做交集合併，別於 interface 的 extends。</li><li>function 作為參數的型別是基本是 <code>( ()=&gt; void )</code></li><li><code>void</code> 是 function 沒有回傳或是 <code>undefind</code> 時使用</li></ul><p>影片以有趣的方式來學習 TS，雖然沒有到很全面🤔，過程透過提問更讓我知道應用上的解決方法，跟著脈絡走對於初步入門是可以嘗試看看的。最後我也沒想過我會寫這麼長篇 …。</p><p>第一次使用 TS 我的心得是 <strong>真的非常的複雜跟麻煩</strong>，光是規則就令人頭疼😵，深刻感覺到 「用的好上天堂，用不好下地獄」，要說跟 JavaScript 有關嗎 ? 真的更像學另一種語言。</p></div><div class="popular-posts-header">相關文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="\2022\11\TypeScript\TypeScript-why-Object.keys-is-unsafe.html" rel="bookmark">筆記 | TypeScript - Object.keys 為什麼不安全</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/TypeScript/" rel="tag"><i class="fa fa-tag"></i> TypeScript</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2022/09/learing-web-performance" rel="prev" title="筆記 | Web - 初探前端效能優化"><i class="fa fa-chevron-left"></i> 筆記 | Web - 初探前端效能優化</a></div><div class="post-nav-item"> <a href="/2022/11/TypeScript/TypeScript-why-Object.keys-is-unsafe" rel="next" title="筆記 | TypeScript - Object.keys 為什麼不安全">筆記 | TypeScript - Object.keys 為什麼不安全<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div style=""><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">RosaHong</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>總字數：</span> <span title="總字數">293k</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>所需總閱讀時間 &asymp;</span> <span title="所需總閱讀時間">4:27</span></span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 強力驅動</div></div></footer><script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1.15.0/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.7.0/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"></body></html>