<!DOCTYPE html><html lang="zh-TW"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/shan-logo-appletouch.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/shan-logo.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/shan-logo-16X16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><script class="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"blog.rosa.tw",root:"/",scheme:"Gemini",version:"8.0.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,"Pisces | Gemini":240},copycode:!0,bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"buttons",active:!0,storage:!0,lazyload:!0,nav:{disqus:{text:"留言區",order:-1}},"Available values":"disqus"},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"fadeInDown",post_body:"fadeInDown",coll_header:"fadeInLeft",sidebar:"fadeInUp"}},prism:!1,i18n:{placeholder:"搜尋...",empty:"We didn't find any results for the search: ${query}",hits_time:"${hits} results found in ${time} ms",hits:"${hits} results found"},path:"search.xml",localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-S8ZEBJDRWG"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-S8ZEBJDRWG")</script><meta name="description" content="文章來自 : useEffect 的完整指南 — Overreacted  摘要  useEffect 的基礎概念 useEffect dependencies array 的使用方式  大部分都是來自原文的再翻譯，我有些比較不懂的部分就用自己的方式去解釋，也會用原始的 JS 實作的方式，跟著一步步編譯。 更重要的是，要用 React 的思維來去了解 useEffect 的內涵。"><meta property="og:type" content="article"><meta property="og:title" content="筆記 | React - 重新了解 useEffect"><meta property="og:url" content="https://blog.rosa.tw/2022/08/React/react-useEffect-about-everythings"><meta property="og:site_name" content="健忘雜記"><meta property="og:description" content="文章來自 : useEffect 的完整指南 — Overreacted  摘要  useEffect 的基礎概念 useEffect dependencies array 的使用方式  大部分都是來自原文的再翻譯，我有些比較不懂的部分就用自己的方式去解釋，也會用原始的 JS 實作的方式，跟著一步步編譯。 更重要的是，要用 React 的思維來去了解 useEffect 的內涵。"><meta property="og:locale" content="zh_TW"><meta property="og:image" content="https://raw.githubusercontent.com/donavon/hook-flow/master/hook-flow.png"><meta property="og:image" content="https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif"><meta property="og:image" content="https://i.imgur.com/cpFlaro.png"><meta property="og:image" content="https://i.imgur.com/Hh8l045.png"><meta property="article:published_time" content="2022-08-14T03:27:57.000Z"><meta property="article:modified_time" content="2022-08-14T15:28:46.954Z"><meta property="article:author" content="Rosa Hong"><meta property="article:tag" content="React"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://raw.githubusercontent.com/donavon/hook-flow/master/hook-flow.png"><link rel="canonical" href="https://blog.rosa.tw/2022/08/React/react-useEffect-about-everythings.html"><script class="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-TW"}</script><title>筆記 | React - 重新了解 useEffect | 健忘雜記</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-S8ZEBJDRWG"></script><script>if(CONFIG.hostname===location.hostname){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-S8ZEBJDRWG")}</script><noscript><style>body{margin-top:2rem}.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header,.use-motion .sidebar{visibility:visible}.use-motion .footer,.use-motion .header,.use-motion .site-brand-container .toggle{opacity:initial}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line{transform:scaleX(1)}.search-pop-overlay,.sidebar-nav{display:none}.sidebar-panel{display:block}</style></noscript><link rel="alternate" href="/atom.xml" title="健忘雜記" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切換導航欄"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">健忘雜記</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">紀錄學習與生活</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首頁</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 標籤<span class="badge">27</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分類<span class="badge">18</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 歸檔<span class="badge">58</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜尋</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜尋..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目錄</li><li class="sidebar-nav-overview"> 本站概要</li></ul><section class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%98%E8%A6%81-10"><span class="nav-number">1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-%E7%9A%84%E6%B8%B2%E6%9F%93%E6%A9%9F%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">React 的渲染機制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#render-function-%E5%85%A7%E7%9A%84-function"><span class="nav-number">3.</span> <span class="nav-text">render function 內的 function ?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#function-%E5%85%A7%E9%83%A8%E6%89%80%E5%BC%95%E7%94%A8%E7%9A%84-state-%E9%97%9C%E4%BF%82"><span class="nav-number">3.1.</span> <span class="nav-text">function 內部所引用的 state 關係</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E9%A0%AD%E7%9C%8B-React-%E7%9A%84-render-%E5%85%A7%E9%83%A8%E7%9A%84-function"><span class="nav-number">3.2.</span> <span class="nav-text">回頭看 React 的 render 內部的 function</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%8F%E4%B8%80%E6%AC%A1-render-%E9%83%BD%E5%AE%83%E8%87%AA%E5%B7%B1%E7%9A%84-Effect"><span class="nav-number">4.</span> <span class="nav-text">每一次 render 都它自己的 Effect</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%8F%E4%B8%80%E6%AC%A1-render-%E4%BF%9D%E6%9C%89%E5%AE%83%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%B1%E8%A5%BF"><span class="nav-number">5.</span> <span class="nav-text">每一次 render 保有它的所有東西</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%9F-class-Component-%E7%9A%84%E5%B7%AE%E5%88%A5"><span class="nav-number">5.1.</span> <span class="nav-text">跟 class Component 的差別</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8B%BF%E5%8F%96%E6%9C%80%E6%96%B0%E7%9A%84-state"><span class="nav-number">6.</span> <span class="nav-text">如何拿取最新的 state ?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-ref-%E4%BE%86%E5%8F%96%E5%BE%97%E6%9C%80%E6%96%B0%E5%80%BC"><span class="nav-number">7.</span> <span class="nav-text">使用 ref 來取得最新值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AB%87%E8%AB%87-clean-up"><span class="nav-number">8.</span> <span class="nav-text">談談 clean up</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%9F%B7%E8%A1%8C%E4%BD%86%E4%B8%8D%E6%98%AF%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F"><span class="nav-number">9.</span> <span class="nav-text">同步執行但不是生命週期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%8A%E8%A8%B4-React-%E4%B8%8D%E5%90%8C-effect-%E4%B9%8B%E9%96%93%E7%9A%84%E5%B7%AE%E5%88%A5"><span class="nav-number">10.</span> <span class="nav-text">告訴 React 不同 effect 之間的差別</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E5%B0%8D-dependencies-%E8%AA%AA%E8%AC%8A"><span class="nav-number">11.</span> <span class="nav-text">不要對 dependencies 說謊</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dependencies-%E8%AA%AA%E8%AC%8A%E4%BA%86%E6%9C%83%E7%99%BC%E7%94%9F%E4%BB%80%E9%BA%BC%E5%95%8F%E9%A1%8C"><span class="nav-number">11.1.</span> <span class="nav-text">dependencies 說謊了會發生什麼問題 ?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AA%A0%E5%AF%A6%E4%BB%A5%E5%B0%8D-dependencies%EF%BC%8C%E6%8A%8A%E6%9C%89%E9%97%9C%E7%9A%84%E6%94%BE%E5%85%A5-array-%E4%B8%AD"><span class="nav-number">11.2.</span> <span class="nav-text">誠實以對 dependencies，把有關的放入 array 中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E4%BD%BF%E7%94%A8-useEffect"><span class="nav-number">12.</span> <span class="nav-text">有效率的使用 useEffect</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A9%A6%E8%91%97%E6%8B%86%E8%A7%A3%E4%B8%A6%E4%BA%86%E8%A7%A3"><span class="nav-number">12.1.</span> <span class="nav-text">試著拆解並了解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%9E-Google-%E6%96%87%E4%BB%B6%E7%9A%84%E6%9B%B4%E6%96%B0%E4%BA%86%E8%A7%A3-function-updater"><span class="nav-number">13.</span> <span class="nav-text">從 Google 文件的更新了解 function updater</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%87%E8%B3%87%E6%96%99%E6%9B%B4%E6%96%B0%E8%88%87%E6%93%8D%E4%BD%9C%E5%88%86%E9%9B%A2"><span class="nav-number">14.</span> <span class="nav-text">將資料更新與操作分離</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%A6%E9%A9%97-%E5%88%86%E9%96%8B%E7%9A%84%E5%85%A9%E7%AD%86%E8%B3%87%E6%96%99%E6%9B%B4%E6%96%B0"><span class="nav-number">14.1.</span> <span class="nav-text">實驗 : 分開的兩筆資料更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%A6%E9%A9%97-%E5%86%8D%E6%9F%90%E7%AD%86%E8%B3%87%E6%96%99%E5%85%A7%E9%83%A8%E6%8B%BF%E5%88%B0%E6%9C%80%E6%96%B0"><span class="nav-number">14.2.</span> <span class="nav-text">實驗 : 再某筆資料內部拿到最新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%A6%E9%A9%97-object-type-%E7%9A%84-state"><span class="nav-number">14.3.</span> <span class="nav-text">實驗 : object type 的 state</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%A6%E9%A9%97-%E6%8A%8A-input-%E8%AE%8A%E6%88%90-uncontrolled-component"><span class="nav-number">14.4.</span> <span class="nav-text">實驗 : 把 input 變成 uncontrolled component</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E5%88%B0-useReducer"><span class="nav-number">15.</span> <span class="nav-text">回到 useReducer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%82%BA%E4%BB%80%E9%BA%BC-useReducer-%E6%98%AF-Hooks-%E7%9A%84%E4%BD%9C%E5%BC%8A%E6%96%B9%E5%BC%8F"><span class="nav-number">16.</span> <span class="nav-text">為什麼 useReducer 是 Hooks 的作弊方式 ?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%99%BD%E8%A9%B1%E7%BF%BB%E8%AD%AF%E6%A9%9F"><span class="nav-number">16.1.</span> <span class="nav-text">白話翻譯機</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%BA%E9%AB%94%E7%B7%A8%E8%AD%AF"><span class="nav-number">16.2.</span> <span class="nav-text">人體編譯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8A-function-%E7%A7%BB%E5%88%B0-useEffect-%E4%B8%AD"><span class="nav-number">17.</span> <span class="nav-text">把 function 移到 useEffect 中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E6%8A%8A-function-%E7%A7%BB%E5%85%A5-useEffect-%E6%80%8E%E9%BA%BC%E8%BE%A6"><span class="nav-number">18.</span> <span class="nav-text">不能把 function 移入 useEffect 怎麼辦 ?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#function-%E6%98%AF%E8%B3%87%E6%96%99%E6%B5%81%E7%9A%84%E4%B8%80%E7%A8%AE%E5%97%8E"><span class="nav-number">19.</span> <span class="nav-text">function 是資料流的一種嗎 ?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F-4"><span class="nav-number">19.1.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AB%87%E8%AB%87%E7%AB%B6%E7%88%AD%E6%A2%9D%E4%BB%B6-race-condition"><span class="nav-number">20.</span> <span class="nav-text">談談競爭條件 (race condition)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%AD%A3%E7%A2%BA%E7%9A%84%E5%BF%83%E6%85%8B%E5%B0%8D%E5%BE%85-useEffect"><span class="nav-number">21.</span> <span class="nav-text">用正確的心態對待 useEffect</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B8%BD%E7%B5%90-33"><span class="nav-number">22.</span> <span class="nav-text">總結</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%8C%E5%A4%96%E8%A9%B1"><span class="nav-number">22.1.</span> <span class="nav-text">題外話</span></a></li></ol></li></ol></div></section><section class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Rosa Hong" src="/images/RosaBlog-LOGO.png"><p class="site-author-name" itemprop="name">Rosa Hong</p><div class="site-description" itemprop="description">菜鳥起飛中</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">58</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">分類</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">27</span> <span class="site-state-item-name">標籤</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/meitung473" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;meitung473" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a></span><span class="links-of-author-item"><a href="mailto:a8870506@gmail.com" title="聯絡我 → mailto:a8870506@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a></span><span class="links-of-author-item"><a href="https://www.facebook.com/yanshan.hong1" title="Rosa Hong → https:&#x2F;&#x2F;www.facebook.com&#x2F;yanshan.hong1" rel="noopener" target="_blank"><i class="fa fa-facebook fa-fw"></i></a></span></div></section></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-TW"><link itemprop="mainEntityOfPage" href="https://blog.rosa.tw/2022/08/React/react-useEffect-about-everythings"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/RosaBlog-LOGO.png"><meta itemprop="name" content="Rosa Hong"><meta itemprop="description" content="菜鳥起飛中"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="健忘雜記"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 筆記 | React - 重新了解 useEffect</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">發表於</span> <time title="創建時間：2022-08-14 11:27:57" itemprop="dateCreated datePublished" datetime="2022-08-14T11:27:57+08:00">2022-08-14</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分類於</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Front-end/" itemprop="url" rel="index"><span itemprop="name">Front-end</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Front-end/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a></span></span></div><div class="post-meta"><span class="post-meta-item" title="文章字數"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">文章字數：</span> <span>39k</span></span><span class="post-meta-item" title="所需閱讀時間"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">所需閱讀時間 &asymp;</span> <span>35 分鐘</span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>文章來自 : <a href="https://overreacted.io/zh-hant/a-complete-guide-to-useeffect/">useEffect 的完整指南 — Overreacted</a></p></blockquote><h2 id="摘要-10">摘要</h2><ol><li>useEffect 的基礎概念</li><li>useEffect dependencies array 的使用方式</li></ol><p>大部分都是來自原文的再翻譯，我有些比較不懂的部分就用自己的方式去解釋，也會用原始的 JS 實作的方式，跟著一步步編譯。</p><p>更重要的是，要用 React 的思維來去了解 <code>useEffect</code> 的內涵。</p><span id="more"></span><h2 id="React-的渲染機制">React 的渲染機制</h2><p>了解 useEffect 之前，先來了解 <code>setState</code> 的時候會發生什麼事。<br> 當我們 <code>setState</code> 時，React 會重新呼叫 Component function，並更新其值，接著<br> React 把我們最新的值更新到 DOM 上。</p><p>而 <code>useEffect</code> 執行的時間點在 render 之後，為什麼 <code>useEffect</code> 會拿到舊的 state 跟 props ?</p><blockquote><p>每一次都渲染都保有自己的 state 跟 props</p></blockquote><p>我們試著把每次 render 拆開來</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useState </span></span><br><span class="line"><span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 1 次 render 是這樣</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">0</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第 2 次 render</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">1</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次 render 重新呼叫 <code>Counter()</code> ，把 count 每次重新賦值，每次 render state 都會是獨立的。</p><p>什麼意思呢？🤔 就是你在一周目看到的資料，既然你在一周目取資料，那也只會拿到一周目的資料。並不能直接取二、三周目的東西。</p><p><code>useEffect</code> 雖然是渲染後執行的，但他其實還是待在同一個時間線的渲染 (也就是同步的)，並不是真正意味上的「渲染 <strong>後</strong>」，別被文字搞混了。</p><h2 id="render-function-內的-function">render function 內的 function ?</h2><p>文中<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>範例順序是</p><ol><li>把 state 加到 3</li><li>按下 <code>alert</code> 按鍵 ( <code>setTimeout</code> for<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span> seconds , and 顯示 state )</li><li>馬上把 state 加到 5，最後顯示是 ?</li></ol><blockquote><p>結果是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span> ，這裡是抓到 (capture) 按下按鈕的 <strong>當下</strong></p></blockquote><p>可以想像成聊天 app ，跟 A 聊天送出訊息，接著馬上切換跟 B 輸入訊息，確實是 A 收到訊息，並不是 B 收到。<br> 在 class Component 跟 functional Component 兩種解決不同的問題 (閉包)</p><h3 id="function-內部所引用的-state-關係">function 內部所引用的 state 關係</h3><p>從最根本的 JavaScript 來看，例子是從文章來的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">person</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = person.<span class="property">name</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Hello, &#x27;</span> + name);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someone = &#123;<span class="attr">name</span>: <span class="string">&#x27;Dan&#x27;</span>&#125;;</span><br><span class="line"><span class="title function_">sayHi</span>(someone);</span><br><span class="line"></span><br><span class="line">someone = &#123;<span class="attr">name</span>: <span class="string">&#x27;Yuzhi&#x27;</span>&#125;;</span><br><span class="line"><span class="title function_">sayHi</span>(someone);</span><br><span class="line"></span><br><span class="line">someone = &#123;<span class="attr">name</span>: <span class="string">&#x27;Dominic&#x27;</span>&#125;;</span><br><span class="line"><span class="title function_">sayHi</span>(someone);</span><br></pre></td></tr></table></figure><p>可以看到 <code>person.name</code> 一開始是 ‘Dan’，但是每次 <code>sayHi</code> 都會經歷以下步驟 :</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第 1 次 </span></span><br><span class="line"><span class="keyword">name</span> = Dan </span><br><span class="line">setTimout 拿到的 <span class="keyword">name</span> 是外部的 <span class="keyword">name</span> = Dan</span><br><span class="line"><span class="comment">// 第 2 次</span></span><br><span class="line"><span class="keyword">name</span> = Yuzhi</span><br><span class="line">setTimout 拿到的 <span class="keyword">name</span> 是外部的 <span class="keyword">name</span> = Yuzhi</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>用 JavaScript 來說就是閉包 (closure) 的概念，Call Stack 到 <code>setTimeout()</code> 的時候，<code>sayHi</code> 裡面宣告的變數會被儲存下來，存在內部，並沒有被回收掉，因此 <code>setTimeout()</code> 當下拿到的值是 <strong>內部已經計算完且被記錄起來的值</strong>，才會是捕獲 (capture) 當時的值。</p><blockquote><p><code>setTimeout</code> 拿到的值會是當下執行完所記錄下的值，這也說明了為什麼 useEffect 會拿到舊的 state : <strong>當下的 <code>setTimeout()</code> 是拿閉包的值。</strong></p></blockquote><h3 id="回頭看-React-的-render-內部的-function">回頭看 React 的 render 內部的 function</h3><p>已經知道 <code>setTimeout</code> 會記錄下當次 render 的值，不管哪一次的 render ，它當次的 state 與 props 都會是一樣的。如果是不同次的 render ，它的 state 和 props 是獨立的，在事件 (event handler) 或事件內的非同步 (async/await) 事件也都是一樣的原則。</p><p>範例用 <code>inline function</code> 是安全的 (button 的 click 事件)，因為 state 的 count 不會每次都被變動 (意思應該是 <strong>產生新的記憶體空間</strong>，指跟 object type 的差別)，如果 state 是 object type 的類型，必須確保 object 是用 <strong>Immutable</strong> 的方式改變。</p><p>文中提到 <code>setState(newObj)</code> 是合理的，為什麼這麼說呢 ?<br> 只要<strong>記住每次 render 都有自己的 state 或 props</strong> ，直接改改成 <code>newObj</code>是沒問的，對於前一次的 render 也是完整的值。<br> 👉 <a href="https://codepen.io/shan473/pen/jOzeWEb?editors=0011">codepen 簡易範例，請看 useRef 變化</a></p><p>例如 : 結構類似，但是巢狀內部有部分改變</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假如原本的 state</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  a : &#123;</span><br><span class="line">    b : <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newState = &#123;</span><br><span class="line">  a : &#123;</span><br><span class="line">    b : <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ✅ 刷新整筆資料，這樣沒問題</span></span><br><span class="line"><span class="title function_">setState</span>(newState)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 直接對值內部些微調整，React 根本察覺不到，不會 re-render</span></span><br><span class="line"><span class="title function_">setState</span>(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">  prevState.<span class="property">a</span>.<span class="property">b</span> = newState.<span class="property">a</span>.<span class="property">b</span></span><br><span class="line">  <span class="keyword">return</span> prevState</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>當我們要觸發 <code>setState</code> 時，React 會先經過 state 的淺比較 (shallow comparison)，如果直接改變並不會 re-render。</p><h2 id="每一次-render-都它自己的-Effect">每一次 render 都它自己的 Effect</h2><p>React 會記住每個 <code>useEffect</code>，觸發的時間點是每次改變 DOM 之後與 browser 渲染完之後才會呼叫。</p><p>概念上來說，effect 是這次 render 後的結果 (render 後才執行的)，但 effect 其實也跟上面提及的 [[#回頭看 React 的 render 內部的 function]] 章節一樣的概念，其 state 跟 props 是都是屬於當次 render 的，effect 也是。</p><h2 id="每一次-render-保有它的所有東西">每一次 render 保有它的所有東西</h2><p>範例<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 。<br> 已經知道 function 每一次的 render 會計下 <code>useEffect</code>，並且拿到內部 <code>local state</code> 的值。</p><p>跟著 <code>setTimeout</code> 跑一次 :</p><ul><li>第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 次 render<ol><li>state 是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></li><li>React 記下 effect : 3 秒之後 You clicked 0 times</li><li><code>Counter</code> 回傳提交 UI 給 React</li><li>React 跟 DOM 溝通並且瀏覽器渲染了畫面</li><li><code>useEffect</code> 這時候呼叫 React 所記下的 effect ，等到 3 秒之後 : 印出 You clicked 0 times</li></ol></li></ul><p>接著按下 button 觸發 <code>setCount</code> 讓 count + 1，React 重新呼叫 <code>Counter()</code> ，進行第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 次渲染</p><ul><li>第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 次 render<ol><li>state 變成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></li><li>React 記下 effect : 3 秒之後 You clicked 1 times</li><li><code>Counter</code> 回傳提交 UI 給 React</li><li>React 跟 DOM 溝通並且瀏覽器渲染了畫面</li><li><code>useEffect</code> 這時候呼叫 React 所記下的 effect ，等到 3 秒之後 : 印出 You clicked 1 times</li></ol></li></ul><p>後面以此類推。<br> function component 是這樣操作，但是 class Component 在處理 effect 時卻不是這樣的。</p><h3 id="跟-class-Component-的差別">跟 class Component 的差別</h3><p>範例<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup><br> 凡有關 effect 的操作會放在 <code>componentDidUpdate</code> 這裡，意思是 <strong>state 或 props 變更之後要做什麼事</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`You clicked <span class="subst">$&#123;<span class="variable language_">this</span>.state.count&#125;</span> times`</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡的 <code>this.state.count</code> 都會是現在的 count，也就是按到 5 <code>setTimeout</code> 抓到的都會是 5 ，而不是 <strong>當下</strong> 觸發的 count。</p><p>每一次 render 都是呼叫內部的 <code>render()</code> function ， state 永遠是指像實例的 state。</p><p>複習一下 class component 的 React 生命週期是</p><blockquote><ol><li><strong>Mouting</strong> : constructor 👉 render 👉 capture refs and DOM 👉DidMount</li><li><strong>Updating</strong> : render 👉 capture refs and DOM 👉DidUpdate</li></ol></blockquote><p>跟著 <code>setTimeout</code> 跑一次 :</p><ul><li>第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 次 render <strong>(Mounting)</strong><ol><li><code>constructor</code> 初始化 ，state = 0</li><li><code>render</code> 觸發 Counter 內部的 render ，並提交 UI 給 React</li><li><code>capture refs and DOM</code> React 跟 DOM 溝通並且瀏覽器渲染了畫面</li><li><code>DidMount</code> 被呼叫，印出 : You clicked 0 times</li></ol></li></ul><p>接著按下 button 觸發讓 count + 1，React 重新呼叫 Counter 的 <code>render()</code> ，進行第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 次渲染</p><ul><li>第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 次 render <strong>(Updating)</strong><ol><li>此時 state 的 count = 1，<code>setState</code> 等同於執行到 <code>Counter.state.count = 1</code> (注意 : 但開發者不能直接在元件內部這樣做，React 幫我們做 )</li><li><code>render</code> 觸發 Counter 內部的 render ，並提交 UI 給 React</li><li><code>capture refs and DOM</code> React 跟 DOM 溝通並且瀏覽器渲染了畫面</li><li>Counter 呼叫 <code>componentDidUpdate</code>，3 秒之後 Counter state 是 1，印出 You clicked 1 times</li></ol></li></ul><p>好，這邊看起來沒問題🤔。</p><blockquote><p>那麼不間斷按了 5 次，而且不等每次 <code>setTimeout</code> 的秒數跑完呢 ?</p></blockquote><p>等於 <code>Event Loop</code> 中的 Call Stack 還在排隊的情況，會一值重複<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> ~<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span> 這個動作，但是到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">4</span></span></span></span> !!!</p><blockquote><p>Counter 呼叫 <code>componentDidUpdate</code>，3 秒之後此時的 State 是 ???</p></blockquote><p>這時候 main thread 上的 Call Stack 跑完，Event Loop 的 stack 開始執行，此時的 <code>Counter.state.count = 5</code>，執行時印出 <strong>You clicked 5 times</strong> 並且依序印出 5 次</p><p>要解決此問題很簡單，把當下的 <code>this.state.count</code> 取下來包給 <code>setTimeout</code> ，其實等同於 <strong>closure</strong> 的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>當非同步進入 <code>Event Loop</code> 跑去排隊的時候，這邊的 <strong>count 已經被記起來了</strong>，所以當 <code>setTimout</code> 到 Call Stack 的時候，就會是當次 render 的 count。</p><p>Closures 很好用，當我們把值關在內部，即使它脫離了 function ，下次再呼叫 function 時其值還是會被保留住不會改變。可以想成把它想成雷同 <code>const</code> 常數。</p><h2 id="如何拿取最新的-state">如何拿取最新的 state ?</h2><p>把握上面所提及的原則，<strong>每一次 component 執行 render function，包含 事件、effect 甚至 timeouts 或是其他 API 都會記住當次定義的 props 或 state。</strong></p><p>這兩個範例其實是一樣的 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">//📍 等到 render 之後才讀取 counter</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">counter</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 📍 一開始把 counter 存起來</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = props.<span class="property">counter</span>;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(counter);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不管是先還是後去讀取值，拿到的 state 是相同的<br> <code>useEffect</code> 已經記住當時的 state<br> state 跟 props 是不會變的</p></blockquote><p>如果我們試圖在上一次的 render function 取得最新的 props 或 state，這樣是逆流而上 (文章這麼說的🤔)。</p><p>有時候我們會需要在 effect 中拿到最新的值，而不是當下 render 所記住的值，這並不是什麼錯誤的操作，但我們可以使用 refs 達成目的。</p><p>refs 不會促使 React re-render，因為 React 確保它是不會被改變的(指不會因 render 產生新的記憶體位址，每次都指向同一個實體)。也可以想成 React 幫我們建立一個全域的物件，我們都是對同一個物件進行直接操作。</p><blockquote><p>然而逆流而上是什麼意思呢 ? 🤔</p></blockquote><p>functional component 是利用閉包 (closure) 的概念，從 JS 的基礎概念來看，執行完 function 後由於裡面的變數還是存在於 function 內部 (沒有被回收)，但是存在內部的變數外部不能直接操作。</p><p>回到 <code>setState</code> 會觸發 re-render，重新呼叫 component function ，但在 effect 中仍是屬於上一次 render 的，當我們想在 effect 取得最新的資料來操作就像在外部對 closure 內部拿某變數，這是不行的，因為值被封裝在內部。除非我們像在外部先建立好一個全域變數，並且直接拿其值進行操作，沒錯，這就等同於 refs 的概念了😲</p><h2 id="使用-ref-來取得最新值">使用 ref 來取得最新值</h2><p>已經知道 [[#跟 class Component 的差別|class component 的行為]] 會拿到最新的值，而 function component 則不會，要怎麼用 function component 復刻 class 的行為呢 ?</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> latestCount = <span class="title function_">useRef</span>(count);</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拿到最新的 count</span></span><br><span class="line">  latestCount.<span class="property">current</span> = count;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 讀取最新的 count</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`You clicked <span class="subst">$&#123;latestCount.current&#125;</span> times`</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如此一來，連按 5 次，就會呈現最後通通印出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span></span></span></span> 的結果。<br> <strong>ref</strong> 就像在外部建立一個盒子，寄放不會被改變的值</p><p>這樣的方式不能保證每次 function call 的那個期間，state 是正確的 (state 不屬於那個當下的時間點)。由於每次都被直接改變 (class component 做的事)，拿到的就會是最新的。<br> 這也是為什麼 React 預設不是 ref 的操作，而是選擇性的。</p><p>這裡可以比較 functional component 跟 class component 對於 render 意義的不同之處 :</p><ul><li>class component 將每次 render 分成不同階段來決定發生哪些事，也就是生命週期。在 A 階段變化到 B 階段的過程，資料也會隨時間發生變化。</li><li>functional component 則是把每次的 render 是獨立的來看，這次 render 只關注這次資料的變化，並且同步一切的東西。</li></ul><h2 id="談談-clean-up">談談 clean up</h2><blockquote><p>clean up 的是舊的 props 還是當下的 props ?</p></blockquote><p>先釐清 <code>clean up</code> 的執行時間，在畫面渲染之後，在下一個 effect 執行之前，會執行 clean up effect。<br> <img data-src="https://raw.githubusercontent.com/donavon/hook-flow/master/hook-flow.png" alt="|400x500"></p><p>意思是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 2️⃣ 在 return 之後才會做</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 1️⃣ 這裡會先執行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>情境 : 有一個 state 從 10 改變成 20</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(props.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(props.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一開始可能會這麼想 :</p><ol><li>React 先清除 (clean up) 帶有 <code>id = 10</code> 的訂閱</li><li>state 更新至 20，React 提交 UI 給瀏覽器渲染</li><li>React effect 執行帶有 <code>id = 20</code> 的訂閱</li></ol><p>🤔這不是正確的，Why ?</p><p>回到 Flow 那張圖，可以知道 effect 執行的時間點是 <strong>瀏覽器將元素放上 DOM (browser painting)</strong> 之後，為什麼 React 要這麼設計 ? 🤔</p><blockquote><p>才不會阻攔螢幕的更新</p></blockquote><p>effect 很常處理 AJAX 取資料的事情， 如果取資料這件事不是安排到 effect 中處理，而是同步處理呢 ? 瀏覽器就必須等到資料回傳再去做 painting 的工作，如果回傳時間拉長，螢幕就會像被卡住、動彈不得。</p><p>React 才會把 effect 執行的時間點放在瀏覽器 painting 之後，以不阻擋螢幕更新率的情況下，提升 UI 體驗。而 <strong>Effect 的 clean up function 也會被延遲</strong>。</p><p>所以上面真正的情境順序</p><ol><li>state 更新至 20，React 提交 UI 給瀏覽器渲染</li><li>瀏覽器渲染了，使用者看見 20 出現在螢幕上</li><li>React 清除 effect ， <code>id = 10</code></li><li>React 執行 effect ，<code>id = 20</code></li></ol><p>奇怪的是，為什麼可以在 <code>id = 20</code> 的情況下，去清除 <code>id = 10</code> 的值呢 ? 🤔</p><blockquote><p>每一個在 render 內部呼叫的 function (包含 handlers 、effect 等瀏覽器 APIs )，都會拿到當下定義的 state 。</p></blockquote><p>實際上清除與執行 effect 的 state 都是來自當次 render 的資料，<strong>effect 執行的並不會拿到最新的資料</strong> ，而是舊 (當下)的。</p><p>What !?🤷</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅實際上是這樣的</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(<span class="number">10</span>, handleStatusChange);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(<span class="number">10</span>, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不是這樣的，我們在想像的 clean up 雖然清除的時間點 state 已經改變成 20，但仍然是屬於 id = 10 那次 render 的</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(<span class="number">20</span>, handleStatusChange);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(<span class="number">10</span>, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>clean up 是延後執行，並不代表是屬於下次的 render。 React 把 effect 相關操作是在瀏覽器渲染之後的原因，目的讓執行比預設的還要快。</p><p>而在 clean up function 被呼叫時，舊的 props 永遠都存在，以防我們需要用到它。</p><p>例如監聽事件，如果某按鍵元素消失於畫面，我們應該將它的監聽事件註銷掉，但是在 render 之後元素早已經從畫面消失，我們要怎麼註銷一個已經不在 DOM 上的元素監聽事件呢 ? clean up function 讓我們把舊的 state 或 props 還存在著，在 effect 呼叫之前，我們就可以把它註銷掉。</p><h2 id="同步執行但不是生命週期">同步執行但不是生命週期</h2><p>在使用 <code>useEffect</code> 要跳脫生命週期的思考方式，運用同步的概念。</p><blockquote><p>一切都是跟結果有關，而不是過程</p></blockquote><p>這跟 JQuery 先呼叫 <code>addClass</code> 又呼叫 <code>removeClass</code> <strong>過程派別</strong> 是不同的 (意思是 DOM 新建立東西，又給它刪除這樣的行為)，這也是為什麼 React 的 CSS class 必須放在 render 程式碼之中 (只在乎結果，並不是從 A 變 B 的過程經歷了什麼。判斷樣式都是看最終的結果，並非隨時間而改變)</p><p>React 根據當下的資料是同步處理 DOM (資料跟 UI 是同步的) ，在 function component 中 render 的 <code>mount</code> 跟 <code>updating</code> 是沒有區別的。這樣使 <code>useEffect</code> 讓我們可以根據 props 或 state 同步 React 樹狀以外的東西。</p><p>假如有一個 state 從 10 變到 20，跟一開始就賦予它 20 ，最終都會是 20。跟 call API 拿資料一樣，最後的結果都會是一樣的。我們看到的 UI 跟資料是同步的，也只會顯示最後資料的結果。</p><p>但是如果每次都 re-render 是很沒效率的，甚至導致無限循環。</p><h2 id="告訴-React-不同-effect-之間的差別">告訴 React 不同 effect 之間的差別</h2><p>避免每次不必要的資料都跟著 re-render，必須告訴 React 那些要 re-render。 (可以想想 render 之後的步驟順序)</p><ol><li>state 改變，render 新的 UI</li><li>React render ，提交 UI 給 DOM</li><li>DOM 更新，經過一系列操作，最後放上畫面 (這也為什麼說 操作 DOM 很昂貴，因為牽涉到太多畫面的 reflow、repaint，尤其是 reflow)</li></ol><p>React 避免 DOM 昂貴的操作，只會更新 DOM 確實有改變的地方。</p><p>React Element 是一個 Object 裝載各種屬性。假如有一個元件指改動了 <code>props.name</code> (不包含 state 的操作) ，也就是文字的部分僅有 children 改變了，React 只會改動 <code>domNode.innerText</code> 的部份而已 (做淺拷貝比較 shallow comparison，這跟 React 的 Recoil 有關)</p><p>範例來自 Dan 大的文章 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldProps = &#123;<span class="attr">className</span>: <span class="string">&#x27;Greeting&#x27;</span>, <span class="attr">children</span>: <span class="string">&#x27;Hello, Dan&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> newProps = &#123;<span class="attr">className</span>: <span class="string">&#x27;Greeting&#x27;</span>, <span class="attr">children</span>: <span class="string">&#x27;Hello, Yuzhi&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>那 React 也會在 <code>useEffect</code> 幫我們檢查嗎 ?</p></blockquote><p><strong>不會。</strong> React 對於沒有呼叫的 function，是沒辦法幫我們檢查、比較。</p><p>React 為了避免一直重複執行 effect 有關的操作，提供 <strong>dependency array</strong> (也稱 <strong>deps</strong> ) ，讓我們加入要關注的資料給 <code>useEffect</code> 判斷。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Hello, &#x27;</span> + name;</span><br><span class="line">&#125;, [name]); <span class="comment">// 👈 deps</span></span><br></pre></td></tr></table></figure><p>透過這個 array 告訴 React ，這裡面</p><blockquote><p>只有包含 array 的資料改變了才要執行，其餘的資料跟我無關，不要叫我謝謝。</p></blockquote><p>React 每次 re-render 會檢查 array 中的資料，如果前後都長的一樣，就會跳過 <code>useEffect</code> 。</p><p>只要放入 array 中的資料，即使只有 1 個改變，也會重新執行 effect ，React 就會知道這是不能跳過的，因為 React 會同步所有事情。</p><p>所以不要把毫無相關的放在一起，<strong>關注會改變而重新呼叫的資料。</strong></p><h2 id="不要對-dependencies-說謊">不要對 dependencies 說謊</h2><p>function Component 中沒有生命週期，如果我們只想要在 <code>mount</code> 執行一次就好，通常會把 dependencies array 寫成空的。</p><p>例如 : 載入資料</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 載入資料</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ajax 是 side effect 把它擺在 useEffect 執行</span></span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, []); <span class="comment">// 👈 放入空陣列 </span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起來合理嗎 ? 如果有牽涉到其他的 props 或 state 這裡就會有問題。</p><h3 id="dependencies-說謊了會發生什麼問題">dependencies 說謊了會發生什麼問題 ?</h3><p>如果以計時功能 (<code>setInterval</code>) 在 class component 中的寫法思維，在 function Component 就要改變這個想法。 <code>setInterval</code> 雖然在基礎的 JS 建立一次，瀏覽器會持續記住直到刪除 id 為止，但在 function Component 每一次都擁有自己的 scope ，所以必須針對每次呼叫 render 時，如果要改變的資料具有副作用要先刪除，再重新產生，不然就會一直往上疊加，造成問題。</p><p>在 class Component 中，有關副作用的問題會在 <code>Mount</code> 監聽與 <code>Unmout</code> 註銷監聽，如果在使用 <code>useEffect</code> 也是同一個思維模式去思考， 把 dependencies array 當作是 mount 的行為，將 array 設為空的，但內部如果使用到有關 props 或 state ，effect 只會在 render 執行一次後就不會再直行了。</p><h3 id="誠實以對-dependencies，把有關的放入-array-中">誠實以對 dependencies，把有關的放入 array 中</h3><p>第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 種方式就是把所有相關資料放入 <code>useEffect</code> 的 array 中，讓 effect 按照資料改變就同步改變。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, [count]); <span class="comment">//👈 用到了 count 放入 array</span></span><br></pre></td></tr></table></figure><p>第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 種是改變 effect 裡面的結構，不需要每輪 render 都要比較 array 中的資料，減少依賴性，往下會說明怎麼減少依賴性。</p><h2 id="有效率的使用-useEffect">有效率的使用 useEffect</h2><blockquote><p>如果我們不想把 state 放入 dependencies array 呢 ?</p></blockquote><blockquote><p>這不是叛不叛逆或是刻意操作<br> 而是 <strong>React 一定需要透過依賴陣列去比較這筆資料嗎 ?</strong> effect 所執行的是具有副作用的操作。而 React 都能知道當次 render 的所有資料，有必要每次都去特別告訴 React 這筆是否具有變化呢 ?</p></blockquote><p>可以先提問自己 <strong>這筆資料的是為了什麼 ?</strong><br> 例如 Counter 中每秒做 <code>setCount(count + 1)</code>，但<strong>其實我們根本不需要比較每次 render 的 count 是多少</strong>，之後再 <code>+1</code> 。</p><p>Why ? 🤔</p><p>因為 React 可以幫我們拿出前一次的 state，而 <code>setInterval</code> 每次是仰賴 <strong>前一次的 state 再 <code>+1</code></strong> ，那麼可以使用 <code>setState</code> 的第二種方式，<code>setState</code> 裡面使用 callback function 拿到最新的 state 並回傳新 state。</p><blockquote><p><code>setState((previousState)=&gt; return state)</code></p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 參數 c 會拿到前一次的 count，回傳 count+1 的結果</span></span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, []); <span class="comment">//👈 這裡就不用放依賴陣列</span></span><br></pre></td></tr></table></figure><p>即使不告訴 React 正確的 dependencies array，<code>setInterval</code> 在第一次 render 後都會存在 (也就是會不斷的執行)，因為 <code>setInterval</code> 是屬於 <code>window</code> 也就是 browser 的 method。</p><p>只有在 Component 本身 <code>unmout</code> 會停下來，也就是上面 <code>return</code> 的部份。</p><p>試著跑一次 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// effect 第一次會被執行，它會在第一次 render 後都存在</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="number">0</span> =&gt; <span class="number">0</span> + <span class="number">1</span>); <span class="comment">// 所以這邊是 setCount(1)</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次 render </span></span><br><span class="line"><span class="keyword">const</span> count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// useEffect 不執行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// setInterval() 這個還是會執行，因為它存在於 browser  而不是每次 render function</span></span><br></pre></td></tr></table></figure><p>文中稱是 <strong>否定式依賴關係</strong> (false dependencies)，因為 React <strong>知道每次 render 的 state 值</strong>，而範例中 <code>setCount</code> 做的事只有回傳 <code>count + 1</code>，React 並不用特別去檢查前後兩次的 count state 是否一樣，再去執行。</p><p>可以看做告訴 React :</p><blockquote><p>總之幫我把 <code>c=&gt;c+1</code> 的結果回傳給我 ，不論 c 是什麼，React 是知道的。</p></blockquote><p>就像指示，這種 <code>function setState</code> 的方式如同批次 (batch) 更新一樣。</p><p>我們確實移除 count 減少依賴性，但並不是對 deps 說謊，只是我們的 effect 沒有讀取來自 render 的範圍裡面的 count。</p><h3 id="試著拆解並了解">試著拆解並了解</h3><p>我用自己的話解釋這段，一開始看的時候真的很吃力😵</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先回味一下原始長相，我要開始幫它變身囉😲</span></span><br><span class="line"><span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="number">0</span> =&gt; <span class="number">0</span> + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><p>上面說到 <code>setInterval</code> 其實可以看做把 function 提到外部，因為 <code>useEffect</code> 只 render 一次，代表內部的 function 是不會變隨 render 重新呼叫 (改變) 的，等同於把 function 提到外面存在來。</p><p>由於 <code>setCount</code> 本身就是透過 <code>updater function</code> 回傳新的 state 就我們按照他的架構回傳。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setIterval 的 callback function 看作把東西寫在 render function 以外</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">countSomething</span> = (<span class="params">setCount</span>) =&gt; &#123;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>把提出的 function 塞回去，並不會影響原本的操作</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放回去</span></span><br><span class="line"><span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 塞回去一樣可以執行</span></span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">countSomething</span>(setCount);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;,[]) <span class="comment">// 👈 依賴陣列是空的</span></span><br></pre></td></tr></table></figure><p>來按照步驟來人體 render 看看，按照 React 每次 render 都同步資料來看</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次 render</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. count = 0 </span></span><br><span class="line"><span class="keyword">const</span> count  = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 3. 進行 effect</span></span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">countSomething</span>(setCount);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 這邊先 clean ，但第一次的 id 是 null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次 render</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 雖然 useEffect 不會執行 </span></span><br><span class="line"><span class="comment">  但內部的 setInterval 會繼續執行，直到被清除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不是這樣 function 一直被呼叫，而是內部的 setInterval 間隔觸發它的 callback function</span></span><br><span class="line"><span class="title function_">countSomething</span>(setCount);</span><br></pre></td></tr></table></figure><p><code>setInterval</code> 不管在哪裡呼叫，由於它是屬於 window (瀏覽器) 底下的 api，如果沒有清除，那麼 <code>window</code> 一樣會每間隔 x 秒呼叫。這個例子證明不論放在 render function 內部或是外部，<code>setInterval</code> 都會風雨無阻的執行。</p><blockquote><p>注意<br> 我們讀取的 count 值已經不是來自於 render 範圍的</p></blockquote><p>這是什麼意思呢 ? 🤔</p><p>經由上面的變化史，已經知道脫離了 render function 依然可以執行，那這裡的 <code>setCount (c=&gt;c+1)</code> 裡面的 <strong><code>c=&gt; c+ 1</code></strong> 又是另一個 callback function，那 <code>c</code> 這個參數來自誰重要嗎 ? 我們有必要填入這個 c 值才能計算嗎 ? (意思是一定要寫<code>setCount(anotherfunction(c))</code> 才能執行嗎 ? )</p><p>我再把 <code>setCount</code> 裡面的 callback function 又拆出 render 以外，叫 <code>plusOne</code>，並且我把這個 <code>plusOne</code> 看做我們要對 <code>setCount</code> 做某事的藍圖。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">countSomething</span> = (<span class="params">setCount</span>) =&gt; &#123;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(plusOne);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 告訴 React 資料要做的事</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">plusOne</span>(<span class="params">c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> c + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉 <a href="https://codesandbox.io/s/mystifying-williamson-s4799j?file=/src/index.js"><code>codsandbox</code> 範例</a></p><p>在把這串放回去，一樣可以執行。<code>setState</code> 如果是使用 callback function 的方式使用，內部其實是呼叫 <strong>updater function</strong><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>，它會保證拿到最新的 state，而我們的 <code>plusOne</code> 只是 updater function 的另一種表達方式。</p><p>回到 React render 的概念 : <strong>每次 render 都保有自己的資料</strong>，所以我們不用特別放入 deps 來告訴 React ，因為 React 就已經知道當次的 state。</p><p>這段有點饒口，但幫助我釐清到底為什麼不用加入 deps 內依然可以執行這個問題。</p><h2 id="從-Google-文件的更新了解-function-updater">從 Google 文件的更新了解 function updater</h2><p>如上面的範例，知道可以使用 <code>setCount(c =&gt; c + 1)</code> 避開 deps 填入 state ，但 :</p><ol><li>為什麼使用呢 ?</li><li>跟原本 <code>setCount( c + 1)</code> 差別在哪 ?</li></ol><p>文章中舉例 Google 文章是雲端編輯。修改的時候，並不是每次都傳送整個頁面的內容給伺服器，文章如果檔案大，那樣傳送覆蓋太沒效率了。那怎麼溝通給後端讓它記住新增或修改的部分呢 ?</p><blockquote><p>透過傳遞 <strong>定義好的表達方式</strong></p></blockquote><p>其實如果使用過 redux 就知道 dispatch 與 action 的發號施令的概念，只有已經定義到的 action type 對應 actions 才能對資料內容進行變動。那也可以想像 Google 文章在編輯時也是如此，<em>使用者點擊某個按鈕，後端再做動作</em>。</p><p>如此一來達到 <strong>找出最小化的資料來改變這個 component</strong> ，如同 Google 文件不會送整頁資料出去改變文件。</p><p>這種方式跟是 React 所建議的原則 : <strong>尋找最小化但完整的 state</strong> 的概念 (意思是有些資料是可以透過計算出來的，不一定所有資料都得是內部的 state，例子補充在後面)，差別是這是 update 的。</p><p>最小化且完整的 state 舉例 :<br> 以 todo list 為例，有存放所有 todo 的陣列 state ，但我想要存取 todo 的長度，並不需要另外儲存的 state</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 不用這樣</span></span><br><span class="line"><span class="keyword">const</span> [length,setLength] = <span class="title function_">useState</span>(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>因為可以從 <code>state.todos.length</code> 取得，這筆資料是可以通過計算取得。<br> 這也是為什麼上面說 <code>c =&gt; c + 1</code> 是一個藍圖，因為它傳達的是個資料的表達方式。</p><p>那為什麼 <code>setCount(c =&gt; c + 1)</code> 比較好呢 ? 🤔</p><p>在於 <strong>它沒有直接改變 count 本身</strong> (沒有汙染到變數)，這個例子用最原始的 JavaScript 來看。由於本次的 count 是 primitive type，這邊並不討論 object type (React 之所以會建議解構 object type 是有原因的)。</p><ul><li><code>c =&gt; c+1</code> : 並沒有改變到原始的 count</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">plusOne</span>(<span class="params">count</span>)&#123;</span><br><span class="line">  count =  count + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newCount = <span class="title function_">plusOne</span>(count) <span class="comment">// 用變數接起來</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newCount) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li><code>c + 1</code> : 直接對 count 進行操作😵</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">plusOne</span>(<span class="params"></span>)&#123;</span><br><span class="line">  count = count + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newCount = <span class="title function_">plusOne</span>() </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newCount) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>不直接操作資料也是避免非預期的結果發生。</p><p>這種方式保證更新多個來源 (事件或是具有副作用的操作等等) 都可以被合併成 <strong>可預測的正確操作</strong>。然而 <code>setCount(c =&gt; c + 1)</code> 並不是最佳解法，遇到以下的情境，可能會產生奇怪的問題 :</p><ol><li>執行 effect 同時依賴多個 state</li><li>透過 props 計算新的 state</li></ol><p>這時候可以使用 <code>useReducer</code> 來幫我們解決問題。</p><p><code>useReducer</code> 可以看做加強版的 useState，而事實上 <code>useState</code> 也是 <code>useReducer</code> 簡化過來的，有興趣可以參考這篇 <a href="https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/react-hooks-usestate-vs-usereducer-b14966ad37dd">React Hooks | 既生 useState 何生 useReducer ? | by Airwaves | 手寫筆記 | Medium</a></p><h2 id="將資料更新與操作分離">將資料更新與操作分離</h2><p>範例中 count 是被 step 影響，我們也確實將正確的 deps 放進去。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [step, setStep] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + step);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, [step]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;step&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> setStep(Number(e.target.value))&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用白話文解釋 : 當 step 改變時， effect 會先清除上一個計時器，接著產生新的計時器。</p><blockquote><p>但是如果不想要改變 step 就重啟 interval 重新計時呢 ? 如果想要動態的改變 step 又能持續計時呢 ?</p></blockquote><p>那麼就必須把 step 從 deps 移除，避免 step 改變也清除 effect 又產生新的 <code>setInterval</code> 重計。</p><p>這種情況是多個資料互相依賴 <code>(count ⇒ step)</code>，而且是 A 資料跟 B 資料現在的值有關。(count 每秒增加的值，跟 step 的值有關)</p><p>可以改使用 <code>useReducer</code> 管理複雜的資料流。<code>useState</code> 通常只能對著一筆資料操作，如果有很多筆，可能會建立多個 <code>useState</code>。或是發覺操作資料是 <strong>根據於前一次的資料</strong>，這時候很適合換成 <code>useReducer</code>。</p><blockquote><p>reducer 可以讓我們透過 <strong>action type 對應 action 再去更新資料</strong> ，而且也可以同時對多筆資料操作。</p></blockquote><p>什麼意思呢 ? 那 <code>useState</code> 不能做這樣的事嗎 ?<br> 可以，但是非常麻煩，會使邏輯變得複雜🤔。</p><p>我試著復刻這兩種方式的操作 :</p><ol><li>照舊分開的兩個資料，同時更新</li><li>由於兩個是相依性的，把它放在同一個資料物件中。</li></ol><p>另外多出來的是嘗試其他種方式。</p><ol><li>原始範例 : <a href="https://codesandbox.io/s/zxn70rnkx">Dan 大提供的 CodeSandbox</a></li><li>實作範例 : <a href="https://codesandbox.io/s/zealous-monad-rco7nx?file=/src/index.js">我複製改過的 CodeSandbox</a>，範例會看到多個不同的寫法，以下會一個個說明。</li></ol><h3 id="實驗-分開的兩筆資料更新">實驗 : 分開的兩筆資料更新</h3><p>首先要釐清改變其值的變因，count 是依賴著 step，但是 step 是手動輸入值所改變的，因此 step 雖然改變了，但是 count 不能拿到最新的 step。</p><ul><li>透過上面說過的 updater function，我們可以知道 <code>(c =&gt; c)</code> 這樣可以拿到最新值。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> [step, setStep] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setStep</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 最新的 step</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 那這裡的 step 呢 ? 🤔</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;step in count&quot;</span>, step);</span><br><span class="line">        <span class="keyword">return</span> c + step;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>其他部分跟原範例一樣沒有更改。</p><blockquote><p>當然結果是不行的。</p></blockquote><p>試著用 <code>setStep</code> 拿到最新的 step，並不代表當下取得的 step 會是最新的。React 新手最常陷入的陷阱是執行 <code>setState</code> 後馬上讀取 state 值，state 不會是新的。<br> 這跟 <code>setState</code> 是非同步的有關係。</p><p>回到那句話 : <strong>每一次 render 都擁有它專屬的 state 或 props</strong> 。<br> 所以 <code>setCount</code> 裏頭的 step 還停留在第一次 render ，<code>step = 1</code>。即使修改 input 的值，雖然 <code>setStep</code> 那行可以拿到最新的 step，但沒辦法在 <code>setCount</code> 裡面拿到。</p><h3 id="實驗-再某筆資料內部拿到最新">實驗 : 再某筆資料內部拿到最新</h3><p>那在 <code>setStep</code> 中拿到最新 step 在傳給 <code>setCount</code> 總可以了吧🤔</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setStep</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;step in count&quot;</span>, step);</span><br><span class="line">        <span class="keyword">return</span> c + s;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>變得越來越複雜了，認真拆解的話就是 callback hell 了。同上面說的如果 deps 是空的，state 再也不是取自 render function 裡面，同樣可以把這些 method 看作寫在外部。</p><ul><li>上面就像 :</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拆解再拆解</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">countSomething</span> = (<span class="params">setCount</span>) =&gt; <span class="function">(<span class="params">setStep</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// callback 再 callback</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setStep</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> c + s);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"> <span class="keyword">const</span> id = <span class="title function_">countSomething</span>(setCount)(setStep);</span><br><span class="line"> <span class="keyword">return</span> <span class="function">()=&gt;</span> <span class="title function_">cleanInterval</span>(id)</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><p>看起來還行🤔，但我認為這樣的架構不好被擴展，除非裡面又再拆，不過同時也讓我想到 HOC (Higher Order Component)，這樣的方法會有效能上的問題。</p><h3 id="實驗-object-type-的-state">實驗 : object type 的 state</h3><p>我認為這個例子是最接近 <code>useReducer</code> 的，同時必須把結構大改，並且用 immutable 的方式改變資料。</p><ul><li><code>useState</code> 設為 object :</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 把所有相關的 state 放入同一個容器中</span></span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">     <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">     <span class="attr">step</span>: <span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 一樣使用 updater function 拿到最新值</span></span><br><span class="line">    <span class="title function_">setValue</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> (&#123; ...v, <span class="attr">count</span>: v.<span class="property">count</span> + v.<span class="property">step</span> &#125;));</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 3. step 也要修改 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;value.step&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setValue(&#123; ...value, step: Number(e.target.value) &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像比上面都更來的精簡，只是改變 state 變成很囉唆😵</p><h3 id="實驗-把-input-變成-uncontrolled-component">實驗 : 把 input 變成 uncontrolled component</h3><p>在 [[#使用 ref 來取得最新值]] 這章節已經有提到，搭配上表單的控制，可以讓我們不 re-render 的情況下，依然拿到 input 的最新值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stepRef = <span class="title function_">useRef</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> c + <span class="title class_">Number</span>(stepRef.<span class="property">current</span>.<span class="property">value</span>));</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改成</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;stepRef&#125;</span> <span class="attr">defaultValue</span>=<span class="string">&#123;1&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="回到-useReducer">回到 useReducer</h2><ul><li>按照文章中提供的 <code>useReducer</code> 範例</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始值</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">step</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="comment">// 解構 state</span></span><br><span class="line">  <span class="keyword">const</span> &#123; count, step &#125; = state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根據不同的 action type 來改變 state，如果 type 一多用 switch case</span></span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;tick&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: count + step, step &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;step&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; count, <span class="attr">step</span>: action.<span class="property">step</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// useReducer </span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br><span class="line">  <span class="comment">// 解構值</span></span><br><span class="line">  <span class="keyword">const</span> &#123; count, step &#125; = state;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// dispatch 一個 action</span></span><br><span class="line">      <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;tick&#x27;</span> &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, [dispatch]); <span class="comment">//👈 deps 放入 dispatch</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;step&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">        // 一樣 dispatch action</span></span><br><span class="line"><span class="language-xml">        dispatch(&#123;</span></span><br><span class="line"><span class="language-xml">          type: &#x27;step&#x27;,</span></span><br><span class="line"><span class="language-xml">          step: Number(e.target.value)</span></span><br><span class="line"><span class="language-xml">        &#125;);</span></span><br><span class="line"><span class="language-xml">      &#125;&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那這有比較好嗎 ? 意思是 deps 放入 dispatch 不是會回到 <code>setInterval</code> 又重新的狀況嗎 ?</p><p>事實上可以這麼做是因為 <strong>React 保證 dispatch 永遠被不會改變</strong>，所以它不會讓 state 改變又重新啟動計時。由於 dispatch 不會改變，所以 <code>prevDispatch === nextDispatch</code>。</p><p><code>useEffect</code> 的 deps 可以忽略</p><ol><li><code>dispatch</code></li><li><code>setState</code></li><li><code>useRef</code> 容器值 : 指 <code>ref.current</code></li></ol><p>因為 React 保證他們是靜態的，不會被改變。不過指定他們也不會怎麼樣。</p><p>回到優點的部分，比起在 effect 裡面直接讀取 <code>state</code>，<strong>dispatch acition</strong> 給予一個資料表達的方式，並且在外部的 reducer 按照 action type 操作資料。讓 effect 把 step 這個 state 分開來看待，count 跟 step 的依賴性就不會因在 render function 導致不同步的問題。</p><p>effect 不關注怎麼更新 state，而是什麼動作要發生，並在 reducer 集中處理這些資料邏輯。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count, step &#125; = state;</span><br><span class="line">  <span class="comment">// 收到 tick，reducer 定義 tick 對資料做某件事，回傳 count : count + step</span></span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;tick&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: count + step, step &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;step&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 收到 step，對 step 資料做重新賦值</span></span><br><span class="line">    <span class="keyword">return</span> &#123; count, <span class="attr">step</span>: action.<span class="property">step</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="為什麼-useReducer-是-Hooks-的作弊方式">為什麼 useReducer 是 Hooks 的作弊方式 ?</h2><p>文中提出一個情境</p><blockquote><p>如果是 step 透過 props 傳下來的值呢 ?</p></blockquote><ul><li>文中範例</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在父元件把 step 往下傳 </span></span><br><span class="line">&lt;<span class="title class_">Counter</span> step=&#123;<span class="number">1</span>&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params">&#123; step &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, dispatch] = <span class="title function_">useReducer</span>(reducer, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 因為 step  是 props ，要把 reducer 搬進來才能讀取到</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;tick&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state + step;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 這邊都沒變</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;tick&#x27;</span> &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, [dispatch]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個範例有優化上的問題，不要當作合理的使用方式。(我覺得是 reducer function 不斷新產生的問題，通常會用 <code>useCallback</code> 避免每次 render 重新產生。)</p><p>這個範例 dispatch 依然不會改變，所以 effect 裏頭並不會 re-render。因為 step 不屬於 <code>useReducer</code> 的 state，<code>reducer</code> 怎麼知道 props 產生變化而拿到最新的 props 呢 ?</p><p>由於 effect 不會再執行，React 會記住 dispatch 中的 action，但這依然會在下次 re-render (state 或是 props 改變) 呼叫 reducer 。這時候 props 是新的，reducer 接收到的 props 也是新，但不是在 effect 拿到。</p><p>這也就是為什麼 Dan 大說 <code>useReducer</code> 像是 Hooks 的作弊模式，因為<strong>把描述事情跟更新邏輯操作分開了</strong>。另外一方面，可以移除一些 effect 中不需要的 deps，避免不必要的 re-render。</p><h3 id="白話翻譯機">白話翻譯機</h3><p>先確定幾件事 :</p><ol><li>effect 是不會重新呼叫，因為 dispatch 永遠都是同一個</li><li>dispatch 發送的只是一個 <code>action</code>，而且也不會改變。而 reducer 是接收 action type 來對 state 操作。</li><li>reducer 在 render function 範圍內，按照原本每一個 render 都有它的 state 或 props ，也就是當 Counter 因 state 或 props 改變而 re-render ，reducer 也會產生新的 function ，也會拿到當前 render 範圍的 props。</li><li><code>setInterval</code> 依然間隔秒數執行。</li></ol><p>如果用 redux 的想法來思考，會看過這張經典的圖，比較容易理解，dispatch 接收一個物件，並再傳給 reducer 處理最後返回 state。<br> <img data-src="https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif" alt="|300x230"></p><p>卡住的話，再試著一步步拆解。<br> 把 dispatch 看作放在外部的 function 接收 action，並且內部呼叫 reducer<br> 👉 <a href="https://codepen.io/shan473/pen/mdxKvYj?editors=0010">嘗試用 <code>codepen</code> 並用 Vanilla JS 復刻</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假的 dispatch 👉 不在 render function 裡面</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakedispatch</span>(<span class="params">action</span>) &#123;</span><br><span class="line">  <span class="comment">// 都呼叫來自 component 中的 reducer，更新目前的 state</span></span><br><span class="line">  component.<span class="title function_">fakereducer</span>(component.<span class="property">state</span>,action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Counter component : 由於 React Element 是一個 Object，所以我轉換成簡化一些 Object 結構。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> step = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> component = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// props 模仿是由外部傳入的 props</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params">props = <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 是不是第一次 render</span></span><br><span class="line">  <span class="keyword">if</span>(component)&#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">state</span> = component.<span class="property">state</span>;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">props</span> = props || component.<span class="property">props</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = count;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">props</span> = props || &#123;step : step&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把 React Element 看成一個 Object</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, &#123;</span><br><span class="line">    <span class="attr">state</span>: <span class="variable language_">this</span>.<span class="property">state</span>,</span><br><span class="line">    <span class="attr">props</span>: <span class="variable language_">this</span>.<span class="property">props</span>,</span><br><span class="line">    <span class="comment">// 😲 fakereducer，放在 render function 內部</span></span><br><span class="line">    <span class="attr">fakereducer</span>: <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&quot;tick&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> += <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">step</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(action.<span class="property">type</span> === <span class="string">&quot;reset&quot;</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Interval : 跟之前的在 <code>useReducer</code> 類似，只是在 dispatch 之後手動 re-render，因為我們改變了 state</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假裝等於 useEffect(()=&gt;&#123;&#125;,[]) ,deps 為空</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fakedispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;tick&quot;</span> &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改變一下 dispatch 內部</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakedispatch</span>(<span class="params">action</span>) &#123;</span><br><span class="line">  prev = component</span><br><span class="line">  <span class="comment">// 要跟 prev 比較的</span></span><br><span class="line">  <span class="keyword">let</span> temp = <span class="keyword">new</span> <span class="title class_">Counter</span>(prev.<span class="property">props</span>);</span><br><span class="line">  <span class="comment">// 更新 state</span></span><br><span class="line">  temp.<span class="title function_">fakereducer</span>(component.<span class="property">state</span>,action)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  假裝 setState 的概念，由於 state 不同，而re-render</span></span><br><span class="line">  <span class="keyword">if</span>(temp.<span class="property">state</span> !== prev.<span class="property">state</span>)&#123;</span><br><span class="line">    <span class="comment">// 重新呼叫 component 更新</span></span><br><span class="line">    component = temp  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新畫面</span></span><br><span class="line">    title.<span class="property">textContent</span> = component.<span class="property">state</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代表 re-render</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;re-render&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>處理 <code>&lt;Counter step=&quot;1&quot;/&gt;</code> props 改變時也 re-render，由於是 input 的值改變導致 props 改變 (re-render)，我們就模擬這個動作。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&quot;input&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="comment">// 檢查輸入是不是數字</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">Number</span>(e.<span class="property">target</span>.<span class="property">value</span>)))&#123;</span><br><span class="line">    result =<span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    result =<span class="title class_">Number</span>(e.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// re-render 並傳入 props</span></span><br><span class="line">  component = <span class="keyword">new</span> <span class="title class_">Counter</span>(&#123;<span class="attr">step</span>: result&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>執行</li></ul><h3 id="人體編譯">人體編譯</h3><p><code>useEffect</code> 在上面的章節說過，如果 deps 沒有任何東西，effect 只會 render 一次，其 資料已經不是來自於 render function 本身，可以把它看作拿到 render 外部一樣。<br> 所以我們製作假的 <code>useEffect</code> 是對應 <code>tick()</code>， 並且在 component 生成之後呼叫。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">component = <span class="keyword">new</span> <span class="title class_">Counter</span>(&#123;step&#125;);</span><br><span class="line"><span class="title function_">tick</span>();</span><br></pre></td></tr></table></figure><ul><li>編譯 : 這裡有兩種情境，(1) 本身 state 改變 ；(2) 傳入的 props 改變</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改變 Counter 的 state</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> step = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 產生 fakereudcer </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakereducer</span>(<span class="params">action</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&quot;tick&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> += <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">step</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(action.<span class="property">type</span> === <span class="string">&quot;reset&quot;</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tick() setInterval 每秒呼叫 dispatch 並送 action 給 fakereducer</span></span><br><span class="line"><span class="title function_">fakedispatch</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;tick&#x27;</span>&#125;) <span class="comment">//👉 count = 0 + 1 </span></span><br><span class="line"><span class="comment">// component state 改變，re-render 、畫面更新</span></span><br><span class="line">temp = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">1</span>);</span><br><span class="line">component = temp</span><br><span class="line">title.<span class="property">textContent</span> = component.<span class="property">state</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改變 props 的 step = 4，props 改變 re-render</span></span><br><span class="line">component = <span class="keyword">new</span> <span class="title class_">Counter</span>(&#123;<span class="attr">step</span>: <span class="number">4</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 產生新的 fakereducer</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakereducer</span>(<span class="params">action</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&quot;tick&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 這次 render 1 += 4 = 5</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> += <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">step</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(action.<span class="property">type</span> === <span class="string">&quot;reset&quot;</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>後面都是周而復始。雖然不是很準確的模仿 React ，透過拆解的方式我比較好理解。我們可以知道 reducer 是因為拿取 props 的最新值，我們才把它放在 component 內部，但是會造成不管 props 是不是有改變都會產生新的 reducer 。我可能會用 <code>useCallback</code> 記憶起來，並加上 <code>props.step</code> 作為 deps。</p><p>藉由這個例子我們知道 dispatch 只要負責把 action 帶給 reducer 就好，我們不用在內部實作詳細邏輯，而是交給 reducer 處理，減少像 <code>setState</code> 直接在 effect 中把資料拆開又塞回去，而且如果是多組資料集中於一個 state，牽一髮動全身😵。</p><h2 id="把-function-移到-useEffect-中">把 function 移到 useEffect 中</h2><p><code>useEffect</code> 很常拿來做 call API 拿資料，也很常只做載入頁面的那一次。按照 effect 只執行一次，我們的 deps 會是空的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(</span><br><span class="line">      <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=react&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面看起來是可行的，比較不好的點在於 <code>fetchData</code> 沒有依靠任何 state 或 props，每一次 render 都是長一樣的，但又會每次產生新的 function🤔。</p><blockquote><p>如果只用到函數內部的值，沒有依靠外部資料，把它放到 effect function 中</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 把 function 搬到 effect 內部</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=react&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(<span class="title function_">getFetchUrl</span>());</span><br><span class="line">    <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fetchData</span>();</span><br><span class="line">&#125;, []); <span class="comment">// ✅ deps 是空的也沒關係，因為沒有用到 state 或 props</span></span><br></pre></td></tr></table></figure><p>我們不用再擔心 deps 的問題，因為確確實實也沒有依賴任何外部資料。</p><p>但是當結構開始變的龐大，而且涉及 state 與 props，這時候如果當資料改變了，但 effect 並不會更新，依然只會停留在第一次 render 並且不會再執行了😵。</p><blockquote><p>那把 state 或 props 加入 deps 呢 ?</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(<span class="title function_">getFetchUrl</span>());</span><br><span class="line">    <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fetchData</span>();</span><br><span class="line">&#125;, [query]); <span class="comment">// ✅ 這樣是合理</span></span><br></pre></td></tr></table></figure><p>如此一來當 <code>query</code> 改變，effect 就會重新呼叫，我們拿到的資料也都會同步。</p><p>加入 deps 不只是讓 React 不要發出警告。而是去理解相關資料的變化，例如 : 拿取資料是依靠 <code>query</code> 字串的變化，把 query 放入 deps 可以讓我們拿到當次正確的資料。</p><p><code>useEffect</code> 強迫讓我們注意資料流應該要怎麼變化，也告訴我們也要讓 effect 一起同步更新，而不是忽略它，讓使用者處處碰到 bug😵</p><h2 id="不能把-function-移入-useEffect-怎麼辦">不能把 function 移入 useEffect 怎麼辦 ?</h2><p>如果有一個 function 在不同的 effect 中進行，那 function 在每次 re-render 都會被重新創造，如果加入 deps 會導致頻繁的更新。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 🔴 re-render 都會使 effect 重新產生並呼叫，況且還依附兩個😵</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params">query</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line">&#125;, [getFetchUrl]); <span class="comment">// 🚧 deps 是正確的但是改變的太頻繁</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">&#125;, [getFetchUrl]); <span class="comment">// 🚧 deps 是正確的但是改變的太頻繁</span></span><br></pre></td></tr></table></figure><p>絕對不會想把它複製貼到 effect 裡面😵。所以解決的方式有兩種 :</p><ul><li>第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 種 : 如上面一直提及的一種方式，把它提到 render function 外部。如果忘記了可以回想一下 [[#有效率的使用 useEffect]] 章節，概念上資料來源是不屬於 render function 範圍的。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 提到外部，不會再被 render 內部的資料影響了</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params">query</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line">  &#125;, []); <span class="comment">// ✅ deps 空的是 OK 的</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">  &#125;, []); <span class="comment">// ✅ deps 空的是 OK 的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 種，把 function 給記起來，由於每次 re-render 都會新建立 function，可以使用 <code>useCallback</code> 記起來，並且按照傳入的 deps 再重新建立 function，選擇再有必要的情況再更新。如果有使用到相關的 state 或 props 就能同步更新。</li></ul><ol><li>類似把 function 提到外部的變化形態 :</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 跟把 function 提到外部類似，但是在 render function 內讓它不變</span></span><br><span class="line"><span class="keyword">const</span> getFetchUrl = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">query</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">&#125;, []);  <span class="comment">// ✅ callback deps 空的沒關係，因為它是靠帶入的參數來變化</span></span><br><span class="line">  </span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line">&#125;, [getFetchUrl]); <span class="comment">// ✅ deps 放入 getFetchUrl 沒問題，因為 getFetchUrl 建立後不會隨 re-render 重新建立</span></span><br><span class="line">  </span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">&#125;, [getFetchUrl]);  <span class="comment">// ✅ deps 放入 getFetchUrl 沒問題，因為 getFetchUrl 建立後不會隨 re-render 重新建立</span></span><br></pre></td></tr></table></figure><ol start="2"><li>依賴內部的 state 或 props</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ getFetchUrl 直到 query 有改變才會更新</span></span><br><span class="line"><span class="keyword">const</span> getFetchUrl = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">&#125;, [query]);  <span class="comment">// ✅ callback deps 根據 query state 改變而重新建立</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>();</span><br><span class="line">&#125;, [getFetchUrl]); <span class="comment">// ✅ deps 是 OK 的，跟 query 是同步更新</span></span><br></pre></td></tr></table></figure><p>而 <code>useCallback</code> 的方式也適用於父元件傳遞 function props 給子元件的操作 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ✅ 直到 query 改變才重新建立 fetchData</span></span><br><span class="line">  <span class="keyword">const</span> fetchData = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">  &#125;, [query]);  <span class="comment">// ✅ callback deps 根據 query state 改變而重新建立</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 傳給子元件，記住 ! 這邊的 function 更新條件是 query，所以傳入的 fetchData 會一直是同一個 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;fetchData&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">&#123; fetchData &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [data, setData] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetchData</span>().<span class="title function_">then</span>(setData);</span><br><span class="line">  &#125;, [fetchData]); </span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  ✅ deps 是 OK，因為它也等 Parent 本身 query 改變才會重新呼叫，其餘的時候 Child 本身無法動到 effect 的，即使 setData 改變了，這裡也不會重新呼叫 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="function-是資料流的一種嗎">function 是資料流的一種嗎 ?</h2><p>這節提到 function 變成 props 傳遞給子元件要注意的點，另外凸顯 class component 跟 function component 之間的差別。</p><p><code>useEffect</code> 我們知道是在 render 之後才呼叫的，而且具有 3 種不同情境 :</p><ol><li>完全沒有 deps array，表示只要 re-render 之後就跟著執行</li><li>deps 為空，表示只在 mount (render) 之後只做一次</li><li>deps 放有相關資料，表示有關資料的改變就會重新呼叫 effect</li></ol><p>看起來 <code>useEffect</code> 是等同於 class component 生命週期中的 <code>componentDidMount</code> 以及 <code>componentDidUpdate</code> 🤔🤔🤔</p><p>在這之前，複習一下 class component 的生命週期圖 :<br> <img data-src="https://i.imgur.com/cpFlaro.png" alt="|600x300"></p><ul><li>class component 中傳遞 function props，把上面的例子轉成 class 版本</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 等同於 const [query, setQuery] = useState(&#x27;react&#x27;);</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">query</span>: <span class="string">&#x27;react&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 定義了 fetchData 方法</span></span><br><span class="line">  fetchData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">query</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// function 透過 props 傳給 Child </span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;this.fetchData&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 等同於上面 let [data, setData] = useState(null);</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 在 render 之後執行</span></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 從 Parent 來的，我們像 functional component 一樣在 render 之後呼叫</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣在第一次 render 之後確實可以執行，但是沒辦法在 Parent props 改變時重新呼叫。</p><p>如果要重新呼叫 <code>this.props.fetchData</code>，就會在 <code>updating</code> 階段 render 完後呼叫 <code>componentDidUpdate</code> 來檢查前後的 props 是否有改變。確實跟 effect 很類似🤔</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">  <span class="comment">// ❌ 這個條件永遠不會成立</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">fetchData</span> !== prevProps.<span class="property">fetchData</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 props 的比較不會成立，為什麼呢 ?</p><blockquote><p>class component 是每次都重新呼叫 <code>render()</code>而已，並不是 new 重新建立實例，已經被建立的 function 是靜態的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class component</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ComponentA</span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="title class_">ComponentA</span>.<span class="title function_">render</span>() <span class="comment">// re-render 是指呼叫 class 中的 render function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 👉 prev ComponentA.method 等於 next ComponentA.method</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// functional component</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ComponentB</span>  = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> ()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">re-render 是指呼叫 ComponentB() 本身，其內部的 function 都會重新建立。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">ComponentB</span>() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 👉 prevComponentB 不等於 nextComponentB</span></span><br></pre></td></tr></table></figure><p>如果把 <code>if</code> 條件拔掉，也是錯誤的。導致每次 re-render 都重新呼叫 <code>fetchData()</code> ，而且是不論 query 是不是有改變，這不是我們要的效果。</p><p>那讓我們的傳遞下去的 <code>fetchData</code> 是會跟著 query 變化的，使用 inline function，並且用 <code>bind</code> 綁定父層的 this ，避免傳到 Child 後用 this 導致指向不正確的問題。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;this.fetchData.bind(this,</span> <span class="attr">this.state.query</span>)&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣導致 <code>this.props.fetchData !== prevProps.fetchData</code> 始終成立，導致每次 re-render 都重新呼叫 <code>fetchData()</code> 。</p><p>解決問題的方法，就是 <strong>把 query 當 props 跟著傳下去</strong>，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent Component</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;this.fetchData&#125;</span> <span class="attr">query</span>=<span class="string">&#123;this.state.query&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child Component</span></span><br><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">  <span class="comment">// 根據 props.query 決定</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">query</span> !== prevProps.<span class="property">query</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>function 可以被傳遞進去，但是 function 內部的改變與否是不能被看見的，它沒辦法直接拿來被比較。另一個原因是，props 傳來的方法封閉了 <code>this</code> (this 是看怎麼被呼叫，什麼意思呢 ? 看下面註解)，我們不能直接依賴它來決定是否更新。導致我們 <strong>必須傳遞內部相關所有的資料</strong>，就為了檢查是否有改變再決定要不要呼叫方法。</p><blockquote><p>對於 class component 來說， function props 不是屬於資料流的一部分。</p></blockquote><p>我們不知道 <code>this.props.fetchData</code> 從 Parent 傳過來是不是跟 state 有關，或是 state 是不是已經改變了。(這個 props 的 stateless 有關嗎 ? )</p><p>使用 <code>useCallback</code> 讓 function 可以加入資料流中，我們根據 function 的輸入值改變，代表 function 本身也要改變，反之亦然，輸入沒有變的話就也不會產生新的 function。有 <code>useCallback</code> 的協助，改變 props 的時候，<code>props.fetchData</code> 也會自動地傳遞下去，因為它本身是資料流的一部分。</p><h3 id="注意-4">注意</h3><p>把任何 function 都加上 <code>useCallback</code> 是一件很不 Ok 的事，這不是保證是效能上的優化。</p><p>雖然它是一個很有效的方法，對於同時傳遞給多個子元件，並且應用在子元件內部的 effect，是可以避免子元件做無意義 render 的問題。當然也可以包裹成 Hooks 避免多個 callbacks 傳遞整個 React 樹狀結構。</p><p>用上面的 <code>fetchData</code> 來試著寫成 <code>useFetchData</code> ，這裡可以搭配 <code>useContext</code>，使用 Provider 包住的元件可以根據 query 改變而更新資料包。<br> 👉 <a href="https://codesandbox.io/s/festive-fermi-1cms7c?file=/src/index.js">codesandbox 簡易查詢各國代碼 API</a></p><p>列出功能 :</p><ol><li>Provider 包住的元件，使用 <code>useFetchData</code> 就可以拿到回傳的資料。</li><li>當 query 改變時重新獲取資料</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext, useMemo, useState, useEffect, useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本網址</span></span><br><span class="line"><span class="keyword">let</span> baseurl = <span class="string">&quot;https://restcountries.com/v3.1/name/&quot;</span>;</span><br><span class="line"><span class="comment">// 建立 context，如此一來包住的元件都可以直接用 useFetchData 取的共享值</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Context</span> = <span class="title function_">createContext</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 修一下名字方便 debug</span></span><br><span class="line"><span class="title class_">Context</span>.<span class="property">displayName</span> = <span class="string">&quot;FetchDataContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 Provider 元件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DataProvider</span>(<span class="params">&#123; children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&quot;tw&quot;</span>);</span><br><span class="line">  <span class="comment">// 避免造成 value re-render ，把 value 記憶起來，直到改變 query</span></span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      query,</span><br><span class="line">      setQuery</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [query]);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom Hooks </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useFetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 這一段主要確認上方是否有 Provider 的防呆</span></span><br><span class="line">  <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">Context</span>);</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;useCount must be used within a CountProvider&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 確定有後把 context 解構比較好讀</span></span><br><span class="line">  <span class="keyword">const</span> &#123; query, setQuery &#125; = context;</span><br><span class="line">  <span class="comment">// 讀取回來的資料</span></span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// 錯誤處理</span></span><br><span class="line">  <span class="keyword">const</span> [message, setMessage] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (query) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(baseurl + query).<span class="title function_">then</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> r.<span class="title function_">json</span>());</span><br><span class="line">        <span class="comment">// 回傳不是 404 時判斷</span></span><br><span class="line">        <span class="keyword">if</span> (!data.<span class="property">status</span>) &#123;</span><br><span class="line">          <span class="title function_">setData</span>(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 回傳 status 為 404 設定錯誤資訊</span></span><br><span class="line">          <span class="title function_">setMessage</span>(data.<span class="property">message</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setMessage</span>(<span class="literal">null</span>); <span class="comment">// 清除錯誤資訊</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [query]); <span class="comment">// 👈 deps 放入 query</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回傳需要的值</span></span><br><span class="line">  <span class="keyword">return</span> &#123; data, query, setQuery, message &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包回傳</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">DataProvider</span>, useFetchData &#125;;</span><br></pre></td></tr></table></figure><p>寫成 Hooks 時在使用就很方便，只要在同一層共享的部份加上 Provider ，內部元件都使用 <code>useFetchData</code> 就能拿到想要的內容👍</p><p>當然這個例子可以再改進，例如 input 的部份可以改用 option，由第一次進入 app 先取得所有國家國碼，這樣使用者可以用選單的方式進行。</p><h2 id="談談競爭條件-race-condition">談談競爭條件 (race condition)</h2><p>什麼是競爭條件呢 ?</p><p>在 JavaScript 中跟競爭條件有關的是非同步的問題，如上面舉例的 <code>fetchData</code> 。<strong>如果在非同步操作的未完成的時候，中途改變 state 或 props 會導致非預期的事情發生。</strong><br> 👉 可以參考這篇文章 : <a href="https://toy9986619.medium.com/javascript-async-await-%E7%9A%84-race-condition-20927705569">JavaScript — async/await 的 race condition</a></p><blockquote><p>簡單來說跟執行順序有關</p></blockquote><p>以 <code>fetchData</code> 為例，我們用 async/await 簡化非同步的處理，內部的 fetch 是 Promise，如果在 pending 的時候又改變 state 重新獲取資料，就會發生問題。</p><p>例如 : 一開始搜尋 usa，在結果還沒返回時改成 peru，假設 usa 資料先回來並且顯示在畫面上，過一下子最終 peru 的 response 才會回來 。<strong>畫面等待 peru 資料回傳時顯示 usa 資料的時候 input 是 peru 呀 !</strong> 造成 UI 跟 state 對不上了😵。</p><p>如果要模仿此動作，可以到 devtool 的 network 並且自訂速度，這邊我訂了一個叫 <code>superslow</code>，把 Download 設為 1kb，讓回傳間隔變長就比較清楚問題。<br> <img data-src="https://i.imgur.com/Hh8l045.png" alt="|400x220"></p><p>怎麼避免或是解決此狀況呢 ? 🤔</p><p>要知道 React 的 <code>useEffect</code> 並不會幫我們處理這個問題，最好的方式是可以讓非同步被中斷 (abort)，並且在 clean up 的階段取消。另外一個方法是，<strong>在把回傳資料放入 state 之前，用 <code>boolean</code> 檢查目前狀態是否要取消。</strong> 因為在執行下一個 effect 之前，會先執行 clean up function。</p><p>既然我們上面有實作，那就來改造上面的例子 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 👉 建立當次 render 的 didCancel</span></span><br><span class="line">    <span class="keyword">let</span> didCancel = <span class="literal">false</span>;</span><br><span class="line">    (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (query) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(baseurl + query).<span class="title function_">then</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> r.<span class="title function_">json</span>());</span><br><span class="line">        <span class="comment">// 檢查是不是有取消 ?</span></span><br><span class="line">        <span class="keyword">if</span> (!didCancel) &#123;</span><br><span class="line">          <span class="title function_">setData</span>(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">setMessage</span>(data.<span class="property">message</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 在下一個 effect 執行前，確定取消</span></span><br><span class="line">      didCancel = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">setMessage</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [query]);</span><br></pre></td></tr></table></figure><p>情境 :</p><ol><li>顯示畫面後改搜尋 usa</li><li>資料還沒返回，改成 peru</li></ol><p>我們來執行看看，從第一次 render 完之後 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input 改成 usa</span></span><br><span class="line">setState query = <span class="string">&quot;usa&quot;</span></span><br><span class="line">re-render <span class="variable constant_">UI</span></span><br><span class="line"></span><br><span class="line">clean up 清除 tw 副作用</span><br><span class="line">  state query <span class="string">&quot;tw&quot;</span></span><br><span class="line">  didCancel = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">effect 執行</span><br><span class="line">  state query <span class="string">&quot;usa&quot;</span></span><br><span class="line">  didCancel = <span class="literal">false</span></span><br><span class="line">  🚀<span class="keyword">async</span> <span class="keyword">function</span> 執行，進入 pending 狀態</span><br><span class="line"></span><br><span class="line"><span class="comment">// input 改成 peru</span></span><br><span class="line">  setState query = <span class="string">&quot;peru&quot;</span></span><br><span class="line">  re-render <span class="variable constant_">UI</span></span><br><span class="line"></span><br><span class="line">clean up 清除 usa 副作用</span><br><span class="line">  state query <span class="string">&quot;usa&quot;</span></span><br><span class="line">  didCancel = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">effect 執行</span><br><span class="line">  state query <span class="string">&quot;peru&quot;</span></span><br><span class="line">  didCancel = <span class="literal">false</span></span><br><span class="line">  🚀<span class="keyword">async</span> <span class="keyword">function</span>  執行，進入 pending 狀態</span><br><span class="line"></span><br><span class="line">👉 usa 資料回來了</span><br><span class="line">  usa clean effect 已經被呼叫，此時 didCancel 是 <span class="literal">true</span> 😵</span><br><span class="line">  ❌ setData 不會被執行</span><br><span class="line"></span><br><span class="line">👉 最後 peru 資料回來了</span><br><span class="line">  didCancel 是 <span class="literal">false</span> </span><br><span class="line">  setData 會執行</span><br><span class="line">  顯示 peru 資料</span><br></pre></td></tr></table></figure><p>一開始從上面看起來 <code>usa</code> 資料回來為什麼 <code>didCancel = true</code> 🤔，明明 <code>peru</code> 的 effect 執行了 <code>didCancel = false</code>。回到順序問題，在 <code>usa</code> 這個 render 時，我們的 <code>didCancel</code> 最後是什麼 ?</p><p>我一開始覺得很微妙，所以再回去複習 [[#談談 clean up]] 這個章節。</p><blockquote><p>每一個在 render 內部呼叫的 function (包含 handlers 、effect 等瀏覽器 APIs )，都會拿到當下定義的 state 。</p></blockquote><p>單看在 <code>usa</code> 這次 render 執行順序應該是 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">usa-didCancel = <span class="literal">false</span></span><br><span class="line">🚀<span class="keyword">async</span> <span class="keyword">function</span> 進行 fetch data</span><br><span class="line">  </span><br><span class="line">peru 的到來觸發了 use-clean up <span class="keyword">function</span></span><br><span class="line">  usa-didCancel = <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">usa 資料回來 data = ...</span><br><span class="line"><span class="keyword">if</span> (usa-didCancel = <span class="literal">true</span>)</span><br><span class="line">❌ setData 這行不會被執行</span><br></pre></td></tr></table></figure><p>在釐清概念的過程，我是使用 console 在每一個階段印出當時的 query ，幫助自己了解 effect 一值提到的 <strong>同步</strong> 概念</p><h2 id="用正確的心態對待-useEffect">用正確的心態對待 useEffect</h2><p><code>useEffect</code> 雖然很常被用在非同步讀取資料，但 <strong><code>useEffect</code> 是核心思想是來做同步的操作</strong>。 side effects 變成資料流的一部分，只要我們的當次 render 的資料同步，取得的資料也是一致的，對於邊際條件 (edge case) 的處理就會比較容易。</p><p>不過 React 在 18 版本對於處理非同步事件比較建議使用 <strong>Suspense</strong>。Suspense 是一個可以讓還沒準備好可以 render 的 UI 可以顯示預設的 Component ，主要要解決 2 個問題</p><ol><li>code splitting : 不用把一次所有 app 元件載下來，而是載必要的</li><li>data fetching : 解決像是上面提到的 race condition 問題</li></ol><p>不過 Suspense 我也還沒認真研究過 😵，先列入補坑大隊的名單吧</p><h2 id="總結-33">總結</h2><ol><li><code>useEffect</code> 是 render 與瀏覽器 painting 之後執行，目的是不阻攔螢幕的更新。</li><li><code>useEffect</code> deps array 如果是空的，僅執行一次，如果 array 有 state 或 props ，根據資料是否有改變，會跟著當次 render 之後重新呼叫。</li><li>每一次 render 都保有它所有的東西，包含 event handler、非同步 (async/await)、effect 或是 API ，以及當次 render 的 state 與 props。</li><li>想拿到最新的值可以使用 <code>refs</code>，refs 就像放在外部的盒子，React 確保它都指向同一記憶體位址，改變其值也不會造成 re-render。</li><li>clean up function 會在下一個 effect 呼叫之前先執行，注意 clean up 所清除的是上一次 render 的值。</li><li>不要欺騙 deps array，通常 lint 會提醒，但是遇到 object type 的值要小心，可能造成過度頻繁更新。</li><li><code>useEffect</code> 的 deps array 是否要放入相關 state 或 props ，可以視 effect function 中的 state 變化是否可由 <code>prevState</code> 推測出來，如果可以可使用 updater function 來更新。</li><li>useReducer 是可以讓資料跟邏輯分開操作的好方法。</li><li><code>useCallback</code> 是可以記住 render 內的 function，使其每次不應 re-render 而重新建立，或是透過 callback 的 deps array 來優化。如果不是 function 則可以使用 <code>useMemo</code> 記住某值。</li><li>function 在 function component 與 Hooks 中是一種資料流。它可以透過 props 來傳遞，也可以被判斷是否為 render 的條件之一。記住，此行為跟 class component 不一樣。</li><li>useEffect 是處理同步的操作，確保每一次 render 的 state 或 props 與 UI 具有一致性。</li></ol><p>本篇雖然著重於 <code>useEffect</code> ，但對於新手一連貫認識 React 概念釐清很有幫助。讀完可以說是醍醐灌頂，從 class Component 到 function Component 的轉變，其解決的原因；function Component 使用的心智模型 (也就是核心概念)，更了解 Hooks 的思維與結合 JavaScript closure 的奧妙，讓人讀完有一種</p><blockquote><p>「原來是這樣的阿 !」</p></blockquote><p>雖然閱讀過程很艱辛😵，因為我是生啃英文版，沒有選擇中文是擔心無法領會翻譯者的意思，不是怕翻不好，而是擔心翻譯者水平太高，反而我看不懂🤣。幸好 Dan 大的文章本身對小白很友善，很值得用原文一讀👍</p><h3 id="題外話">題外話</h3><p>這段期間校正本篇文章時，FB 社團 <a href="https://www.facebook.com/groups/reactjs.tw/">ReactJS.tw</a> 也正好有大神做同樣的主題 <a href="https://slides.com/tz5514/useeffect-guide?fbclid=IwAR2VdZODJPO8Ex1Kd7PksCRA4dakIVvY-4aJ3X3ZtgfSwgq7hOGE6qHvcNc">都 2022 年了你還是可能不懂 useEffect</a>。整理出的脈絡清晰，也有提到 React 18 為什麼嚴格模式會執行兩次的問題。目前我還沒完全看完，但我認為看不同的人解釋同篇文章也是很有值得學習的地方，畢竟新手跟老手的認知起點不同😂，很慶幸正好在學習 useEffect 同時遇到大神的簡報與演講，遇到觀念卡住時，我也會翻到大神的簡報去彌補我不懂的地方。</p><p>有一度想以簡報的內容去重新整理文章，但想想這也我學習 useEffect 的原汁原味學習過程，就全保留了🤓。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">render 內部 function 的執行點 : <a href="https://codesandbox.io/s/w2wxl3yo0l">w2wxl3yo0l - CodeSandbox</a></span> <a href="#fnref:1" rev="footnote">↩</a></li><li id="fn:2"><span style="display:inline-block;vertical-align:top;padding-right:10px">2.</span><span style="display:inline-block;vertical-align:top">function 版本 : setTimeout 之依序印出 state <a href="https://codesandbox.io/s/lyx20m1ol">lyx20m1ol - CodeSandbox</a></span> <a href="#fnref:2" rev="footnote">↩</a></li><li id="fn:3"><span style="display:inline-block;vertical-align:top;padding-right:10px">3.</span><span style="display:inline-block;vertical-align:top">class 版本 : setTimeout 之全部同時一樣的 state <a href="https://codesandbox.io/s/kkymzwjqz3">kkymzwjqz3 - CodeSandbox</a></span> <a href="#fnref:3" rev="footnote">↩</a></li><li id="fn:4"><span style="display:inline-block;vertical-align:top;padding-right:10px">4.</span><span style="display:inline-block;vertical-align:top"><a href="https://reactjs.org/docs/hooks-reference.html#functional-updates">Hooks API Reference – React – functional-updates</a></span> <a href="#fnref:4" rev="footnote">↩</a></li></ol></div></div></div><div class="popular-posts-header">相關文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="\2022\04\04\Practice-to-Master-01.html" rel="bookmark">紀錄 | Frontend Mentor 挑戰題 - Time tracking dashboard</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="\2022\07\React\ContextAPI.html" rel="bookmark">筆記 | React - Context API</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="\2022\07\React\Higher-Order-Component.html" rel="bookmark">筆記 | React - Higher Order Component (HOC)</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="\2022\07\React\Render-props.html" rel="bookmark">筆記 | React - render props</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="\2022\08\React\ref-and-callback-ref.html" rel="bookmark">筆記 | React - ref 與 callback ref</a></div></li></ul><footer class="post-footer"><div class="post-tags"><a href="/tags/React/" rel="tag"><i class="fa fa-tag"></i> React</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2022/07/React/Render-props" rel="prev" title="筆記 | React - render props"><i class="fa fa-chevron-left"></i> 筆記 | React - render props</a></div><div class="post-nav-item"> <a href="/2022/08/React/ref-and-callback-ref" rel="next" title="筆記 | React - ref 與 callback ref">筆記 | React - ref 與 callback ref<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div style=""><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">RosaHong</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i></span> <span>總字數：</span> <span title="總字數">289k</span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span>所需總閱讀時間 &asymp;</span> <span title="所需總閱讀時間">4:23</span></span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 強力驅動</div></div></footer><script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1.15.0/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.7.0/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"></body></html>