<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>健忘雜記</title>
  
  <subtitle>紀錄學習與生活</subtitle>
  <link href="https://blog.rosa.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.rosa.tw/"/>
  <updated>2022-09-02T08:49:44.966Z</updated>
  <id>https://blog.rosa.tw/</id>
  
  <author>
    <name>Rosa Hong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>筆記 | Web - 初探前端效能優化</title>
    <link href="https://blog.rosa.tw/2022/09/learing-web-performance"/>
    <id>https://blog.rosa.tw/2022/09/learing-web-performance</id>
    <published>2022-09-01T20:40:43.000Z</published>
    <updated>2022-09-02T08:49:44.966Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>參考文章連結 : <a href="https://medium.com/starbugs/%E4%BB%8A%E6%99%9A-%E6%88%91%E6%83%B3%E4%BE%86%E9%BB%9E-web-%E5%89%8D%E7%AB%AF%E6%95%88%E8%83%BD%E5%84%AA%E5%8C%96%E5%A4%A7%E8%A3%9C%E5%B8%96-e1a5805c1ca2">今晚，我想來點 Web 前端效能優化大補帖！. 效能是工程師在維護專案時非常重視的要點，不論是 Web 還是…</a></p></blockquote><h2 id="摘要-5">摘要</h2><p>收集常見的前端優化的方式及例子。主要了解常見名詞上的解釋，沒有深入其實作方法，幫助自己吸收了解。</p><span id="more"></span><h2 id="一定要做效能優化嗎">一定要做效能優化嗎 ?</h2><p>效能的優化是選擇性的，非必要性。並不是所有的應用都需要追求效能，很有可能優化的效益不大，但花的時間過多，造成成本上的浪費。</p><h2 id="為什麼要做效能優化">為什麼要做效能優化 ?</h2><p>優化目的是 :</p><ul><li>SEO</li><li>使用者體驗 : 著重於 Core Web Vital 指標，包含 LCP、FID 以及 CLS</li><li>影響營收的重要指標</li></ul><h2 id="如何分析效能">如何分析效能 ?</h2><p>使用工具幫我們找到導致效能瓶頸來源，使用 performance analyzer 找出問題，常見有 :</p><ol><li><a href="https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk?hl=zh-tw">Lighthouse</a> : 多用於開發階段的測試，因為其 FID 沒有使用者可以根據來評測，會使用 TBT 來測量。</li><li><a href="https://pagespeed.web.dev/?hl=zh_TW">PageSpeed Insights</a> : 發布版本測試。</li></ol><h2 id="衡量網頁的指標-Core-Web-Vitals">衡量網頁的指標 : Core Web Vitals</h2><p>網頁常用的衡量指標有 3 個<br><img data-src="https://i.imgur.com/WmPuRSn.png" alt=""></p><ol><li>LCP : 載入最大區塊元素 渲染的時間</li><li>FID : 從載入到與網頁元素互動的時間</li><li>CLS : 視覺上布局的偏移量</li></ol><h3 id="LCP-─-Largest-Contentful-Paint">LCP ─ Largest Contentful Paint</h3><p>顯示 <strong>最大內容元素</strong> 所需時間 (速度)，通常最大內容元素通常是圖片或影片，不然節點大的文字區塊。</p><p>LCP 是計算網頁可視區 (viewport) 中 <strong>最大元件的載入時間</strong>，也就是頁面的主要內容被使用者看到的時間，是速度的指標。</p><blockquote><p>可視區內最大的元素並不是固定不變的 。會隨使用者滑動而找尋下一個最大的區塊元素。</p></blockquote><h4 id="如何優化-LCP">如何優化 LCP ?</h4><ol><li>減少伺服器回應時間<ul><li>針對主機效能優化 : 硬體上優化</li><li><strong>提早載入第三方資源</strong></li><li><strong>使用較近的 CDN Cache</strong></li></ul></li><li>盡量避免 Blocking Time<ul><li>降低 JavaScript blocking time。</li><li>降低 CSS blocking time。</li></ul></li><li>加快資源載入的時間<ul><li><strong>圖片大小優化</strong></li><li><strong>預先載入重要資源</strong></li><li>將文字檔案進行壓縮</li><li>根據使用者的網路狀態提供不同的內容 (可以分成 離線 . 線上)</li><li>使用 service worker</li></ul></li><li>避免使用客戶端渲染(CSR)<ul><li>若必須使用 CSR ，建議優化 JavaScript ，避免渲染時使用太多資源。</li><li>盡量在伺服器端完成頁面渲染，讓用戶端取得已渲染好的內容 。<br>原因是 CSR 把後端要做的渲染頁面工作給承攬到由前端執行，第一次載入時要花更多時間處理 JavaScript 的渲染內容。<strong>CSR 使 FP 到 FCP 這段時間畫面都是空白的</strong>😥，導致東西出現的時間被延後。<br><img data-src="https://i.imgur.com/lZqUiRq.png" alt="圖源來自 : https://www.patterns.dev/posts/client-side-rendering/"></li></ul></li></ol><h3 id="FID-—-First-Input-Delay">FID — First Input Delay</h3><p>首次輸入延遲/封鎖時間總計 (互動性)</p><p>輸入延遲 (Input Delay) 通常發生於瀏覽器的主執行序過度繁忙，而導致頁面內容無法正確地與使用者進行互動。</p><h4 id="如何優化-FID">如何優化 FID</h4><ul><li>減少 JavaScript 運作的時間。</li><li>降低網站的 request 數並降低檔案大小。</li><li>減少主執行序的工作</li><li>降低第三方程式碼的影響</li></ul><h3 id="CLS-—-Cumulative-Layout-Shift">CLS — Cumulative Layout Shift</h3><p>累計版面配置轉移 (穩定性)。雖然畫面被渲染，但隔一下下又被重排 (reflow) 導致畫面明顯抖動，使用者會看到畫面不是很穩定的被重新繪製。這跟使用者體驗有較大的關係。</p><p>實際的場景可以參考 : <a href="https://web.dev/cls/">Cumulative Layout Shift (CLS)</a>。範例中當使用者進行互動後導致布局改變太大，導致下一個互動誤觸。</p><h4 id="如何避免-CLS">如何避免 CLS</h4><ul><li>給予會比較慢載入的元素一個預設的寬度與高度 ，減少版面的偏移。</li></ul><h2 id="優化手段">優化手段</h2><h3 id="Code-Minimize-Uglify">Code Minimize &amp; Uglify</h3><p>通常利用如 webpack 、gulp 等打包工具替我們做這些事情。</p><h4 id="Minimize">Minimize</h4><p>變數跟 code 寫的越短，或是刪除不必要的空白，可以省掉不少瀏覽器 Parse 的時間，也就是提升前端程式的效能。</p><p>白話來說 : 佔據物理的空間越少，跑越快</p><h4 id="Uglify">Uglify</h4><p>通常會使用較短的變數名稱作為代替，打亂程式的邏輯，避免源代碼外流。</p><h3 id="圖片優化-壓縮、圖片的種類選擇">圖片優化 : 壓縮、圖片的種類選擇</h3><blockquote><p>補充文章 : <a href="https://ithelp.ithome.com.tw/articles/10252501">Optimize Images</a></p></blockquote><p>圖片佔網站載入資源的很大一部分，對網站效能有顯著的影響。在考慮 Image Lazy Load 等技巧以前，我們可以先將圖片壓縮，透過減少檔案大小來加快載入時間。</p><p>優化步驟 :</p><ol><li>選擇正確的圖片類型</li><li>進行壓縮 (svg 等檔案可以再壓縮)</li><li>進一步做 lazy load</li></ol><h4 id="避免使用點陣圖">避免使用點陣圖</h4><p>使用前考慮 :</p><ul><li>避免以圖片內嵌文字的方式顯示文字</li><li>能用 CSS 達到類似的效果？(例如 : 圓形、三角形等幾何圖案)</li><li>可以轉換成 SVG 嗎？</li></ul><p>圖片類型的壓縮 :</p><ol><li>有損壓縮：如 JPG，使用只取部分像素資料的方式來壓縮圖片大小，並且 <strong>壓縮後是不可逆</strong> 的。</li><li>無損壓縮：如 PNG，壓縮後不影響圖片品質。</li></ol><h4 id="使用-SVG">使用 SVG</h4><p>SVG 為優先考量，其優點 :</p><ol><li>向量檔不失真</li><li>SVG 相對體積較小</li><li>傳輸可用 <code>Gzip</code>、<code>Brotli</code> 等壓縮格式</li></ol><h4 id="另一種選擇-WebP">另一種選擇 : WebP</h4><blockquote><p>說明連結 : <a href="https://developers.google.com/speed/webp">An image format for the Web</a></p></blockquote><ul><li>相較其他點陣圖，WebP 小很多，大概縮小 25% 左右</li><li>支援動圖，GIF 轉 WebP（但還有更小的 <code>WebM</code>）</li><li>支援透明</li></ul><h3 id="Critical-Render-Path-關鍵渲染路徑">Critical Render Path 關鍵渲染路徑</h3><p>效能最佳化其實就是 <strong>渲染步驟中所有的活動，再經過最佳化</strong>，這就是所謂的關鍵渲染路徑 Critical Render Path 。</p><blockquote><p>使用者首要互動與看見的先去處理。</p></blockquote><h4 id="網頁是如何渲染到頁面上">網頁是如何渲染到頁面上 ?</h4><p>從收到 HTML、CSS 和 JavaScript，再對程式碼進行必需的處理，到最後轉變為顯示像素的過程中還有許多中間步驟。<br><img data-src="https://miro.medium.com/max/1400/1*HUNT1RjFy_LONbmR4DpNeg.png" alt=""></p><p>根據上圖，網頁渲染的流程為：</p><ol><li>讀取 HTML 後生成 DOM Tree</li><li>讀取 HTML 中的 CSS Link Tag 生成 CSSOM Tree</li><li>DOM Tree 與 CSSOM Tree 共同生成 Render Tree</li><li>根據 Render Tree 生成 Layout</li><li>最後 Paint 畫面</li></ol><p>JavaScript 可以查詢及修改 DOM 和 CSSOM，在 CSSOM 執行完畢後，JavaScript 才會執行 。</p><blockquote><p>CSS file 盡快引入，JS 在 CSS 後引入，因為 JS的執行會導致網頁載入的暫停</p></blockquote><h4 id="JavaScript-載入時間差別">JavaScript 載入時間差別</h4><blockquote><p>參考圖片來源 : <a href="https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html#script">async vs defer attributes - Growing with the Web</a></p></blockquote><p><code>&lt;script&gt;</code> tag 除了一般的引入，還有 <strong>async</strong> 跟 <strong>defer</strong> 這兩種方式：<br><img data-src="https://i.imgur.com/MQAQvPt.png" alt="來源自上面的圖片"></p><ul><li>async : 非同步去請求外部腳本，回應後停止解析執行腳本內容。用於載入第三方函式庫等<strong>不需要動到 DOM 結構的狀況</strong>。</li><li>defer : 也會非同步請求外部腳本，但是 <strong>等待瀏覽器解析完才執行</strong>。適合整個頁面都下載及分析完成後才會執行，非常<strong>類似於把 JS 放在頁尾的情況</strong>  。</li></ul><blockquote><p>兩種都是非同步下載，不同的是 <strong>執行的時間點</strong></p></blockquote><h4 id="最佳化-CRP">最佳化 CRP</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path#optimizing_for_crp">MDN 提供幾項參考</a> :</p><ol><li>最小化主要資源，並且使用 <strong>非同步</strong> 的方式或是減少下載的次要資源 (non-critical)。</li><li>優化資源請求的數量，或是請求資源的體積大小</li><li>優化下載主要資源的優先順序 (priority)，縮短主要渲染路徑。</li></ol><p>實際上這是一個很大的主題😵，可以參考 <a href="https://www.patterns.dev/">Patterns.dev</a> 的詳細說明 : <a href="https://www.patterns.dev/posts/loading-sequence/">Optimize your loading sequence</a>，裡面還包含各項怎麼去影響 Core Web Vitals。</p><h3 id="Code-Splitting">Code Splitting</h3><p>現代網頁程式漸漸走向使用框架以模組化方式來開發。程式 bundle size 仍然會變得過於肥大，導致 client side 的網頁載入時間變長，嚴重影響使用者體驗。</p><blockquote><p>Code Splitting 就是為了要解決單一 JS Bundle 過於肥大的問題。</p></blockquote><p>將原本單一的 bundle 切分成數個小 chunk，可以搭配平行載入，或者是有需要時才載入某些特定的 chink，又或是對一些不常變動的 chunk 個別做快取，來達到載入效能的優化。</p><p>較常見的 Code Splitting 又分為兩種方式 :</p><ol><li>抽離第三方套件 Bundle Splitting</li><li>動態載入功能模組 Dynamic Import</li></ol><p>在 Webpack 5 可以透過設定 <code>SplitChunksPlugin</code> 來幫助 chunk 上的設定。</p><p>註 : 文中是寫 <code>CommonsChunkPlugin</code>，但在 Webpack 4 已經把 <a href="https://webpack.js.org/plugins/commons-chunk-plugin/">CommonsChunkPlugin</a>抽離掉設定了，改成 <a href="https://webpack.js.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a>。其使用方法可以參考 : <a href="https://awdr74100.github.io/2020-04-06-webpack-splitchunksplugin/">Webpack 前端打包工具 - 使用 SplitChunksPlugin 抽離公用模組</a></p><p>事實上，Webpack 5 在打包時會自動預設 default 的選項，幫我們處理打包，官方稱預設就能獲得不錯的效能，可以參考 <a href="https://webpack.js.org/plugins/split-chunks-plugin/#defaults">chunk 的規則</a></p><h4 id="抽離第三方套件">抽離第三方套件</h4><p>細分兩種方式：</p><ol><li>將所有第三方套件打包為單一檔案</li><li>將第三方套件打包為多個檔案</li></ol><h5 id="將所有第三方套件打包為單一檔案">將所有第三方套件打包為單一檔案</h5><blockquote><p>參考 : <a href="https://s.itho.me/modernweb/2020/Slides/d502.pdf">你的 JS 該減肥了！5 個提升網⾴載入速度的技巧</a></p></blockquote><p>可以先做一個最大的拆分：</p><ol><li><code>Application Bundle</code> ：UI 與商業邏輯，跟我們寫的程式有關，是經常變動的部分。</li><li><code>Vendor Bundle</code> ：第三⽅套件 / node_modules，不太會變動。</li></ol><p>拆分出 Vendor Bundle 變動的頻率相對較低，因此比較適合被 cache。<br>Vendor Bundle 被 cache 的狀況下由於減少了 Application Bundle 的⼤⼩，因此加快了再訪者的載入速度。採用這樣的方式的優點為邏輯簡單。</p><blockquote><p>缺點為更新任何第三方套件都會使快取失效 😟。</p></blockquote><h5 id="將第三方套件打包為多個檔案">將第三方套件打包為多個檔案</h5><blockquote><p>參考 : <a href="https://medium.com/frochu/%E6%B7%BA%E8%AB%87%E5%A4%A7%E5%9E%8B-react-%E5%B0%88%E6%A1%88%E7%9A%84-code-splitting-8a258a13ac67">淺談大型 React 專案的 Code Splitting. 如何透過快取和動態載入加速你的網路應用</a></p></blockquote><p><strong>根據套件關聯性打包</strong>，減少套件更新時造成的延遲。<br>缺點則是相較前面打包成單一檔案的方式，這種方式需要處理的邏輯複雜許多。</p><p>以 Webpack5 為例 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">config.<span class="property">optimization</span> = &#123;</span><br><span class="line">  <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">      <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">          <span class="attr">reactLib</span>: &#123;</span><br><span class="line">              <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/](react|react-dom|styled-components[\\/]dist)[\\/]/</span>,</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&quot;react-lib&quot;</span>,</span><br><span class="line">              <span class="attr">priority</span>: <span class="number">40</span>,</span><br><span class="line">              <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">vendors</span>: &#123;</span><br><span class="line">              <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&quot;vendors&quot;</span>,</span><br><span class="line">              <span class="attr">priority</span>: <span class="number">10</span>,</span><br><span class="line">              <span class="attr">enforce</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用 Regex 把 <code>react</code> 跟 <code>react-dom</code>  抽離出來，因為 window 字元的問題只要有關 <code>/</code> 都要前面加 <code>\\</code> 跳脫，官方有提及這個問題，mac 好像不用。</p><p>我第一次使用 chunk ，所以我把能切的都切出來了🤔，但那個 <code>concatenated</code> 我不太知道是什麼…，翻譯是說關聯的資源，參考 : <a href="https://twitter.com/olore/status/937523005407813632">caused by the ModuleConcatenationPlugin</a><br><img data-src="https://i.imgur.com/3syl3x4.png" alt="拿其中一個專案實作"><br>這個頁面的左上角有拉頁，拉開來可以看到打包的幾之程式碼名稱、要不要顯示 module 的全名還有 chunk + 壓縮、chunk + 沒壓縮 以及完全原始的大小。</p><p>在 build 並壓縮之後顯示的 chunk 的大小，WOW 😲!<br><img data-src="https://i.imgur.com/kZjmg5G.png" alt=""></p><h4 id="要怎麼知道哪些一起打包">要怎麼知道哪些一起打包 ?</h4><p>可以透過 <strong>webpack-bundle-analyzer</strong>，視覺化分析專案有哪些 bundle chunk，各個 bundle chunk 的組成又為何，再針對可以改進的 bundle 進行優化。<br>類似工具 : <code>WebpackVisualizerPlugin</code><br><img data-src="https://i.imgur.com/mIBd788.png" alt="還沒 chunk 之前，webpack 會做 default 照規則 chunk"></p><p>之後再針對比較肥大的套件再進行不同的打包優化方式。</p><h4 id="動態載入功能模組-Dynamic-Import">動態載入功能模組 Dynamic Import</h4><p>在檔案的開頭引入需要用到的模組，通常在網頁載入時就被引入進來，稱為 static import。</p><ul><li>static import 不能滿足這兩種狀況的需求 :<ul><li>模組名稱為動態變數時</li><li>需依照特定邏輯或特定時機引入時</li></ul></li><li>Dynamic Import 的使用情境 :<ul><li>根據路徑做 Dynamic Import</li><li>針對肥大套件做 Dynamic Import</li></ul></li></ul><h4 id="根據路徑做-Dynamic-Import">根據路徑做 Dynamic Import</h4><p>有些路由 (router) 少被造訪，CSR 建站的方式會使沒有對 bundle 做額外處理的狀況下會在一開始載入 JS bundle 時就載入許多頁面的資源，這樣會導致許多不太會被使用者瀏覽的頁面是很有機會被載入卻又沒被使用的。</p><p>選擇針對路徑做 Dynamic Import，當切換到特定路徑時再載入該路徑會用到的資源。</p><h4 id="針對肥大套件做-Dynamic-Import">針對肥大套件做 Dynamic Import</h4><p>「肥大卻又不會馬上用到」的模組做 Dynamic Import， 透過 <code>webpack-bundle-analyzer</code> 分析較大的套件，並且做動態載入，減少了一開始載入的 bundle size。</p><h3 id="懶加載-Lazy-Load-Image">懶加載 : Lazy Load Image</h3><p>圖片佔了網站資源相當大的比例，避免在網頁載入的瞬間就想把所有圖片都載入下來，是對效能是一個硬傷。</p><p>可以採用 lazy load 的方法去載入圖片，<strong>一開始只需載入部分的圖片</strong>，待現有圖片快要接觸到 viewport 的底部時再去動態載入新的圖片。</p><ol><li>搭配 Intersection Observer web API : 偵測目標元素是不是與特定位置交會，交會時再去載入新的資源。</li><li>瀏覽器原生支援，html 加上 <code>loading=lazy</code></li></ol><p>無限卷軸 (Infinite Scrolling) 的分頁載入 API data 也會使用 lazy load 的技巧。</p><h3 id="Virtualized-List">Virtualized List</h3><blockquote><p>額外閱讀 : <a href="https://www.patterns.dev/posts/virtual-lists/">List Virtualization (patterns.dev)</a></p></blockquote><p><code>virtualized list</code> 是優化長列表的一種技巧。同時渲染數量大的元素會有幾個缺點：</p><ol><li>載入時白屏時間會比較長</li><li>渲染了大量的 dom 節點的狀況下，在滾動事件觸發時會大大增加記憶體的用量</li><li>容易失幀，因為渲染很慢，所以無法維持瀏覽器的幀率，頁面會顯得卡頓</li><li>最慘的話網頁會失去響應</li></ol><h4 id="Virtualized-List-概念">Virtualized List 概念</h4><p>用陣列 <strong>儲存所有列表元素的位置</strong>，只渲染可視區 (viewport)內的列表元素。當可視區滾動時，根據滾動的 offset 大小以及所有列表元素的位置，計算在可視區應該渲染哪些元素。</p><p>當原本被渲染的 item 移出可視區後，就會被 unmount 掉，避免前面說的同時生成一堆 dom 節點的狀況。</p><p>這種方式也稱做 <strong>windowing</strong>，在 react 有現成的 library : <a href="https://github.com/bvaughn/react-window">react-window</a>、<a href="https://github.com/bvaughn/react-virtualized">react-virtualized</a>，兩個都是同一個作者，window 算是輕量版的。</p><p>Brian Vaughn 也就是作者，有一場演講說明他怎麼用 windowing 來優化 rendering。<a href="https://www.youtube.com/watch?v=t4tuhg7b50I">Creating More Efficient React Views with Windowin</a>。</p><h4 id="為什麼說-DOM-很昂貴">為什麼說 DOM 很昂貴</h4><p>常常在 React 上看見說直接操作 DOM 很昂貴，為什麼說昂貴呢 ?</p><p>從 [[#Critical Render Path 關鍵渲染路徑]] 裡面的網頁解析來說，直接操作到 DOM 可能會導致 UI 的變化。以上面大量的節點例子來說，僅僅只是刪除一個節點，被改變的節點都要進行重排 (reflow)，就會重複網頁從 DOM 解析 ~ 到渲染的過程，這才會說 DOM 很昂貴，貴的不是 DOM (DOM 也只是一個物件罷了) 而是操作過後的 re-render 步驟😵。</p><p>所以才會有框架利用 Virtual DOM 來改善這部分的問題🤔</p><h3 id="Tree-Shaking">Tree Shaking</h3><blockquote><p>補充連結 : <a href="https://web.dev/reduce-javascript-payloads-with-tree-shaking/#what-is-tree-shaking">Reduce JavaScript payloads with tree shaking</a></p></blockquote><p>意象上就是把枯葉從樹上搖落下來。</p><p>在程式碼之中有些 code 在某些階段是不需要被載入的，透過打包工具在打包階段就可以分析哪些 code 或哪些 function 是用不到的，而把它們從最終的 bundle 中剔除。</p><blockquote><p>確保最後的 bundle 不會包含無用或多餘的程式碼與資源，減少 bundle size。</p></blockquote><h4 id="如何做到-Tree-Shaking">如何做到 Tree Shaking ?</h4><p>得透過 ES6 的 <code>import/export</code> 的幫忙。所幸 <code>@babel/preset-env</code> 幫我們處理間榮幸的問題。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般我們會全部載入</span></span><br><span class="line"><span class="keyword">import</span> arrayUtils <span class="keyword">from</span> <span class="string">&quot;array-utils&quot;</span>;</span><br></pre></td></tr></table></figure><p>假設我們要使用 array-utils 中的某幾個函式，應該避免上面的引入方式（把整個 array-utils 引入進來，再去使用特定的 property），而改為下面這種引入方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入特定使用到的方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; unique, implode, explode &#125; <span class="keyword">from</span> <span class="string">&quot;array-utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不用 property</span></span><br><span class="line"><span class="keyword">import</span> arrayUtils <span class="keyword">from</span> <span class="string">&quot;array-utils&quot;</span>;</span><br><span class="line">arrayUtils.<span class="title function_">explode</span>() ...</span><br></pre></td></tr></table></figure><ul><li>為什麼只能用 ES6 的 module <code>import/export</code> 呢?<br>因為 CommonJS 使得打包時不知道哪些會被使用，模組的對象/方法暴露於全域當中。而 ES6 的 import/export 採用 static 方法，在編譯時期就已經決定哪些會被包進去。詳細可以看這篇 : <a href="https://loveky.github.io/2018/02/26/tree-shaking-and-pkg.module/">聊聊 package.json 文件中的 module 字段</a></li></ul><h3 id="link-tag-各種的預加載">link tag 各種的預加載</h3><blockquote><p>文章參考 : <a href="https://shubo.io/preload-prefetch-preconnect/">教學 - Preload, Prefetch 和 Preconnect 的差異 - Shubo 的程式開發筆記</a></p></blockquote><p>* 粗體是很常見的</p><ol><li>prefetch</li><li><strong>preload</strong></li><li><strong>preconnect</strong></li><li>dns-preconnect</li><li>prerender</li></ol><p>其共同的效能優化目標：<br>對將來會用到的資源預先處理，可能是載入資源，或是建立連線，因此在真的要使用到該資源時可以省去不少時間。</p><h4 id="Preload-VS-Prefetch">Preload VS Prefetch</h4><p>都是在提早取得將來會用到的資源。</p><ol><li>Preload：先取得當前頁面的資源（例如 <a href="https://web.dev/i18n/en/preload-optional-fonts/">字體 font</a>）。</li><li>Prefetch：告訴瀏覽器「這些資源我待會會用到，先幫我下載吧！」</li></ol><p>prefetch 抓取的資源不限於當前頁面使用，也就是可以跨越 navigation。很確定使用者會點擊下一頁，就可以使用 prefetch 預先抓取下一頁的資源。</p><p>瀏覽器對於資源的載入順序是有規則的，是以 <strong>檔案類型</strong> 來決定下載的優先順序，以 chrome 舉例來說，參考文章 : <a href="https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf">Preload, Prefetch And Priorities in Chrome</a></p><ul><li>High priority : style /font / XHR (sync)</li><li>Medium priority : 位於可視區域的圖片 / Preload without as/ XHR (async)</li><li>Low priority : favicon、<code>script async / defer / block</code>、不在可視區域的圖片、媒體檔、SVG 等 。</li></ul><p>preload 與 prefetch 也是以屬性來分辨檔案類型。</p><p>註 : 瀏覽器 devtool 的 network tab 也可以看到各資源的 priority 。</p><h4 id="Preconnect">Preconnect</h4><p>cross-origin 的資源要被使用，先建立好連線</p><p>瀏覽器在實際傳輸資源前，實際上的步驟 :</p><ol><li>向 DNS 請求解析網域名</li><li>TCP Handshake</li><li>(HTTPS connection) SSL Negotiation</li><li>建立連線完成，等待拿到資料的第一個byte</li></ol><p>每一步都會需要一個 RTT (Round Trip Time) 的來回時間。所以在實際傳輸資料之前，已經花了3個 RTT 的時間。</p><p>在網路狀況很差的狀況下，會讓獲取資源的速度大大降低。</p><p><code>preconnect</code> 提早建立好與特定 domain 之間的連線，省去了一次完整的  <strong>DNS Lookup + TCP Handshake + SSL Negotiation</strong>，共三個 Round Trip Time 的時間。</p><h5 id="Preconnect-使用例子">Preconnect 使用例子</h5><p>通常只會對確定短時間內就會用到的 domain 做 preconnect，因為如果 10 秒內沒有使用的話瀏覽器會自動把連線 close 掉 (HTTP/1.1 的連線機制)</p><ol><li>CDN：如果網站中有很多資源要從 CDN 拿取，可以 <code>preconnect CDN</code> 的域名，這在不能預先知道有哪些資源要抓取的情況。</li><li>Streaming 串流媒體。範例 : <a href="https://github.com/paulirish/lite-youtube-embed">lite-youtube-embed</a></li></ol><h4 id="DNS-Preconnect">DNS Preconnect</h4><blockquote><p>參考連結 : <a href="https://developer.mozilla.org/en-US/docs/Web/Performance/dns-prefetch#why_use_dns-prefetch">Using dns-prefetch - Web Performance | MDN</a></p></blockquote><p>跟 <code>preconnect</code> 類似，差別在於只 <strong>提示瀏覽器預先處理第一步 DNS lookup</strong> 而已。</p><ul><li><code>dns-preconnect</code> = DNS look up</li><li><code>preconnect</code> = DNS look up + TCP Handshake + SSL Negotiation</li></ul><p><code>dns-preconnet</code> 對於第三方資源請求可以節省很多時間，因為每個資源都得跑一次解析網址到回應的過程。<br>參考 : <a href="https://www.cloudflare.com/zh-tw/learning/dns/what-is-dns/">dns 是什麼？如何運作解析懶人包 | Cloudflare</a> 。<br><img data-src="https://i.imgur.com/fquZlQp.png" alt="cloudflare 解釋 DNS 怎麼從網址被解析到回應"></p><h4 id="Prerender">Prerender</h4><p>prerender 比 prefetch 更進一步。</p><blockquote><p>不僅僅會下載對應的資源，還會對資源進行解析。</p></blockquote><p>解析過程中，如果需要其他的資源，<strong>可能</strong>會直接下載這些資源。<br>基本上就是 <strong>盡可能預先渲染下個頁面</strong>，這樣一來當用戶在從當前頁面跳轉到目標頁面時，瀏覽器可以快速的響應。</p><blockquote><p>適合用在用戶很高機率會轉到另一個頁面的狀況下使用。</p></blockquote><h3 id="CDN-Cache">CDN &amp; Cache</h3><p>CDN 的全名為 <strong>Content Delivery Network</strong> 內容傳遞網路。物理上的距離也是影響 response time 的重大因素。CDN 就是透過在各個地理位置建立 edge server 來避免取資源時都要跟距離遙遠的 server 溝通，造成效能的低落。</p><p>當使用者對被 CDN 加速過的域名發出 request 時，CDN 會自動將 request 導到地理位置離使用者較近或是流量較不吃緊的 edge server。</p><p>儘管第一次取資源時因為 CDN 還沒有快取的資料，所以仍然需要跟 original server 要資料，不過之後的 request 就可以透過地理位置離使用者較近的 CDN cache 取得，加快 client 端資源載入的速度。</p><p>除了 cache 機制以外，CDN 某方面也算是增強了服務的可用性、負載功能、安全性（降低 DDOS 對網站的影響）。</p><p><strong>在物理位置上變近，使得伺服器請求時間縮短</strong>。透過 cache ，下一次使用者使用其資源就可以對物理位置上比較近的主機進行索取。</p><h3 id="Write-Good-Code">Write Good Code</h3><p>平常在寫 code 就該多注意自己寫的 code 是否會對效能造成影響</p><ol><li>會不會造成不必要的重新渲染 (Re-render)？</li><li>事件監聽器 (Event Listener) 在用不到時是否正確被移除？</li><li>撰寫的 Function 應該注意一下是否有時間複雜度更低的解法 (演算法)</li><li>會不會造成不必要的 memory 浪費？</li><li>擅用適合情境的 Design Pattern，除了提高程式碼可讀性與可維護性外，也有優化效能的機會。</li></ol><h2 id="總結-26">總結</h2><p><strong>優化的目的 :</strong></p><ol><li>SEO</li><li><strong>提升使用者體驗</strong> (最為重要)</li><li>影響營收的重要指標</li></ol><p><strong>現代網頁優化的指標 :</strong></p><ol><li>LCP : 載入最大區塊元素渲染的時間</li><li>FID : 從載入到與網頁元素互動的時間</li><li>CLS : 視覺上布局的偏移量</li></ol><p><strong>優化的實際手段 :</strong></p><ol><li>Minimize &amp; Uglify : 不影響運作的情況，壓縮並減少內容與空白。</li><li>圖片優化 : 壓縮與不同種類的選擇</li><li>Critical Render Path 關鍵渲染路徑 : 找出一開始必要的東西</li><li>Code Splitting : 重點是不要一次就下載一大包，等待時間太久<ul><li>抽離第三方套件 : 分割 (chunk) 大法，把資源切小載入。</li><li>動態載入功能模組 Dynamic Import : 讓資源有用到再載入</li></ul></li><li>懶加載 : lazy loading : 避免首次發出太多資源請求，隨時間的交互作用再載入。</li><li>Virtualized List : 只選擇渲染可視區域的元素。</li><li>Tree Shaking : 把不需要的 dead code 移除掉。</li><li>link tag 各種的預加載 : 加快外部資源載入的方法。</li><li>CDN &amp; cache : 代理伺服器與暫存。使得物理上的距離縮短，減少資源請求時間。只有首次造訪較花時間，後續的造訪則會選擇較近的伺服器並且使用 cache。</li><li>寫好 code : 應用不同的 Design Pattern ，以及注意重複渲染的問題。</li></ol><p>優化是一個很大的主題，第一次讀好吃力😵，因為很多方法我都沒有使用過，導致吸收覺得好抽象，邊查資料越覺得陷越深，決定在這裡先暫停，回到以認識為主的目的，之後再把各個優化獨立出來研究。</p><p>莫大後來有針對他的文章出一系列的鐵人賽文章 <a href="https://ithelp.ithome.com.tw/users/20113277/ironman/3877">今晚，我想來點 Web 前端效能優化大補帖！ </a> ，我已經放進我的 later reading 名單了。此外，除了正宗的 <a href="https://web.dev/tags/performance/">web.dev</a>網站，我也非常推薦 <a href="https://www.patterns.dev/posts/#performance-patterns">Patterns.dev</a> ，提供現代網頁的 Design Pattern 以及網頁優化的方針，目前打算近期把 <code>Pattern.dev</code> 好好讀一讀了💪</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;參考文章連結 : &lt;a href=&quot;https://medium.com/starbugs/%E4%BB%8A%E6%99%9A-%E6%88%91%E6%83%B3%E4%BE%86%E9%BB%9E-web-%E5%89%8D%E7%AB%AF%E6%95%88%E8%83%BD%E5%84%AA%E5%8C%96%E5%A4%A7%E8%A3%9C%E5%B8%96-e1a5805c1ca2&quot;&gt;今晚，我想來點 Web 前端效能優化大補帖！. 效能是工程師在維護專案時非常重視的要點，不論是 Web 還是…&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要-5&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;收集常見的前端優化的方式及例子。主要了解常見名詞上的解釋，沒有深入其實作方法，幫助自己吸收了解。&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="https://blog.rosa.tw/categories/Web/"/>
    
    
    <category term="Web" scheme="https://blog.rosa.tw/tags/Web/"/>
    
    <category term="Web-optimize" scheme="https://blog.rosa.tw/tags/Web-optimize/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | Obsidian - Plugin-Excalidraw 區域、群組與文字圖片的使用方式</title>
    <link href="https://blog.rosa.tw/2022/08/Obsidian-Excalidraw-image-url"/>
    <id>https://blog.rosa.tw/2022/08/Obsidian-Excalidraw-image-url</id>
    <published>2022-08-29T02:58:31.000Z</published>
    <updated>2022-09-02T08:22:54.793Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>影片連結 : <a href="https://www.youtube.com/watch?v=yZQoJg2RCKI">Block reference parts of images just like text with Obsidian Excalidraw - YouTube</a></p></blockquote><h2 id="摘要-3">摘要</h2><p>解決我怎麼在同一個大張 Excalidraw 把不同的圖片匯出到 markdown 上。一開始我都是靠多個檔案連結，因為我以為只能 1 個檔案全部匯出成 PNG 或者 SVG ，才能在其他 markdown 匯入，但其實是可以 <strong>直接取需要的區塊</strong> 就好，把 Excalidraw 畫板對待成一般的 markdown 文件，把圖像可標記、可連結，是 markdown 文件的加強版工具。</p><span id="more"></span><h2 id="區塊-圖片嵌入的-3-種方法">區塊/圖片嵌入的 3 種方法</h2><p>Excalidraw  區塊/圖片嵌入的方法有 3 種</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text : [[file#^elementID]]</span><br><span class="line">area : [[file#area=Section heading]]</span><br><span class="line">group : [[file#^group=elementID]] </span><br></pre></td></tr></table></figure><ol><li><code>text</code> : 純粹文字，等同於 Obsidian 裡面的 block ID <code>(^elementID)</code>。</li><li><code>area</code> : 區塊性圖片，被截出來 (cutout) 的那一塊。有點抽象，泛指被覆蓋疊到區塊都算，至於區塊的計算我目前看不出所以然🤔，因為有時候某些元素也會被截掉，應該是對應 Excalidraw 偵測文字的邊圍之類的。</li><li><code>group</code> : 有被群組  <code>(ctrl + G)</code> 起來的才會抓到，個人最常用。</li></ol><h2 id="快捷產生區塊-圖片連結">快捷產生區塊/圖片連結</h2><p>工具列最旁邊的小 obsidian 標誌 + 搭配連結圖片圖示<br><img data-src="https://i.imgur.com/JCnnStN.png" alt="小黑曜石 + 視窗按鈕"></p><p>對應 3 種區塊圖片的方式 :</p><ol><li><code>text</code> : 直接按下按鈕</li><li><code>area</code> :  <kbd>shift</kbd> + 按鈕</li><li><code>group</code> :  <kbd>ctrl</kbd> + 按鈕</li></ol><h2 id="實際範例">實際範例</h2><p>針對畫板內容來實作不同的截圖方式。<br><img data-src="https://i.imgur.com/9mau5Ph.png" alt="|400x320"></p><h3 id="text-橘色區塊">text : 橘色區塊</h3><p>結果是找不到該區塊 😵<br><img data-src="https://i.imgur.com/RVloCQU.png" alt="出現找不到的錯誤訊息"></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">連結顯示的文字 : </span><br><span class="line"> ![[Excalidraw/區域、群組與文字圖片的使用方式.md#^zUw1QSHwfxMypXDbPBNBJ]]</span><br></pre></td></tr></table></figure><p>對應實際被標註的 element id 物件，把  Excalidraw 轉成 markdown 就能看見。<br><img data-src="https://i.imgur.com/Qt2nIkW.png" alt="|300x200"><br>會發現實際被標註 id 的是 rectangle ，也就是 group 最外層的橘色方框，理所當然這裡不會有文字，會出現找不到的錯誤訊息。</p><blockquote><p>不可對圖形包裹的 group 取 text， 等同取非文字區域的文字，就是沒文字🤔</p></blockquote><p>如果是 <strong>多個文字框</strong> 被 group 起來 (只有文字組成)，並使用 text 的方式取圖片，是可以的，但只會取到第一個文字框。</p><h3 id="text-藍色區塊">text : 藍色區塊</h3><p>結果只有最後的文字被標註<br><img data-src="https://i.imgur.com/Izkkgqi.png" alt="|200x60"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![[Excalidraw/區域、群組與文字圖片的使用方式.md#^P94rSxUw]]</span><br></pre></td></tr></table></figure><ul><li>markdown 文件標示<br>找回 markdown 標註的目標，會發現只有「顆顆」被標註到🤔<br><img data-src="https://i.imgur.com/ELtkPBQ.png" alt="|300x310"></li></ul><p>如果我們想要整個藍色區塊為圖片怎麼辦 ?</p><h3 id="area-藍色區塊">area : 藍色區塊</h3><p>確實取到藍色區塊，但是包含疊在畫面上的東西🤔<br><img data-src="https://i.imgur.com/dkS6rqh.png" alt="|300x350"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![[Excalidraw/區域、群組與文字圖片的使用方式.md#^area=P94rSxUw]]</span><br></pre></td></tr></table></figure><p>markdown 文件標示的跟 <a href="https://blog.rosa.tw/2022/08/Obsidian-Excalidraw-image-url#more">text 藍色區塊</a> markdown 一樣，因為後面的 element id 跟 text 截取藍色區塊是一樣的，但是 area 很明顯連大區塊 (heading) 都包含了。後面也會凸顯了為什麼 area 是 <code>cutout</code>  (畫面截出來的區域)，並且跟 group 有非常不同的地方。</p><h3 id="area-橘色區塊">area : 橘色區塊</h3><p>一樣涵蓋了被覆蓋到的部分。<br><img data-src="https://i.imgur.com/tRv7yrj.png" alt="|300x350"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![[Excalidraw/區域、群組與文字圖片的使用方式.md#^area=zUw1QSHwfxMypXDbPBNBJ]]</span><br></pre></td></tr></table></figure><p>注意這裡的 element id，跟上面 [[#text 橘色區塊]] 一樣，但也會跟底下的 group 一樣，都是對 rectangle 標註 id。</p><h3 id="group-橘色區塊">group : 橘色區塊</h3><p>確實取到橘色區塊，含一點白色邊框，但範圍不包含覆蓋的綠色圓圈。<br><img data-src="https://i.imgur.com/gTT38aq.png" alt="300|280"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">連結顯示的文字 : </span><br><span class="line"> ![[Excalidraw/區域、群組與文字圖片的使用方式.md#^group=zUw1QSHwfxMypXDbPBNBJ]]</span><br></pre></td></tr></table></figure><p>好，這邊 area 跟 group 的差別就很明顯了，對於 Obsidian 來說 <code>area</code> 是類似直接對視窗截圖 (說法不是到很精確)，而 group 只計算被群組的範圍，只要不包含都不會被算在內。</p><p>具體來說從 markdown 文件來看，group 的一起的文字與圖案，在 <code>json</code> 上的 <code>groupIds</code> 都會被標上一樣的 id，以辨識他們是渲染圖層上的同一組。</p><p>area 在 markdown 上可以看做找該區塊的 section heading 視為範圍，至於怎麼計算，應該是文字區塊的 <code>width x height</code> 加上 padding 範圍內的都截圖進去。</p><p>padding 的部分只支援 SVG ，可以在該 Excalidraw   的 markdown 文件加上  <code>excalidraw-export-svgpadding</code> 的 metadata，會覆寫預設設定，預設是 10。</p><h2 id="SVG-v-s-PNG">SVG v.s PNG</h2><p>在 group 與 area 不同的圖片格式會有不同的表現。<br><img data-src="https://i.imgur.com/1qYAhUj.png" alt="來源自影片的 1:57 "></p><p>上面的範例都只有用 SVG 解釋，但其實可以匯出 PNG，只要在設定把預設匯出 SVG 的按鈕關掉就可以了。<br><img data-src="https://i.imgur.com/N5auj8H.png" alt="SVG 預設匯出設定"></p><p>根據圖表 text 無論對非文字的取文字是都不行的。但此時如果用 <code>area</code> 去針對橘色區塊截圖，會發現截到 <em>整個畫版</em> 的圖，更簡單來說 <code>area</code> 辨別不出哪裡是個別區塊，只好整張截了。</p><p>可以說 PNG 把 markdown 文字標註的 id  <code>(^ids)</code> 忽略了，PNG 不認識字，只認 <strong>物件</strong>，此時對 area 來說整張圖就是一個物件。而 group 還是能截到正確區塊的原因，因為它是透過 json 的 id (別忘了 json 也是一種物件)，所以不會被影響。</p><h2 id="圖片原始尺寸">圖片原始尺寸</h2><p>影片最後作者提到應用 Excalidraw 插件 ─ <code>Set Dimensions</code> ，校正圖片正確的圖片尺寸，使黏貼在上面的元素能完好符合圖片本身。插件的功能是重新計算區塊大小，讓文字符合其比例。</p><p>以 威力在哪裡 為例😄，透過 <code>Set Dimensions</code> 把原始圖片尺寸復原回去，新增的元素就能以比較正確的比例出現。<br><img data-src="https://i.imgur.com/krH1Hcy.png" alt="圖源自網路"><br>會覺得好像沒什麼差別，但我在打字時小圖片的藍色圖塊會被撐大，因為預設文字的比例關係，無法壓縮在壓縮。而原始圖片就沒這問題，在大圖上進行註解不用一直微調其他元素的尺寸。</p><h2 id="注意-貼上的圖片-連結圖片的-group">注意 : 貼上的圖片 + 連結圖片的 group</h2><p>當我用截圖複製進來的圖片，再用 Excalidraw 的 <code>group</code> 連結圖片，會出現的是截圖的圖片本身，而不是實際上 Excalidraw group 上的區塊。這時候要用 area 先把圖片區塊匯進去再手動改成 group ，才不會被判定成是截圖的單張圖片。</p><p>我出問題的步驟 :</p><ol><li>用 window 內建截圖並且複製圖片到 Excalidraw  貼上</li><li>含所有的內容一起群組</li><li>用 <code>group</code> 連結的方式貼上</li><li>😵 跳出截圖本身的本地文件連結，然後按 back 還回不去</li></ol><p>先改用 area 再改 group<br><img data-src="https://i.imgur.com/x83ulO7.png" alt="area 的範圍會被削到"></p><p>我在想是不是一張外部載入的圖片應該也是算一個 id ，所以再辨識時 id 應該是被貼到圖片上，而不是我圈起來的 group。至於 area 則是以區塊來截取，包含圖片與其他文字元素，當範圍確立之後，換成定義的 group 就能更精確的定到… 🤔。</p><h2 id="總結-15">總結</h2><p>圖片截圖有 3 種 :</p><ol><li><code>text</code> : 純文字截圖，但不能對非文字截。快捷 : 直接按下按鈕。</li><li><code>area</code> : 鄰近區塊截圖，只要看到的都截。快捷 :  <kbd>shift</kbd> + 按鈕。</li><li><code>group</code> :  只有被群組 (group) 的才截。 快捷 : <kbd>ctrl</kbd> + 按鈕</li></ol><p>Excalidraw Plugin 有更多好用的技巧與小工具，我之前都只是為了製造圖片並且匯出 SVG 來附在 markdown 上，直到我看了這部影片，才了解到這 Plugin 的強大。</p><p>圖片一直以來是 Obsidian 的硬傷，這麼說是因為無法 <strong>好好用文字來管理圖像</strong>，我們只能把他附加於某個資料夾底下，並且嵌入使用，沒用到的圖片就會放著長灰，也不能對圖片進行其他附加屬性。但 Excalidraw  使圖片具有可被標記的 tag 與 aliases 的方式，跟引入其他的 markdown 筆記段落一樣，更加彈性，重點是可以用搜尋以及 tag 來管理，另外也可以把一整個相關的筆記圖片都放在同一個檔案，變得非常方便。</p><p>不過這樣的便利只能留在 Obsidian 本身，像是我如果要搬運到 hexo 上發布， wikilinks 是無法被辨識的，圖片的效果也只能另外匯出來處理😵，只好期許有批量匯出圖片的插件誕生。</p><p>另外這部也是來自 Excalidraw-Plugin 作者的影片，他對視覺化的筆記方式有很多想法，甚至可以說是狂熱🤓 的地步，他的頻道與部落格上有很多 PKM 的技巧與再思考。近期我也很好奇 PKM 以及 GTD 這類的東西，YT 上都被推薦類似影片，未來會再來研究研究。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;影片連結 : &lt;a href=&quot;https://www.youtube.com/watch?v=yZQoJg2RCKI&quot;&gt;Block reference parts of images just like text with Obsidian Excalidraw - YouTube&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要-3&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;解決我怎麼在同一個大張 Excalidraw 把不同的圖片匯出到 markdown 上。一開始我都是靠多個檔案連結，因為我以為只能 1 個檔案全部匯出成 PNG 或者 SVG ，才能在其他 markdown 匯入，但其實是可以 &lt;strong&gt;直接取需要的區塊&lt;/strong&gt; 就好，把 Excalidraw 畫板對待成一般的 markdown 文件，把圖像可標記、可連結，是 markdown 文件的加強版工具。&lt;/p&gt;</summary>
    
    
    
    <category term="Obsidian" scheme="https://blog.rosa.tw/categories/Obsidian/"/>
    
    
    <category term="Obsidian" scheme="https://blog.rosa.tw/tags/Obsidian/"/>
    
    <category term="Obsidian-Plugin-Excalidraw" scheme="https://blog.rosa.tw/tags/Obsidian-Plugin-Excalidraw/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | React - ref 與 callback ref</title>
    <link href="https://blog.rosa.tw/2022/08/React/ref-and-callback-ref"/>
    <id>https://blog.rosa.tw/2022/08/React/ref-and-callback-ref</id>
    <published>2022-08-24T02:43:24.000Z</published>
    <updated>2022-08-24T03:00:27.210Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章來自 :</p><ol><li><a href="https://zh-hant.reactjs.org/docs/refs-and-the-dom.html">Refs 和 DOM – React</a></li><li><a href="https://medium.com/hannah-lin/react-hook-%E7%AD%86%E8%A8%98-useref-c628cbf0d7fb">React Hook 筆記 useRef. useRef 神奇的地方除了可以在不 re-render… </a></li><li><a href="https://www.linkedin.com/pulse/imperative-vs-declarative-programming-javascript-yehuda-margolis">Imperative vs Declarative Programming in JavaScript</a></li></ol></blockquote><h2 id="摘要-8">摘要</h2><ol><li>什麼是 ref ?</li><li>ref 使用的時機</li><li>ref 的另一種型態 callback ref</li></ol><span id="more"></span><h2 id="什麼是-ref">什麼是 ref ?</h2><p>ref 提供 React 資料流以外的操作方式，讓我們可以改變 React Component 的 instance (實例)，或者它來來操作 DOM 元素。</p><p>ref 可看作是一個普通的 JavaScript 物件，內部具有 current 的屬性的東西，可以直接 (mutable) 改變它。 React 保證它在生命週期 (render) 循環中永遠都指向同一個位址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = &#123;current : ... &#125;;</span><br></pre></td></tr></table></figure><h2 id="不過度使用-ref">不過度使用 ref</h2><p>使用 ref 的第一直覺上，我們可能會想說 ref <strong>要在哪裡發生</strong> ( 像是 state 會放到需要用到的元件內)，ref 不單單是拿來存放不會影響 re-render 的值，不應該被過度使用操作有關 React 資料流的部分。這時候應該使用 state，並且考慮 <strong>哪個 component 應該擁有狀態</strong>，如果是要共同擁有的 state 要做的是 <em>提升 state</em>。</p><h2 id="使用-ref-的時機">使用 ref 的時機</h2><ol><li>focus、選擇文字或影音媒體播放等等</li><li>觸發即時的動畫</li><li>與第三方 DOM 函式整合</li></ol><blockquote><p>如果操作可以用宣告式 (declarative) 操作，避免使用 ref</p></blockquote><p>例如 : 對話視窗我們可以不用暴露 <code>open()</code> 或 <code>close()</code> 方法 ，而是使用 <code>isOpen</code> 作為 props 來操作。 我們不用告訴某元件要怎麼做 (HOW) ，而告訴其結果 (WHAT) 就好。</p><h2 id="補充-Declarative-v-s-Imperative-in-JavaScript">補充 : Declarative v.s Imperative in JavaScript</h2><h3 id="Declarative-宣告式">Declarative 宣告式</h3><p>著重於 WHAT (想要拿到的結果是什麼)，比較抽象的流程，多使用表達式 (expression)，特色是單純運算且具有回傳值。像是 functional programming。</p><p><strong>特色 :</strong></p><ul><li>Stateless : 專注內部算式，並不會直接改變原本傳入的值，單純輸入與輸出。</li><li>無副作用 (side effect)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函式表達相乘</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiple</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr.<span class="property">length</span>===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="comment">// 回傳相乘後的結果，其 state 又被塞進內部回傳新的結果</span></span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x*<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiple</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p>將其 function 名稱代表回傳的意義會使程式碼比較了解，也可以說 <strong>定義 OO 是什麼</strong>。</p><h3 id="Imperative-命令式">Imperative 命令式</h3><p>著重於 HOW (目標到底要怎麼做)，具體表示應該怎麼做來達到目標，一步步按照步驟，常使用 statement 流程控制 (if , while , for , switch) 等。像是 OOP。</p><p><strong>特色 :</strong></p><ul><li>Stateful :  state 是互相有關連性的。</li><li>常會有副作用 side effect 發生</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">multiple</span> = array =&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(array.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;array.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    result.<span class="title function_">push</span>(array[i]*<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiple</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure><h3 id="小結-8">小結</h3><p>從例子來看，兩種方式都能達到結果，在 Imperative 中可以很清楚看見 state 是 “如何變化” 的，經過一步步的流程控制得出結果；在 Declarative 中資料的變化都被藏到內部另一個函式中 (邏輯被抽象化)，我們看到的是 “結果”。</p><p>JavaScript 使我們可以用兩種方式來實作，其各有優缺 :<br><strong>Imperative :</strong></p><ul><li>優點 :<ol><li>語法對於開發人員比較好掌握。</li><li>在流程控制上都是在同一個區塊操作，包含停止或暫停 loop 都可以根據想要的操作。</li><li>在某些情況下，效能會比較好。</li></ol></li><li>缺點 :<ol><li>程式碼通常較冗長，原因是邏輯都寫在同一塊</li><li>比較難以閱讀</li></ol></li></ul><p><strong>Declarative :</strong></p><ul><li>優點 :<ol><li>程式碼通常都很短，而且整潔、易讀</li><li>很適合用在 JavaScript 一些框架上，像是 React 與狀態管理的 redux</li></ol></li><li>缺點 :<ol><li>運行的比較慢一點，但在小型的應用程式不是太明顯。</li></ol></li></ul><h2 id="建立-ref">建立 ref</h2><p>在 class component 可以在建立 (constructor)  時新建 ref，可以是代表屬於某個 instance 的屬性，或者透過屬性 (attribute) 依附在 React element，在整個 component 裡面被參考。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="comment">// 1. 用 createRef() 建立</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 2. 使其用 attr 依附在 node 上，透過 this.myRef 就可以操作 DOM 元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 function component 用 Hooks 可以直接在內部建立 ref</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = <span class="title function_">useRef</span>(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// ref = &#123; current : 0&#125;</span></span><br></pre></td></tr></table></figure><p><code>useRef</code> 比一般的 ref 更有用，它可以很方便地持有任何 mutable 的值 (<code>useRef</code> 可以是任何的值)，跟 class 中的 instance field 類似。</p><p>除非做延遲初始化<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，避免在 render 時設定 ref ，造成非預期的行為，所以我們應該 <strong>在 event handler 和 effect 中修改 ref</strong>。</p><h2 id="存取-ref">存取 ref</h2><p>Ref 的值會根據節點的類型而有所不同：</p><ol><li>建立的 ref 用在 html 元素上的屬性，等同於取得 DOM 元素本身作為 current 屬性。</li><li>客製化的 class component 使用 ref 時，ref 等同於此 component mount 之後的實例(instance) 當作 current。 (簡單來說 ref 可以直接傳給 class component 中的子元件，但 functional component 不行)</li><li>不能在 functional component 上使用 ref，因為他們沒有實例 (instance)。</li></ol><h3 id="在-DOM-Element-加上-Ref">在 DOM Element 加上 Ref</h3><p>在 DOM Element 加上 ref，利用 ref 來儲存對於 DOM 節點的參考：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomTextInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="comment">// 產生一個可以儲存 textInput DOM element 的 ref</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">focusTextInput</span> = <span class="variable language_">this</span>.<span class="property">focusTextInput</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// focus 方法，直接對 DOM 元素操作</span></span><br><span class="line">  <span class="title function_">focusTextInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span>.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &#123;/* <span class="attr">在</span> <span class="attr">mount</span> <span class="attr">的時候將</span> <span class="attr">DOM</span> <span class="attr">element</span> <span class="attr">賦值到</span> <span class="attr">current</span> <span class="attr">屬性</span>*/&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&#123;this.textInput&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&quot;Focus the text input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onClick</span>=<span class="string">&#123;this.focusTextInput&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 會在 component mount 的時候將 DOM element 賦值到 current 屬性，並在 unmount 時將它清空回 null 。 ref 的更新發生在生命週期 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 之前。</p><h3 id="在-Class-Component-加上-Ref">在 Class Component 加上 Ref</h3><p>如果我們想在父元件 mount 之後，自動做 <code>focus</code> 這件事，可以透過父元件的 ref 拿到 <code>textInput</code> 實例本身 (也可以直接使用內部的方法)，並在 <code>componentDidMount</code> 呼叫。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoFocusTextInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在元件 mount 之後自動做這件事 </span></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// focusTextInput() 是來自 CustomTextInput 本身 </span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span>.<span class="property">current</span>.<span class="title function_">focusTextInput</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">CustomTextInput</span> <span class="attr">ref</span>=<span class="string">&#123;this.textInput&#125;</span> /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意這 <strong>只適用於利用 class 來宣告</strong> <code>CustomTextInput</code> 的情形：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomTextInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ref-和-Function-Component">Ref 和 Function Component</h3><p>不能用 function component 使用 ref ，因為本身沒有 instance ，不能像 class component 直接將 ref 傳給 child component。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 沒有這東西 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Input</span>(<span class="params">&#123;ref&#125;</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* ❌不行， Input 沒有 instance，不能接收 ref */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要不就在 child component 直接使用 <code>useRef</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Input</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// ✅ 這樣可以</span></span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在父元件真的想將 ref 交遞給其他 function component ，React 會建議使用 <strong>傳送 ref</strong> (<code>forwardRef</code>) 的方式，<strong>傳送 Ref 使得 component 能夠選擇要不要把 child component 的 ref 當作自己的 ref</strong> 。不過這樣的方法不太建議，因為會破壞 component 的封裝。但有時候觸發 focus 或測量 child 的 DOM 節點的大小、位置是很有用的。</p><h2 id="實務上的-ref">實務上的 ref</h2><ol><li>計算 render 次數 (少)</li><li><strong>用 Imperatively 方法改變 DOM 跟 Child Component (最常)</strong></li><li>想抓 Previous 的值 (少)</li></ol><h3 id="計算-render-次數">計算 render 次數</h3><p>如果用 state 來計算，這個例子會導致無窮迴圈， <code>setState</code> 導致 re-render ，做 <code>setRenderCount</code> 又一而再地觸發，沒完沒了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [renderCount,setRenderCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次 render 就 ++</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">setRenderCount</span>(<span class="function"><span class="params">r</span> =&gt;</span> r+<span class="number">1</span>) </span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;count&#125;</span></span><br><span class="line"><span class="language-xml">      render : &#123;renderCount&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這時候很適合使用 <code>useRef</code> ，因為它不會觸發 re-render。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [count,setCount] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> countRef = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次 render 就 ++</span></span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    countRef.<span class="property">current</span> +=<span class="number">1</span> </span><br><span class="line">  &#125;,[count])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;count&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setCount(count+1)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      render : &#123;countRef.current&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用-Imperatively-方法改變-DOM-跟-Child-Component">用 Imperatively 方法改變 DOM 跟 Child Component</h3><p>Imperative 的意思在 <a href="https://blog.rosa.tw/2022/08/React/ref-and-callback-ref#%E8%A3%9C%E5%85%85-Declarative-v-s-Imperative-in-JavaScript">補充 Declarative v s Imperative in JavaScript</a> 章節解釋過。如果使用<br>state 的思路來看，會利用 focus state 來控制元件的狀態，基於好奇，我也就實作了 state 版本。</p><h4 id="實作-使用-state-來控制-autofocus">實作 : 使用 state 來控制 autofocus</h4><p>利用 key 的特性，讓 React 換掉節點，為什麼用 key 後面會解釋</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [autoFocus, setAutoFocus] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">key</span>=<span class="string">&#123;Number(autoFocus)&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autoFocus</span>=<span class="string">&#123;autoFocus&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setAutoFocus((f) =&gt; !f)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        關注</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 render 之後自動 Focus 也可以使用 <code>useEffect</code> 再多做一次的 render</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">setAutoFocus</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><p>還記得 key 是拿來判斷 DOM 節點是否替換的一種指標嗎 ? 我們最常使用在 array 上，但其實也可以單獨拿出來使用，尤其對於大區塊的更動。</p><p>這部分時原本採取這樣的寫法，結果發現雖然 state 有改變，但是 <code>input</code> 沒有被 focus :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> autoFocus=&#123;autoFocus&#125; /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setAutoFocus((f) =&gt; !f)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">  關注</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>阿 ! 結果忘了 React 怎麼去渲染這件基本的事，記得嗎😵它會做淺比較，既然 input 節點沒有改變，它只會修改屬性。在來說說 <code>autofocus</code> ，它的觸發點是在 DOM 節點被放在上面之後才會做 <code>focus()</code>，那上面這段我們確實可以把 <code>autoFoucs</code> 透過 state 變化添加上去，但是 input 本身是沒有重新建立這件事，因為 React 淺比較自動幫我們做渲染上的優化，所以我透過 key 幫直接重新產生 input 。</p><p>原本是透過替換不同的 html tag，實作 <code>autoFocus</code> 成功，但這不是正確的答案，又突然想到 key 的作用，結果就出來了。</p><h4 id="使用-ref">使用 ref</h4><p>回到 ref ，建立 ref 綁在 DOM element 上，使我們可以直接操作 DOM，比上面的簡單多了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    inputRef.<span class="property">current</span>.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;,[])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣的方式在表單很常使用，在 React 中分成 controlled component 和 uncontrolled component， 前者依賴 state 來操作，後者是透過 ref 直接讀取 DOM。</p><blockquote><p>ref 並不會出現在 <code>devtool</code> 的檢查視窗上，實際看到的只會是  <code>&lt;input type=&quot;text&quot;/&gt;</code></p></blockquote><h3 id="抓-Previous-的值">抓 Previous 的值</h3><p>function component 因為 closure 的關係，只會記住當次 render 的 state 或 props 甚至是任何東西，我們沒辦法拿到上一次 render 的值。而透過 ref  來建立不會隨 render 而改變的盒子，讓我們可以在下一次 effect 呼叫之前先記住上一次的值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [value,setValue] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">const</span> prevValue =<span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    prevValue.<span class="property">current</span> = value</span><br><span class="line">  &#125;,[value])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span>=&gt;</span> setValue(e.target.value)&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>previous: &#123;prevValue.current&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>實際跟著跑一次 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次 render</span></span><br><span class="line">  value = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">// JSX(UI顯示)</span></span><br><span class="line">  input value =<span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">previous</span>:</span><br><span class="line"><span class="comment">// effect 執行</span></span><br><span class="line">  prevValue.<span class="property">current</span> = value = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用者輸入 &quot;1&quot; re-render</span></span><br><span class="line">  value = <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="comment">// JSX(UI顯示)</span></span><br><span class="line">  input value =<span class="string">&quot;1&quot;</span></span><br><span class="line">  <span class="attr">previous</span>:</span><br><span class="line"><span class="comment">// effect 執行，但是改變 ref 並不會造成 re-render，此時沒有更新停留在 previous:</span></span><br><span class="line">  prevValue.<span class="property">current</span> = value = <span class="string">&quot;1&quot;</span> </span><br></pre></td></tr></table></figure><p>實際上 <code>prevValue.current</code> 等於 <code>value</code>，但是 render 是停留在第二次，並沒有刷新 UI，因此在畫面上看起來 <code>prevValue</code> 停留在前一次的 render，使我們可以拿到 previous 值。<br><img data-src="https://i.imgur.com/H2K46gT.png" alt="300x180"></p><h2 id="callback-ref">callback ref</h2><p>ref 還有另一種形式，不是將 <code>createRef()</code> 所產生的 ref 傳遞下去，而是把一個 function 往下傳 (function 也是一種 Object)。 function 會將 React component 的實例 (instance) 或 HTML DOM 作為它的參數，儲存之後在別的地方使用。</p><ul><li>class component</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomTextInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="comment">// 1. 儲存 callback ref 取得的 node 或 instance 的空間</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 2. 參數是 html DOM 或是 component 實例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setTextInputRef</span> = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">textInput</span> = element;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">focusTextInput</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 利用原生的 DOM API 來 focus 文字輸入</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">textInput</span>) <span class="variable language_">this</span>.<span class="property">textInput</span>.<span class="title function_">focus</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在 mount 的時候自動 focus 輸入</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">focusTextInput</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &#123;/* <span class="attr">ref</span> <span class="attr">儲存參考</span> */&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&#123;this.setTextInputRef&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&quot;Focus the text input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onClick</span>=<span class="string">&#123;this.focusTextInput&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 會在 component render 時用 DOM element 呼叫 ref callback，然後在 unmount 時用 null 呼叫它。</p><blockquote><p>Ref 被保證在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 觸發時能夠維持在最新的狀態。</p></blockquote><h3 id="有-ref-effect-為什麼還需要-callback-ref">有 ref + effect 為什麼還需要 callback ref</h3><p>ref 建立/更新的時間點是在 render 階段，且在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 觸發時能夠維持在最新的狀態 (在裡面獲取 state 是最新的)，換成 Hooks 是 <code>setState</code> 當下能拿到最新值，並且在 effect 執行之前發生。這避免在還沒獲取到 DOM 元素之前拿到 null 來操作。以往我們直接在 html tag 加上 ref 在 effect 操作 ref 時就已經拿到 <code>ref.current</code> 存取的 DOM 元素本身。</p><p>到這裡好像都沒問題，但如果是 <strong>子元件的條件式渲染</strong> 呢 ? 在子元件巢狀結構中，父元件並不知道子元件的巢狀元件是否存在 (或是存在於第一次 render )，導致 render 之後在父元件的 ref 不知道有沒有抓到就執行 effect，而導致錯誤。</p><blockquote><p>範例來自 : <a href="https://tkdodo.eu/blog/avoiding-use-effect-with-callback-refs#focus-with-an-effect">Avoiding useEffect with callback refs | TkDodo’s blog</a></p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 🚨 ref.current 永遠是 null，這行會報錯 </span></span><br><span class="line">    ref.<span class="property">current</span>?.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;, [])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Form</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [show, setShow] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(true)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        show</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      /* </span></span><br><span class="line"><span class="language-xml">      ref 附加在 input 上。</span></span><br><span class="line"><span class="language-xml">      但這是條件是渲染，ref.current 在 show = false 並沒有抓到 input DOM</span></span><br><span class="line"><span class="language-xml">      */</span></span><br><span class="line"><span class="language-xml">      &#123;show &amp;&amp; <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我後來在想這個例子好不好🤔，其實提升 state 就可以解決問題了。但想一想我搞錯了😵，目的是 <strong>Form 本身去判斷 input 出現就 autofocus</strong>，應該把功能跟 Form 綁在一起，並非透過外部的元件來控制，這樣會使 APP 跟著 re-render ，是不必要的，所以應該是 Form 元件本身 state 改變， input 執行 <code>onfocus</code>。</p><p>補 : 後來我又想了想，應該是指 ref 傳下去不知道是不是有抓到該值，由於 ref 是可以直接改變的，如果在 render 期間改變，會造成結果不同🤔。</p><p>第二次嘗試，直覺上我們會在 Form 元件用 state 透過 effect 來操作，這也是可以的 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// ❌ 不需要 effect 了</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Form</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [show, setShow] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用 effect 來補這個問題</span></span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(show)&#123;</span><br><span class="line">      ref.<span class="property">current</span>?.<span class="title function_">focus</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,[show]) <span class="comment">// 當按下按鈕就顯示，執行 focus</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(true)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        show</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;show &amp;&amp; <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>恩…雖然這可以解決問題，但 effect 其實不必這樣檢查 show ，何況 button 只觸發一次的 <code>setShow</code>🤔，難道不能讓它產生的時候自己  focus 嗎 ? 當 input <code>mount</code> 就自己 focus 。</p><p>另一個著手點就是把 <code>autoFocus</code> 裝上去， input 做 <code>mount</code> 又 <code>unmout</code> 對 React 來說都是新的節點誕生 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;show &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">autoFocus</span>/&gt;</span></span>&#125;</span><br></pre></td></tr></table></figure><p>不過衍生問題就在 <a href="https://blog.rosa.tw/2022/08/React/ref-and-callback-ref#%E8%A3%9C%E5%85%85-Declarative-v-s-Imperative-in-JavaScript">實作 使用 state 來控制 autofocus</a><br>的部分有討論過，如果在 input 是 “已出現” 的狀況下透過按鈕來控制 <code>autoFocus</code> ，由於 React 的淺比較優化導致元件僅修改屬性，而  <code>autoFocus</code> 只會在元件 mount 執行。</p><p>最後一個解決的問題就是靠 <strong>callback ref</strong> 自己去判斷 Element node 是否存在去執行邏輯 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Form</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Form</span> = (<span class="params">props</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> [show, setShow] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(true)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        show</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;show &amp;&amp; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          // <span class="attr">ref</span> <span class="attr">接收的是一個</span> <span class="attr">function</span>，<span class="attr">參數會是</span> <span class="attr">DOM</span> <span class="attr">節點本身</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&#123;(node)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            if (node) &#123;</span></span><br><span class="line"><span class="language-xml">              node.focus();</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>檢查 node 是否存在再呼叫，因為 ref 是在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 拿到最新值，簡單來說就是 render 階段執行，在我們 <code>setShow</code> 改變 show 為 true 進到 render 階段，如果沒有加上判斷，會導致 <code>unmout</code> 時執行錯誤。</p><p>如果我們不判斷 node 是否存在，執行順序上是這樣 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次 render</span></span><br><span class="line"><span class="keyword">const</span> show = <span class="literal">false</span></span><br><span class="line">input callback ref 不會執行</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用者按下按鈕觸發 setShow re-render</span></span><br><span class="line"><span class="keyword">const</span> show = <span class="literal">true</span></span><br><span class="line"><span class="comment">// input ref function 執行， function(node) 參數是該 DOM 元素</span></span><br><span class="line">node.<span class="title function_">focus</span>() <span class="comment">// ✅ 執行成功，node 不是 null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再按一次按鈕 setShow re-render </span></span><br><span class="line"><span class="keyword">const</span> show = <span class="literal">false</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  input unmout，ref function 執行，ref 回到 null 代表節點消失，元素消失了 node = null </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">node.<span class="title function_">focus</span>() <span class="comment">//😵 執行失敗</span></span><br></pre></td></tr></table></figure><p>callback ref 會在 component  <code>mount</code> 跟 <code>unmout</code> 都各執行一次，但 <code>unmount</code> 那次就不會抓到參數本身，因為 ref 回傳的是 null。</p><p>寫成 inline 的方式就會使元件 re-render 也跟著重新建立 function，可以用 <code>useCallback</code> 把 function 記起來，避免不必要的 render :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Form</span> = (<span class="params">props</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> [show, setShow] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// 1. 建立 function</span></span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="function">(<span class="params">node</span>)=&gt;</span>&#123;</span><br><span class="line">    node?.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;,[])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(true)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        show</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;show &amp;&amp; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          // <span class="attr">2.</span> <span class="attr">填入</span> <span class="attr">function</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="callback-ref-的使用時機">callback ref 的使用時機</h2><ol><li>節點會消失又出現，需要動態的控制元件本身</li><li>測量 DOM 的位置、大小</li></ol><p>callback ref 提供動態的方式讓我們取得 DOM 節點，並且在 browser painting 之前可以做一些事。從上面 <code>autofocus</code> 可以讓元件建立又做 DOM 的 <code>focus()</code>。</p><h3 id="小實作">小實作</h3><p>Accordion 的內容會按照 <code>open</code> 開關影響高度，我們只要在 <code>open</code> 觸發 re-render 時，一併把樣式改變就可以輕鬆做到功能。<br>👉<a href="https://codepen.io/shan473/pen/MWVxzPX">Collapsibles/Accordion React callback ref</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Accordion</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 開關控制</span></span><br><span class="line">  <span class="keyword">const</span> [open,setOpen] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="comment">// 2. callback ref node 存在且 open = true</span></span><br><span class="line">  <span class="keyword">const</span> panelRef = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="function">(<span class="params">node</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(node &amp;&amp; open)&#123;</span><br><span class="line">        node.<span class="property">style</span>.<span class="property">maxHeight</span> =node.<span class="property">scrollHeight</span> +<span class="string">&#x27;px&#x27;</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node &amp;&amp; !open)&#123;</span><br><span class="line">        node.<span class="property">style</span>.<span class="property">maxHeight</span> =<span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,[open])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;accordion&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setOpen(open =&gt; !open)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Section</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">className</span>=<span class="string">&quot;panel&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">ref</span>=<span class="string">&#123;panelRef&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do</span></span><br><span class="line"><span class="language-xml">          eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad</span></span><br><span class="line"><span class="language-xml">          minim veniam, quis nostrud exercitation ullamco laboris nisi ut</span></span><br><span class="line"><span class="language-xml">          aliquip ex ea commodo consequat.</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>當然這樣的方式也可以使用 <code>useRef</code> 搭配 <code>useEffect</code> 來實作 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> panelRef = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"> panelRef.<span class="property">current</span>.<span class="property">style</span>.<span class="property">maxHeight</span>= open ? panelRef.<span class="property">current</span>.<span class="property">scrollHeight</span> +<span class="string">&#x27;px&#x27;</span> : <span class="number">0</span></span><br><span class="line">&#125;,[open])</span><br></pre></td></tr></table></figure><p>目前還想不到實際上的差異，但論時間點來說，useEffect 會在 render 之後才執行，很可能畫面會造成一瞬間的閃爍，這時候我們可能會用 <code>useLayoutEffect</code> 來處理，在 painting 之前就執行結束，像是樣式的更新，這不會讓使用者看到畫面突然閃一下變化。</p><p>通常 ref + <code>useEffect</code> 都可以做到 callback ref 做到的事。但  <code>useEffect</code> 具有 clean up function，假如元件具有監聽事件且 <code>unmount</code> 時，需要做清除的動作 (clean up function)，effect 使時我們拿到的 <code>ref.current</code> 依舊是上一次 render ，對 <code>ref.current</code> 取消監聽事件是可以的，但是 callback ref 在 unmount 時會把 node 回歸到 null，不能對 null 取消監聽事件。</p><h3 id="注意-3">注意</h3><p>如果 callback ref  是被 inline function 所定義的，會在更新的時候被呼叫兩次。render 一次，mount 一次。第一次用 null 然後再用 DOM element 呼叫一次。這是因為新的 function 的 instance 是在每次 render 的時候被產生，所以 React 需要將舊的 ref 清掉然後設定新的。</p><p>可以定義 callback ref 為 class 上的一個 bound method (<code>method.bind</code>) 來避免這種情形，但在大多情況下他並沒有任何影響。</p><blockquote><p>簡單來說 function 不要隨 render 每次都產生新的，將其給記住。</p></blockquote><h2 id="ref-、-effect-與-layouteffect">ref 、 effect 與 layouteffect</h2><p>👉 <a href="https://codepen.io/shan473/pen/BarbEWJ?editors=0011">Box moving / multiple ref test with show null</a> 我試做 <code>ref + useEffect</code> 、 <code>ref + uselayoutEffect</code>  ，來看看這三者的時間點。</p><p>根據範例印出 <code>render</code> 、<code>mount</code>  以及 <code>unmout</code> 時間 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render</span></span><br><span class="line">callback ref call <span class="literal">undefined</span> (不管有沒有 node)</span><br><span class="line">callback ref call <span class="literal">null</span> node <span class="literal">undefined</span></span><br><span class="line">callback ref render <span class="literal">undefined</span></span><br><span class="line">render effect <span class="literal">null</span></span><br><span class="line">render layout <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mount </span></span><br><span class="line">callback ref call (不管有沒有 node)</span><br><span class="line">  &lt;div <span class="keyword">class</span>=​<span class="string">&quot;box one&quot;</span> style=​<span class="string">&quot;top:​ 100px;​&quot;</span>&gt;​callback ref​&lt;/div&gt;​</span><br><span class="line">callback ref call <span class="keyword">in</span> node </span><br><span class="line">  &lt;div <span class="keyword">class</span>=​<span class="string">&quot;box one&quot;</span> style=​<span class="string">&quot;top:​ 100px;​&quot;</span>&gt;​callback ref​&lt;/div&gt;​</span><br><span class="line"><span class="keyword">in</span> effect layout </span><br><span class="line">  &lt;div <span class="keyword">class</span>=​<span class="string">&quot;box three&quot;</span> style=​<span class="string">&quot;top:​ 100px;​&quot;</span>&gt;​layout effect​&lt;/div&gt;​</span><br><span class="line"><span class="keyword">in</span> effect </span><br><span class="line">  &lt;div <span class="keyword">class</span>=​<span class="string">&quot;box two&quot;</span> style=​<span class="string">&quot;top:​ 100px;​&quot;</span>&gt;​effect​&lt;/div&gt;​</span><br><span class="line"></span><br><span class="line"><span class="comment">// unmount</span></span><br><span class="line">callback ref call <span class="literal">null</span> (不管有沒有 node)</span><br><span class="line">callback ref call <span class="literal">null</span> node <span class="literal">null</span></span><br><span class="line">clean up layout </span><br><span class="line">  &lt;div <span class="keyword">class</span>=​<span class="string">&quot;box three&quot;</span> style=​<span class="string">&quot;top:​ 100px;​&quot;</span>&gt;​layout effect​&lt;/div&gt;​</span><br><span class="line">clean up effect <span class="literal">null</span></span><br></pre></td></tr></table></figure><ol><li>callback ref 在 render 時 call 再 mount 時又 call</li><li><code>layoutEffect</code> 在 unmount 時 ref 還沒消失🤔</li></ol><p>網路上已經有人把它製成表格，而且還有 updating 😄<br><img data-src="https://blog.thoughtspile.tech/images/react-ref-order-f455246e4b65dcd8bad4434384f2460e.png" alt="|400x180"></p><blockquote><p>圖源自 : <a href="https://blog.thoughtspile.tech/2021/05/17/everything-about-react-refs/">So you think you know everything about React refs</a></p></blockquote><p>effect 在 unmount 讀取 node 也會消失，但可以利用 closure 的特性，建立變數先將 node 給記住，在 <code>unmout</code> 呼叫 clean up function 時取消監聽事件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 刻意記住，因為 boxRef 是會變動的</span></span><br><span class="line">  <span class="keyword">const</span> keepRef = boxRef.<span class="property">current</span></span><br><span class="line">  boxRef.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, changeColor);</span><br><span class="line">  boxRef.<span class="property">current</span>.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&quot;100px&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// null , box two 本身</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(boxRef.<span class="property">current</span>,keepRef.<span class="property">current</span>)</span><br><span class="line">    keepRef.<span class="property">current</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;click&quot;</span>, changeColor);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>那 <code>layoutEffect</code> 可以直接在清除執行取消監聽嗎 ? 雖然 <code>ref.current</code> 依舊存在，但還是不安全的，最好是像 effect 一樣，利用 closure 的方式來取消監聽事件。</p><h2 id="callback-ref-的-clean-up-function">callback ref 的 clean up function</h2><blockquote><p>官方討論串 :  <a href="https://github.com/facebook/react/issues/15176">React callback ref cleanup function · Issue #15176 · facebook/react · GitHub</a></p></blockquote><p>在 React 18 釋出以前已經有探討 callback ref clean up 的問題，上面有提到當 callback ref 在 <code>unmount</code> 呼叫時是 null，因此註銷監聽事件是不容易的，因此有人提出一些解決方案，未來也可能出現新的 API 來解決此問題🤔，大概看完 RFC 目前應該是沒有打算建立新 API ，結尾都指出這樣的改變可能導致新舊會產生衝突。</p><p>不過這部分我還沒詳讀😵，先記錄起來，之後會再寫文章來研究研究🤔</p><ol><li>Dan 大有提到，useCallback 如果回傳 function ，等同於做出新的行為，就不會有呼叫到 null 得的問題，🤔。 <a href="https://github.com/reactjs/rfcs/pull/205">RFC: Callback Ref Cleanup by KurtGokhan · Pull Request #205</a></li><li>我覺得很玄的問題， 改變 ref 不 re-render ，但是這個需求卻要求 ref 要跟 state 做一樣的事🤔，不過最後也是提到 <code>return ()=&gt;&#123;&#125;</code> clean up function 。<a href="https://github.com/facebook/react/issues/21903">React 18 let’s make ref.currant to be reactive value · Issue #21903 </a></li><li>這一串討論 Custom Hooks 將 ref 外傳，然後 <code>useEffect</code> 的 deps 是放入 <code>ref.current</code> 這件事。聽起來有點反設計，因為 ref 不會觸發 re-render ，但是卻把它放在 deps 中監聽是否有改變再隨 re-render 重新呼叫🤔 <a href="https://github.com/facebook/react/issues/16154">Accessing state/props in callback ref with hooks · Issue #16154</a></li><li>根據第三點官方提出的解決辦法 : <a href="https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback">Hooks FAQ – How to read an often-changing value from useCallback?t</a></li></ol><p>以上都是處理邊際條件 (edge case) 的討論。</p><h2 id="總結-30">總結</h2><ol><li>ref 可以看做是一個普通 JavaScript 物件，帶有 <code>current</code> 屬性，React 確保改變它不會造成 re-render，也不會隨生命週期改變 。</li><li>不能使用 <code>useRef</code> 替代 <code>useState</code>。 <code>useRef</code> 不會觸發 re-render ，操作後不保證能同步 UI (資料改了但是 React 不會刷新畫面，參見 : <a href="https://blog.rosa.tw/2022/08/React/ref-and-callback-ref#%E8%A3%9C%E5%85%85-Declarative-v-s-Imperative-in-JavaScript">抓 Previous 的值</a>。</li><li>最好在 effect 或是 event handler 裡面更新 ref ，因為 ref 的建立與更新的時間點。</li><li>最常拿來直接操作 DOM 元素。</li><li>callback ref 常用來測量 DOM 的大小</li></ol><p>過程中差點忘記主要目的是認識 ref 的用途，一不小心挖太深🤓，同時也看到原來 callback ref 有這麼多可擴展的方式，我一開始不太能理解 callback ref 要怎麼使用 ，因為 <code>useEffect + ref</code> 都能解決大部分的問題，只是麻煩了點🤔。後續 ref 的部份會再寫一篇再深入 ref 的文章。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">延遲初始化是指初始值需要經過計算而來，我們只需要在 render 一次建立就好</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章來自 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://zh-hant.reactjs.org/docs/refs-and-the-dom.html&quot;&gt;Refs 和 DOM – React&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/hannah-lin/react-hook-%E7%AD%86%E8%A8%98-useref-c628cbf0d7fb&quot;&gt;React Hook 筆記 useRef. useRef 神奇的地方除了可以在不 re-render… &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.linkedin.com/pulse/imperative-vs-declarative-programming-javascript-yehuda-margolis&quot;&gt;Imperative vs Declarative Programming in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要-8&quot;&gt;摘要&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;什麼是 ref ?&lt;/li&gt;
&lt;li&gt;ref 使用的時機&lt;/li&gt;
&lt;li&gt;ref 的另一種型態 callback ref&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Front-end" scheme="https://blog.rosa.tw/categories/Front-end/"/>
    
    <category term="React" scheme="https://blog.rosa.tw/categories/Front-end/React/"/>
    
    
    <category term="React" scheme="https://blog.rosa.tw/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | React - 重新了解 useEffect</title>
    <link href="https://blog.rosa.tw/2022/08/React/react-useEffect-about-everythings"/>
    <id>https://blog.rosa.tw/2022/08/React/react-useEffect-about-everythings</id>
    <published>2022-08-14T03:27:57.000Z</published>
    <updated>2022-08-14T15:28:46.954Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章來自 : <a href="https://overreacted.io/zh-hant/a-complete-guide-to-useeffect/">useEffect 的完整指南 — Overreacted</a></p></blockquote><h2 id="摘要-9">摘要</h2><ol><li>useEffect 的基礎概念</li><li>useEffect dependencies array 的使用方式</li></ol><p>大部分都是來自原文的再翻譯，我有些比較不懂的部分就用自己的方式去解釋，也會用原始的 JS 實作的方式，跟著一步步編譯。</p><p>更重要的是，要用 React 的思維來去了解 <code>useEffect</code> 的內涵。</p><span id="more"></span><h2 id="React-的渲染機制">React 的渲染機制</h2><p>了解 useEffect 之前，先來了解 <code>setState</code> 的時候會發生什麼事。<br>當我們 <code>setState</code> 時，React 會重新呼叫 Component function，並更新其值，接著<br>React 把我們最新的值更新到 DOM 上。</p><p>而 <code>useEffect</code> 執行的時間點在 render 之後，為什麼 <code>useEffect</code> 會拿到舊的 state 跟 props ?</p><blockquote><p>每一次都渲染都保有自己的 state 跟 props</p></blockquote><p>我們試著把每次 render 拆開來</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useState </span></span><br><span class="line"><span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 1 次 render 是這樣</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">0</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第 2 次 render</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">1</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次 render 重新呼叫 <code>Counter()</code> ，把 count 每次重新賦值，每次 render state 都會是獨立的。</p><p>什麼意思呢？🤔 就是你在一周目看到的資料，既然你在一周目取資料，那也只會拿到一周目的資料。並不能直接取二、三周目的東西。</p><p><code>useEffect</code> 雖然是渲染後執行的，但他其實還是待在同一個時間線的渲染 (也就是同步的)，並不是真正意味上的「渲染 <strong>後</strong>」，別被文字搞混了。</p><h2 id="render-function-內的-function">render function 內的 function ?</h2><p>文中<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>範例順序是</p><ol><li>把 state 加到 3</li><li>按下 <code>alert</code> 按鍵 ( <code>setTimeout</code> for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span> seconds , and 顯示 state )</li><li>馬上把 state 加到 5，最後顯示是 ?</li></ol><blockquote><p>結果是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span> ，這裡是抓到 (capture) 按下按鈕的 <strong>當下</strong></p></blockquote><p>可以想像成聊天 app ，跟 A 聊天送出訊息，接著馬上切換跟 B 輸入訊息，確實是 A 收到訊息，並不是 B 收到。<br>在 class Component 跟 functional Component 兩種解決不同的問題 (閉包)</p><h3 id="function-內部所引用的-state-關係">function 內部所引用的 state 關係</h3><p>從最根本的 JavaScript 來看，例子是從文章來的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">person</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = person.<span class="property">name</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Hello, &#x27;</span> + name);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someone = &#123;<span class="attr">name</span>: <span class="string">&#x27;Dan&#x27;</span>&#125;;</span><br><span class="line"><span class="title function_">sayHi</span>(someone);</span><br><span class="line"></span><br><span class="line">someone = &#123;<span class="attr">name</span>: <span class="string">&#x27;Yuzhi&#x27;</span>&#125;;</span><br><span class="line"><span class="title function_">sayHi</span>(someone);</span><br><span class="line"></span><br><span class="line">someone = &#123;<span class="attr">name</span>: <span class="string">&#x27;Dominic&#x27;</span>&#125;;</span><br><span class="line"><span class="title function_">sayHi</span>(someone);</span><br></pre></td></tr></table></figure><p>可以看到 <code>person.name</code> 一開始是 ‘Dan’，但是每次 <code>sayHi</code> 都會經歷以下步驟 :</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第 1 次 </span></span><br><span class="line"><span class="keyword">name</span> = Dan </span><br><span class="line">setTimout 拿到的 <span class="keyword">name</span> 是外部的 <span class="keyword">name</span> = Dan</span><br><span class="line"><span class="comment">// 第 2 次</span></span><br><span class="line"><span class="keyword">name</span> = Yuzhi</span><br><span class="line">setTimout 拿到的 <span class="keyword">name</span> 是外部的 <span class="keyword">name</span> = Yuzhi</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>用 JavaScript 來說就是閉包 (closure) 的概念，Call Stack 到 <code>setTimeout()</code> 的時候，<code>sayHi</code> 裡面宣告的變數會被儲存下來，存在內部，並沒有被回收掉，因此 <code>setTimeout()</code>  當下拿到的值是 <strong>內部已經計算完且被記錄起來的值</strong>，才會是捕獲 (capture) 當時的值。</p><blockquote><p><code>setTimeout</code> 拿到的值會是當下執行完所記錄下的值，這也說明了為什麼 useEffect 會拿到舊的 state : <strong>當下的 <code>setTimeout()</code> 是拿閉包的值。</strong></p></blockquote><h3 id="回頭看-React-的-render-內部的-function">回頭看 React 的 render 內部的 function</h3><p>已經知道 <code>setTimeout</code> 會記錄下當次 render 的值，不管哪一次的 render ，它當次的 state 與 props 都會是一樣的。如果是不同次的 render ，它的 state 和 props 是獨立的，在事件 (event handler) 或事件內的非同步 (async/await) 事件也都是一樣的原則。</p><p>範例用 <code>inline function</code> 是安全的 (button 的 click 事件)，因為 state 的 count 不會每次都被變動 (意思應該是 <strong>產生新的記憶體空間</strong>，指跟 object type 的差別)，如果 state 是 object type 的類型，必須確保 object 是用 <strong>Immutable</strong> 的方式改變。</p><p>文中提到 <code>setState(newObj)</code> 是合理的，為什麼這麼說呢 ?<br>只要<strong>記住每次 render 都有自己的 state 或 props</strong> ，直接改改成 <code>newObj</code>是沒問的，對於前一次的 render 也是完整的值。<br>👉  <a href="https://codepen.io/shan473/pen/jOzeWEb?editors=0011">codepen 簡易範例，請看 useRef 變化</a></p><p>例如 : 結構類似，但是巢狀內部有部分改變</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假如原本的 state</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  a : &#123;</span><br><span class="line">    b : <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newState = &#123;</span><br><span class="line">  a : &#123;</span><br><span class="line">    b : <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ✅ 刷新整筆資料，這樣沒問題</span></span><br><span class="line"><span class="title function_">setState</span>(newState)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 直接對值內部些微調整，React 根本察覺不到，不會 re-render</span></span><br><span class="line"><span class="title function_">setState</span>(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">  prevState.<span class="property">a</span>.<span class="property">b</span> = newState.<span class="property">a</span>.<span class="property">b</span></span><br><span class="line">  <span class="keyword">return</span> prevState</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>當我們要觸發 <code>setState</code> 時，React 會先經過 state 的淺比較 (shallow comparison)，如果直接改變並不會 re-render。</p><h2 id="每一次-render-都它自己的-Effect">每一次 render 都它自己的 Effect</h2><p>React 會記住每個 <code>useEffect</code>，觸發的時間點是每次改變 DOM 之後與 browser 渲染完之後才會呼叫。</p><p>概念上來說，effect 是這次 render 後的結果 (render 後才執行的)，但 effect 其實也跟上面提及的 [[#回頭看 React 的 render 內部的 function]] 章節一樣的概念，其 state 跟 props 是都是屬於當次 render 的，effect 也是。</p><h2 id="每一次-render-保有它的所有東西">每一次 render 保有它的所有東西</h2><p>範例<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 。<br>已經知道 function 每一次的 render 會計下 <code>useEffect</code>，並且拿到內部 <code>local state</code> 的值。</p><p>跟著 <code>setTimeout</code> 跑一次 :</p><ul><li>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 次 render<ol><li>state 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></li><li>React 記下 effect : 3 秒之後 You clicked 0 times</li><li><code>Counter</code> 回傳提交 UI 給 React</li><li>React 跟 DOM 溝通並且瀏覽器渲染了畫面</li><li><code>useEffect</code> 這時候呼叫 React 所記下的 effect ，等到 3 秒之後 : 印出 You clicked 0 times</li></ol></li></ul><p>接著按下 button 觸發 <code>setCount</code> 讓 count + 1，React 重新呼叫 <code>Counter()</code> ，進行第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 次渲染</p><ul><li>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 次 render<ol><li>state 變成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></li><li>React 記下 effect : 3 秒之後 You clicked 1 times</li><li><code>Counter</code> 回傳提交 UI 給 React</li><li>React 跟 DOM 溝通並且瀏覽器渲染了畫面</li><li><code>useEffect</code> 這時候呼叫 React 所記下的 effect ，等到 3 秒之後 : 印出 You clicked 1 times</li></ol></li></ul><p>後面以此類推。<br>function component 是這樣操作，但是 class Component 在處理 effect 時卻不是這樣的。</p><h3 id="跟-class-Component-的差別">跟 class Component 的差別</h3><p>範例<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup><br>凡有關 effect 的操作會放在 <code>componentDidUpdate</code> 這裡，意思是  <strong>state 或 props 變更之後要做什麼事</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`You clicked <span class="subst">$&#123;<span class="variable language_">this</span>.state.count&#125;</span> times`</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡的 <code>this.state.count</code>  都會是現在的 count，也就是按到 5 <code>setTimeout</code> 抓到的都會是 5 ，而不是 <strong>當下</strong> 觸發的 count。</p><p>每一次 render 都是呼叫內部的 <code>render()</code> function ， state 永遠是指像實例的 state。</p><p>複習一下 class component 的 React 生命週期是</p><blockquote><ol><li><strong>Mouting</strong> : constructor 👉 render 👉 capture refs and DOM 👉DidMount</li><li><strong>Updating</strong> : render 👉 capture refs and DOM 👉DidUpdate</li></ol></blockquote><p>跟著 <code>setTimeout</code> 跑一次 :</p><ul><li>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 次 render <strong>(Mounting)</strong><ol><li><code>constructor</code> 初始化 ，state = 0</li><li><code>render</code> 觸發 Counter 內部的 render ，並提交 UI 給 React</li><li><code>capture refs and DOM</code> React 跟 DOM 溝通並且瀏覽器渲染了畫面</li><li><code>DidMount</code> 被呼叫，印出 : You clicked 0 times</li></ol></li></ul><p>接著按下 button 觸發讓 count + 1，React 重新呼叫 Counter 的 <code>render()</code> ，進行第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 次渲染</p><ul><li>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 次 render <strong>(Updating)</strong><ol><li>此時 state 的 count = 1，<code>setState</code> 等同於執行到 <code>Counter.state.count = 1</code> (注意 : 但開發者不能直接在元件內部這樣做，React 幫我們做 )</li><li><code>render</code> 觸發 Counter 內部的 render ，並提交 UI 給 React</li><li><code>capture refs and DOM</code> React 跟 DOM 溝通並且瀏覽器渲染了畫面</li><li>Counter 呼叫 <code>componentDidUpdate</code>，3 秒之後 Counter state 是 1，印出 You clicked 1 times</li></ol></li></ul><p>好，這邊看起來沒問題🤔。</p><blockquote><p>那麼不間斷按了 5 次，而且不等每次 <code>setTimeout</code> 的秒數跑完呢 ?</p></blockquote><p>等於 <code>Event Loop</code> 中的 Call Stack 還在排隊的情況，會一值重複 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span> 這個動作，但是到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">4</span></span></span></span> !!!</p><blockquote><p>Counter 呼叫  <code>componentDidUpdate</code>，3 秒之後此時的 State 是 ???</p></blockquote><p>這時候 main thread 上的 Call Stack 跑完，Event Loop 的 stack 開始執行，此時的 <code>Counter.state.count =  5</code>，執行時印出 <strong>You clicked 5 times</strong> 並且依序印出 5 次</p><p>要解決此問題很簡單，把當下的 <code>this.state.count</code> 取下來包給 <code>setTimeout</code> ，其實等同於 <strong>closure</strong> 的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>當非同步進入 <code>Event Loop</code> 跑去排隊的時候，這邊的 <strong>count 已經被記起來了</strong>，所以當 <code>setTimout</code> 到 Call Stack 的時候，就會是當次 render 的 count。</p><p>Closures 很好用，當我們把值關在內部，即使它脫離了 function ，下次再呼叫 function 時其值還是會被保留住不會改變。可以想成把它想成雷同 <code>const</code> 常數。</p><h2 id="如何拿取最新的-state">如何拿取最新的 state ?</h2><p>把握上面所提及的原則，<strong>每一次 component 執行 render function，包含 事件、effect 甚至 timeouts 或是其他 API 都會記住當次定義的 props 或 state。</strong></p><p>這兩個範例其實是一樣的 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">//📍 等到 render 之後才讀取 counter</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">counter</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 📍 一開始把 counter 存起來</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = props.<span class="property">counter</span>;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(counter);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不管是先還是後去讀取值，拿到的 state 是相同的<br><code>useEffect</code> 已經記住當時的 state<br>state 跟 props 是不會變的</p></blockquote><p>如果我們試圖在上一次的 render function 取得最新的 props 或 state，這樣是逆流而上 (文章這麼說的🤔)。</p><p>有時候我們會需要在 effect 中拿到最新的值，而不是當下 render 所記住的值，這並不是什麼錯誤的操作，但我們可以使用 refs 達成目的。</p><p>refs 不會促使 React re-render，因為 React 確保它是不會被改變的(指不會因 render 產生新的記憶體位址，每次都指向同一個實體)。也可以想成 React 幫我們建立一個全域的物件，我們都是對同一個物件進行直接操作。</p><blockquote><p>然而逆流而上是什麼意思呢 ? 🤔</p></blockquote><p>functional component 是利用閉包 (closure) 的概念，從 JS 的基礎概念來看，執行完 function 後由於裡面的變數還是存在於 function 內部 (沒有被回收)，但是存在內部的變數外部不能直接操作。</p><p>回到 <code>setState</code> 會觸發 re-render，重新呼叫 component function ，但在 effect 中仍是屬於上一次 render 的，當我們想在 effect 取得最新的資料來操作就像在外部對 closure 內部拿某變數，這是不行的，因為值被封裝在內部。除非我們像在外部先建立好一個全域變數，並且直接拿其值進行操作，沒錯，這就等同於 refs 的概念了😲</p><h2 id="使用-ref-來取得最新值">使用 ref 來取得最新值</h2><p>已經知道 [[#跟 class Component 的差別|class component 的行為]] 會拿到最新的值，而 function component 則不會，要怎麼用 function component 復刻 class 的行為呢 ?</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> latestCount = <span class="title function_">useRef</span>(count);</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拿到最新的 count</span></span><br><span class="line">  latestCount.<span class="property">current</span> = count;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 讀取最新的 count</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`You clicked <span class="subst">$&#123;latestCount.current&#125;</span> times`</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如此一來，連按 5 次，就會呈現最後通通印出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span></span></span></span> 的結果。<br><strong>ref</strong> 就像在外部建立一個盒子，寄放不會被改變的值</p><p>這樣的方式不能保證每次 function call 的那個期間，state 是正確的 (state 不屬於那個當下的時間點)。由於每次都被直接改變 (class component 做的事)，拿到的就會是最新的。<br>這也是為什麼 React 預設不是 ref 的操作，而是選擇性的。</p><p>這裡可以比較 functional component 跟 class  component 對於 render 意義的不同之處 :</p><ul><li>class component 將每次 render 分成不同階段來決定發生哪些事，也就是生命週期。在 A 階段變化到 B 階段的過程，資料也會隨時間發生變化。</li><li>functional component 則是把每次的 render 是獨立的來看，這次 render 只關注這次資料的變化，並且同步一切的東西。</li></ul><h2 id="談談-clean-up">談談 clean up</h2><blockquote><p>clean up 的是舊的 props 還是當下的 props ?</p></blockquote><p>先釐清 <code>clean up</code> 的執行時間，在畫面渲染之後，在下一個 effect 執行之前，會執行 clean up effect。<br><img data-src="https://raw.githubusercontent.com/donavon/hook-flow/master/hook-flow.png" alt="|400x500"></p><p>意思是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 2️⃣ 在 return 之後才會做</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 1️⃣ 這裡會先執行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>情境 : 有一個 state 從 10 改變成 20</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(props.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(props.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一開始可能會這麼想 :</p><ol><li>React 先清除 (clean up) 帶有 <code>id = 10</code> 的訂閱</li><li>state 更新至 20，React 提交 UI 給瀏覽器渲染</li><li>React effect 執行帶有 <code>id = 20</code> 的訂閱</li></ol><p>🤔這不是正確的，Why ?</p><p>回到 Flow 那張圖，可以知道 effect 執行的時間點是 <strong>瀏覽器將元素放上 DOM (browser painting)</strong> 之後，為什麼 React 要這麼設計 ? 🤔</p><blockquote><p>才不會阻攔螢幕的更新</p></blockquote><p>effect 很常處理 AJAX 取資料的事情， 如果取資料這件事不是安排到 effect 中處理，而是同步處理呢 ? 瀏覽器就必須等到資料回傳再去做 painting 的工作，如果回傳時間拉長，螢幕就會像被卡住、動彈不得。</p><p>React 才會把 effect 執行的時間點放在瀏覽器 painting 之後，以不阻擋螢幕更新率的情況下，提升 UI 體驗。而 <strong>Effect 的 clean up function 也會被延遲</strong>。</p><p>所以上面真正的情境順序</p><ol><li>state 更新至 20，React 提交 UI 給瀏覽器渲染</li><li>瀏覽器渲染了，使用者看見 20 出現在螢幕上</li><li>React 清除 effect ， <code>id = 10</code></li><li>React 執行 effect ，<code>id =  20</code></li></ol><p>奇怪的是，為什麼可以在 <code>id = 20</code> 的情況下，去清除 <code>id = 10</code> 的值呢 ? 🤔</p><blockquote><p>每一個在 render 內部呼叫的 function (包含 handlers 、effect 等瀏覽器 APIs )，都會拿到當下定義的 state 。</p></blockquote><p>實際上清除與執行 effect 的 state 都是來自當次 render 的資料，<strong>effect 執行的並不會拿到最新的資料</strong> ，而是舊 (當下)的。</p><p>What !?🤷</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅實際上是這樣的</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(<span class="number">10</span>, handleStatusChange);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(<span class="number">10</span>, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不是這樣的，我們在想像的 clean up 雖然清除的時間點 state 已經改變成 20，但仍然是屬於 id = 10 那次 render 的</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(<span class="number">20</span>, handleStatusChange);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(<span class="number">10</span>, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>clean up 是延後執行，並不代表是屬於下次的 render。 React 把 effect 相關操作是在瀏覽器渲染之後的原因，目的讓執行比預設的還要快。</p><p>而在 clean up function 被呼叫時，舊的 props 永遠都存在，以防我們需要用到它。</p><p>例如監聽事件，如果某按鍵元素消失於畫面，我們應該將它的監聽事件註銷掉，但是在 render 之後元素早已經從畫面消失，我們要怎麼註銷一個已經不在 DOM 上的元素監聽事件呢 ?  clean up function 讓我們把舊的 state 或 props 還存在著，在 effect 呼叫之前，我們就可以把它註銷掉。</p><h2 id="同步執行但不是生命週期">同步執行但不是生命週期</h2><p>在使用 <code>useEffect</code> 要跳脫生命週期的思考方式，運用同步的概念。</p><blockquote><p>一切都是跟結果有關，而不是過程</p></blockquote><p>這跟 JQuery 先呼叫 <code>addClass</code> 又呼叫 <code>removeClass</code> <strong>過程派別</strong> 是不同的 (意思是 DOM 新建立東西，又給它刪除這樣的行為)，這也是為什麼 React 的 CSS class 必須放在 render 程式碼之中 (只在乎結果，並不是從 A 變 B 的過程經歷了什麼。判斷樣式都是看最終的結果，並非隨時間而改變)</p><p>React 根據當下的資料是同步處理 DOM (資料跟 UI 是同步的) ，在 function component 中 render 的  <code>mount</code> 跟 <code>updating</code> 是沒有區別的。這樣使 <code>useEffect</code> 讓我們可以根據 props 或 state 同步 React 樹狀以外的東西。</p><p>假如有一個 state 從 10 變到 20，跟一開始就賦予它 20 ，最終都會是 20。跟 call API 拿資料一樣，最後的結果都會是一樣的。我們看到的 UI 跟資料是同步的，也只會顯示最後資料的結果。</p><p>但是如果每次都 re-render 是很沒效率的，甚至導致無限循環。</p><h2 id="告訴-React-不同-effect-之間的差別">告訴 React 不同 effect 之間的差別</h2><p>避免每次不必要的資料都跟著 re-render，必須告訴 React 那些要 re-render。 (可以想想 render 之後的步驟順序)</p><ol><li>state 改變，render 新的 UI</li><li>React render ，提交 UI 給 DOM</li><li>DOM 更新，經過一系列操作，最後放上畫面 (這也為什麼說 操作 DOM 很昂貴，因為牽涉到太多畫面的 reflow、repaint，尤其是 reflow)</li></ol><p>React 避免 DOM 昂貴的操作，只會更新 DOM 確實有改變的地方。</p><p>React Element 是一個 Object 裝載各種屬性。假如有一個元件指改動了 <code>props.name</code> (不包含 state 的操作) ，也就是文字的部分僅有 children 改變了，React 只會改動 <code>domNode.innerText</code> 的部份而已 (做淺拷貝比較 shallow comparison，這跟 React 的 Recoil 有關)</p><p>範例來自 Dan 大的文章 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldProps = &#123;<span class="attr">className</span>: <span class="string">&#x27;Greeting&#x27;</span>, <span class="attr">children</span>: <span class="string">&#x27;Hello, Dan&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> newProps = &#123;<span class="attr">className</span>: <span class="string">&#x27;Greeting&#x27;</span>, <span class="attr">children</span>: <span class="string">&#x27;Hello, Yuzhi&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>那 React 也會在 <code>useEffect</code> 幫我們檢查嗎 ?</p></blockquote><p><strong>不會。</strong> React 對於沒有呼叫的 function，是沒辦法幫我們檢查、比較。</p><p>React 為了避免一直重複執行 effect 有關的操作，提供 <strong>dependency array</strong> (也稱 <strong>deps</strong> ) ，讓我們加入要關注的資料給 <code>useEffect</code> 判斷。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Hello, &#x27;</span> + name;</span><br><span class="line">&#125;, [name]); <span class="comment">// 👈 deps</span></span><br></pre></td></tr></table></figure><p>透過這個 array 告訴 React ，這裡面</p><blockquote><p>只有包含 array 的資料改變了才要執行，其餘的資料跟我無關，不要叫我謝謝。</p></blockquote><p>React 每次 re-render 會檢查 array 中的資料，如果前後都長的一樣，就會跳過 <code>useEffect</code>  。</p><p>只要放入 array 中的資料，即使只有 1 個改變，也會重新執行 effect ，React 就會知道這是不能跳過的，因為 React 會同步所有事情。</p><p>所以不要把毫無相關的放在一起，<strong>關注會改變而重新呼叫的資料。</strong></p><h2 id="不要對-dependencies-說謊">不要對 dependencies 說謊</h2><p>function Component 中沒有生命週期，如果我們只想要在 <code>mount</code> 執行一次就好，通常會把 dependencies array 寫成空的。</p><p>例如 : 載入資料</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 載入資料</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ajax 是 side effect 把它擺在 useEffect 執行</span></span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, []); <span class="comment">// 👈 放入空陣列 </span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起來合理嗎 ? 如果有牽涉到其他的 props 或 state 這裡就會有問題。</p><h3 id="dependencies-說謊了會發生什麼問題">dependencies 說謊了會發生什麼問題 ?</h3><p>如果以計時功能 (<code>setInterval</code>) 在 class component 中的寫法思維，在 function Component 就要改變這個想法。 <code>setInterval</code> 雖然在基礎的 JS 建立一次，瀏覽器會持續記住直到刪除 id 為止，但在 function Component 每一次都擁有自己的 scope ，所以必須針對每次呼叫 render 時，如果要改變的資料具有副作用要先刪除，再重新產生，不然就會一直往上疊加，造成問題。</p><p>在 class Component 中，有關副作用的問題會在 <code>Mount</code> 監聽與 <code>Unmout</code> 註銷監聽，如果在使用 <code>useEffect</code> 也是同一個思維模式去思考， 把 dependencies array 當作是 mount 的行為，將 array 設為空的，但內部如果使用到有關 props 或 state ，effect 只會在 render 執行一次後就不會再直行了。</p><h3 id="誠實以對-dependencies，把有關的放入-array-中">誠實以對 dependencies，把有關的放入 array 中</h3><p>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 種方式就是把所有相關資料放入 <code>useEffect</code> 的 array 中，讓 effect 按照資料改變就同步改變。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, [count]); <span class="comment">//👈 用到了 count 放入 array</span></span><br></pre></td></tr></table></figure><p>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 種是改變 effect 裡面的結構，不需要每輪 render 都要比較 array 中的資料，減少依賴性，往下會說明怎麼減少依賴性。</p><h2 id="有效率的使用-useEffect">有效率的使用 useEffect</h2><blockquote><p>如果我們不想把 state 放入 dependencies array 呢 ?</p></blockquote><blockquote><p>這不是叛不叛逆或是刻意操作<br>而是 <strong>React 一定需要透過依賴陣列去比較這筆資料嗎 ?</strong>   effect 所執行的是具有副作用的操作。而 React 都能知道當次 render 的所有資料，有必要每次都去特別告訴 React 這筆是否具有變化呢 ?</p></blockquote><p>可以先提問自己 <strong>這筆資料的是為了什麼 ?</strong><br>例如 Counter 中每秒做 <code>setCount(count + 1)</code>，但<strong>其實我們根本不需要比較每次 render 的 count 是多少</strong>，之後再 <code>+1</code> 。</p><p>Why ? 🤔</p><p>因為 React 可以幫我們拿出前一次的 state，而 <code>setInterval</code> 每次是仰賴 <strong>前一次的 state 再 <code>+1</code></strong> ，那麼可以使用 <code>setState</code> 的第二種方式，<code>setState</code> 裡面使用 callback function 拿到最新的 state 並回傳新 state。</p><blockquote><p><code>setState((previousState)=&gt; return state)</code></p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 參數 c 會拿到前一次的 count，回傳 count+1 的結果</span></span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, []); <span class="comment">//👈 這裡就不用放依賴陣列</span></span><br></pre></td></tr></table></figure><p>即使不告訴 React  正確的 dependencies array，<code>setInterval</code> 在第一次 render 後都會存在 (也就是會不斷的執行)，因為 <code>setInterval</code> 是屬於 <code>window</code> 也就是 browser 的 method。</p><p>只有在 Component 本身 <code>unmout</code> 會停下來，也就是上面 <code>return</code> 的部份。</p><p>試著跑一次 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// effect 第一次會被執行，它會在第一次 render 後都存在</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="number">0</span> =&gt; <span class="number">0</span> + <span class="number">1</span>); <span class="comment">// 所以這邊是 setCount(1)</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次 render </span></span><br><span class="line"><span class="keyword">const</span> count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// useEffect 不執行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// setInterval() 這個還是會執行，因為它存在於 browser  而不是每次 render function</span></span><br></pre></td></tr></table></figure><p>文中稱是 <strong>否定式依賴關係</strong> (false dependencies)，因為 React <strong>知道每次 render 的 state 值</strong>，而範例中 <code>setCount</code> 做的事只有回傳 <code>count + 1</code>，React 並不用特別去檢查前後兩次的 count state 是否一樣，再去執行。</p><p>可以看做告訴 React :</p><blockquote><p>總之幫我把  <code>c=&gt;c+1</code> 的結果回傳給我 ，不論 c 是什麼，React 是知道的。</p></blockquote><p>就像指示，這種  <code>function setState</code>  的方式如同批次 (batch) 更新一樣。</p><p>我們確實移除 count 減少依賴性，但並不是對 deps 說謊，只是我們的 effect 沒有讀取來自 render 的範圍裡面的 count。</p><h3 id="試著拆解並了解">試著拆解並了解</h3><p>我用自己的話解釋這段，一開始看的時候真的很吃力😵</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先回味一下原始長相，我要開始幫它變身囉😲</span></span><br><span class="line"><span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="number">0</span> =&gt; <span class="number">0</span> + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><p>上面說到 <code>setInterval</code> 其實可以看做把 function 提到外部，因為 <code>useEffect</code> 只 render 一次，代表內部的 function 是不會變隨 render 重新呼叫 (改變) 的，等同於把 function 提到外面存在來。</p><p>由於 <code>setCount</code> 本身就是透過 <code>updater function</code> 回傳新的 state  就我們按照他的架構回傳。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setIterval 的 callback function 看作把東西寫在 render function 以外</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">countSomething</span> = (<span class="params">setCount</span>) =&gt; &#123;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>把提出的 function 塞回去，並不會影響原本的操作</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放回去</span></span><br><span class="line"><span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 塞回去一樣可以執行</span></span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">countSomething</span>(setCount);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;,[]) <span class="comment">// 👈 依賴陣列是空的</span></span><br></pre></td></tr></table></figure><p>來按照步驟來人體 render 看看，按照 React 每次 render 都同步資料來看</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次 render</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. count = 0 </span></span><br><span class="line"><span class="keyword">const</span> count  = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 3. 進行 effect</span></span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">countSomething</span>(setCount);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 這邊先 clean ，但第一次的 id 是 null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次 render</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 雖然 useEffect 不會執行 </span></span><br><span class="line"><span class="comment">  但內部的 setInterval 會繼續執行，直到被清除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不是這樣 function 一直被呼叫，而是內部的 setInterval 間隔觸發它的 callback function</span></span><br><span class="line"><span class="title function_">countSomething</span>(setCount);</span><br></pre></td></tr></table></figure><p><code>setInterval</code> 不管在哪裡呼叫，由於它是屬於 window (瀏覽器) 底下的 api，如果沒有清除，那麼 <code>window</code> 一樣會每間隔 x 秒呼叫。這個例子證明不論放在 render function 內部或是外部，<code>setInterval</code> 都會風雨無阻的執行。</p><blockquote><p>注意<br>我們讀取的 count 值已經不是來自於 render 範圍的</p></blockquote><p>這是什麼意思呢 ? 🤔</p><p>經由上面的變化史，已經知道脫離了 render function 依然可以執行，那這裡的 <code>setCount (c=&gt;c+1)</code> 裡面的 <strong><code>c=&gt; c+ 1</code></strong> 又是另一個 callback function，那 <code>c</code> 這個參數來自誰重要嗎 ?  我們有必要填入這個 c 值才能計算嗎 ? (意思是一定要寫<code>setCount(anotherfunction(c))</code> 才能執行嗎 ?  )</p><p>我再把 <code>setCount</code> 裡面的 callback function 又拆出 render 以外，叫 <code>plusOne</code>，並且我把這個 <code>plusOne</code> 看做我們要對 <code>setCount</code> 做某事的藍圖。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">countSomething</span> = (<span class="params">setCount</span>) =&gt; &#123;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(plusOne);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 告訴 React 資料要做的事</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">plusOne</span>(<span class="params">c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> c + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉  <a href="https://codesandbox.io/s/mystifying-williamson-s4799j?file=/src/index.js"> <code>codsandbox</code> 範例</a></p><p>在把這串放回去，一樣可以執行。<code>setState</code> 如果是使用 callback function 的方式使用，內部其實是呼叫 <strong>updater function</strong><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>，它會保證拿到最新的 state，而我們的 <code>plusOne</code> 只是 updater function 的另一種表達方式。</p><p>回到 React render 的概念 : <strong>每次 render 都保有自己的資料</strong>，所以我們不用特別放入 deps 來告訴 React ，因為 React 就已經知道當次的 state。</p><p>這段有點饒口，但幫助我釐清到底為什麼不用加入 deps 內依然可以執行這個問題。</p><h2 id="從-Google-文件的更新了解-function-updater">從 Google 文件的更新了解 function updater</h2><p>如上面的範例，知道可以使用 <code>setCount(c =&gt; c + 1)</code>  避開 deps 填入 state ，但 :</p><ol><li>為什麼使用呢 ?</li><li>跟原本 <code>setCount( c + 1)</code> 差別在哪 ?</li></ol><p>文章中舉例 Google 文章是雲端編輯。修改的時候，並不是每次都傳送整個頁面的內容給伺服器，文章如果檔案大，那樣傳送覆蓋太沒效率了。那怎麼溝通給後端讓它記住新增或修改的部分呢 ?</p><blockquote><p>透過傳遞 <strong>定義好的表達方式</strong></p></blockquote><p>其實如果使用過 redux 就知道 dispatch 與 action 的發號施令的概念，只有已經定義到的 action type 對應 actions 才能對資料內容進行變動。那也可以想像 Google 文章在編輯時也是如此，<em>使用者點擊某個按鈕，後端再做動作</em>。</p><p>如此一來達到 <strong>找出最小化的資料來改變這個 component</strong> ，如同 Google 文件不會送整頁資料出去改變文件。</p><p>這種方式跟是 React 所建議的原則 : <strong>尋找最小化但完整的 state</strong> 的概念 (意思是有些資料是可以透過計算出來的，不一定所有資料都得是內部的 state，例子補充在後面)，差別是這是 update 的。</p><p>最小化且完整的 state 舉例 :<br>以 todo list 為例，有存放所有 todo 的陣列 state ，但我想要存取 todo 的長度，並不需要另外儲存的 state</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 不用這樣</span></span><br><span class="line"><span class="keyword">const</span> [length,setLength] = <span class="title function_">useState</span>(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>因為可以從 <code>state.todos.length</code>  取得，這筆資料是可以通過計算取得。<br>這也是為什麼上面說  <code>c =&gt; c + 1</code> 是一個藍圖，因為它傳達的是個資料的表達方式。</p><p>那為什麼 <code>setCount(c =&gt; c + 1)</code> 比較好呢 ? 🤔</p><p>在於 <strong>它沒有直接改變 count 本身</strong> (沒有汙染到變數)，這個例子用最原始的 JavaScript 來看。由於本次的 count 是 primitive type，這邊並不討論 object type (React 之所以會建議解構 object type 是有原因的)。</p><ul><li><code>c =&gt; c+1</code> : 並沒有改變到原始的 count</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">plusOne</span>(<span class="params">count</span>)&#123;</span><br><span class="line">  count =  count + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newCount = <span class="title function_">plusOne</span>(count) <span class="comment">// 用變數接起來</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newCount) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li><code>c + 1</code> : 直接對 count 進行操作😵</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">plusOne</span>(<span class="params"></span>)&#123;</span><br><span class="line">  count = count + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newCount = <span class="title function_">plusOne</span>() </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newCount) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>不直接操作資料也是避免非預期的結果發生。</p><p>這種方式保證更新多個來源 (事件或是具有副作用的操作等等) 都可以被合併成 <strong>可預測的正確操作</strong>。然而 <code>setCount(c =&gt; c + 1)</code> 並不是最佳解法，遇到以下的情境，可能會產生奇怪的問題 :</p><ol><li>執行 effect 同時依賴多個 state</li><li>透過 props 計算新的 state</li></ol><p>這時候可以使用 <code>useReducer</code> 來幫我們解決問題。</p><p><code>useReducer</code> 可以看做加強版的 useState，而事實上 <code>useState</code> 也是 <code>useReducer</code> 簡化過來的，有興趣可以參考這篇 <a href="https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/react-hooks-usestate-vs-usereducer-b14966ad37dd">React Hooks | 既生 useState 何生 useReducer ? | by Airwaves | 手寫筆記 | Medium</a></p><h2 id="將資料更新與操作分離">將資料更新與操作分離</h2><p>範例中 count 是被 step 影響，我們也確實將正確的 deps 放進去。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [step, setStep] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + step);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, [step]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;step&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> setStep(Number(e.target.value))&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用白話文解釋 : 當 step 改變時， effect 會先清除上一個計時器，接著產生新的計時器。</p><blockquote><p>但是如果不想要改變 step 就重啟 interval 重新計時呢 ? 如果想要動態的改變 step 又能持續計時呢 ?</p></blockquote><p>那麼就必須把 step 從 deps 移除，避免 step 改變也清除 effect 又產生新的 <code>setInterval</code> 重計。</p><p>這種情況是多個資料互相依賴 <code>(count ⇒ step)</code>，而且是 A 資料跟 B 資料現在的值有關。(count 每秒增加的值，跟 step 的值有關)</p><p>可以改使用 <code>useReducer</code> 管理複雜的資料流。<code>useState</code> 通常只能對著一筆資料操作，如果有很多筆，可能會建立多個 <code>useState</code>。或是發覺操作資料是 <strong>根據於前一次的資料</strong>，這時候很適合換成 <code>useReducer</code>。</p><blockquote><p>reducer 可以讓我們透過 <strong>action type 對應 action 再去更新資料</strong> ，而且也可以同時對多筆資料操作。</p></blockquote><p>什麼意思呢 ? 那 <code>useState</code> 不能做這樣的事嗎 ?<br>可以，但是非常麻煩，會使邏輯變得複雜🤔。</p><p>我試著復刻這兩種方式的操作 :</p><ol><li>照舊分開的兩個資料，同時更新</li><li>由於兩個是相依性的，把它放在同一個資料物件中。</li></ol><p>另外多出來的是嘗試其他種方式。</p><ol><li>原始範例 : <a href="https://codesandbox.io/s/zxn70rnkx">Dan 大提供的 CodeSandbox</a></li><li>實作範例 : <a href="https://codesandbox.io/s/zealous-monad-rco7nx?file=/src/index.js">我複製改過的 CodeSandbox</a>，範例會看到多個不同的寫法，以下會一個個說明。</li></ol><h3 id="實驗-分開的兩筆資料更新">實驗 : 分開的兩筆資料更新</h3><p>首先要釐清改變其值的變因，count 是依賴著 step，但是 step 是手動輸入值所改變的，因此 step 雖然改變了，但是 count 不能拿到最新的 step。</p><ul><li>透過上面說過的 updater function，我們可以知道 <code>(c =&gt; c)</code> 這樣可以拿到最新值。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> [step, setStep] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setStep</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 最新的 step</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 那這裡的 step 呢 ? 🤔</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;step in count&quot;</span>, step);</span><br><span class="line">        <span class="keyword">return</span> c + step;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>其他部分跟原範例一樣沒有更改。</p><blockquote><p>當然結果是不行的。</p></blockquote><p>試著用 <code>setStep</code> 拿到最新的 step，並不代表當下取得的 step 會是最新的。React 新手最常陷入的陷阱是執行 <code>setState</code> 後馬上讀取 state 值，state 不會是新的。<br>這跟 <code>setState</code> 是非同步的有關係。</p><p>回到那句話 : <strong>每一次 render 都擁有它專屬的 state 或 props</strong> 。<br>所以  <code>setCount</code> 裏頭的 step 還停留在第一次 render ，<code>step = 1</code>。即使修改 input 的值，雖然 <code>setStep</code> 那行可以拿到最新的 step，但沒辦法在 <code>setCount</code> 裡面拿到。</p><h3 id="實驗-再某筆資料內部拿到最新">實驗 :  再某筆資料內部拿到最新</h3><p>那在 <code>setStep</code> 中拿到最新 step 在傳給 <code>setCount</code> 總可以了吧🤔</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setStep</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;step in count&quot;</span>, step);</span><br><span class="line">        <span class="keyword">return</span> c + s;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>變得越來越複雜了，認真拆解的話就是 callback hell 了。同上面說的如果 deps 是空的，state 再也不是取自 render function 裡面，同樣可以把這些 method 看作寫在外部。</p><ul><li>上面就像 :</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拆解再拆解</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">countSomething</span> = (<span class="params">setCount</span>) =&gt; <span class="function">(<span class="params">setStep</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// callback 再 callback</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setStep</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> c + s);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"> <span class="keyword">const</span> id = <span class="title function_">countSomething</span>(setCount)(setStep);</span><br><span class="line"> <span class="keyword">return</span> <span class="function">()=&gt;</span> <span class="title function_">cleanInterval</span>(id)</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><p>看起來還行🤔，但我認為這樣的架構不好被擴展，除非裡面又再拆，不過同時也讓我想到 HOC (Higher Order Component)，這樣的方法會有效能上的問題。</p><h3 id="實驗-object-type-的-state">實驗 : object type 的 state</h3><p>我認為這個例子是最接近 <code>useReducer</code> 的，同時必須把結構大改，並且用 immutable 的方式改變資料。</p><ul><li><code>useState</code> 設為 object :</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 把所有相關的 state 放入同一個容器中</span></span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">     <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">     <span class="attr">step</span>: <span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 一樣使用 updater function 拿到最新值</span></span><br><span class="line">    <span class="title function_">setValue</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> (&#123; ...v, <span class="attr">count</span>: v.<span class="property">count</span> + v.<span class="property">step</span> &#125;));</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 3. step 也要修改 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;value.step&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setValue(&#123; ...value, step: Number(e.target.value) &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像比上面都更來的精簡，只是改變 state 變成很囉唆😵</p><h3 id="實驗-把-input-變成-uncontrolled-component">實驗 : 把 input 變成 uncontrolled component</h3><p>在 [[#使用 ref 來取得最新值]] 這章節已經有提到，搭配上表單的控制，可以讓我們不 re-render 的情況下，依然拿到 input 的最新值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stepRef = <span class="title function_">useRef</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> c + <span class="title class_">Number</span>(stepRef.<span class="property">current</span>.<span class="property">value</span>));</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改成</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;stepRef&#125;</span> <span class="attr">defaultValue</span>=<span class="string">&#123;1&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="回到-useReducer">回到 useReducer</h2><ul><li>按照文章中提供的 <code>useReducer</code> 範例</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始值</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">step</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="comment">// 解構 state</span></span><br><span class="line">  <span class="keyword">const</span> &#123; count, step &#125; = state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根據不同的 action type 來改變 state，如果 type 一多用 switch case</span></span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;tick&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: count + step, step &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;step&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; count, <span class="attr">step</span>: action.<span class="property">step</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// useReducer </span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br><span class="line">  <span class="comment">// 解構值</span></span><br><span class="line">  <span class="keyword">const</span> &#123; count, step &#125; = state;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// dispatch 一個 action</span></span><br><span class="line">      <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;tick&#x27;</span> &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, [dispatch]); <span class="comment">//👈 deps 放入 dispatch</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;step&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">        // 一樣 dispatch action</span></span><br><span class="line"><span class="language-xml">        dispatch(&#123;</span></span><br><span class="line"><span class="language-xml">          type: &#x27;step&#x27;,</span></span><br><span class="line"><span class="language-xml">          step: Number(e.target.value)</span></span><br><span class="line"><span class="language-xml">        &#125;);</span></span><br><span class="line"><span class="language-xml">      &#125;&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那這有比較好嗎 ? 意思是 deps 放入 dispatch 不是會回到 <code>setInterval</code> 又重新的狀況嗎 ?</p><p>事實上可以這麼做是因為 <strong>React 保證 dispatch 永遠被不會改變</strong>，所以它不會讓 state 改變又重新啟動計時。由於 dispatch 不會改變，所以 <code>prevDispatch === nextDispatch</code>。</p><p><code>useEffect</code> 的 deps 可以忽略</p><ol><li><code>dispatch</code></li><li><code>setState</code></li><li><code>useRef</code> 容器值 : 指 <code>ref.current</code></li></ol><p>因為 React 保證他們是靜態的，不會被改變。不過指定他們也不會怎麼樣。</p><p>回到優點的部分，比起在 effect 裡面直接讀取 <code>state</code>，<strong>dispatch acition</strong> 給予一個資料表達的方式，並且在外部的 reducer 按照 action type 操作資料。讓 effect 把 step 這個 state 分開來看待，count 跟 step 的依賴性就不會因在 render function 導致不同步的問題。</p><p>effect 不關注怎麼更新 state，而是什麼動作要發生，並在 reducer 集中處理這些資料邏輯。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count, step &#125; = state;</span><br><span class="line">  <span class="comment">// 收到 tick，reducer 定義 tick 對資料做某件事，回傳 count : count + step</span></span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;tick&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: count + step, step &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;step&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 收到 step，對 step 資料做重新賦值</span></span><br><span class="line">    <span class="keyword">return</span> &#123; count, <span class="attr">step</span>: action.<span class="property">step</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="為什麼-useReducer-是-Hooks-的作弊方式">為什麼 useReducer 是 Hooks 的作弊方式 ?</h2><p>文中提出一個情境</p><blockquote><p>如果是 step 透過 props 傳下來的值呢 ?</p></blockquote><ul><li>文中範例</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在父元件把 step 往下傳 </span></span><br><span class="line">&lt;<span class="title class_">Counter</span> step=&#123;<span class="number">1</span>&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params">&#123; step &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, dispatch] = <span class="title function_">useReducer</span>(reducer, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 因為 step  是 props ，要把 reducer 搬進來才能讀取到</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;tick&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state + step;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 這邊都沒變</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;tick&#x27;</span> &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, [dispatch]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個範例有優化上的問題，不要當作合理的使用方式。(我覺得是 reducer function 不斷新產生的問題，通常會用 <code>useCallback</code> 避免每次 render  重新產生。)</p><p>這個範例 dispatch 依然不會改變，所以 effect 裏頭並不會 re-render。因為 step 不屬於 <code>useReducer</code>  的 state，<code>reducer</code> 怎麼知道 props 產生變化而拿到最新的 props 呢 ?</p><p>由於 effect 不會再執行，React 會記住 dispatch 中的 action，但這依然會在下次 re-render (state 或是 props 改變) 呼叫 reducer 。這時候 props 是新的，reducer 接收到的 props 也是新，但不是在 effect 拿到。</p><p>這也就是為什麼 Dan 大說 <code>useReducer</code> 像是 Hooks 的作弊模式，因為<strong>把描述事情跟更新邏輯操作分開了</strong>。另外一方面，可以移除一些 effect 中不需要的 deps，避免不必要的 re-render。</p><h3 id="白話翻譯機">白話翻譯機</h3><p>先確定幾件事 :</p><ol><li>effect 是不會重新呼叫，因為 dispatch 永遠都是同一個</li><li>dispatch 發送的只是一個 <code>action</code>，而且也不會改變。而 reducer 是接收 action type 來對 state 操作。</li><li>reducer 在 render function 範圍內，按照原本每一個 render 都有它的 state 或 props ，也就是當 Counter 因 state 或 props 改變而 re-render ，reducer 也會產生新的 function ，也會拿到當前 render  範圍的 props。</li><li><code>setInterval</code> 依然間隔秒數執行。</li></ol><p>如果用 redux 的想法來思考，會看過這張經典的圖，比較容易理解，dispatch 接收一個物件，並再傳給 reducer 處理最後返回 state。<br><img data-src="https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif" alt="|300x230"></p><p>卡住的話，再試著一步步拆解。<br>把 dispatch 看作放在外部的 function 接收 action，並且內部呼叫 reducer<br>👉 <a href="https://codepen.io/shan473/pen/mdxKvYj?editors=0010">嘗試用 <code>codepen</code> 並用 Vanilla JS 復刻 </a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假的 dispatch 👉 不在 render function 裡面</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakedispatch</span>(<span class="params">action</span>) &#123;</span><br><span class="line">  <span class="comment">// 都呼叫來自 component 中的 reducer，更新目前的 state</span></span><br><span class="line">  component.<span class="title function_">fakereducer</span>(component.<span class="property">state</span>,action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Counter component : 由於 React Element 是一個 Object，所以我轉換成簡化一些 Object 結構。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> step = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> component = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// props 模仿是由外部傳入的 props</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params">props = <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 是不是第一次 render</span></span><br><span class="line">  <span class="keyword">if</span>(component)&#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">state</span> = component.<span class="property">state</span>;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">props</span> = props || component.<span class="property">props</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = count;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">props</span> = props || &#123;step : step&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把 React Element 看成一個 Object</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, &#123;</span><br><span class="line">    <span class="attr">state</span>: <span class="variable language_">this</span>.<span class="property">state</span>,</span><br><span class="line">    <span class="attr">props</span>: <span class="variable language_">this</span>.<span class="property">props</span>,</span><br><span class="line">    <span class="comment">// 😲 fakereducer，放在 render function 內部</span></span><br><span class="line">    <span class="attr">fakereducer</span>: <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&quot;tick&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> += <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">step</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(action.<span class="property">type</span> === <span class="string">&quot;reset&quot;</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Interval : 跟之前的在 <code>useReducer</code> 類似，只是在 dispatch 之後手動 re-render，因為我們改變了 state</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假裝等於 useEffect(()=&gt;&#123;&#125;,[]) ,deps 為空</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fakedispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;tick&quot;</span> &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改變一下 dispatch 內部</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakedispatch</span>(<span class="params">action</span>) &#123;</span><br><span class="line">  prev = component</span><br><span class="line">  <span class="comment">// 要跟 prev 比較的</span></span><br><span class="line">  <span class="keyword">let</span> temp = <span class="keyword">new</span> <span class="title class_">Counter</span>(prev.<span class="property">props</span>);</span><br><span class="line">  <span class="comment">// 更新 state</span></span><br><span class="line">  temp.<span class="title function_">fakereducer</span>(component.<span class="property">state</span>,action)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  假裝 setState 的概念，由於 state 不同，而re-render</span></span><br><span class="line">  <span class="keyword">if</span>(temp.<span class="property">state</span> !== prev.<span class="property">state</span>)&#123;</span><br><span class="line">    <span class="comment">// 重新呼叫 component 更新</span></span><br><span class="line">    component = temp  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新畫面</span></span><br><span class="line">    title.<span class="property">textContent</span> = component.<span class="property">state</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代表 re-render</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;re-render&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>處理 <code>&lt;Counter step=&quot;1&quot;/&gt;</code> props 改變時也 re-render，由於是 input 的值改變導致 props 改變 (re-render)，我們就模擬這個動作。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&quot;input&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="comment">// 檢查輸入是不是數字</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">Number</span>(e.<span class="property">target</span>.<span class="property">value</span>)))&#123;</span><br><span class="line">    result =<span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    result =<span class="title class_">Number</span>(e.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// re-render 並傳入 props</span></span><br><span class="line">  component = <span class="keyword">new</span> <span class="title class_">Counter</span>(&#123;<span class="attr">step</span>: result&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>執行</li></ul><h3 id="人體編譯">人體編譯</h3><p><code>useEffect</code> 在上面的章節說過，如果 deps 沒有任何東西，effect 只會 render 一次，其 資料已經不是來自於 render function 本身，可以把它看作拿到 render 外部一樣。<br>所以我們製作假的 <code>useEffect</code> 是對應 <code>tick()</code>， 並且在 component 生成之後呼叫。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">component = <span class="keyword">new</span> <span class="title class_">Counter</span>(&#123;step&#125;);</span><br><span class="line"><span class="title function_">tick</span>();</span><br></pre></td></tr></table></figure><ul><li>編譯 : 這裡有兩種情境，(1) 本身 state 改變 ；(2) 傳入的 props 改變</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改變 Counter 的 state</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> step = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 產生 fakereudcer </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakereducer</span>(<span class="params">action</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&quot;tick&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> += <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">step</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(action.<span class="property">type</span> === <span class="string">&quot;reset&quot;</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tick() setInterval 每秒呼叫 dispatch 並送 action 給 fakereducer</span></span><br><span class="line"><span class="title function_">fakedispatch</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;tick&#x27;</span>&#125;) <span class="comment">//👉 count = 0 + 1 </span></span><br><span class="line"><span class="comment">// component state 改變，re-render 、畫面更新</span></span><br><span class="line">temp = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">1</span>);</span><br><span class="line">component = temp</span><br><span class="line">title.<span class="property">textContent</span> = component.<span class="property">state</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改變 props 的 step = 4，props 改變 re-render</span></span><br><span class="line">component = <span class="keyword">new</span> <span class="title class_">Counter</span>(&#123;<span class="attr">step</span>: <span class="number">4</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 產生新的 fakereducer</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakereducer</span>(<span class="params">action</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&quot;tick&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 這次 render 1 += 4 = 5</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> += <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">step</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(action.<span class="property">type</span> === <span class="string">&quot;reset&quot;</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>後面都是周而復始。雖然不是很準確的模仿 React ，透過拆解的方式我比較好理解。我們可以知道 reducer 是因為拿取 props 的最新值，我們才把它放在 component 內部，但是會造成不管 props 是不是有改變都會產生新的 reducer 。我可能會用 <code>useCallback</code> 記憶起來，並加上 <code>props.step</code> 作為 deps。</p><p>藉由這個例子我們知道 dispatch 只要負責把 action 帶給 reducer 就好，我們不用在內部實作詳細邏輯，而是交給 reducer 處理，減少像 <code>setState</code> 直接在 effect 中把資料拆開又塞回去，而且如果是多組資料集中於一個 state，牽一髮動全身😵。</p><h2 id="把-function-移到-useEffect-中">把 function 移到 useEffect 中</h2><p><code>useEffect</code> 很常拿來做 call API 拿資料，也很常只做載入頁面的那一次。按照 effect 只執行一次，我們的 deps 會是空的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(</span><br><span class="line">      <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=react&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面看起來是可行的，比較不好的點在於  <code>fetchData</code> 沒有依靠任何 state 或 props，每一次 render 都是長一樣的，但又會每次產生新的 function🤔。</p><blockquote><p>如果只用到函數內部的值，沒有依靠外部資料，把它放到 effect function 中</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 把 function 搬到 effect 內部</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=react&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(<span class="title function_">getFetchUrl</span>());</span><br><span class="line">    <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fetchData</span>();</span><br><span class="line">&#125;, []); <span class="comment">// ✅ deps 是空的也沒關係，因為沒有用到 state 或 props</span></span><br></pre></td></tr></table></figure><p>我們不用再擔心 deps 的問題，因為確確實實也沒有依賴任何外部資料。</p><p>但是當結構開始變的龐大，而且涉及 state 與 props，這時候如果當資料改變了，但 effect 並不會更新，依然只會停留在第一次 render 並且不會再執行了😵。</p><blockquote><p>那把 state 或 props 加入 deps 呢 ?</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(<span class="title function_">getFetchUrl</span>());</span><br><span class="line">    <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fetchData</span>();</span><br><span class="line">&#125;, [query]); <span class="comment">// ✅ 這樣是合理</span></span><br></pre></td></tr></table></figure><p>如此一來當 <code>query</code> 改變，effect 就會重新呼叫，我們拿到的資料也都會同步。</p><p>加入 deps 不只是讓 React 不要發出警告。而是去理解相關資料的變化，例如 : 拿取資料是依靠 <code>query</code> 字串的變化，把 query 放入 deps 可以讓我們拿到當次正確的資料。</p><p><code>useEffect</code> 強迫讓我們注意資料流應該要怎麼變化，也告訴我們也要讓 effect 一起同步更新，而不是忽略它，讓使用者處處碰到 bug😵</p><h2 id="不能把-function-移入-useEffect-怎麼辦">不能把 function 移入 useEffect 怎麼辦 ?</h2><p>如果有一個 function 在不同的 effect 中進行，那 function 在每次 re-render 都會被重新創造，如果加入 deps 會導致頻繁的更新。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 🔴 re-render 都會使 effect 重新產生並呼叫，況且還依附兩個😵</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params">query</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line">&#125;, [getFetchUrl]); <span class="comment">// 🚧 deps 是正確的但是改變的太頻繁</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">&#125;, [getFetchUrl]); <span class="comment">// 🚧 deps 是正確的但是改變的太頻繁</span></span><br></pre></td></tr></table></figure><p>絕對不會想把它複製貼到 effect 裡面😵。所以解決的方式有兩種 :</p><ul><li>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 種 : 如上面一直提及的一種方式，把它提到 render function 外部。如果忘記了可以回想一下  [[#有效率的使用 useEffect]] 章節，概念上資料來源是不屬於 render function 範圍的。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 提到外部，不會再被 render 內部的資料影響了</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params">query</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line">  &#125;, []); <span class="comment">// ✅ deps 空的是 OK 的</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">  &#125;, []); <span class="comment">// ✅ deps 空的是 OK 的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 種，把 function 給記起來，由於每次 re-render 都會新建立 function，可以使用 <code>useCallback</code> 記起來，並且按照傳入的 deps 再重新建立 function，選擇再有必要的情況再更新。如果有使用到相關的 state 或 props 就能同步更新。</li></ul><ol><li>類似把 function 提到外部的變化形態 :</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 跟把 function 提到外部類似，但是在 render function 內讓它不變</span></span><br><span class="line"><span class="keyword">const</span> getFetchUrl = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">query</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">&#125;, []);  <span class="comment">// ✅ callback deps 空的沒關係，因為它是靠帶入的參數來變化</span></span><br><span class="line">  </span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line">&#125;, [getFetchUrl]); <span class="comment">// ✅ deps 放入 getFetchUrl 沒問題，因為 getFetchUrl 建立後不會隨 re-render 重新建立</span></span><br><span class="line">  </span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">&#125;, [getFetchUrl]);  <span class="comment">// ✅ deps 放入 getFetchUrl 沒問題，因為 getFetchUrl 建立後不會隨 re-render 重新建立</span></span><br></pre></td></tr></table></figure><ol start="2"><li>依賴內部的 state 或 props</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ getFetchUrl 直到 query 有改變才會更新</span></span><br><span class="line"><span class="keyword">const</span> getFetchUrl = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">&#125;, [query]);  <span class="comment">// ✅ callback deps 根據 query state 改變而重新建立</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>();</span><br><span class="line">&#125;, [getFetchUrl]); <span class="comment">// ✅ deps 是 OK 的，跟 query 是同步更新</span></span><br></pre></td></tr></table></figure><p>而 <code>useCallback</code> 的方式也適用於父元件傳遞 function props 給子元件的操作 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ✅ 直到 query 改變才重新建立 fetchData</span></span><br><span class="line">  <span class="keyword">const</span> fetchData = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">  &#125;, [query]);  <span class="comment">// ✅ callback deps 根據 query state 改變而重新建立</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 傳給子元件，記住 ! 這邊的 function 更新條件是 query，所以傳入的 fetchData 會一直是同一個 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;fetchData&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">&#123; fetchData &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [data, setData] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetchData</span>().<span class="title function_">then</span>(setData);</span><br><span class="line">  &#125;, [fetchData]); </span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  ✅ deps 是 OK，因為它也等 Parent 本身 query 改變才會重新呼叫，其餘的時候 Child 本身無法動到 effect 的，即使 setData 改變了，這裡也不會重新呼叫 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="function-是資料流的一種嗎">function 是資料流的一種嗎 ?</h2><p>這節提到 function 變成 props 傳遞給子元件要注意的點，另外凸顯 class component 跟 function component 之間的差別。</p><p><code>useEffect</code> 我們知道是在 render 之後才呼叫的，而且具有 3 種不同情境 :</p><ol><li>完全沒有 deps array，表示只要 re-render 之後就跟著執行</li><li>deps 為空，表示只在 mount (render) 之後只做一次</li><li>deps 放有相關資料，表示有關資料的改變就會重新呼叫 effect</li></ol><p>看起來 <code>useEffect</code> 是等同於 class component 生命週期中的 <code>componentDidMount</code> 以及 <code>componentDidUpdate</code> 🤔🤔🤔</p><p>在這之前，複習一下 class component 的生命週期圖 :<br><img data-src="https://i.imgur.com/cpFlaro.png" alt="|600x300"></p><ul><li>class component 中傳遞 function props，把上面的例子轉成 class 版本</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 等同於 const [query, setQuery] = useState(&#x27;react&#x27;);</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">query</span>: <span class="string">&#x27;react&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 定義了 fetchData 方法</span></span><br><span class="line">  fetchData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">query</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// function 透過 props 傳給 Child </span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;this.fetchData&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 等同於上面 let [data, setData] = useState(null);</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 在 render 之後執行</span></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 從 Parent 來的，我們像 functional component 一樣在 render 之後呼叫</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣在第一次 render 之後確實可以執行，但是沒辦法在 Parent props 改變時重新呼叫。</p><p>如果要重新呼叫 <code>this.props.fetchData</code>，就會在 <code>updating</code> 階段 render 完後呼叫 <code>componentDidUpdate</code> 來檢查前後的 props 是否有改變。確實跟 effect 很類似🤔</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">  <span class="comment">// ❌ 這個條件永遠不會成立</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">fetchData</span> !== prevProps.<span class="property">fetchData</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 props 的比較不會成立，為什麼呢 ?</p><blockquote><p>class component 是每次都重新呼叫 <code>render()</code>而已，並不是 new 重新建立實例，已經被建立的 function 是靜態的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class component</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ComponentA</span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="title class_">ComponentA</span>.<span class="title function_">render</span>() <span class="comment">// re-render 是指呼叫 class 中的 render function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 👉 prev ComponentA.method 等於 next ComponentA.method</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// functional component</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ComponentB</span>  = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> ()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">re-render 是指呼叫 ComponentB() 本身，其內部的 function 都會重新建立。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">ComponentB</span>() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 👉 prevComponentB 不等於 nextComponentB</span></span><br></pre></td></tr></table></figure><p>如果把 <code>if</code> 條件拔掉，也是錯誤的。導致每次 re-render 都重新呼叫 <code>fetchData()</code> ，而且是不論 query 是不是有改變，這不是我們要的效果。</p><p>那讓我們的傳遞下去的 <code>fetchData</code> 是會跟著 query 變化的，使用 inline function，並且用 <code>bind</code> 綁定父層的 this ，避免傳到 Child 後用 this 導致指向不正確的問題。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;this.fetchData.bind(this,</span> <span class="attr">this.state.query</span>)&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣導致 <code>this.props.fetchData !== prevProps.fetchData</code> 始終成立，導致每次 re-render 都重新呼叫 <code>fetchData()</code> 。</p><p>解決問題的方法，就是 <strong>把 query 當 props 跟著傳下去</strong>，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent Component</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;this.fetchData&#125;</span> <span class="attr">query</span>=<span class="string">&#123;this.state.query&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child Component</span></span><br><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">  <span class="comment">// 根據 props.query 決定</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">query</span> !== prevProps.<span class="property">query</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>function 可以被傳遞進去，但是 function 內部的改變與否是不能被看見的，它沒辦法直接拿來被比較。另一個原因是，props 傳來的方法封閉了 <code>this</code> (this 是看怎麼被呼叫，什麼意思呢 ? 看下面註解)，我們不能直接依賴它來決定是否更新。導致我們 <strong>必須傳遞內部相關所有的資料</strong>，就為了檢查是否有改變再決定要不要呼叫方法。</p><blockquote><p>對於 class component 來說， function props 不是屬於資料流的一部分。</p></blockquote><p>我們不知道 <code>this.props.fetchData</code> 從 Parent 傳過來是不是跟 state 有關，或是 state 是不是已經改變了。(這個 props 的 stateless 有關嗎 ? )</p><p>使用 <code>useCallback</code> 讓 function 可以加入資料流中，我們根據 function 的輸入值改變，代表 function 本身也要改變，反之亦然，輸入沒有變的話就也不會產生新的 function。有 <code>useCallback</code> 的協助，改變 props 的時候，<code>props.fetchData</code> 也會自動地傳遞下去，因為它本身是資料流的一部分。</p><h3 id="注意-4">注意</h3><p>把任何 function 都加上 <code>useCallback</code> 是一件很不 Ok 的事，這不是保證是效能上的優化。</p><p>雖然它是一個很有效的方法，對於同時傳遞給多個子元件，並且應用在子元件內部的 effect，是可以避免子元件做無意義 render 的問題。當然也可以包裹成 Hooks 避免多個 callbacks 傳遞整個 React 樹狀結構。</p><p>用上面的 <code>fetchData</code> 來試著寫成 <code>useFetchData</code> ，這裡可以搭配 <code>useContext</code>，使用 Provider 包住的元件可以根據 query 改變而更新資料包。<br>👉 <a href="https://codesandbox.io/s/festive-fermi-1cms7c?file=/src/index.js">codesandbox 簡易查詢各國代碼 API</a></p><p>列出功能 :</p><ol><li>Provider 包住的元件，使用 <code>useFetchData</code> 就可以拿到回傳的資料。</li><li>當 query 改變時重新獲取資料</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext, useMemo, useState, useEffect, useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本網址</span></span><br><span class="line"><span class="keyword">let</span> baseurl = <span class="string">&quot;https://restcountries.com/v3.1/name/&quot;</span>;</span><br><span class="line"><span class="comment">// 建立 context，如此一來包住的元件都可以直接用 useFetchData 取的共享值</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Context</span> = <span class="title function_">createContext</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 修一下名字方便 debug</span></span><br><span class="line"><span class="title class_">Context</span>.<span class="property">displayName</span> = <span class="string">&quot;FetchDataContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 Provider 元件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DataProvider</span>(<span class="params">&#123; children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&quot;tw&quot;</span>);</span><br><span class="line">  <span class="comment">// 避免造成 value re-render ，把 value 記憶起來，直到改變 query</span></span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      query,</span><br><span class="line">      setQuery</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [query]);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom Hooks </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useFetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 這一段主要確認上方是否有 Provider 的防呆</span></span><br><span class="line">  <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">Context</span>);</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;useCount must be used within a CountProvider&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 確定有後把 context 解構比較好讀</span></span><br><span class="line">  <span class="keyword">const</span> &#123; query, setQuery &#125; = context;</span><br><span class="line">  <span class="comment">// 讀取回來的資料</span></span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// 錯誤處理</span></span><br><span class="line">  <span class="keyword">const</span> [message, setMessage] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (query) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(baseurl + query).<span class="title function_">then</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> r.<span class="title function_">json</span>());</span><br><span class="line">        <span class="comment">// 回傳不是 404 時判斷</span></span><br><span class="line">        <span class="keyword">if</span> (!data.<span class="property">status</span>) &#123;</span><br><span class="line">          <span class="title function_">setData</span>(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 回傳 status 為 404 設定錯誤資訊</span></span><br><span class="line">          <span class="title function_">setMessage</span>(data.<span class="property">message</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setMessage</span>(<span class="literal">null</span>); <span class="comment">// 清除錯誤資訊</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [query]); <span class="comment">// 👈 deps 放入 query</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回傳需要的值</span></span><br><span class="line">  <span class="keyword">return</span> &#123; data, query, setQuery, message &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包回傳</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">DataProvider</span>, useFetchData &#125;;</span><br></pre></td></tr></table></figure><p>寫成 Hooks 時在使用就很方便，只要在同一層共享的部份加上 Provider ，內部元件都使用 <code>useFetchData</code> 就能拿到想要的內容👍</p><p>當然這個例子可以再改進，例如 input 的部份可以改用 option，由第一次進入 app 先取得所有國家國碼，這樣使用者可以用選單的方式進行。</p><h2 id="談談競爭條件-race-condition">談談競爭條件 (race condition)</h2><p>什麼是競爭條件呢 ?</p><p>在 JavaScript 中跟競爭條件有關的是非同步的問題，如上面舉例的 <code>fetchData</code> 。<strong>如果在非同步操作的未完成的時候，中途改變 state 或 props 會導致非預期的事情發生。</strong><br>👉 可以參考這篇文章 : <a href="https://toy9986619.medium.com/javascript-async-await-%E7%9A%84-race-condition-20927705569">JavaScript — async/await 的 race condition</a></p><blockquote><p>簡單來說跟執行順序有關</p></blockquote><p>以 <code>fetchData</code> 為例，我們用 async/await 簡化非同步的處理，內部的 fetch 是 Promise，如果在 pending 的時候又改變 state 重新獲取資料，就會發生問題。</p><p>例如 : 一開始搜尋 usa，在結果還沒返回時改成 peru，假設 usa 資料先回來並且顯示在畫面上，過一下子最終 peru 的 response 才會回來 。<strong>畫面等待 peru 資料回傳時顯示 usa 資料的時候 input 是 peru 呀 !</strong>  造成 UI 跟 state 對不上了😵。</p><p>如果要模仿此動作，可以到 devtool 的 network 並且自訂速度，這邊我訂了一個叫 <code>superslow</code>，把 Download 設為 1kb，讓回傳間隔變長就比較清楚問題。<br><img data-src="https://i.imgur.com/Hh8l045.png" alt="|400x220"></p><p>怎麼避免或是解決此狀況呢 ? 🤔</p><p>要知道 React 的 <code>useEffect</code> 並不會幫我們處理這個問題，最好的方式是可以讓非同步被中斷 (abort)，並且在 clean up 的階段取消。另外一個方法是，<strong>在把回傳資料放入 state 之前，用 <code>boolean</code> 檢查目前狀態是否要取消。</strong> 因為在執行下一個 effect 之前，會先執行 clean up function。</p><p>既然我們上面有實作，那就來改造上面的例子 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 👉 建立當次 render 的 didCancel</span></span><br><span class="line">    <span class="keyword">let</span> didCancel = <span class="literal">false</span>;</span><br><span class="line">    (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (query) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(baseurl + query).<span class="title function_">then</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> r.<span class="title function_">json</span>());</span><br><span class="line">        <span class="comment">// 檢查是不是有取消 ?</span></span><br><span class="line">        <span class="keyword">if</span> (!didCancel) &#123;</span><br><span class="line">          <span class="title function_">setData</span>(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">setMessage</span>(data.<span class="property">message</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 在下一個 effect 執行前，確定取消</span></span><br><span class="line">      didCancel = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">setMessage</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [query]);</span><br></pre></td></tr></table></figure><p>情境 :</p><ol><li>顯示畫面後改搜尋 usa</li><li>資料還沒返回，改成 peru</li></ol><p>我們來執行看看，從第一次 render 完之後 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input 改成 usa</span></span><br><span class="line">setState query = <span class="string">&quot;usa&quot;</span></span><br><span class="line">re-render <span class="variable constant_">UI</span></span><br><span class="line"></span><br><span class="line">clean up 清除 tw 副作用</span><br><span class="line">  state query <span class="string">&quot;tw&quot;</span></span><br><span class="line">  didCancel = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">effect 執行</span><br><span class="line">  state query <span class="string">&quot;usa&quot;</span></span><br><span class="line">  didCancel = <span class="literal">false</span></span><br><span class="line">  🚀<span class="keyword">async</span> <span class="keyword">function</span> 執行，進入 pending 狀態</span><br><span class="line"></span><br><span class="line"><span class="comment">// input 改成 peru</span></span><br><span class="line">  setState query = <span class="string">&quot;peru&quot;</span></span><br><span class="line">  re-render <span class="variable constant_">UI</span></span><br><span class="line"></span><br><span class="line">clean up 清除 usa 副作用</span><br><span class="line">  state query <span class="string">&quot;usa&quot;</span></span><br><span class="line">  didCancel = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">effect 執行</span><br><span class="line">  state query <span class="string">&quot;peru&quot;</span></span><br><span class="line">  didCancel = <span class="literal">false</span></span><br><span class="line">  🚀<span class="keyword">async</span> <span class="keyword">function</span>  執行，進入 pending 狀態</span><br><span class="line"></span><br><span class="line">👉 usa 資料回來了</span><br><span class="line">  usa clean effect 已經被呼叫，此時 didCancel 是 <span class="literal">true</span> 😵</span><br><span class="line">  ❌ setData 不會被執行</span><br><span class="line"></span><br><span class="line">👉 最後 peru 資料回來了</span><br><span class="line">  didCancel 是 <span class="literal">false</span> </span><br><span class="line">  setData 會執行</span><br><span class="line">  顯示 peru 資料</span><br></pre></td></tr></table></figure><p>一開始從上面看起來 <code>usa</code> 資料回來為什麼 <code>didCancel = true</code> 🤔，明明 <code>peru</code> 的 effect 執行了 <code>didCancel = false</code>。回到順序問題，在 <code>usa</code> 這個 render 時，我們的 <code>didCancel</code> 最後是什麼 ?</p><p>我一開始覺得很微妙，所以再回去複習 [[#談談 clean up]] 這個章節。</p><blockquote><p>每一個在 render 內部呼叫的 function (包含 handlers 、effect 等瀏覽器 APIs )，都會拿到當下定義的 state 。</p></blockquote><p>單看在 <code>usa</code> 這次 render 執行順序應該是 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">usa-didCancel = <span class="literal">false</span></span><br><span class="line">🚀<span class="keyword">async</span> <span class="keyword">function</span> 進行 fetch data</span><br><span class="line">  </span><br><span class="line">peru 的到來觸發了 use-clean up <span class="keyword">function</span></span><br><span class="line">  usa-didCancel = <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">usa 資料回來 data = ...</span><br><span class="line"><span class="keyword">if</span> (usa-didCancel = <span class="literal">true</span>)</span><br><span class="line">❌ setData 這行不會被執行</span><br></pre></td></tr></table></figure><p>在釐清概念的過程，我是使用 console 在每一個階段印出當時的 query ，幫助自己了解 effect 一值提到的 <strong>同步</strong> 概念</p><h2 id="用正確的心態對待-useEffect">用正確的心態對待 useEffect</h2><p><code>useEffect</code> 雖然很常被用在非同步讀取資料，但 <strong><code>useEffect</code> 是核心思想是來做同步的操作</strong>。 side effects 變成資料流的一部分，只要我們的當次 render 的資料同步，取得的資料也是一致的，對於邊際條件 (edge case) 的處理就會比較容易。</p><p>不過 React 在 18 版本對於處理非同步事件比較建議使用 <strong>Suspense</strong>。Suspense 是一個可以讓還沒準備好可以 render 的 UI 可以顯示預設的 Component ，主要要解決 2 個問題</p><ol><li>code splitting : 不用把一次所有 app 元件載下來，而是載必要的</li><li>data fetching : 解決像是上面提到的 race condition 問題</li></ol><p>不過 Suspense 我也還沒認真研究過 😵，先列入補坑大隊的名單吧</p><h2 id="總結-32">總結</h2><ol><li><code>useEffect</code> 是 render 與瀏覽器 painting 之後執行，目的是不阻攔螢幕的更新。</li><li><code>useEffect</code> deps array 如果是空的，僅執行一次，如果 array 有 state 或 props ，根據資料是否有改變，會跟著當次 render 之後重新呼叫。</li><li>每一次 render 都保有它所有的東西，包含 event handler、非同步 (async/await)、effect 或是 API ，以及當次 render 的 state 與 props。</li><li>想拿到最新的值可以使用 <code>refs</code>，refs 就像放在外部的盒子，React 確保它都指向同一記憶體位址，改變其值也不會造成 re-render。</li><li>clean up function 會在下一個 effect 呼叫之前先執行，注意 clean up 所清除的是上一次 render 的值。</li><li>不要欺騙 deps array，通常 lint 會提醒，但是遇到 object type 的值要小心，可能造成過度頻繁更新。</li><li><code>useEffect</code> 的 deps array 是否要放入相關 state 或 props ，可以視 effect function 中的 state 變化是否可由 <code>prevState</code> 推測出來，如果可以可使用 updater function 來更新。</li><li>useReducer 是可以讓資料跟邏輯分開操作的好方法。</li><li><code>useCallback</code> 是可以記住 render 內的 function，使其每次不應 re-render 而重新建立，或是透過 callback 的 deps array 來優化。如果不是 function 則可以使用 <code>useMemo</code> 記住某值。</li><li>function 在 function component 與 Hooks 中是一種資料流。它可以透過 props 來傳遞，也可以被判斷是否為 render 的條件之一。記住，此行為跟 class component 不一樣。</li><li>useEffect 是處理同步的操作，確保每一次 render  的 state 或 props 與 UI 具有一致性。</li></ol><p>本篇雖然著重於 <code>useEffect</code>  ，但對於新手一連貫認識 React 概念釐清很有幫助。讀完可以說是醍醐灌頂，從 class Component 到 function Component 的轉變，其解決的原因；function Component 使用的心智模型 (也就是核心概念)，更了解 Hooks 的思維與結合 JavaScript closure 的奧妙，讓人讀完有一種</p><blockquote><p>「原來是這樣的阿 !」</p></blockquote><p>雖然閱讀過程很艱辛😵，因為我是生啃英文版，沒有選擇中文是擔心無法領會翻譯者的意思，不是怕翻不好，而是擔心翻譯者水平太高，反而我看不懂🤣。幸好 Dan 大的文章本身對小白很友善，很值得用原文一讀👍</p><h3 id="題外話">題外話</h3><p>這段期間校正本篇文章時，FB 社團 <a href="https://www.facebook.com/groups/reactjs.tw/">ReactJS.tw</a>  也正好有大神做同樣的主題 <a href="https://slides.com/tz5514/useeffect-guide?fbclid=IwAR2VdZODJPO8Ex1Kd7PksCRA4dakIVvY-4aJ3X3ZtgfSwgq7hOGE6qHvcNc">都 2022 年了你還是可能不懂 useEffect</a>。整理出的脈絡清晰，也有提到 React 18 為什麼嚴格模式會執行兩次的問題。目前我還沒完全看完，但我認為看不同的人解釋同篇文章也是很有值得學習的地方，畢竟新手跟老手的認知起點不同😂，很慶幸正好在學習 useEffect  同時遇到大神的簡報與演講，遇到觀念卡住時，我也會翻到大神的簡報去彌補我不懂的地方。</p><p>有一度想以簡報的內容去重新整理文章，但想想這也我學習 useEffect 的原汁原味學習過程，就全保留了🤓。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">render 內部 function 的執行點 : <a href="https://codesandbox.io/s/w2wxl3yo0l">w2wxl3yo0l - CodeSandbox</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">function 版本 : setTimeout 之依序印出 state <a href="https://codesandbox.io/s/lyx20m1ol">lyx20m1ol - CodeSandbox</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">class 版本 : setTimeout 之全部同時一樣的 state <a href="https://codesandbox.io/s/kkymzwjqz3">kkymzwjqz3 - CodeSandbox</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://reactjs.org/docs/hooks-reference.html#functional-updates">Hooks API Reference – React – functional-updates</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章來自 : &lt;a href=&quot;https://overreacted.io/zh-hant/a-complete-guide-to-useeffect/&quot;&gt;useEffect 的完整指南 — Overreacted&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要-9&quot;&gt;摘要&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;useEffect 的基礎概念&lt;/li&gt;
&lt;li&gt;useEffect dependencies array 的使用方式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大部分都是來自原文的再翻譯，我有些比較不懂的部分就用自己的方式去解釋，也會用原始的 JS 實作的方式，跟著一步步編譯。&lt;/p&gt;
&lt;p&gt;更重要的是，要用 React 的思維來去了解 &lt;code&gt;useEffect&lt;/code&gt; 的內涵。&lt;/p&gt;</summary>
    
    
    
    <category term="Front-end" scheme="https://blog.rosa.tw/categories/Front-end/"/>
    
    <category term="React" scheme="https://blog.rosa.tw/categories/Front-end/React/"/>
    
    
    <category term="React" scheme="https://blog.rosa.tw/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | React - render props</title>
    <link href="https://blog.rosa.tw/2022/07/React/Render-props"/>
    <id>https://blog.rosa.tw/2022/07/React/Render-props</id>
    <published>2022-07-30T21:35:00.000Z</published>
    <updated>2022-07-31T13:25:13.573Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章來自 :</p><ol><li><a href="https://zh-hant.reactjs.org/docs/render-props.html">Render Props – React</a></li><li><a href="https://gist.github.com/heygrady/f9bf3b6dd93fe3d87ba87430fd3c20d5">Avoiding HOC; Favoring render props · GitHub</a></li></ol></blockquote><h2 id="摘要-7">摘要</h2><ol><li>什麼是 render props</li><li>render props 的應用範例</li><li>render props 與 HOC (higher order component) 的差別</li></ol><span id="more"></span><h2 id="什麼是-render-props">什麼是 render props</h2><p>render props 是一種把 props 當作 render function 的概念。<br>擁有 render props 的 Component 不會執行自己的 render 邏輯，或是可以想成把 children 當成 function 呼叫後回傳一個 <code>React.Element</code> 。</p><ul><li>這是一種 : 但是不見得一定要用 <code>props.children</code></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">AComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        /* 把 children 寫成 function 帶入*/</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>實際上只要 props 是 function ，而且在 render function 內部被呼叫</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">AComponent</span>(<span class="params">props</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Wrapper</span> <span class="attr">render</span>=<span class="string">&#123;props</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">/* 直接把 function 拆開來，可以直接接收 AComponent 的 state 與 props*/</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;&#125;/&gt;</span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接把 props.render 在內部呼叫</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Wrapper</span>(<span class="params">props</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;props.render(props)&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>叫不叫 <code>render</code> 都沒關係，這是種命名上的慣例而已。</p><p>如果使用過 <a href="https://blog.rosa.tw/2022/07/React/React-Context">Context Consumer</a>，Consumer 的另一個型態就是 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Context.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;props =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">/* 放在這裡面的 Component 都能透過 props 拿到 context value*/</span></span><br><span class="line"><span class="language-xml">&#125;&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Context.Consumer</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>好處是可以同時擁有多個 Provider 來使用，優點就顯示在動態上的資料結構。</p><h2 id="render-props-的結構">render props 的結構</h2><p>把 props 當作 function 直接傳入 <code>(props)=&gt; &lt;Component &#123;傳入想要的 props 與 state&#125;/&gt;</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">somethingwithToggle</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">render</span>=<span class="string">&#123;(props)</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">return (</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/* ✅在這裡就可以直接接收到資料，不用再經過另外的 Container 包住*/&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">AnthorComponent</span> <span class="attr">somevalue</span>=<span class="string">&#123;value&#125;</span> <span class="attr">someprop</span>=<span class="string">&#123;props.OOO&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">)</span></span><br><span class="line"><span class="language-xml">&#125;&#125;/&gt;</span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我自己看作 <strong>直接在 props 把 function 結構打開</strong> 到父元件直接使用，在內部的 Element 可以直接接收到 props 與 state。跟 HOC 比較而言，在使用結構上更一目了然。</p><p>由於 HOC 是將 Component 用 function 包起來，邏輯包在 function 內部 (封裝起來)，如果要知道傳入的 props name 還要把 HOC 所在的腳本打開來看。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 看不出來 Toggle 裡面傳什麼東西給 Navbar </span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NavbarwithToggle</span>  = <span class="title function_">withToggle</span>(<span class="title class_">Navbar</span>)</span><br></pre></td></tr></table></figure><p>另一個是動態與靜態的關係，render props 的 render 部分可以想填入任何結構的 JSX，而 HOC 類似 <strong>固定的模板</strong> (Container)，只能按照定義的格式填入。</p><ul><li>HOC</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最簡單的 HOC，這邊只能回傳被包住的結構</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">withToggle</span> = (<span class="params">Component</span>)=&gt; <span class="function">(<span class="params">props</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="comment">// 產生出來的結構 👉 </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Navbar</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>render props</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ToggleComponent</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span> <span class="attr">render</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">(<span class="attr">props</span>)=&gt;</span>(</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">// 任何結構，一個也可以</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">OnlyComponent</span> <span class="attr">open</span>=<span class="string">&#123;props.open&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">// Nested 也行</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NestedContainer</span> &#123;/*<span class="attr">也可以插入</span> <span class="attr">props</span> */&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">open</span>=<span class="string">&#123;props.open&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NestedContainer</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">)</span></span><br><span class="line"><span class="language-xml">&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">)</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="實際範例-2">實際範例</h2><p>可以先複習 HOC 的部份，會改寫來自 <a href="https://blog.rosa.tw/2022/07/React/Higher-Order-Component">HOC 實作練習</a>。</p><p>接下來我要做的 :</p><ol><li>將 <code>withToggle</code> 改成 render props 格式，叫 <code>&lt;Toggle/&gt;</code></li><li>用 <code>&lt;Toggle/&gt;</code> 把 Navbar 與 Accordion 包起來</li><li>實作 Push Canvas Navbar</li></ol><p>其實在 HOC 時有一種 Navbar 不太好做到，那就是向整個畫面推的 Navbar，因為 HOC 將結構給綁住了，結果只能控制 Component 本身，雖然可以用判斷的方式 (conditional rendering)，但會使得結構攏長 😵，接著會使用 <strong>render props</strong> 創建 Push Canvas Navbar。</p><p>在寫這篇的同時，我也在 HOC 也有補上 Push Canvas Navbar 的寫法 👉 <a href="https://codepen.io/shan473/pen/WNzjdmJ">React - HOC practice</a></p><h3 id="掰掰-withToggle-👋">掰掰 withToggle 👋</h3><p>通通砍掉 HOC 的部分，改成 Component 的形式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. props.render 是一個 function，render children</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Toggle</span>(<span class="params">&#123;render&#125;</span>) &#123;</span><br><span class="line"><span class="comment">// 2. 類似邏輯的 open 與 togglehandler</span></span><br><span class="line">  <span class="keyword">const</span> [open, setOpen] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">togglehandler</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setOpen</span>(<span class="function">(<span class="params">prevOpen</span>) =&gt;</span> !prevOpen);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/* 3. 👇 重點在這裡 render 是一個 function 負責渲染 React Element，參數是帶給 Element </span></span><br><span class="line"><span class="comment">  的 props</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;render(&#123; open, togglehandler &#125;)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>參數使用 object 比起使用 array ，用解構時不用管順序的問題。</p><h3 id="加上客製化的-Navbar">加上客製化的 Navbar</h3><p>基本上兩個元件的結構並沒有動到，而是將 HOC 中的 <code>withNavbarType</code> 改成 <code>&lt;CustomNavbar/&gt;</code>，並且改成傳入的 type 來判斷 <code>width</code> 的值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CustomNavbar</span>(<span class="params">&#123; type &#125;</span>) &#123;</span><br><span class="line"><span class="comment">// 1. displayName 是幫助 devtool 辨名稱，但是這裡有 BUG 😵😵😵，下面會說明</span></span><br><span class="line">  <span class="title class_">CustomNavbar</span>.<span class="property">displayName</span> = type + <span class="string">&quot;Navbar&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  <span class="comment">// 2. 把 Toggle 元件 render function 展開，並且把 props 直接傳給 Navbar</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">render</span>=<span class="string">&#123;(props)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">        return <span class="tag">&lt;<span class="name">Navbar</span> <span class="attr">type</span>=<span class="string">&#123;type&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    /&gt;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其實有點多此一舉，不過我原本是想要加上 displayName ，但這邊出 BUG 😵</p><h3 id="組合">組合</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  &#123;/* 1. 兩種 Navbar */&#125;</span></span><br><span class="line"><span class="language-xml">      Overlay:</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">CustomNavbar</span> <span class="attr">type</span>=<span class="string">&quot;Overlay&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      FullNavbar:</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">CustomNavbar</span> <span class="attr">type</span>=<span class="string">&quot;Full&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 2. Accordion */&#125;</span></span><br><span class="line"><span class="language-xml">        &#123;Array.from(&#123; length: 3 &#125;).map((_, i) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          return (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Toggle</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">key</span>=<span class="string">&#123;i&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">render</span>=<span class="string">&#123;(props)</span> =&gt;</span> <span class="tag">&lt;<span class="name">Accordion</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">index</span>=<span class="string">&#123;i&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">            /&gt;</span></span><br><span class="line"><span class="language-xml">          );</span></span><br><span class="line"><span class="language-xml">        &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其實 Navbar 也可以一起拆開，因為只有包住 Navbar 而已。如此一來，在結構上就可以看的出來在做什麼</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;/* 1. 透過 Navtype 直接取 name 生成，由於 Push Navbar 處理方式不一樣就另外用*/&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;Object.keys(Navtype).map((name, i) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        if (i === 2) return null;</span></span><br><span class="line"><span class="language-xml">        return (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;name&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Toggle</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">key</span>=<span class="string">&#123;name&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">render</span>=<span class="string">&#123;(props)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                return <span class="tag">&lt;<span class="name">Navbar</span> <span class="attr">type</span>=<span class="string">&#123;name&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="language-xml">              &#125;&#125;</span></span><br><span class="line"><span class="language-xml">            /&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">      &#123;<span class="comment">/* 2. 這裡的 Accordion 沒什麼差別，但比 HOC 少一層包裝 */</span>&#125;</span><br><span class="line">        &#123;<span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;).<span class="title function_">map</span>(<span class="function">(<span class="params">_, i</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">key</span>=<span class="string">&#123;i&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">render</span>=<span class="string">&#123;(props)</span> =&gt;</span> <span class="tag">&lt;<span class="name">Accordion</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">index</span>=<span class="string">&#123;i&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">            /&gt;</span></span><br><span class="line">          );</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後效果跟 HOC 一樣，不過 render props 是在結構上就很清楚看見自己在做什麼👌(看 devtools 的地方)<br><img data-src="https://i.imgur.com/YJChQnc.gif" alt="|420x400"></p><h3 id="Push-版本的Navbar">Push 版本的Navbar</h3><p>Push 版本需要把 <em>整個畫面往右推</em>，在結構上是長在 <code>root Element</code> 的鄰居，所以必須透過 <strong>Portal</strong> 來幫我們直接在 <code>root</code> 以外的節點生成 DOM 。</p><p>首先在 <code>html</code> 加上要長出的 <code>container</code>，叫 <code>push-navbar</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;push-navbar&quot;</span>&gt;</span>Push:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只有 Push 的 Navbar 結構不同，我希望把它獨立出來</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1. 拿到 Container 的 DOM */</span></span><br><span class="line"><span class="keyword">const</span> pushEl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;push-navbar&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">PushNavbar</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">/* 2. ReactDOM.createPortal 可以在指定的 Container 生成 element */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">render</span>=<span class="string">&#123;(props)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">      /* 4. 根據 open 讓 root 往右推移。我選擇不在 Navbar 裡面判斷，把它提到這裡 */</span></span><br><span class="line"><span class="language-xml">        React.useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          if (props.open) &#123;</span></span><br><span class="line"><span class="language-xml">            document.getElementById(&quot;app&quot;).style.marginLeft = &quot;250px&quot;;</span></span><br><span class="line"><span class="language-xml">          &#125; else &#123;</span></span><br><span class="line"><span class="language-xml">            document.getElementById(&quot;app&quot;).style.marginLeft = 0;</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">          /* 5. 記得加上 dependencies */</span></span><br><span class="line"><span class="language-xml">        &#125;, [props.open]);</span></span><br><span class="line"><span class="language-xml">        </span></span><br><span class="line"><span class="language-xml">    /* 6. render props Navbar ，並且把 Toggle 的資料塞回去，一樣要加上 type */</span></span><br><span class="line"><span class="language-xml">        return <span class="tag">&lt;<span class="name">Navbar</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">type</span>=<span class="string">&quot;Push&quot;</span> /&gt;</span>;</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    /&gt;</span>,</span><br><span class="line">    <span class="comment">/* 3. 第二個參數放 Container */</span></span><br><span class="line">    pushEl</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後把他加在 <code>&lt;App/&gt;</code> 裡面，雖然在裡面， Portal 只會在指定的 Container 生成。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;/* 在這裡加上 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">PushNavbar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* ... 略 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果 :<br><img data-src="https://i.imgur.com/zh8X6fB.gif" alt="|580x400"></p><h3 id="遇到的問題-CustomNavbar-的-displayName-錯誤">遇到的問題 :  CustomNavbar 的 displayName 錯誤</h3><p>因為 CustomNavbar 是用在只有固定移動寬度的 Navbar 上，為了方便 debug 加上了 displayName ，但是永遠只會顯示排在最後面改過名的 Navbar ，我用 console 印出 displayName 是兩個不同的，不過在 React devtools 卻顯示一樣的😵 ，實際上我也不知道發生什麼問題…</p><blockquote><p>如果有解答的大神，煩請寫信告訴我😢</p></blockquote><p><img data-src="https://i.imgur.com/2X0ATS6.png" alt="600x280"></p><h2 id="注意-render-props-使用在-Pure-Component">注意 : render props 使用在 Pure Component</h2><p>props 放入 function，Object Type 放在 render 會導致每次 re-render ，這在 [[…/React - 巢狀 Component 優化 &amp; anti-pure Pattern | Component 優化的問題]] 有提過，所以使用 render props 的方式，在 render 展開的 function 本身就不會是 Pure 的，如果裝有 render props 的元件要變成 Pure Component 可以把傳入 function 提出來，而不是每次 re-render 產生新的 function。</p><blockquote><p>簡單來說 : <code>&#123; &#125; !== &#123; &#125;</code></p></blockquote><p>把 render function 永遠指向相同的 function，以  <code>&lt;Toggle/&gt;</code> 為例</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 把 render function 提出來，🤔 是不是跟 HOC 有 87% 像</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderNavbar</span>(<span class="params">type</span>) &#123;</span><br><span class="line"><span class="comment">// 2. 這邊回傳的是一個 function 不是 element，因為我們要把 type 跟 props 同時帶進去</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Navbar</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">type</span>=<span class="string">&#123;type&#125;/</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 把這個帶 type 的 function 記起來</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FullwithToggle</span> = <span class="title function_">renderNavbar</span>(<span class="string">&quot;Full&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CustomNavbar</span>(<span class="params">&#123; type &#125;</span>) &#123;</span><br><span class="line">  <span class="title class_">CustomNavbar</span>.<span class="property">displayName</span> = type + <span class="string">&quot;Navbar&quot;</span>;</span><br><span class="line"><span class="comment">// 4. ✅ 記住傳進去的是一個 function ，不是 &quot;呼叫的&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span> <span class="attr">render</span>=<span class="string">&#123;FullwithToggle&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不能這樣，因為傳入的還是回傳新的 function，</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CustomNavbar</span>(<span class="params">&#123; type &#125;</span>) &#123;</span><br><span class="line">  <span class="title class_">CustomNavbar</span>.<span class="property">displayName</span> = type + <span class="string">&quot;Navbar&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span> <span class="attr">render</span>=<span class="string">&#123;renderNavbar(type)&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我準備兩個一樣的介面，一個 Toggle 傳入的 function 有被記憶起來，另一個沒有。<br>用 devtools 來看，App  state 改變 ，<code>&lt;CustomNavbar/&gt;</code> 也會 re-render。當 render props 的 function 被提出來， <code>&lt;Toggle/&gt;</code> 這邊不會進行 re-render，只會顯示 <code>parent render</code>；另一組則是會寫 <code>props changed(render)</code>。<br><img data-src="https://i.imgur.com/DB2jLnQ.png" alt=""><br>我覺得這樣的方法很類似 HOC ，結構上沒有太大的延展性， render 裡面的結構變成固定的，不過依然比 HOC 好一點。</p><h2 id="HOC-render-props-的組合技">HOC + render props 的組合技</h2><p>當然也可以使用 HOC 包住 render props 的方式，<strong>但反之是不行的</strong>，這也是為什麼 HOC 逐漸不備受用，而大部分推從 render props 的原因。</p><p>在 <strong>react-router v5</strong> 的<code> withRouter</code> 就採取 HOC 包住 render props 的方式，HOC 包出去的是 Pure Component 。在 <code>withRouter</code> 的部份，會改變 historyAPI 也就是顯示的網址 (SPA 並非真的執行跳轉的行為，而是改變 url 的長相)</p><p><code>withRouter</code> 的結構<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withRouter</span> = (<span class="params">Component</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">C</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; wrappedComponentRef, ...remainingProps &#125; = props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">render</span>=<span class="string">&#123;routeComponentProps</span> =&gt;</span> (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...remainingProps</span>&#125; &#123;<span class="attr">...routeComponentProps</span>&#125; <span class="attr">ref</span>=<span class="string">&#123;wrappedComponentRef&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;/&gt;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但在 v6 後 <code>withRouter</code> 就消失了，現今都改成 Hooks 版本，因為 Hooks 很香阿 (X</p><h2 id="render-props-v-s-HOCs">render props v.s HOCs</h2><p>當我學習 HOC 時，很多文章指出 render props 是比 HOC 更好的實作方式，從上面的實作大略知道超越的優點，接著要來深入更具體的原因。</p><p>根據這篇文章<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，來釐清幾個 HOC 的問題</p><h2 id="HOC-被淘汰的原因">HOC 被淘汰的原因</h2><ol><li>HOC 廣泛的被濫用，造成任何結構相同都得用來包。有些包裝成 HOC 卻<strong>沒有實行傳遞 props 或 method 的功能</strong>，失去它的核心意義。</li><li>造成 React tree 變得更複雜。這個概念就是 function 裡面不斷包 function，Call Stack 不斷往上疊加，加重效能上的負擔。</li><li>需要額外的動作兼容原始 Component 的行為。<ol><li>ref 的問題。不能直接加在 HOC 產生的 Component 上，必須透過 <strong>forwardref</strong> 承接 ref，再多包一層往下傳遞至 <code>WrappedComponent</code></li><li>Class Component 的 method 不會被傳遞，必須提升靜態 (static) 的 function 到 HOC 上來擴充。</li></ol></li></ol><p>這些缺點都有在 React 官方被提及<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>，也都有補救的方式。<br>更簡單來說，使用 HOC 要像補丁一樣，東補西補把它回還原成原本 Component 應有的東西，在有些時候多此一舉了。</p><ul><li>以文章的 <code>Row</code> 為例</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">import</span> hoistStatics <span class="keyword">from</span> <span class="string">&#x27;hoist-non-react-statics&#x27;</span></span><br><span class="line"><span class="keyword">import</span> classnames <span class="keyword">from</span> <span class="string">&#x27;classnames&#x27;</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./row.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getDisplayName</span> = (<span class="params">WrappedComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">WrappedComponent</span>.<span class="property">displayName</span> || <span class="title class_">WrappedComponent</span>.<span class="property">name</span> || <span class="string">&#x27;Component&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">row</span> = (<span class="params">&#123; backgroundColor, className, style &#125;</span>) =&gt; <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 產生合併的 Component</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">Row</span> = (<span class="params">&#123; wrappedComponentRef, ...otherProps &#125;</span>) =&gt; (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#123;classnames(styles.row,</span> <span class="attr">className</span>)&#125; <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">backgroundColor</span>, <span class="attr">...style</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">ref</span>=<span class="string">&#123;wrappedComponentRef&#125;</span> &#123;<span class="attr">...otherProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. displayName，因為由 HOC 包出來的元件通常不具名</span></span><br><span class="line">  <span class="title class_">Row</span>.<span class="property">displayName</span> = <span class="string">`Row(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 定義型別 : forward refs </span></span><br><span class="line">  <span class="title class_">Row</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">wrappedComponentRef</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 把 WrappedComponent 靜態的方法提升並繼承過來</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">hoistStatics</span>(<span class="title class_">Row</span>, <span class="title class_">WrappedComponent</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> row</span><br></pre></td></tr></table></figure><p>HOC 變得要遵守額外許多規則，因為本身突破 React 的基礎規定，導致要花其他的功能幫忙把 React 的功能補回去😵😵😵。</p><p>不如直接使用 <code>&lt;Row&gt;</code> 元件包裹裡面的東西</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Somewhere</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;/* ✅ 邏輯直接在這裡拆開，不用刻意包裝到 HOC，直接少一層結構 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Row</span> <span class="attr">backgroundColor</span>=<span class="string">&quot;green&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyThing</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Row</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>亦或者改成 render props :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MyThing</span> = (<span class="params">&#123; className, name, style &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Row</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">backgroundColor</span>=<span class="string">&#x27;green&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">className</span>=<span class="string">&#123;className&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">style</span>=<span class="string">&#123;style&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &#123;/* <span class="attr">render</span> */&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">render</span>=<span class="string">&#123;(&#123;</span> <span class="attr">visible</span> &#125;) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">      if (!visible) &#123;</span></span><br><span class="line"><span class="language-xml">        return null</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">      return `Hello, $&#123;name&#125;!`</span></span><br><span class="line"><span class="language-xml">    &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  /&gt;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>不過 <code>visible</code> 在那裏判斷 <code>null</code>，我感覺不太好🤔，應該在 <code>Row</code> 還沒 return 之前就要直接跳出了，在裡面判斷會導致 <code>Mything</code> 已經 <code>mount</code> 又多一次渲染 <code>unmout</code> 掉。</p><h2 id="小結-7">小結</h2><p>我覺得這篇還有提到一個有趣的問題，<strong>React-redux <code>connect</code> 為什麼不改為 render props ?</strong>， 因為 connect 內部還是 HOC ，因此有人發起討論希望可以改成 render props ，用 Component 的方式包裝，但是被駁回了<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>。主要當時 Hooks 的興起，團隊比較傾向改為 Hooks ，另外關鍵的點在於 render props 不是 Pure 的，會導致每次 re-render 都產生新的 <code>connect</code> ，造成效能問題，之後有時間再慢慢破解內部的 funciton 。</p><h2 id="總結-29">總結</h2><ol><li>傳入的 props 是一個 function，並且 render React Element，等同於 <code>props.children</code> 作為 function 並且傳入 props  為參數。</li><li>render props 要謹慎使用 Pure Component，因為 props 放入 function 每次 re-render 都是新 function ，本身就不 Pure。</li><li>render props &gt; HOCs。 React  composition Design Pattern 的選擇是 <strong>Hooks &gt; render props &gt; Hocs</strong></li></ol><p>HOC 與 render props</p><ul><li><strong>HOC</strong> : 一個 function 包住要擁有功能的 Component，並且產生新的加強版 Component。</li><li><strong>render props</strong> : 一個 Component 直接將其中一個 props 作為 function，並帶上 props 作為參數給內部使用。</li></ul><h2 id="補充閱讀">補充閱讀</h2><ol><li>React 關於 Design Pattern 的歷史補充 : <a href="https://segmentfault.com/a/1190000018811476?utm_source=sf-similar-article">【React深入】从Mixin到HOC再到Hook - SegmentFault 思否</a></li><li>一些關於 render props 常見的問題 : <a href="https://kentcdodds.com/blog/answers-to-common-questions-about-render-props#question-1-performance">Answers to common questions about render props</a></li></ol><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://github.com/remix-run/react-router/blob/v5.3.3/packages/react-router/modules/withRouter.js#L11">react-router/withRouter.js at v5.3.3 · remix-run/react-router · GitHub</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://gist.github.com/heygrady/f9bf3b6dd93fe3d87ba87430fd3c20d5">Avoiding HOC; Favoring render props · GitHub</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zh-hant.reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over">Higher-Order Components – React</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://github.com/reduxjs/react-redux/issues/799">Render props version of connect · Issue #799 · reduxjs/react-redux · GitHub</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章來自 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://zh-hant.reactjs.org/docs/render-props.html&quot;&gt;Render Props – React&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/heygrady/f9bf3b6dd93fe3d87ba87430fd3c20d5&quot;&gt;Avoiding HOC; Favoring render props · GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要-7&quot;&gt;摘要&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;什麼是 render props&lt;/li&gt;
&lt;li&gt;render props 的應用範例&lt;/li&gt;
&lt;li&gt;render props 與 HOC (higher order component) 的差別&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Front-end" scheme="https://blog.rosa.tw/categories/Front-end/"/>
    
    <category term="React" scheme="https://blog.rosa.tw/categories/Front-end/React/"/>
    
    
    <category term="React" scheme="https://blog.rosa.tw/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | React - Context API</title>
    <link href="https://blog.rosa.tw/2022/07/React/ContextAPI"/>
    <id>https://blog.rosa.tw/2022/07/React/ContextAPI</id>
    <published>2022-07-30T21:31:43.000Z</published>
    <updated>2022-07-31T10:17:44.968Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章來自 :</p><ol><li><a href="https://www.taniarascia.com/using-context-api-in-react/">Using Context API in React (Hooks and Classes) | Tania Rascia</a></li><li><a href="https://reactjs.org/docs/context.html#gatsby-focus-wrapper">Context – React</a></li></ol></blockquote><h2 id="摘要-4">摘要</h2><p>主要以 Class Component 為主</p><ol><li>使用 Context 的時機</li><li>如何使用 class Component 的 ContextAPI</li><li>Context 缺點</li></ol><span id="more"></span><h2 id="什麼時候用-Context">什麼時候用 Context ?</h2><p>在 React 中，當這個值想要共享的範圍很廣，擴及多個 Component ，意味著變成 <strong>global</strong> ，可以使用 Context 來避免 props 傳遞至太深的地方 (又稱 <code>props drilling</code>)。</p><p>常見使用 Context 範例 :</p><ul><li>使用者登入的狀態、資料 : 元件操作之權限</li><li>網頁主題 (theme) : 不同元件需要更換顏色</li><li>偏好語言 : 文字資料切換</li></ul><h2 id="或許不用-Context">或許不用 Context</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最上層接收 props 後往下傳</span></span><br><span class="line">&lt;<span class="title class_">Page</span> user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中間幫忙傳遞而已</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">PageLayout</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">avatarSize</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavigationBar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">avatarSize</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 內部終於拿到 props</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&#123;user.permalink&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Avatar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">size</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>user</code> 跟  <code>avatarSize</code> 不斷地被重複提到。<br>如果只是避免傳遞 props 到每一層，你應該做的是 <strong>提出來並重構<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></strong> (component composition)，而不是使用 Context 。</p><h2 id="Context-createContext">Context.createContext</h2><p>建立 Context，主要是建立 <code>Provider</code> 與 <code>Consumer</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(defaultValue);</span><br></pre></td></tr></table></figure><p>defaultValue 可以設定預設值，例如對於 <strong>主題</strong> 來說，可以先預設 <code>theme.dark</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> theme = &#123;</span><br><span class="line">   <span class="attr">light</span>: &#123;</span><br><span class="line">      background : <span class="string">&#x27;#fff&#x27;</span>;</span><br><span class="line">      text : <span class="string">&#x27;#000&#x27;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">dark</span>:&#123;</span><br><span class="line">      background : <span class="string">&#x27;#000&#x27;</span>;</span><br><span class="line">      text : <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(theme.<span class="property">dark</span>);</span><br></pre></td></tr></table></figure><p>並且 <strong>defaultValue 是給沒有被 Provider 包住 Component</strong>，對 Consumer 並沒有影響。</p><blockquote><p>Note: passing <strong>undefined</strong> as a Provider value does not cause consuming components to use defaultValue.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p></blockquote><p>如果把 Provider 的 value 設成 <code>undefined</code>，也不會是 defaultValue</p><p>👉試著實作 <a href="https://codepen.io/shan473/pen/XWEjrQy">React Context Provider value as undefined</a>。</p><h3 id="default-Value-的用意">default Value 的用意</h3><p>那我就好奇了，defalut value 的用意在哪裡 ?<br>我找到這篇</p><blockquote><p>This is helpful for testing components in isolation without wrapping them, or testing it with different values from the Provider.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p></blockquote><p>default value  是不在 Provider 裡面的 component，如果試圖用 Context 會拿到 createContext defalutValue 的值。</p><p>👉試著實作 <a href="https://codepen.io/shan473/pen/LYdRYZV?editors=0010">React Context - out of Provider component get Context</a></p><p>好處是提高測試性，可以獨立測試 component。</p><h2 id="Context-Provider">Context.Provider</h2><p>Context 翻譯是上下文，上有 Provider 下有 Consumer。<br>Provider 可以將提供 value 給 Consumer 使用 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Primative type</span></span><br><span class="line">&lt;<span class="title class_">Context</span>.<span class="property">Provider</span> value=&#123;<span class="string">&#x27;hello world&#x27;</span>&#125;&gt;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&lt;/<span class="title class_">Context</span>.<span class="property">Provider</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object type : 注意物件型別的問題</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;[1,2,3]&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   //...</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>每一個 Consumer 都會監聽 Provider value 的變化。<br>一個 Provider 底下可以有很多個 Consumer，也可以被底下的其他的 Provider 覆寫。</p><h3 id="render-的問題">render 的問題</h3><blockquote><p>當 Provider 的 value 改變時，所有的 Consumer (包含使用 contextType 與 useContext) 都會被強迫 re-render。</p></blockquote><p>變化是傳遞到所有 Consumer 元件，這種更新是不受 shouldComponentUpdate 控制，即使父層沒有變化，還是會被迫更新，</p><p>決定 value 改變的比較方式是 <code>Object.is</code>。</p><blockquote><p>[!NOTE] <strong><a href="http://Object.is">Object.is</a></strong> v.s === &amp; ==</p><ul><li><strong>==</strong> 會強制轉型，undefined、null 等等會被強制轉為 falsy</li><li><strong>===</strong> 比 == 多比較型別，但與 <a href="http://Object.is">Object.is</a> 不同的是</li></ul></blockquote><table><thead><tr><th>比較相同</th><th style="text-align:center">Number.NaN &amp; NaN</th><th style="text-align:center">+0 &amp; -0</th></tr></thead><tbody><tr><td><a href="http://Object.is">Object.is</a></td><td style="text-align:center">true</td><td style="text-align:center">false</td></tr><tr><td>===</td><td style="text-align:center">false</td><td style="text-align:center">true</td></tr><tr><td>==</td><td style="text-align:center">false</td><td style="text-align:center">true</td></tr></tbody></table><p>如果 value 是 Object type 會讓底下的子孫代 component 強迫 re-render，簡單來說 <code>&#123;&#125; !== &#123;&#125;</code> 或是 <code>[] !== []</code>。</p><h3 id="value-是-Object-Type-的問題">value 是 Object Type 的問題</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Context</span>.<span class="property">Provider</span> value=&#123;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;&gt;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&lt;/<span class="title class_">Context</span>.<span class="property">Provider</span>&gt;</span><br></pre></td></tr></table></figure><p>value 如果是物件型別，每次 render 都會重新建立，如果是頻繁變動的 context ，可以把控制權交給 React 的 state，<strong>提升 state 到 parent component</strong>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">value</span>: &#123;<span class="attr">something</span>: <span class="string">&#x27;something&#x27;</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Toolbar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Consumer">Consumer</h2><p>Consumer 使用的 context 是在樹狀中最鄰近 Provider 的 value。<br>class Component 建立 Consumer 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 種方式，並且用於不同情境</p><ol><li><code>&lt;Context.Consumer&gt;</code> :<ul><li>僅有 <code>render()</code> 可以使用</li><li>可以同時使用多個 Context</li><li>優化 Context ，拆分成好幾個 Consumer</li></ul></li><li><code>contextType</code> :<ul><li>所有生命週期內可以使用，並使用 <code>this.context</code> 取得值</li><li>只能應用一個 context</li></ul></li></ol><p>在 Hooks 中只要用到 <code>useContext</code> 就可以拿到 context value。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>)</span><br></pre></td></tr></table></figure><h3 id="Class-contextType">Class.contextType</h3><p><strong>在生命週期內使用 context</strong>，可以在 class 內部加上 static 的 contextType，或是在外部加。<br>使用時可以直接用 <code>this.context</code> 取得 value 的值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyContext</span> <span class="keyword">from</span> <span class="string">&#x27;./MyContext&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在外部指定</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">contextType</span> = <span class="title class_">MyContext</span>;</span><br></pre></td></tr></table></figure><p>也可以使用 class 中的 <code>static</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">   <span class="keyword">static</span> contextType = <span class="title class_">MyContext</span></span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Context-Consumer">Context.Consumer</h3><p>有別於 <code>this.context</code> 的方式，<code>Context.Consumer</code> 是透過 <strong>props</strong> 取的 context 的值，就像 functional component 一樣，使用 props 並 return React Node。<br>這種方式是 Render Props<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> 的技巧，等同把 React Element 當作 props 來傳遞。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>(</span><br><span class="line">         <span class="language-xml"><span class="tag">&lt;<span class="name">MyContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           &#123; props =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                 return (</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                       &#123;props.value&#125;</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                 )</span></span><br><span class="line"><span class="language-xml">              &#125;   </span></span><br><span class="line"><span class="language-xml">           &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">MyContext.Consumer</span>&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Context-displayName">Context.displayName</h2><p>替 context 取別名，在 React 的開發工具之下，會使用 displayName 的值來顯示這個 context。<br>我比較常看見在 UI 函式庫看到這樣的用法，例如 : <a href="https://github.com/react-bootstrap/react-bootstrap/blob/master/src/AccordionContext.ts">React-Boostrap - Accordion</a></p><p>範例 :</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = <span class="title class_">React</span>.<span class="property">createContext</span>&lt;<span class="title class_">AccordionContextValue</span>&gt;(&#123;&#125;);</span><br><span class="line">context.<span class="property">displayName</span> = <span class="string">&#x27;AccordionContext&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context;</span><br></pre></td></tr></table></figure><p>如果在同一個 Component 有多個 Provider ，在 DevTools 只會出現 <code>Context.Provider</code><br><img data-src="https://i.imgur.com/TCVpxYH.png" alt="#small"><br>重複的 Context.Provider 造成 Debug 困難，這時候可以使用 displayName 將不同 context 分開。</p><h2 id="Multiple-Context">Multiple Context</h2><p>最好不要把所有用到的值都塞進同一個 Context，這就會導致非相關的 component 強制更新，優化的方式就是拆成好幾個 Provider 與 Consumer ，將明確的界線劃分出來。</p><p>範例 :  theme 跟 user 分開成不同的 context</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Content</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;theme =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">UserContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;user =&gt; (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ProfilePage</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          )&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">UserContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Context-的優缺點">Context 的優缺點</h2><ul><li>優點<ol><li>改善 props drilling 的問題，跳過 intermediate component ，把值直接給想要的 component。</li><li>在小型的 APP 中，可以快速解決 global 的問題，不用用到 React-Redux</li></ol></li><li>缺點<ol><li>效能上的問題，只要 value 中的值更新，其底下所有套上 Consumer 的元件也會被強迫更新</li><li>當 APP 擴展共享值越多時，使用 Context 會造成效能上的問題。</li><li>不適合用 <strong>頻繁</strong> 改變的值</li><li>耦合性高，不好做測試</li></ol></li></ul><h2 id="如何改善-Context-的效能問題">如何改善 Context 的效能問題</h2><p>Dan 大提供 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span>  種優化 Context 的方式<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>，主要以 Hooks 為主。</p><ol><li>分開不同的 Context，跟上面 [[#Multiple Context | 多個 Context]] 是一樣的意思，只有用到 theme 就拆成 themeContext，不要跟其他 Context 包在一起。<strong>分開 Context 這是最好的方式</strong></li><li><code>memo</code> 作為 component 的 props 觀察需要<strong>需要變化的 value</strong>。<br>Button 主要是接收 Context 的容器，將 theme 給分離出來。</li></ol> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> appContextValue = <span class="title function_">useContext</span>(<span class="title class_">AppContext</span>);</span><br><span class="line">   <span class="comment">// 把 theme 從 Context 提取出來</span></span><br><span class="line">   <span class="keyword">let</span> theme = appContextValue.<span class="property">theme</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ThemedButton</span> <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 當 theme 沒有改變的時候，就不會 re-render</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemedButton</span> = <span class="title function_">memo</span>(<span class="function">(<span class="params">&#123; theme &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 剩下的邏輯</span></span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ExpensiveTree</span> <span class="attr">className</span>=<span class="string">&#123;theme&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li><code>useMemo</code> : 如果全部塞在同一個地方，這裡的 <code>useMemo</code> 記住 React Element，並監聽 theme 是不是有改變。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> appContextValue = <span class="title function_">useContext</span>(<span class="title class_">AppContext</span>);</span><br><span class="line">  <span class="keyword">let</span> theme = appContextValue.<span class="property">theme</span>; <span class="comment">// Your &quot;selector&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// The rest of your rendering logic</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ExpensiveTree</span> <span class="attr">className</span>=<span class="string">&#123;theme&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;, [theme])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>memo</code> 與 <code>useMemo</code> 都是額外交給 React 處理，因此效能上不一定保證能優化，是需要去權衡的 (React 將優化流程的方式稱作 <strong>bailout</strong>)。</p><h2 id="總結-25">總結</h2><ul><li>建立 Context 使用 <code>createContext()</code></li><li>Context 提供 <code>Provider</code> 與 <code>Consumer</code>，Provider 的 <code>value</code> props 就是傳遞下去的值；接住值使用 Consumer 。</li><li>如果 value 是 Object type ，最好提到 Component 之外建立，或者只用 state 。</li><li>不相干的 Context 最好分開來，避免造成效能上不必要的 render</li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://reactjs.org/docs/composition-vs-inheritance.html#containment">Composition vs Inheritance – React</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://reactjs.org/docs/context.html#reactcreatecontext">Context -  default Value – React</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">default 的用意 :  <a href="https://stackoverflow.com/questions/49949099/react-createcontext-point-of-defaultvalue">javascript - React.createContext point of defaultValue? - Stack Overflow</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">把 React Element 當作 props 傳遞<a href="https://reactjs.org/docs/render-props.html">Render Props – React</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">Context 預防 re-render : <a href="https://github.com/facebook/react/issues/15156#issuecomment-474590693">Preventing rerenders with React.memo and useContext hook. · Issue #15156 · facebook/react · GitHub</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章來自 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.taniarascia.com/using-context-api-in-react/&quot;&gt;Using Context API in React (Hooks and Classes) | Tania Rascia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://reactjs.org/docs/context.html#gatsby-focus-wrapper&quot;&gt;Context – React&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要-4&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;主要以 Class Component 為主&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 Context 的時機&lt;/li&gt;
&lt;li&gt;如何使用 class Component 的 ContextAPI&lt;/li&gt;
&lt;li&gt;Context 缺點&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Front-end" scheme="https://blog.rosa.tw/categories/Front-end/"/>
    
    <category term="React" scheme="https://blog.rosa.tw/categories/Front-end/React/"/>
    
    
    <category term="React" scheme="https://blog.rosa.tw/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | React - Higher Order Component (HOC)</title>
    <link href="https://blog.rosa.tw/2022/07/React/Higher-Order-Component"/>
    <id>https://blog.rosa.tw/2022/07/React/Higher-Order-Component</id>
    <published>2022-07-26T22:30:10.000Z</published>
    <updated>2022-07-31T10:19:43.042Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章來自 :</p><ol><li><a href="https://zh-hant.reactjs.org/docs/higher-order-components.html">Higher-Order Components – React</a></li></ol></blockquote><h2 id="摘要-6">摘要</h2><ol><li>了解 HOC 的運作原理，以及意義</li><li>HOC 的架構與實作</li><li>HOC 應用上的注意事項</li></ol><span id="more"></span><h2 id="什麼是-Higher-Order-Component">什麼是 Higher Order Component  ?</h2><p>HOC 是一個 function，把另一個元件的邏輯包起來，產生新的 <strong>加強版</strong> 元件， 使元件內部的邏輯可以重複使用。而且不會動到原本 Component 的結構，而是加上 HOC 帶來的功能。</p><p>被共用的邏輯是封裝在裡面，大部分第三方 library 都是這麼使用。<br>例如 : react-redux 裡 <code>connect()</code> 就是一個 HOC。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">NewComponent</span> = <span class="title function_">connect</span>(<span class="title class_">StoreProp</span>,<span class="title class_">StateProps</span>)(<span class="title class_">Component</span>);</span><br></pre></td></tr></table></figure><blockquote><p>HOC 的重點是減少類似功能元件的 <strong>重複邏輯</strong>，提高元件的重用性 (reusable)。</p></blockquote><p>舉個實際例子，todolist 具有 toggle 功能，也很多個 button 也有 (切換背景顏色啦等等)，兩者具有 <code>open State</code> 並且 <code>setOpen</code> 只負責切換 true &amp; false 。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 這一段邏輯不斷的重複撰寫，把它提出來 做成 withToggle，把 toggle 功能封裝</span></span><br><span class="line"><span class="keyword">const</span> [open,setOpen] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleToggle</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line"><span class="title function_">setOpen</span>(<span class="function">(<span class="params">prevOpen</span>)=&gt;</span> !prevOpen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toggle 這個邏輯要被抽成可重複性的邏輯，所以 HOC 可以是一個叫 <code>withtoggle(&lt;Component/&gt;)</code>，又稱具有 toggle 功能, 的 Component。</p><h2 id="HOC-的架構">HOC  的架構</h2><p>最基本的架構是包裹著另一個 Component，回傳的是一個新的 Component。其他參數可以自訂，也可以傳入想要共同使用 data。</p><blockquote><p>HOC 是一個 pure function (same input ,same output)，不具有副作用 (side effects)</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">NewComponent</span> = <span class="title function_">higherFunction</span>(<span class="title class_">WrappedComponent</span>);</span><br></pre></td></tr></table></figure><p>HOC <strong>不是用繼承的方式</strong> 來產生新的 Component ，而是 <strong>composed</strong> (重組)。<br>可以看是一個新容器 (Container)。其參數是不限的，另外 HOC 不管資料的來源出處，它只是負責開一個通道，讓被包住的 Component 省去做重複動作。</p><p>functional Component</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">EnhancedComponent</span> = (<span class="params">WrappedComponent</span>) =&gt;&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">props</span>)&#123;</span><br><span class="line"><span class="comment">// 記得把 props 還回去</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class Component</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">EnhancedComponent</span> = (<span class="params">WrappedComponent</span>) =&gt;&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span>&#123;</span><br><span class="line"><span class="keyword">return</span>()&#123;</span><br><span class="line"><span class="comment">// 一樣要把 props 還回去</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡的 <code>&#123;...props&#125;</code> 是 <code>&lt;NewComponent&gt;</code> 傳入的 props。</p><p>例 : <code>&lt;WithToggleCompoent index=&quot;1&quot;/&gt;</code> 像是 index 這個 props，在不影響原本 <code>&lt;WrappedComponent/&gt;</code>情況下把 <code>props</code> 都塞回去。如果沒有 <code>&#123;...props&#125;</code> 這步驟，就不會接收到 HOC 包裹的效果。</p><h2 id="橫切關注點-Cross-cutting-concern">橫切關注點 (Cross-cutting concern)</h2><p>邏輯是透過 HOC 攜帶的，並不是硬生生嵌入在某元件的程式碼中，有助於 <strong>橫切關注點</strong>。</p><p>範例情境 :</p><ol><li>有一 a 元件需要附帶 A 功能，功能 A 被開發，由於目前只有 a 元件需要，直接將邏輯寫死在 a 元件上。</li><li>某一天 a 元件需要被更新改成 b 元件，其中 A 功能需要被保留，其餘都不要，這時候需要挖出 A 功能的代碼並進行重構。</li><li>那如果某天 b 元件又不要 A 功能呢 ?</li></ol><blockquote><p>導致元件的代碼就會一直被重構😵，是很糟的行為</p></blockquote><p>橫切關注點的概念使得 A 功能被抽取出來，並採用 <strong>添加</strong> 的方式加到需要的元件身上。邏輯被分開的狀況，如果突然不想要 A 功能隨時都抽取掉，原本的元件也不會被受影響。</p><p>HOC 之所以說是加強版的元件，它追加新的功能在原本的元件上，但也不影響原本的元件。</p><h2 id="實作練習">實作練習</h2><p>codepen 👉 <a href="https://codepen.io/shan473/pen/WNzjdmJ">React - HOC practice</a></p><p>凡是有操作開開關關的 Component ，包成 <code>withToggle</code> 的 HOC，把同樣的 <strong>開關邏輯</strong> 抽出來。以 W3school 的 <a href="https://www.w3schools.com/howto/howto_js_sidenav.asp">Navbar</a> 與 <a href="https://www.w3schools.com/howto/howto_js_accordion.asp">Accordion</a> 為例。</p><h3 id="HOC-withToggle">HOC withToggle</h3><ul><li>建立一個 HOC - <code>withToggle</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withToggle</span> = (<span class="params">Component</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [open,setOpen] =<span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">togglehandler</span> = (<span class="params"></span>)=&gt; &#123;<span class="title function_">setOpen</span>(<span class="function"><span class="params">prevOpen</span> =&gt;</span> !prevOpen)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">open</span>=<span class="string">&#123;open&#125;</span> <span class="attr">togglehandler</span>=<span class="string">&#123;togglehandler&#125;</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span> </span><br><span class="line">    )</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 </span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AccordionWithToggle</span> =  <span class="title function_">withToggle</span>(<span class="title class_">Accordion</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NavbarWithToggle</span> = <span class="title function_">withToggle</span>(<span class="title class_">Navbar</span>);</span><br></pre></td></tr></table></figure><p>主要傳入的 props 是 <code>open</code> 的 state ，與 <code>togglehandler</code> 這個 method</p><h3 id="Accordion">Accordion</h3><p>基本的 Accordion (手風琴)，手風琴最重要的就是改變 <code>maxheight</code> 讓內容伸縮。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Accordion</span>(<span class="params">&#123;open,togglehandler,index&#125;</span>)&#123;</span><br><span class="line"><span class="comment">// 1. 內容的高度資料</span></span><br><span class="line"> <span class="keyword">const</span> [panelheight,setPanelHeight] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> 2. 使用 callback ref，透過 ref 拿到 DOM 內容的高度，並根據 開關 open 來決定高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">const</span> panelref = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="function">(<span class="params">node</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(node!==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!open)&#123;</span><br><span class="line">          <span class="title function_">setPanelHeight</span>(node.<span class="property">scrollHeight</span>)</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="title function_">setPanelHeight</span>(<span class="number">0</span>)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,[open])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">  &#123;/* 3. 填入 HOC 傳入的 togglehandler */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;accordion&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;togglehandler&#125;</span>&gt;</span>Section &#123;index+1&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#123;/* 4. 改變 maxHeight */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;panel&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;panelref&#125;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">maxHeight:</span> <span class="attr">panelheight</span>+&#x27;<span class="attr">px</span>&#x27;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Navbar-fullwidth">Navbar fullwidth</h3><p>重點是改變 <code>width</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Navbar</span>(<span class="params">&#123;open,togglehandler,type&#125;</span>)&#123;</span><br><span class="line"><span class="comment">// 1. width 的 state </span></span><br><span class="line">  <span class="keyword">const</span> [width,setWidth] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 監聽 open 的變化</span></span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(open)&#123;</span><br><span class="line">      <span class="title function_">setWidth</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="title function_">setWidth</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,[open])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   &#123;/* 3. 改變 width */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;sidenav&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">width</span> <span class="attr">:</span> <span class="attr">width</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span> <span class="attr">className</span>=<span class="string">&quot;closebtn&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;togglehandler&#125;</span>&gt;</span><span class="symbol">&amp;times;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Services<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Clients<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 4. 填入 HOC 傳入的 togglehandler */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;togglehandler&#125;</span>&gt;</span>open<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果">效果</h3><p><img data-src="https://i.imgur.com/6tr37Nj.gif" alt=""><br>如此一來我們只要幫元件包上 <code>withToggle</code> 都可以擁有開開關關的功能。<br>看到 w3school 的 Navbar 範例有很多款，我決定再來實作可以依照不同類型產生客製化的 Navbar😎。</p><h3 id="再包裝-Navbar-withNavbarType">再包裝 Navbar : withNavbarType</h3><p>不同的 type ， width 不一樣。一開始新增 type 的參數來達成效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 Object bracket notation 的特性，帶字串當索引</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Navtype</span> = &#123;</span><br><span class="line">  <span class="title class_">Full</span> : <span class="string">&#x27;100%&#x27;</span>,</span><br><span class="line">  <span class="title class_">Overlay</span>: <span class="string">&#x27;250px&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">withNavbarType</span> =(<span class="params">CoreComponent,type</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">CoreComponent</span> <span class="attr">type</span>=<span class="string">&#123;Navtype[type]&#125;</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FullNavbar</span> = <span class="title function_">withNavbarType</span>(<span class="title function_">withToggle</span>(<span class="title class_">Navbar</span>,<span class="string">&#x27;Full&#x27;</span>))</span><br></pre></td></tr></table></figure><p>但又覺得這樣很不優雅😵，想變成 <code>const FullNavbar = customNavbar(type)</code> ，讓每次輸入都只剩一個參數 (柯里化)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Navtype</span> = &#123;</span><br><span class="line">  <span class="title class_">Full</span> : <span class="string">&#x27;100%&#x27;</span>,</span><br><span class="line">  <span class="title class_">Overlay</span>: <span class="string">&#x27;250px&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 讓 type 成為最後一個參數，只要添入對應字串就好</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">withNavbarType</span> =(<span class="params">CoreComponent</span>)=&gt; <span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">CoreComponent</span> <span class="attr">type</span>=<span class="string">&#123;Navtype[type]&#125;</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 把原本的功能加一加，變成 客製化的 Navbar</span></span><br><span class="line"><span class="keyword">const</span> customNavbar = <span class="title function_">withNavbarType</span>(<span class="title function_">withToggle</span>(<span class="title class_">Navbar</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 帶入想要的 style string 就可以產生對應的 Navbar</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FullNavbar</span> = <span class="title function_">customNavbar</span>(<span class="string">&#x27;Full&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OverlayNavbar</span> = <span class="title function_">customNavbar</span>(<span class="string">&#x27;Overlay&#x27;</span>)</span><br></pre></td></tr></table></figure><p>接著修改 <code>&lt;Navbar/&gt;</code> 的其中一個部份</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(open)&#123;</span><br><span class="line"><span class="comment">// 改成按照 prop 傳入的 type 改變 width</span></span><br><span class="line"><span class="title function_">setWidth</span>(type)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">setWidth</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,[open])</span><br></pre></td></tr></table></figure><p>搭啦 ! 就可以擁有不同的客製化 Navbar。<br><img data-src="https://i.imgur.com/Hq7kYZg.gif" alt=""><br>好處是 <strong>不用在原本的 Navbar 元件內判斷 type 是什麼才做不同的 width 變化</strong> ，只要專注在 Navbar 的功能就好。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 我覺得不是很好的 pattern</span></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// 😵 如果沒有抽出來，在元件裡面判斷</span></span><br><span class="line"><span class="keyword">let</span> finallywitdh;</span><br><span class="line"><span class="keyword">switch</span>(type)&#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;Full&#x27;</span>:</span><br><span class="line"> finallywitdh = <span class="string">&#x27;100%&#x27;</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;Overlay&#x27;</span>:</span><br><span class="line">finallywitdh = <span class="string">&#x27;250px&#x27;</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(open)&#123;</span><br><span class="line"><span class="title function_">setWidth</span>(finallywitdh)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">setWidth</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,[open])</span><br></pre></td></tr></table></figure><p>在這個 Navbar 例子中，我使用 HOC 在包裹著另一個 HOC，讓元件可以往上追加想要的資料或功能。</p><h2 id="慣例-使用-HOC-傳遞不相關的-props">慣例 : 使用 HOC 傳遞不相關的 props</h2><p>慣例是 React 官方建議的操作習慣。<br><a href="https://zh-hant.reactjs.org/docs/higher-order-components.html#convention-pass-unrelated-props-through-to-the-wrapped-component">🔗章節連結</a></p><p>有些 props 傳進來可能是 <strong>作為運算使用</strong>，傳入的 props 並非全部都要傳進 <code>&lt;WrappedComponent/&gt;</code> 而是經過一些運算後留下 <code>&lt;WrappedComponent/&gt;</code> 需要的。</p><p>通常會傳給 <code>&lt;WrappedComponent/&gt;</code> 的 props 通常是 state 或是在 HOC 定義的 method。</p><blockquote><p>重點在於 <strong>只關注想要的資料</strong>，可以在 HOC 傳入不相關的沒關係，HOC 的 props 傳至 <code>&lt;WrappedComponent/&gt;</code> 之前可以篩選出哪些 props 要繼續傳下去。</p></blockquote><p>這樣的好處是讓 HOC 更加彈性化。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  props 傳進來的不一定跟 WrappedComponent 有直接關係，HOC 是一個容器，將關注於想要的資料傳給 WrappedComponent</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">const</span> &#123; extraProp, ...passThroughProps &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  特別提出要被傳入的 props，通常是 state 或是 methods </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">const</span> injectedProp = someStateOrInstanceMethod;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用 props 傳給 WrappedComponent</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">injectedProp</span>=<span class="string">&#123;injectedProp&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &#123;<span class="attr">...passThroughProps</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以官方的例子來說，HOC 包含資料，但是資料在 A 元件中只要 a 部分，B 元件中只要 b 部分，但他們的 <strong>來源都是同一個資料</strong>。</p><p>這時候可以透過傳入的 prop 拿出不同的資料，傳進 <code>&lt;WrappedComponent/&gt;</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withData</span> = (<span class="params">Component,data</span>)=&gt;&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// 1. 不同的 props 抽出來</span></span><br><span class="line"><span class="keyword">const</span> &#123;dataType,...restprops&#125; = props</span><br><span class="line"><span class="comment">// 2. 按照 type 再來取出不同的 data</span></span><br><span class="line"><span class="keyword">const</span> needData = data.<span class="title function_">filter</span>( <span class="function"><span class="params">x</span> =&gt;</span> x === dataType)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">data</span>=<span class="string">&#123;needData&#125;</span> &#123;<span class="attr">...restprops</span>&#125;/&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一開始我有點看不懂這個例子，想不到應用的例子。原本只知道可以 <strong>加功能</strong>，但沒有想過類似分類篩的概念，經過幾次的實作突然就悟了😂。</p><h2 id="慣例-最大化的可組合性-Maximizing-Composability">慣例 : 最大化的可組合性 (Maximizing Composability)</h2><p>HOC 的寫法可以只回傳一個參數，也可以回傳好幾個參數。HOC 並沒有特別限制傳遞的參數量，但是那顯得很冗長，盡可能讓 HOC 只接收一個參數。</p><p>像 React-redux，使用 <code>connect()()</code> 這樣呈現</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ConnectedComment</span> = <span class="title function_">connect</span>(commentSelector, commentActions)(<span class="title class_">CommentList</span>);</span><br></pre></td></tr></table></figure><p>把上面的分開解析 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// connect 是一個 function ，功能是回傳另一個 function</span></span><br><span class="line"><span class="keyword">const</span> enhance = <span class="title function_">connect</span>(commentListSelector, commentListActions);</span><br><span class="line"><span class="comment">// 回傳的是一個 HOC，是跟 Redux store 連結的 Component</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ConnectedComment</span> = <span class="title function_">enhance</span>(<span class="title class_">CommentList</span>);</span><br></pre></td></tr></table></figure><blockquote><p>簡單來說 : HOC 包住另一個 HOC</p></blockquote><p>如果 HOC 數量一多，寫起來就會變得很冗長，這時候可以運用 compose (組合) 的概念</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 😵 不應該一層包一層</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">EnhancedComponent</span> = <span class="title function_">withRouter</span>(<span class="title function_">connect</span>(commentSelector)(<span class="title class_">WrappedComponent</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以運用一個 function 將傳入的 HOC 打包成捆，compose 是別處地定義組合 function 的方法</span></span><br><span class="line"><span class="keyword">const</span> enhance = <span class="title function_">compose</span>(</span><br><span class="line">  <span class="comment">// 這邊的 HOC 只接收一個參數</span></span><br><span class="line">  withRouter,</span><br><span class="line">  <span class="title function_">connect</span>(commentSelector)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">EnhancedComponent</span> = <span class="title function_">enhance</span>(<span class="title class_">WrappedComponent</span>)</span><br></pre></td></tr></table></figure><p>也有其他的 library 可以幫助把 HOCs 打包成捆，例如 :</p><ul><li>lodash.flowRight</li><li>Redux</li><li>Ramda</li></ul><h2 id="慣例-用-displayName-取名字幫助-Debug">慣例 : 用 displayName 取名字幫助 Debug</h2><p>HOCs 是 Container 的概念，如果結構上是使用 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withToggle</span> = (<span class="params">WrappedComponent</span>)=&gt; <span class="function">(<span class="params">props</span>)=&gt;</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名的 arrow function，在 Debug 會傻傻搞不清楚。</p><p>從實作範例打開 devtool 來看，用 HOC 包過的元件都只顯示 <strong>Anonymous</strong><br><img data-src="https://i.imgur.com/V4Uk0fb.png" alt="|200x250"></p><p>Navbar 有 <code>Full</code> 跟 <code>Overlay</code> 兩種，但在這邊是看不出來的。主要原因就是上面提到的結構，重點是 <strong>讓內部的 function 擁有名字</strong>，必須獨立出來。可以先把它一步步給解開來</p><ul><li>在內部取名 :</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withToggle</span> = (<span class="params">WrappedComponent</span>)=&gt; &#123;</span><br><span class="line"><span class="comment">// 第一種 : 直接寫成 function statements</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">newComponent</span>(<span class="params">props</span>)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二種 : 寫成 function expressions</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">newComponent</span> = (<span class="params">props</span>)=&gt;&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 讓被包成 HOC 的元件拿到原本 WrappedComponent 的名稱(例如 : &quot;Navbar&quot;)</span></span><br><span class="line">newComponent.<span class="property">displayName</span> = <span class="string">`withNavbarType(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class="line"><span class="keyword">return</span> newComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 官方寫法 : 讀取到被包裹的元件原名稱 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDisplayName</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">WrappedComponent</span>.<span class="property">displayName</span> || <span class="title class_">WrappedComponent</span>.<span class="property">name</span> || <span class="string">&#x27;Component&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>外部命名 : 直接替生產出來的 HOC 命名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一種 : 直接附加屬性</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AccordionwithToggle</span> =  <span class="title function_">withToggle</span>(<span class="title class_">Accordion</span>);</span><br><span class="line"><span class="title class_">AccordionWithToggle</span>.<span class="property">displayName</span> = <span class="string">&quot;withToggleAccordion&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二種 : Object.assign，物件上 + 物件屬性</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AccordionwithToggle</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title function_">withToggle</span>(<span class="title class_">Accordion</span>),&#123;</span><br><span class="line"><span class="attr">displayName</span>: <span class="string">&#x27;withToggleAccordion&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img data-src="https://i.imgur.com/e3103Wo.png" alt="|250x250"><br><code>withToggle</code> 我沒有在內部命名，而是在 <code>Accordion</code> HOC 上命名，所以自然在 <code>Navbar</code> withToggle 會看到匿名。</p><p>displayName 這個屬性是 React 提供我們替 Component 取不同的名稱時，在 devtools 上觀察，方便 Debug。<br>如果有使用 Context API ，其實也是同個概念，Context 中的 Provider 可以放在 APP 以下的樹狀位置，也可能出現複數個，這時候可以替 Context 命名方便查看。</p><p>在內部取名就是讓 function 露出名字，雖然 <code>function expressions</code> 對於內部是匿名的，但我們只在乎最外部 function 的名稱。</p><p>另外像上面寫的 <code>withNavbarType()</code> 這樣包裹起來，括號以外的會在外部 (圖中灰色方塊區)，類似 Component 的附加訊息，但被括號包裹住的最裡面才是顯示元件的 displayName。</p><h2 id="注意-不要直接修改到原本的-Component">注意 : 不要直接修改到原本的 Component</h2><ul><li><p>假如我們要操作有關元件的生命週期，不應該直接修改元件的 prototype</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 壞透了</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logProps</span>(<span class="params">InputComponent</span>) &#123;</span><br><span class="line">  <span class="title class_">InputComponent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">componentDidUpdate</span> = <span class="keyword">function</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Current props: &#x27;</span>, <span class="variable language_">this</span>.<span class="property">props</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Previous props: &#x27;</span>, prevProps);</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// InputComponent 本身已經被改變</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">InputComponent</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EnhancedComponent will log whenever props are received</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">EnhancedComponent</span> = <span class="title function_">logProps</span>(<span class="title class_">InputComponent</span>);</span><br></pre></td></tr></table></figure><p>導致所有傳進來的 Component  被改變，<code>componentDidUpdate</code> 這個方法都被 修改/覆寫 了，HOC 不能被重複使用，因為 function component 並沒有生命週期的方法。</p></li><li><p>利用 composition 的概念</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ composition</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logProps</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line"><span class="comment">// 用新的 Component 包裹傳入的 Component，不去影響到原本的 Component</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Current props: &#x27;</span>, <span class="variable language_">this</span>.<span class="property">props</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Previous props: &#x27;</span>, prevProps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="注意-不要在-render-function-使用-HOC">注意 : 不要在 render function 使用 HOC</h2><p>function 是 Object 的一種，每次 re-render 都是新的 function (object)，造成效能上的浪費。所以要在外部產生 HOC 再帶入新的 Component 中。</p><blockquote><p>簡單來說 : <strong>{ } !== { }</strong>，要避免這種情況發生</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 這是 ok 的，AccordionwithToggle 不會因為 App re-render 而改變</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AccordionwithToggle</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title function_">withToggle</span>(<span class="title class_">Accordion</span>))</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">AccordionwithToggle</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123; setCount(count+1) &#125;&#125;&gt;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 每次 App re-render 都是重新呼叫 function,產生新的 Accordion，React 會將全部替換，因為跟上一次的 Accordion 不一樣。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 每次都是新的</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AccordionwithToggle</span> = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="title function_">withToggle</span>(<span class="title class_">Accordion</span>),[])</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">AccordionwithToggle</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123; setCount(count+1) &#125;&#125;&gt;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>codepen 中預設的引入的 React script 是 production mode，是不能使用 React 的 profiler… 的。<br>要麼改成 development，在 html 添加這兩行，並且把編輯器的 <code>External Scripts/Pens</code> 取消。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@18/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@18/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>in render<br><img data-src="https://i.imgur.com/GgF9oDS.gif" alt="|600x350"></li><li>outside<br><img data-src="https://i.imgur.com/j4Uec3j.gif" alt="|600x350"></li></ul><p>以肉眼來看，當 App 的 state 改變，進行 re-render，如果是在 render 產生的 <code>&lt;Accordion/&gt;</code>會閃一下，因為對 App 來說 <code>&lt;Accordion/&gt;</code> 是新物件，等同於產生新的 DOM 節點 並且 repaint 。放在外部的話，就沒有這個問題。</p><h2 id="注意-refs-並不會被傳遞">注意 : refs 並不會被傳遞</h2><p><strong>refs</strong> 不是 props 的一種，就像 <code>key</code>，是由 React 來控制的。就像你不能在子元件中拿到 <code>❌props.key</code>。如果在 HOC 使用 ref，接收到 ref 的不會是 WrappedComponent，而是 HOC 本身。</p><p>要使 WrappedComponent 能夠接收 ref ，必須使用 <code>React.forwardRef</code><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p><p><code>React.forwardRef</code> 包住的 Component 可以接收 <strong>ref</strong> (這裡的 ref 是 forwardRef 刻意為之)。</p><ul><li><code>withtoggle</code> 為例，改成 <strong>withToggle2</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withToggle2</span> = (<span class="params">Component</span>) =&gt; &#123;</span><br><span class="line"><span class="comment">/* 接住上層傳下來的 ref */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [open, setOpen] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">togglehandler</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="title function_">setOpen</span>(<span class="function">(<span class="params">prevOpen</span>) =&gt;</span> !prevOpen);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 😵 Wrapped Component 不能使用 ref 這個字眼接 ref ，要取別名接 */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">open</span>=<span class="string">&#123;open&#125;</span> <span class="attr">togglehandler</span>=<span class="string">&#123;togglehandler&#125;</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardRef</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App 產生新的 ref</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">SpecialRef</span> = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 使用 ref 直接傳 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">AccordionwithToggle2</span> <span class="attr">index</span>=<span class="string">&quot;special&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;SpecialRef&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Wrapped Component 從 prop 接收 ref </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Accordion</span>(<span class="params">&#123; open, togglehandler, index,forwardRef &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(forwardRef) <span class="comment">// 結果 hello</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  <span class="comment">//...略</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，只有在產生 Ref 的同一層可以直接使用 ref ，例如 :</p><ul><li>App 在這裡 <code>createref / useRef</code> 👉  <code>&lt;AccordionwithToggle2 ref=&#123;✅&#125; /&gt;</code></li><li>HOC 裡面的 <code>&lt;WrappedComponent/&gt;</code> 不能使用 ref 傳，要取別名。 HOC 👉<code>&lt;WrappedComponent ref=&#123;❌&#125; forwardref=&#123;✅&#125; /&gt;</code></li></ul><h2 id="總結-28">總結</h2><p>關於 HOC 的特點</p><ol><li>是一個 Design Pattern ，可以提高 Component 重複性</li><li>是一個 function ，包裹另一個 Component，回傳新的 Component，又稱 <strong>加強版 Component</strong>，並且不會影響到包住的 Component 。</li></ol><p>HOC 最常比較的還有 render props 這個 Pattern，差別可以參考</p><ul><li><a href="https://medium.com/frochu/hoc-%E8%88%87renderprops-%E8%AB%87%E6%88%91%E5%BE%9E%E5%A5%B9%E5%80%91%E8%BA%AB%E4%B8%8A%E5%AD%B8%E5%88%B0%E4%BB%80%E9%BA%BC-2681ab4cc453">HOC 與Render Props，談我從她們身上學到什麼. 前言 | by Wendell Liu | Frochu | Medium</a></li><li><a href="https://gist.github.com/heygrady/f9bf3b6dd93fe3d87ba87430fd3c20d5">Avoiding HOC; Favoring render props · GitHub</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">補充 HOC 的 ref 問題 : <a href="https://zh-hant.reactjs.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components">傳送 Ref – React</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章來自 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://zh-hant.reactjs.org/docs/higher-order-components.html&quot;&gt;Higher-Order Components – React&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要-6&quot;&gt;摘要&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;了解 HOC 的運作原理，以及意義&lt;/li&gt;
&lt;li&gt;HOC 的架構與實作&lt;/li&gt;
&lt;li&gt;HOC 應用上的注意事項&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Front-end" scheme="https://blog.rosa.tw/categories/Front-end/"/>
    
    <category term="React" scheme="https://blog.rosa.tw/categories/Front-end/React/"/>
    
    
    <category term="React" scheme="https://blog.rosa.tw/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - fetch 獲取遠端資料</title>
    <link href="https://blog.rosa.tw/2022/06/JavaScript/JavaScript-fetch"/>
    <id>https://blog.rosa.tw/2022/06/JavaScript/JavaScript-fetch</id>
    <published>2022-06-22T04:45:11.000Z</published>
    <updated>2022-07-28T03:57:32.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-34">前言</h2><p>想要獲取遠端的資料可以使用 AJAX ，在 ES6 之前大多會使用 JQuery 的 <code>$.ajax</code>  或者原生的 XHR，而在 HTML5 則提供 fetch 使用，更多時候會使用 axios 套件。<br>本篇記錄 fetch 的使用方式與常見的使用誤區。</p><span id="more"></span><h2 id="fetch">fetch</h2><p>fetch 是 HTML5 原生獲取遠端的方式，其操作也十分簡單</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url)</span><br><span class="line"><span class="title function_">fetch</span>(url,&#123;obj&#125;) <span class="comment">// 第二個參數為 options</span></span><br></pre></td></tr></table></figure><p>沒有 options 的物件，只有網址的話是 <code>GET</code>。<br>fetch 回傳的是一個 Promise 物件，Promise 簡單來說是 <strong>處理非同步操作的特殊物件</strong>，有關於 Promise 之後會再補充。</p><h3 id="then-catch">then &amp; catch</h3><p>如果要拿到回傳的 response ，可以透過 <code>then</code>。要接 .then 前面的物件必要類型為 Promise，而 <code>fetch()</code> 回傳的就是一個 Promise 物件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> endPoint = <span class="string">&#x27;https://restcountries.com/v3.1/name/Taiwan&#x27;</span></span><br><span class="line"><span class="title function_">fetch</span>(endPoint).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>是 <code>fetch().then</code> 而不是 <strong>fetch.then</strong>，是 fetch 這個函式裡面回傳 Promise</p></blockquote><p>then 接收的參數是 Promise 中 resolve 或是 reject 的函式運行的結果，通常是 resolve，如果是 reject 則會用 <code>.catch</code> 來作錯誤處理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(endPoint).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>會被丟進 catch 處理的 err 並不是像 XHR status 404 或 500 這類的，而是可能網路連線錯誤或者網址有誤導致不能發出 request 。</p><h3 id="HTTP-狀態碼處理-Response-status-Response-ok">HTTP 狀態碼處理 Response.status &amp;  Response.ok</h3><p>只要是 HTTP 狀態碼 400 以上的我們通常會在 XHR 做錯誤處理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">err</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure><p>但是 fetch 不管狀態碼多少，只要有正確的發出請求後回傳的 response 都會進入 resolve ，如果要處理像 onerror 的錯誤可以透過 .then 中 response 的 status 或 ok。</p><ul><li>response.status : 回傳結果的 HTTP code</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(endPoint).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>) <span class="comment">// 200 代表成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>response.ok : 回傳 boolean ，如果 HTTP code 在 200~299 就回傳 true</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(endPoint).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(response.<span class="property">ok</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Response-text-json">Response.text() &amp; .json()</h3><p>可以將 response 解析成想要的形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(endPoint).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> response.<span class="title function_">text</span>()</span><br><span class="line"><span class="comment">// return response.json() 兩者擇一</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>.text()</code> : 直接印出文字</li><li><code>.json()</code> : 自動幫我們解析 json 格式的資料</li></ul><p>其他種類的格式 :</p><ul><li><code>.blob()</code>：把資料轉成Blob物件</li><li><code>.formData()</code>：把資料轉成FormData物件</li><li><code>.arrayBuffer()</code>：把資料轉成二進制數組</li></ul><blockquote><p>這些方法 <strong>只能擇一</strong>，一但被解析過就不能重複再使用其他的函式解析了。</p></blockquote><h2 id="POST">POST</h2><p>POST 也很簡單，跟 <code>$.ajax()</code> 的操作很像</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二個參數可以攜帶 header 、body 或 Http 等資訊</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;<span class="attr">name</span>:<span class="string">&#x27;Rosa&#x27;</span>&#125;</span><br><span class="line"><span class="title function_">fetch</span>(endPoint,&#123;</span><br><span class="line"><span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data),</span><br><span class="line">  <span class="attr">headers</span>: <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>fetch 的 options 還有包含其他常見的 HTTP 處理，<br>在 body 中如果我們要上傳的格式是 JSON 檔，記得要將內容轉換成 JSON 格式。</p><blockquote><p><strong>GET 與 HEAD 是沒有 body 的</strong></p></blockquote><h2 id="fetch-的-Headers">fetch 的 Headers</h2><p>以往在 XHR 要加上 Header</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">XMLHttpRequest</span>.<span class="title function_">setRequestHeader</span>(header, value);</span><br></pre></td></tr></table></figure><p>在 fetch 要加上 Header，可以直接加，或者 new 出一個 Header 容器來放置所需的內容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接使用 headers</span></span><br><span class="line"><span class="title function_">fetch</span>(url,&#123;</span><br><span class="line"><span class="attr">headers</span>:&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//透過實例出一個 Headers</span></span><br><span class="line"><span class="title function_">fetch</span>(url,&#123;</span><br><span class="line"><span class="attr">headers</span>: <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Content-Type">Content Type</h3><p>表單 或是 JSON 格式資料</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON</span></span><br><span class="line">&#x27;Content-Type&#x27;<span class="punctuation">:</span> &#x27;application/json&#x27;</span><br><span class="line"><span class="comment">// 表單</span></span><br><span class="line">&#x27;Content-Type&#x27;<span class="punctuation">:</span> &#x27;application/x-www-form-urlencoded&#x27; </span><br></pre></td></tr></table></figure><h3 id="credentials">credentials</h3><p>預設上不會自動帶上或接收任何 cookies，如果網站依賴 session 會導致請求回傳未經認證，想把 cookies 一起帶上，要加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url,&#123;</span><br><span class="line"><span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="對-mode-的誤解">對 mode 的誤解</h2><p>發送 request 可能會遇到 CORS 的限制，fetch 中mode 提供 <code>'no-cors'</code> 的方法，乍看之下會以為能突破 CORS 限制，既不會跳出錯誤 (不會跳到 .catch)，也能發出 request ，但 <strong>response 的 status 是 0 ，body 是空的</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url,&#123;</span><br><span class="line"><span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line"><span class="attr">headers</span>: <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line"><span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">&#125;),</span><br><span class="line"><span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;Rosa&#x27;</span>&#125;),</span><br><span class="line">mode : <span class="string">&#x27;no-cors&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="title function_">json</span>())</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></table></figure><blockquote><p>麻瓜翻譯機 :<br>不會回傳錯誤，也不會突破 CORS 的限制<br>避免發生錯誤，硬要丟出一個 request ，還你一個安心 response，裡面包含沒東西的 body 以及 status 為 0 。</p></blockquote><p>CORS 的限制是後端要解決，前端無法直接實現掛跨 CORS。</p><h2 id="為什麼-XMLHttpRequest-還是存在">為什麼 XMLHttpRequest 還是存在 ?</h2><p>我們都知道 XHR 寫起來有點囉嗦，在 fetch 問世之後，除了支援舊的瀏覽器會使用到 XHR，現代開發大多還是使用 fetch，但是 XMLHttpRequest 並沒有被廢棄，因為 fetch 還是有些功能是無法做到的。</p><p>**fetch 做不到 : **</p><ol><li>上傳進度追蹤，fetch 必須搭配其他的 API 才能做到，</li><li>錯誤的回應處理<br>fetch 不管 HTTP 404 還是 500 ，也還是會 resolve，代表 <strong>你確實有送出 request</strong>，<code>.catch</code> 會抓到的錯誤只會是 <strong>網路錯誤或其他會中斷 request 的情況</strong>。對於錯誤的處理不是那麼直覺。</li><li>中斷  (absort) fetch<br>目前沒有直接中斷 fetch (Promise) 的方法，不像 XHR 提供 <code>.absort()</code>，但是 WebAPIs 有提供 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/AbortController#browser_compatibility">AbortController</a> 可以讓 fetch 做到中斷，目前為實驗性(?)<br><a href="https://mdn.github.io/dom-examples/abort-api/">MDN 提供的範例</a>，讓你突然不想看影片的時候，停止發出 request。</li><li>逾時處理 (timeout)<br>XHR 逾期的時候可以暫停發出請求，第三點也提到 fetch 因為沒有中斷的功能，無法做到。</li></ol><h2 id="補充-幾種發-request-的方法">補充 : 幾種發 request 的方法</h2><p>以下都會使用 GET 為例</p><ol><li>XHR <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(url)</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">response</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(response.<span class="property">state</span>&gt;=<span class="number">200</span> &amp;&amp; response.<span class="property">state</span> &lt;=<span class="number">400</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure></li><li>JQuery <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">method : <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">url : url</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">done</span>(<span class="keyword">function</span>(<span class="params">response</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">fail</span>(<span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>fetch <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>axios <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(url)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line"> &#125;)</span><br><span class="line"> .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="結語-12">結語</h2><p>在我學習 JavaScript 這段期間，講到遠端取資料，很多教學並不會提到 fetch 或是 XMLHttpRequest，反而是叫你直接使用 axios，畢竟重新造輪子是很麻煩的 🥴，不過 fetch 無疑的是會越來越完善，不論是用何者工具或手法必有一定誕生的理由，了解原理後開發都可以更得心應手。</p><p>我蠻喜歡<a href="https://www.ithome.com.tw/voice/121435">良葛格 下的這番結論</a></p><blockquote><p>舊東西誕生在舊的時代，適時地解決了當時的問題，而後從中累積了不少的使用經驗，因而誕生了新的技術、概念或規範，急著預言舊東西將會逝去，並不會讓開發者看起來更為耀眼，只會讓開發者看不清楚新東西的本質罷了。</p></blockquote><h2 id="參考-6">參考</h2><ol><li>從 fetch 解決什麼問題來看 : <a href="https://www.ithome.com.tw/voice/121435">從XHR到Fetch | iThome</a></li><li>Huli 大的 fetch 系列影片<ul><li><a href="https://youtu.be/_8cLWMAQe3A">Fetch 與 Promise 補充系列（一）：初探 Fetch</a></li><li><a href="https://youtu.be/Ovv9tPhiW_0">Fetch 與 Promise 補充系列（二）：fetch 的 POST 與錯誤處理</a></li><li><a href="https://youtu.be/5A9ogWY7J7w">Fetch 與 Promise 補充系列（三）：fetch 的使用注意事項</a></li></ul></li><li>XHR v.s fetch，單純只是好奇查詢 XD <a href="https://blog.openreplay.com/ajax-battle-xmlhttprequest-vs-the-fetch-api">Ajax Battle: XMLHttpRequest vs the Fetch API </a></li><li><a href="https://zh.javascript.info/fetch">Fetch</a></li><li>很推的詳細文字版學習 : <a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/ajax_fetch.html">AJAX與Fetch API · 從ES6開始的JavaScript學習生活 (gitbooks.io)</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-34&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;想要獲取遠端的資料可以使用 AJAX ，在 ES6 之前大多會使用 JQuery 的 &lt;code&gt;$.ajax&lt;/code&gt;  或者原生的 XHR，而在 HTML5 則提供 fetch 使用，更多時候會使用 axios 套件。&lt;br&gt;
本篇記錄 fetch 的使用方式與常見的使用誤區。&lt;/p&gt;</summary>
    
    
    
    <category term="Front-end" scheme="https://blog.rosa.tw/categories/Front-end/"/>
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/categories/Front-end/JavaScript/"/>
    
    
    <category term="fetch" scheme="https://blog.rosa.tw/tags/fetch/"/>
    
    <category term="AJAX" scheme="https://blog.rosa.tw/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - Event Loop 事件循環 (I)</title>
    <link href="https://blog.rosa.tw/2022/06/06/JavaScript-Event-Loop-01"/>
    <id>https://blog.rosa.tw/2022/06/06/JavaScript-Event-Loop-01</id>
    <published>2022-06-17T16:54:45.000Z</published>
    <updated>2022-07-28T02:04:00.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-32">前言</h2><p>在 JavaScript 中，非同步的操作是很常見的，舉凡滑鼠事件、發出請求獲取資料…等，反過來問，如果這些操作是 <strong>同步</strong> 的，你可能操作後，畫面就像被卡住了，要等到目前的程式執行完畢才能繼續瀏覽。</p><p>Event Loop 的概念如何幫我們了解這件事，具體怎麼做呢 ? 本篇主要是幫助我自己釐清 Event Loop 的概念。</p><span id="more"></span><h2 id="為什麼會有-Event-Loop">為什麼會有 Event Loop ?</h2><p>JS 的語言特性是</p><ol><li>Single Thread (單線程)</li><li>Synchronous (同步)</li></ol><p>有時候語意上很令人誤解，同步 <strong>並不是同時做很多事</strong>，而是你只能一次做一件事。那為什麼我們可以在 <strong>瀏覽器</strong> 中操作按鈕獲取資料的同時又能做別的事 ?</p><p>沒錯，特別指出 <strong>瀏覽器</strong>，因為在不同的執行環境下，才能讓我們執行非同步的操作。(node 也是一種 JavaScript 執行環境，其中也有提供非同步的 API 來操作)</p><p>JavaScript 在 Runtime (執行環境) 是同步的，而是瀏覽器提供 Web APIs 讓我們透過 Event Loop 搭配非同步操作，才能&quot;同時&quot;處理很多事。</p><h3 id="關於-Event-Loop-的名詞">關於 Event Loop 的名詞</h3><h4 id="Stack-堆疊">Stack (堆疊)</h4><p>Stack 是資料結構的一種，遵守 LIFO (Last In,First Out)。</p><p>JavaScript 中的 Call Stack 會記錄目前執行到程式的部分，因為 JavaScript 是 Single Thread (單線程) ，只會有一個 Call Stack。</p><p><strong>那 Call Stack 怎麼運作呢 ?</strong><br>當執行某個函式，會將目前執行的函式放在 Stack 的最上層，如果函式執行 <code>return</code> 就會從 Stack 最上方抽離。</p><p><strong>範例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="title function_">a</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="title function_">b</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">c</span>();</span><br></pre></td></tr></table></figure><p>跟著程式走 :</p><ol><li>執行 c() ，把 c() 放入 Call Stack 中 1</li></ol><table><thead><tr><th>order</th><th>stack</th></tr></thead><tbody><tr><td>1</td><td>c () <strong>(now)</strong></td></tr></tbody></table><ol start="2"><li>印出 ‘c’，接著執行 b()，把 b() 放入 Call Stack 中</li></ol><table><thead><tr><th>order</th><th>stack</th></tr></thead><tbody><tr><td>2</td><td>b() <strong>(now)</strong></td></tr><tr><td>1</td><td>c ()</td></tr></tbody></table><ol start="3"><li>印出 ‘b’，接著執行 a()，把 a() 放入 Call Stack 中</li></ol><table><thead><tr><th>order</th><th>stack</th></tr></thead><tbody><tr><td>3</td><td>a() <strong>(now)</strong></td></tr><tr><td>2</td><td>b()</td></tr><tr><td>1</td><td>c ()</td></tr></tbody></table><ol start="4"><li>印出 ‘a’，a() 後面沒有程式碼，代表執行完畢，抽離 Stack 中</li></ol><table><thead><tr><th>order</th><th>stack</th></tr></thead><tbody><tr><td><s>3</s></td><td><s>a() ----&gt; 抽離</s></td></tr><tr><td>2</td><td>b()</td></tr><tr><td>1</td><td>c ()</td></tr></tbody></table><ol start="5"><li>後面跟步驟 4 一樣，依序抽離，直到 c() 執行完畢，後面也沒有程式碼，最後 Call Stack 為空</li></ol><p>解釋了上面提及的 Stack <strong>Last In,First Out</strong> 的原因。</p><h4 id="Task-Queue-任務佇列">Task Queue (任務佇列)</h4><p>又稱作 Callback Queue，在 Web APIs 的 function 執行完後，把 callback (接著要執行的 function) 放到 Task Queue 等待。</p><p>👉<a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D">參考 Loupe 視覺化工具</a></p><p>在這個例子中，有 setTimeout 與 click 事件。當程式執行時 :</p><ol><li>Button 事件並沒有觸發，callback function 並不會執行，先放置到 Web APIs 等待</li><li>第 7 行排進 Call Stack ，印出 ‘Hi !’，執行完畢移出 Call Stack 外</li><li>setTimeOut 放置到 Web APIs 等待，並且開始算 5 秒鐘</li><li>第 13 行排進 Call Stack ，印出 ‘Welcome to loupe.’，執行完畢移出 Call Stack 外，到這邊靜態的程式碼都執行完畢，Call Stack 變成空的 。(同一時間 setTimeOut 還在跑秒數)</li><li>過了大概 5 秒鐘， 把第 9 行 setTimeOut 的 callback <code>timeout()</code> 放到 Callback Queue。</li><li><strong>此時 Call Stack 為空的，把 Task Queue 第一順位的 timeout() 搬到 Call Stack 執行</strong> (此時會看見橘色的旋轉鈕轉動，代表 Event Loop)</li><li>第 10 行排進 Call Stack ，印出 ‘Click the button’，timeout() 執行完畢，移出 Call Stack 外，Stack 又變成空的。</li></ol><p><strong>如果這時候按下按鈕呢 ?</strong></p><ol><li>按下後，onClick 事件執行，排進 Call Stack</li><li>執行第 2 行 setTimeout ，把 setTimeout 放置到 Web APIs 等待，並且開始算 2 秒鐘，onClick 事件執行完畢，移出 Call Stack 外，Stack 又變成空的</li><li>過了大概 2 秒鐘， 把 setTimeOut 的 callback <code>timer()</code> 放到 Callback Queue。</li><li><strong>此時 Call Stack 為空的，把 Task Queue 第一順位的 timer() 搬到 Call Stack 執行</strong></li><li>第 3 行排進 Call Stack，印出 ‘You click the button !’，執行完畢，移出 Call Stack 外，Stack 又變成空的。</li></ol><p>以上是一步步跟著的 Event Loop 的基本運作</p><h4 id="Blocking-阻塞">Blocking (阻塞)</h4><blockquote><p>那如果一直按按鈕呢 ?</p></blockquote><p>會發現一個個 onClick 事件的 callback 會被排進 Callback Queue 正在排隊等待，setTimeout 同時也在排隊，也要等待 onClick 事件結束，移出 Call Stack 外，透過 Event Loop 檢查 Call Stack 是否為空…(略)，重複一直執行。</p><p>這時候畫面就好像靜止了，setTimeout 的 2 秒也不是很精準，這就是發生了 Blocking 。</p><p>如果會以為同時印出，要回想 <strong>JavaScript 是同步的</strong> 這句話，執行的結果會是依序出現，不會一下子 “啪!” 全部出來。</p><h5 id="阻塞常見的例子-無限滾動載入資料">阻塞常見的例子 : 無限滾動載入資料</h5><p>如果直接 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">// Ajax 獲取資料</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>發現每一滑，都會觸發 callback 。就像你一直按按鈕，然後發出請求資料，排進 Web APIs 並且等待資料的 response ，再排進 Callback Queue，這時候會造成 Blocking。為避免一直觸發 scroll 事件，通常會搭配 lodash 的 debounce。</p><h3 id="小結-Event-Loop-是…">小結 : Event Loop 是…</h3><p>一種機制，讓 JavaScript 可以同時做很多事</p><blockquote><p>當 Call Stack 為空時，把 Callback Queue 等待的 callback function 放進 Call Stack 來執行</p></blockquote><h2 id="幾個-Event-Loop-的例子">幾個 Event Loop 的例子</h2><p>來自 <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">What the heck is the event loop anyway?</a> 提到的範例</p><h3 id="沒那麼精準的-setTimeout-與-setInterval">沒那麼精準的 setTimeout 與 setInterval</h3><p>setTimeout 與 setInterval 都是 Web APIs ，會排進 Callback Queue 並且等到 Call Stack 為空的時候才執行。所以不能保證一定精準 x 秒後執行，但至少執行間距的最小秒數是 x 秒。</p><p><strong>常見的 0 秒 setTimeout</strong><br>乍看之下會以為 0 秒是立即執行，其實不然。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br></pre></td></tr></table></figure><p>結果是 <code>hi</code> 先印出，再印出 <code>hello</code>。</p><p>跟著步驟走 :</p><ol><li>setTimeout 放入 Web APIs 等待 0 秒後，放入 Task Queue 等待</li><li><code>console.log('hi')</code> 排進 Call Stack，並且執行</li><li>印出 ‘hi’ ，執行結束，移出 Stack 外</li><li>此時的 Call Stack 是空的，而且 Task Queue 的第一位是 setTimeout 的 callback ，排進 Call Stack</li><li>執行 <code>console.log('hello')</code></li><li>印出 ‘hello’，執行結束，移出 Stack 外</li><li>程式碼執行結束</li></ol><p>這也是為什麼 setTimeout  沒那麼 精準的原因，因為必須等到  Call Stack 為空才會執行，導致中間可能會有誤差。</p><h3 id="多個-setTimeout">多個 setTimeout</h3><p>遇到 setTimeout 常會問 console.log 的結果是 ?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><ol><li>每間隔 1 秒後，依序印出 ‘hi’ (1 秒 ‘hi’，隔 1 秒 ‘hi’…)</li><li>在 4 秒後，同時印出 <figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span>(hi)</span><br></pre></td></tr></table></figure></li><li>至少間距 1 秒以後，一次印出 4 次的 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br></pre></td></tr></table></figure></li></ol><p>.<br>.<br>.<br>.<br>.<br>.<br>.<br>結果是<strong>至少間距 1 秒以後，一次印出 4 次的 hi</strong> 。經過 1 秒後即使已經排定到 Callback Queue，但是如果這時候 Call Stack 還不是空的，Queue 就會發生 Blocking 塞車在這裡等待，等到 Stack 空再依序印出 hi。如果 1 秒短到看不見，可以調成更久的時間。</p><h3 id="同步與非同步的-callback">同步與非同步的 callback</h3><p>我覺得這個例子很有意思，我們知道頻繁的呼叫 callback function 會造成 Blocking 的情形，但是 <strong>Call Stack 塞車或是 Callback Queue 塞車有什麼差別呢 ?</strong></p><p>透過這個例子我自己覺得更清楚知道有了 Event Loop 到底幫助在哪。</p><p>在這裡的 callback function 有兩種</p><ol><li>在函式中呼叫另一個函式 (同步的 callback，都在 Call Stack 執行完畢) <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>像是跟 Web APIs 有關的，例 : click 事件後的 callback function 不會馬上執行，而是等到 Event Loop 後才會。<br>(非同步的 callback  差別在於，有排隊到 Callback Queue 再到 Call Stack) <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="同步的-callback-發生了什麼事">同步的 callback 發生了什麼事</h4><p>如上面的第一個 callback 範例，我們必須等到 forEach 印完所有元素，才能做其他的事。這段時間造成 Call Stack 的 Blocking，導致畫面不能動作。</p><p>一般來說，瀏覽器會在每 16.6 毫秒的時候重新渲染畫面，但這時候 Call Stack 還在處理事情，導致畫面的解析被延遲，在影片中講者有開啟模擬畫面 render 的模擬，render 一直被占據紅線。</p><h4 id="改成非同步的-callback-差別在哪">改成非同步的 callback 差別在哪 ?</h4><p>上面不斷強調 Event Loop 是 Call Stack 為空時，才會把 Callback Queue 推上 Stack 執行。而在 Call Stack 空的期間，提供瀏覽器執行畫面重新渲染的機會，才不會因為忙碌導致卡住。</p><blockquote><p>簡單來說 : <strong>畫面渲染的優先度是高於 Callback Queue 的 callback function</strong></p></blockquote><p>這也是為什麼在影片講者提到不要造成耗時的程式碼放在 Call Stack ，因為 Call Stack 賽車沒辦法重新渲染畫面。</p><p>也可以參考這篇 Jack 大的實作範例二，文章也有提到什麼時候會 rendering，助於瞭解整個流程<br>👉 <a href="https://yu-jack.github.io/2020/02/03/javascript-runtime-event-loop-browser/#%E7%AF%84%E4%BE%8B%E4%BA%8C">Event Loop 運行機制解析 - 瀏覽器篇 - 技術雜記 Technology Notes - Jack Yu | 傑克</a></p><h2 id="結語-11">結語</h2><p>目前提到瀏覽器的 Event Loop ，至於 Node 的 Event Loop 我還沒研究，未來會再研究補充。不過還有 mircoTask 與 macroTask 還沒補完 QQ，才能算是了解 Event Loop。</p><p>如果有誤麻煩請寄信告訴我，我會非常感謝</p><h2 id="參考-4">參考</h2><ol><li><a href="https://pjchender.blogspot.com/2017/08/javascript-learn-event-loop-stack-queue.html">[筆記] 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式 | PJCHENder 那些沒告訴你的小細節</a></li><li>講解 Event Loop 的影片(有中文字幕) : <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">What the heck is the event loop anyway? | Philip Roberts | JSConf EU - YouTube</a></li><li>模擬 Event Loop 的網頁 : <a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D">latentflip.com</a></li><li><a href="https://yu-jack.github.io/2020/02/03/javascript-runtime-event-loop-browser/#%E7%AF%84%E4%BE%8B%E4%BA%8C">Event Loop 運行機制解析 - 瀏覽器篇 - 技術雜記 Technology Notes - Jack Yu | 傑克</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-32&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在 JavaScript 中，非同步的操作是很常見的，舉凡滑鼠事件、發出請求獲取資料…等，反過來問，如果這些操作是 &lt;strong&gt;同步&lt;/strong&gt; 的，你可能操作後，畫面就像被卡住了，要等到目前的程式執行完畢才能繼續瀏覽。&lt;/p&gt;
&lt;p&gt;Event Loop 的概念如何幫我們了解這件事，具體怎麼做呢 ? 本篇主要是幫助我自己釐清 Event Loop 的概念。&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="06" scheme="https://blog.rosa.tw/categories/2022/06/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - 運算子 ?. 與 ??</title>
    <link href="https://blog.rosa.tw/2022/06/06/JavaScript-null-undefined-operator"/>
    <id>https://blog.rosa.tw/2022/06/06/JavaScript-null-undefined-operator</id>
    <published>2022-06-15T06:31:13.000Z</published>
    <updated>2022-07-27T14:15:29.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-33">前言</h2><p>對於 undefined 或是 null 的處理，我比較常使用 <code>||</code> (OR) 或是 <code>&amp;&amp;</code> (AND) 的寫法，找資料的時候很常看見 <code>??</code> 以及 <code>?.</code> 的寫法。實在是太好奇了，於是找了資料學習並且記錄下來 。</p><span id="more"></span><h2 id="Optional-chaining">Optional chaining (?.)</h2><p>如果要查找 <strong>Object 的某項是否存在</strong>。我們可能會遍歷整個物件，但不用這麼麻煩，可以使用 <code>obj?.</code> ，如果物件是 null 或是 undefined 就做別的處理，在判斷值存在與否就很好用。</p><p>例 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj?.<span class="property">b</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span> + (obj?.<span class="property">b</span> || <span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>那在巢狀的結構中如果不用 <code>?.</code> ，必須先判斷前面的是不是存在</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span> &amp;&amp; obj.<span class="property">a</span>.<span class="property">b</span>) <span class="comment">// obj.a 存在才往下一步</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>?.<span class="property">b</span>) <span class="comment">// 使用 ?.</span></span><br></pre></td></tr></table></figure><p>透過 (?.) 的方式 JavaScript 內部會透過隱式 (implicitly) 去確認 obj.a 是不是 null 或是 undefined，而不用顯式 (explicitly) 確認 obj.a 存不存在再去判斷下一個。</p><h3 id="為什麼要有">為什麼要有 (?.)</h3><p>從一般的判斷來說，我們可以用 <code>||</code>  來決定值存不存在，因而來設定 <strong>預設值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> product =&#123;</span><br><span class="line">name : <span class="string">&#x27;Rosa&#x27;</span>,</span><br><span class="line">cost : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> total = product.<span class="property">cost</span> || <span class="number">50</span> <span class="comment">// ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(total)</span><br></pre></td></tr></table></figure><p>雖然 <code>||</code> 很好用，但是 <code>||</code> 會強制轉型，也就是 falsy 。數字 0 在判斷中會被轉為 false ，因此在上面的例子，數字 0 也會被判斷成 false 而預設成 50。</p><p>可能會想說那判斷 <code>&gt;=0</code> 不就可以了 ?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = product.<span class="property">cost</span> &gt;= <span class="number">0</span> ? product.<span class="property">cost</span> : <span class="number">50</span> </span><br></pre></td></tr></table></figure><p>是可以，但會重複寫兩次 <code>product.cost</code>🥴。<br>BUT !!! 如果有 <strong>負數</strong> 呢 ? 總不能判斷不是 0 吧。<br>邏輯寫法就更綁手綁腳，但我們實際只確認是不是空值或是為賦值而已。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = (product.<span class="property">cost</span> === <span class="literal">null</span> || product.<span class="property">cost</span> === <span class="literal">undefined</span>) ? <span class="number">50</span> : product.<span class="property">cost</span></span><br></pre></td></tr></table></figure><p>因此 short-hand 的 <code>?.</code> 誕生，讓我們可以更快判斷。</p><blockquote><p>IE 並不支援 <code>?.</code> ，如果要使用就是 <strong>依序判斷是否為 null 或是 undefined</strong></p></blockquote><h3 id="fuction-call-的">fuction call 的 (?.)</h3><p>MDN 有提到是如果使用套件的 API，可以使用這種方式，可以確認 function 是否存在再執行，以免發生錯誤。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayhello = &#123;</span><br><span class="line"><span class="title function_">hello</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayhello.<span class="property">hi</span>?.()) <span class="comment">// undefined ，不會發生錯誤</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayhello?.<span class="title function_">hello</span>()) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>但是如果 hi 本身並不是 function 就會發生 <code>is not a function</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sayhello.<span class="property">hi</span> = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayhello.<span class="property">hi</span>?.()) <span class="comment">// hi is not a function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayhello?.<span class="title function_">hello</span>()) <span class="comment">// 不會執行，因為上面出現錯誤</span></span><br></pre></td></tr></table></figure><p>手動矯正 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sayhello.<span class="property">hi</span> = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> sayhello.<span class="property">hi</span>=== <span class="string">&#x27;function&#x27;</span> ? sayhello.<span class="title function_">hi</span>() : sayhello.<span class="property">hi</span> ) <span class="comment">// &#x27;123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayhello?.<span class="title function_">hello</span>())  <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h3 id="什麼時候不應該用">什麼時候不應該用 (?.)</h3><ol><li>沒有被 <strong>宣告</strong> 的變數 : 對變數使用，會發生錯誤，因為 a 並不存在 (is not defined)，並不能這樣判斷。 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a?.<span class="property">b</span>) <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure></li><li>重新賦值 (left-hand side) : 不能這樣使用 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">2</span>&#125;</span><br><span class="line">obj?.<span class="property">a</span>  = <span class="number">1</span>  <span class="comment">// Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure></li><li>本身是 null <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> prop = a?.[x++]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// 0 並不會增加</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>這邊我有點不太了解，因此我試了空物件，x 遞增是  1 🤔，a 依然是空物件。後來我找到 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">運算子優先序 - JavaScript | MDN (mozilla.org)</a>，簡單來說 <strong>越高階的運算子會按照規則先執行</strong>。<br><code>?.</code> 是 18 ,判斷是從左至右。a 已經是 null 了，所以不會執行。但是如果是空物件 <code>&#123;&#125;</code>，?. 會執行，不是 null 也不是 undefined。而<code>[ ]</code> 跟 <code>?.</code> 的層級相同，<code>[x]</code> 存在所以也會執行 ， <code>++</code> 也會執行。(這邊有點不太確定，待補)</li></ol><p>另一個有關優先序的常見例子是 <code>(function()&#123;var a = b = 5&#125;)()</code>，在非嚴格模式下， global 依序印出 b 跟 a ，b 是 5 ，a 是 is not defined。因為 <code>=</code> 是 right-to-left，也就是 b 在未宣告下賦值，<code>var  a</code> 因作用域的關係，自然在 global 是 not defined。</p><blockquote><p>MDN 也提到不應該過度使用 (?.)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj?.[<span class="string">&#x27;Rosa&#x27;</span>]?.<span class="property">number</span> ? obj.[<span class="string">&#x27;Rosa&#x27;</span>].<span class="property">number</span> : obj?.[<span class="string">&#x27;Rosa&#x27;</span>]) <span class="comment">// 👎，因為在 obj.[&#x27;Rosa&#x27;] 不存在就可以停止了，不用串串樂來確認</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj?.[<span class="string">&#x27;Rosa&#x27;</span>] ? obj.[<span class="string">&#x27;Rosa&#x27;</span>].<span class="property">number</span> : <span class="literal">undefined</span>) <span class="comment">// V</span></span><br></pre></td></tr></table></figure><h2 id="Nullish-coalescing-operator">Nullish coalescing operator (??)</h2><p>可用來判斷 <strong>某個值是 null 或是 undefined</strong></p><h3 id="為什麼要有-2">為什麼要有 (??)</h3><p>跟上面提到 <code>||</code> 的判斷是一樣的，如果是數字 0 會被強制轉型比較成 false，如果只是想檢查 null 或是 undefined，?? 就會比較方便 。</p><p><strong>舉例來說</strong></p><ol><li>先讓 input 有 0 或是有值</li><li>手動把 input 的值完全清空， <code>e.target.value</code> 會是 <strong>空字串</strong>，但是我不想讓空字串也通過</li></ol><p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="ZErwEBe" data-user="shan473" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">  <span>See the Pen <a href="https://codepen.io/shan473/pen/ZErwEBe">  練習 ?? &amp; ?.</a> by YanShanHong (<a href="https://codepen.io/shan473">@shan473</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script><h3 id="function-call-的">function call 的 (??)</h3><p>來自 MDN 的範例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A was called&#x27;</span>); <span class="keyword">return</span> <span class="literal">undefined</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B was called&#x27;</span>); <span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;C was called&#x27;</span>); <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">A</span>() ?? <span class="title function_">C</span>() );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">B</span>() ?? <span class="title function_">C</span>() );</span><br></pre></td></tr></table></figure><p>根據 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">運算子優先序</a></p><blockquote><p><code>??</code> 是 <code>left-hand side</code> ，也就是 <strong>從左邊判斷開始</strong>。</p></blockquote><p>其結果是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;A was called&quot;</span></span><br><span class="line"><span class="string">&quot;C was called&quot;</span></span><br><span class="line"><span class="string">&quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;B was called&quot;</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>跟著跑一次 :</p><ol><li>A() 執行，印出 “A was called”</li><li>?? 的左邊是 undefined 所以決定執行 C()</li><li>C() 執行，印出 “C was called”</li><li>?? 左邊是 undefined 所以是 C() 回傳的結果 ‘foo’</li><li>B() 執行，印出 “B was called”</li><li>?? 的左邊是 false ，不符合 null 或是 undefined，C() 並不會執行</li><li>回傳 B() 的結果</li></ol><h3 id="不要直接用-OR-或-AND-一起使用">不要直接用 OR (||) 或 AND (&amp;&amp;) 一起使用 (??)</h3><p>OR 跟 AND 運算子的優先度比 <strong>??</strong> 還低，因此一起使用會發生錯誤，即使前面的結果是 null 或是 undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> || <span class="literal">undefined</span> ?? <span class="string">&quot;foo&quot;</span>) <span class="comment">// 錯誤</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> || <span class="literal">undefined</span> ?? <span class="string">&quot;foo&quot;</span>) <span class="comment">// 錯誤</span></span><br></pre></td></tr></table></figure><p>想讓前面先判斷可以用 <code>()</code> grouping 包起來，grouping 的優先度是最高的，所以會先執行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">null</span> || <span class="literal">undefined</span>) ?? <span class="string">&quot;foo&quot;</span>) <span class="comment">// &#x27;foo&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">true</span> || <span class="literal">undefined</span>) ?? <span class="string">&quot;foo&quot;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Polyfills">Polyfills</h2><p>如果瀏覽器不支援 (如 : IE)，可以使用 Polyfills，只要判斷 null 以及 undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = (somevalue !== <span class="literal">null</span> || somevalue !== <span class="literal">undefined</span>) ? somevalue ? <span class="title class_">DefaultValue</span></span><br></pre></td></tr></table></figure><h2 id="總結-20">總結</h2><ol><li><code>?.</code> 是中找尋 Object 類型 (object 、array 、function 等等)的值如果是 null 或是 undefined，結果是右邊的值。亦可用在 function call (<strong>object.method?.()</strong>) 上</li><li><code>?.</code> 不管存不存在，不能用來重新賦值</li><li><code>??</code> 是判斷任何值如果是 null 或是 undefined，結果是右邊的值</li><li><code>??</code> 不要直接跟 OR 或是 AND 一起使用，要用先把 ?? 左邊的括號起來先執行</li><li>兩種 IE 不支援 QQ</li></ol><h2 id="參考-5">參考</h2><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">Optional chaining (?.) - JavaScript | MDN</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_Coalescing_Operator">Nullish coalescing operator (??) - JavaScript | MDN</a></li><li><a href="https://javascript.info/optional-chaining">Optional chaining ‘?.’ (javascript.info)</a></li><li><a href="https://javascript.info/nullish-coalescing-operator">Nullish coalescing operator ‘??’ (javascript.info)</a></li><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">運算子優先序 - JavaScript | MDN (mozilla.org)</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-33&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;對於 undefined 或是 null 的處理，我比較常使用 &lt;code&gt;||&lt;/code&gt; (OR) 或是 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (AND) 的寫法，找資料的時候很常看見 &lt;code&gt;??&lt;/code&gt; 以及 &lt;code&gt;?.&lt;/code&gt; 的寫法。實在是太好奇了，於是找了資料學習並且記錄下來 。&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="06" scheme="https://blog.rosa.tw/categories/2022/06/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>紀錄 | Frontend Mentor 挑戰題 - Time tracking dashboard</title>
    <link href="https://blog.rosa.tw/2022/04/04/Practice-to-Master-01"/>
    <id>https://blog.rosa.tw/2022/04/04/Practice-to-Master-01</id>
    <published>2022-04-29T04:00:01.000Z</published>
    <updated>2022-07-27T05:30:49.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-45">前言</h2><p>這是在 <a href="https://www.frontendmentor.io/solutions/responsive-reactjs-styledcomponent-BkFnvCvr9">frontend mentor 的挑戰題</a><br>使用 React + styled-components</p><ul><li><a href="https://meitung473.github.io/time-tracking-dashboard-main/">網頁</a></li><li><a href="https://github.com/meitung473/time-tracking-dashboard-main">github repo</a></li></ul><p><img data-src="https://dsm01pap006files.storage.live.com/y4m9LQmpdiru45ZO2sTWfVBoSuRS1cfQoRCmHTFQxc-7aQWX0hkbq0r2q3tefJlGHA3SeXfA_G4CV5PHZIagjALPplvZ3s9MO6tpWyEEYyL2J7ep3EbhiNczfUybFUlxBTjvVQybnsXtFwrgoLmqEFJBftLbJvhzcipVkL-hdLjY23wEqHVpwrW0vNREUMTmt-y?width=1024&amp;height=585&amp;cropmode=none" alt="完成圖"></p><span id="more"></span><h2 id="專案建置">專案建置</h2><ol><li><strong>create-react-app</strong> : 一鍵建立好環境</li><li><strong>eslint</strong> : 加上 <code>Protype</code> 來檢查類型</li></ol><h2 id="我的流程">我的流程</h2><ol><li>Design - 照著參考圖刻出 figma 版型及元件</li><li>JS - 完成 filter 的功能，拿出想要的資料</li><li>JS - 照 figma 切出 component 架構</li><li>CSS - mobile 刻板</li><li>CSS - RWD</li><li>上傳至 frontend mentor + 撰寫 Readme</li></ol><h2 id="額外練習-figma-切版">額外練習 figma : 切版</h2><p>一邊練習切版以及 figma 的使用<br>本次學習 &amp; 練習</p><ul><li>元件 <code>component</code> :</li><li>變體 <strong>variants</strong> : 用程式概念想有點像 obj  <code>key-value</code> pair，可透過先建立好的類似類型，再替換選項。<br>常用的例子 : 有無圖案，實心空心，方向。<br>figma 是 <code>[property,value]</code> 來替換。<blockquote><p>obj 的 key 不能重複， <strong>figma 的 property 也是不能重複</strong>。<br>如果不在同一個 frame 裡的元件不能結為變體</p></blockquote></li><li><strong>auto layout</strong> : 有點像 css 的 flex</li><li><strong>asset</strong> : 將重複的物件作做成元件，放到元件庫</li><li>巢狀結構 : 用 <code>/</code> 斜線來代表類似的元件群組</li></ul><p>最後切出來的元件<br><img data-src="https://dsm01pap006files.storage.live.com/y4mZHL-B7h3iluUZzub-BxoLDbrZc2Wp43yRJd2NVsXDW2zIV5XhtSM4KNshxjCkPBfsHoSgqnK2Kdxg1pBBWw0T5RjD-TTXkiNZn69EENIX9dqbxu3K51pbNjKeNhyHJ1bpXSDwFX9c_cUoC8vv_UUaPUbmLmE9C2qcbYmNRl93CPWgVuKOBRb8U8crh2FSTTU?width=656&amp;height=1024&amp;cropmode=none" alt="Asset"></p><p>菜鳥設計稿 🥴，照著圖片檔慢慢切出來<br><img data-src="https://dsm01pap006files.storage.live.com/y4mwTdZBRAfGvMzTnynXGFrQ4yShvVgoGM-PJdXLOnF-3zi3OCyKeWiW1TYFmpurDs8l3lReNkOzMNTIDjoFCNdWNQbukzoR0iXkfmz9edOCJrqOrnH-aS2aT-17DZPd3W4cOL2lLovbNjta_rMsjlzeAgNDWQf458D4AxkOyiGYVlSHwfLTq1slPvuG8YDTHV4?width=1024&amp;height=800&amp;cropmode=none" alt="設計稿"><br>上半部都是變體的設定</p><h3 id="變體設定">變體設定</h3><p>變體部分是透過 nested 的方式，從元件最小的部分到整塊卡片都是可以切換</p><ol><li>卡片種類，我把每一種都先做樣板，可以直接替換卡片。<br>發現用處不大 XD，因為卡片都只有一張…，替換順序倒是蠻有幫助的。</li><li>滑鼠移入 <code>:hover</code> active &amp; inactive。<br>我直接做在 setting component 上</li><li>Profile 底下的時間節點切換，把 daily 、 weekly 等等的跟 setting 一樣分成 active 跟 inactive。</li><li>電腦版型  &amp; 手機版型 卡片，用處也不大。當時是想說如果多一種版型可以思考…</li><li>背景的 icon 切換，這是在做個別卡片原件快速切換用的而已</li></ol><p>在把上述的合併起來，在面板可以自由切換 😃<br>接下來就是進到寫程式的環節🥰</p><h2 id="React-部分">React 部分</h2><p>練習題較少用到使用到 React Hooks<br>大部分還是 CSS 居多<br>只有使用 <code>useState</code>、<code>useMemo</code> 而已</p><h3 id="svg-當作-component-匯入">svg 當作 component 匯入</h3><p><a href="https://create-react-app.dev/docs/adding-images-fonts-and-files/">官方</a> 要引入圖片有兩種方式</p><ol><li>當作 component 匯入 (svg)</li><li>直接匯入圖檔來源</li></ol><p>圖檔是 svg ，這邊我採用 component 的方式，主要是想改變 hover 時的填色</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 當作元件匯入</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">ReactComponent</span> <span class="keyword">as</span> <span class="title class_">Play</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./images/icon-play.svg&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/*作為元件使用*/&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Play</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>關於第二點，使用 <code>src</code> 引入圖檔<br>因為 deploy 之後 <code>index.html</code> 的路徑無法對上，有的人會建議把圖檔放在 <code>public</code> 上，在透過相對路徑引入。<br>或者讓 webpack 幫我們透過 JavaScript module (file loader)來處理，不過要注意的是，路徑的起始點是 <code>./</code>，所以後續在 deploy 時要設定 <code>homepage</code> 來矯正路徑</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 這邊是相對路徑字串</span></span><br><span class="line"><span class="keyword">import</span> play <span class="keyword">from</span> <span class="string">&#x27;./images/icon-play.svg&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/*作為路徑使用*/&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;play&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;Play icon&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="從外部匯入的-Element-轉成正確的-React-component">從外部匯入的 Element 轉成正確的 React component</h3><p>這邊我需要找到對應的樣式跟 icon 圖，起初我是回傳 <code>[Icon[type], theme.primary[type]]</code><br>預想中是在 component 中要拿到 <code>&lt;Play/&gt;</code> 這樣的 svg as component<br>轉出來的是 component <code>&#123;Play&#125;</code> 這樣可以，看起來好像一般的值，我想改成 tag 的形式，加上 <code>&lt;&gt;</code> 反而變成  <code>React Element</code> 。<br>從<a href="https://github.com/facebook/react/issues/13445#issuecomment-414389398">官方的 issues 這篇</a> 有提到，是因為 <strong>格式錯誤</strong><br>加上 tag 的方法實際上變成這樣 <code>&lt;&lt;Play/&gt;/&gt;</code>，可以用 function 先把元件輸出再使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// svg as component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Icon</span> = &#123;</span><br><span class="line">    <span class="title class_">Exercise</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Exercise</span> /&gt;</span></span>,</span><br><span class="line">    <span class="title class_">Play</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Play</span> /&gt;</span></span>,</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 拿到該圖檔跟顏色</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">type2Style</span>(<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type.<span class="title function_">includes</span>(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">        type = type.<span class="title function_">replace</span>(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// React Element -&gt; Component，把 React Component </span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">BgIcon</span> = (<span class="params"></span>) =&gt; <span class="title class_">Icon</span>[type];</span><br><span class="line">    <span class="keyword">return</span> [<span class="title class_">BgIcon</span>, theme.<span class="property">primary</span>[type]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="資料轉化">資料轉化</h3><p>這部分是想要熟悉如何去使用 Object &amp; Array 的 function<br>把自己想要的資料召喚出來，目前已知的是按鈕切換取得資料，<code>useState</code> 在 set 的時候做 re-render 讓我們可以看到資料改變後畫面也改變。</p><ul><li>Click Event</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 1. 觀察 timeframe 改變時設定的值</span></span><br><span class="line">    <span class="keyword">const</span> [timeframe, setTimeframe] = <span class="title function_">useState</span>(<span class="function">() =&gt;</span></span><br><span class="line">        <span class="title class_">Type2Data</span>(timetype.<span class="property">daily</span>, data)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 2. 點擊後改變 type</span></span><br><span class="line">    <span class="keyword">const</span> [type, setType] = <span class="title function_">useState</span>(timetype.<span class="property">daily</span>);</span><br><span class="line">    <span class="comment">// 3. 傳入 type 值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">clickhandler</span> = (<span class="params">type</span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">setTimeframe</span>(<span class="function">() =&gt;</span> <span class="title class_">Type2Data</span>(type, data));</span><br><span class="line">        <span class="title function_">setType</span>(<span class="function">() =&gt;</span> type);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeProvider</span> <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">TimerLayout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;/* 4. 把 handler 當作 props 傳給元件的 button */&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">ProfileCard</span> <span class="attr">clickhandler</span>=<span class="string">&#123;clickhandler&#125;</span> <span class="attr">type</span>=<span class="string">&#123;type&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;timeframe.map((&#123; last, title, prev, current &#125;, i) =&gt; (</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">TimeframeCard</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">key</span>=<span class="string">&#123;i&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">data</span>=<span class="string">&#123;&#123;</span> <span class="attr">last</span>, <span class="attr">title</span>, <span class="attr">prev</span>, <span class="attr">current</span> &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    /&gt;</span></span></span><br><span class="line"><span class="language-xml">                ))&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">TimerLayout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ThemeProvider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>轉換資料的 function</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Type2Data</span>(<span class="params">type, data</span>) &#123;</span><br><span class="line"><span class="comment">// 初始值是陣列</span></span><br><span class="line">    <span class="keyword">return</span> data.<span class="title function_">reduce</span>(<span class="function">(<span class="params">p, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 把官方給的 data.json 解構</span></span><br><span class="line">        <span class="keyword">const</span> &#123; title, timeframes &#125; = n;</span><br><span class="line">        <span class="comment">// 2. 畫面上需要轉換 timeframe 的文字</span></span><br><span class="line">        <span class="keyword">let</span> type2text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> timetype.<span class="property">daily</span>:</span><br><span class="line">                type2text = <span class="string">&quot;day&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> timetype.<span class="property">weekly</span>:</span><br><span class="line">                type2text = <span class="string">&quot;week&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> timetype.<span class="property">monthly</span>:</span><br><span class="line">                type2text = <span class="string">&quot;month&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 把符合的 timeframe 資料抓出來，後續要透過 map 把資料印出來</span></span><br><span class="line">        p.<span class="title function_">push</span>(&#123;</span><br><span class="line">            <span class="attr">last</span>: type2text,</span><br><span class="line">            title,</span><br><span class="line">            <span class="attr">prev</span>: timeframes[type].<span class="property">previous</span>,</span><br><span class="line">            <span class="attr">current</span>: timeframes[type].<span class="property">current</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搭拉 ! 當我按下按鈕，state 改變進行 re-render<br><img data-src="https://i.imgur.com/P9Aj0ae.gif" alt="切換 timeframe"></p><h3 id="useMemo-把資料記起來">useMemo : 把資料記起來</h3><p>由於我的圖片以及顏色是透過計算而來，而不是寫死的， 每次 state 改變時也會 re-render ，導致每次都重新計算一次😓。<br>但是 <strong>樣式內容是不變</strong> 的，所以用 <code>useMemo</code> 包起來，紀錄樣式資料</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TimeframeCard</span>(<span class="params">&#123; data &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; last, title, current, prev &#125; = data;</span><br><span class="line">    <span class="comment">// 避免 re-render 又跑一次</span></span><br><span class="line">    <span class="keyword">const</span> [<span class="title class_">BgIcon</span>, <span class="title class_">BgColor</span>] = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">type2Style</span>(title), [title]);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">TimeframeCardContainer</span> <span class="attr">bgcolor</span>=<span class="string">&#123;BgColor&#125;</span> <span class="attr">br</span>=<span class="string">&#123;br&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">BgIcon</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">FrameBody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">FrameHeader</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">FrameHeaderTitle</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">FrameHeaderTitle</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Setting</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">FrameHeader</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">FrameContent</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">CurrentText</span>&gt;</span>&#123;current&#125;hrs<span class="tag">&lt;/<span class="name">CurrentText</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">PrevText</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        Last &#123;last&#125; - &#123;prev&#125;hrs</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">PrevText</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">FrameContent</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">FrameBody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">TimeframeCardContainer</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>後來寫文時，我覺得這邊寫的不是很好，既然是固定的，我為什麼要透過計算來取得樣式呢🥴<br>回想當初在寫，多想到如果改成客製化卡片，樣式內容就會改變，以目前的練習題並沒有這個需求😅<br>也許可以作為之後的 :Todo</p><h3 id="Deploy-部屬網站">Deploy : 部屬網站</h3><p><code>package.json</code> 需要設定 homepage 將路徑重新設定，否則輸出的 build 裡面的 index.html 引入的東西會找不到。<br><a href="https://create-react-app.dev/docs/deployment/#building-for-relative-paths">Deployment 官方教學</a></p><ul><li>package.json</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;my-app&quot;</span>,</span><br><span class="line">  <span class="comment">// 我發布在網頁上的路徑</span></span><br><span class="line">+ <span class="string">&quot;homepage&quot;</span>: <span class="string">&quot;https://meitung473.github.io/time-tracking-dashboard-main/&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS部分">CSS部分</h2><p>包含 styled-component 以及一些 CSS 遇到的問題</p><h3 id="normalize-css">normalize.css</h3><p>我記得在 create-react-app 使用 normalize 在 <code>index.css</code> 加上 :</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import-normalize</span></span><br></pre></td></tr></table></figure><p>結果 IDE 提示格式錯誤以外，感覺好像都沒作用<br><img data-src="https://dsm01pap006files.storage.live.com/y4muj1fnDJhMGuehE88QmzA1uezUw5o7ocb8_KQf52VuXLdBQFYupbRyS3943vlDwAYqGq1KtqHfS80RjlFnRRYsuOvLIUb1Nd-Rog1ThCib7FhPDbyqo_bYip_65arJPHfXKV5Q4g4iJGC1JO8kls0kAU8JQXlHFxFogThYvQFB2GRkhdoUH31i7XUKHkXADaH?width=1024&amp;height=115&amp;cropmode=none" alt="IDE 提示格式錯誤"><br>我是按照官方的 <a href="https://create-react-app.dev/docs/adding-css-reset/#browser-support">教學</a><br>打開 devtool 反而是多了 <code>where:</code> 的樣式，所以並不是沒有<br><img data-src="https://dsm01pap006files.storage.live.com/y4mzXONRr23Eb4GiE7hLxjSlL9TuG5SxD6Xhhcl5xYKY__SAR-WM9kUhCeYYOZQpf1O6AFdFl27BwQM1_6LlbadtlQvNV1T-VtH7aIhhR0MP35pOqAxyfMIjPgTVbN0UhbGShKwyy-LxhksBAcP-GSYnocw-tj-k3YF6zbeelM3Tn2MOfTm-p5cIGAwkqtW9xUl?width=1024&amp;height=147&amp;cropmode=none" alt="where:"></p><p>我查到 <a href="https://stackoverflow.com/questions/56532121/normalize-css-does-not-fully-add-reset-to-react-app">這篇</a> 解釋為什麼 normalize.css 其實有不同份，如果在另外安裝 <a href="https://github.com/necolas/normalize.css">normalize.css</a> ，引入為什麼作用是因為 <strong>根本沒有指向到這版</strong>。</p><p>目前的 React 是使用 <code>@csstool/normalize</code> 而不是 <code>necolas/normalize</code> 版的<br>關於這兩份的差別，<a href="https://github.com/csstools/normalize.css/issues/3">共同作者解釋</a> 是移除一些固定格式的設定像是 (<code>body&#123;margin:0&#125;</code>) ，以及兼顧瀏覽器的兼容性問題。 🤔</p><p>另外我也查了一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:where">:where</a> 偽元素，為什麼 normalize 會使用這個。<br>以往在寫 CSS 必須注意權重的問題，而 <code>:where</code> 的權重是 0 ，不管設定的 CSS 權重後來的值都可以覆蓋過去， 相較 <code>:is()</code> 來的更適合設定預設值。<br>目前幾乎所有的瀏覽器都有支援，IE 因為今年六月要被淘汰了，就沒差了吧 🥴</p><h3 id="styled-components-media-query">styled-components @media query</h3><p>在之前學習是寫成個別一行，再一個個 import 到需要改動的元件裡面做修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> breakpoint_md = <span class="string">&quot;@media screen and (min-width: 768px)&quot;</span>;</span><br></pre></td></tr></table></figure><p>不過都 CSS-in-JS 了，不如把它變得更加程式化一點。<br>我在寫 styled-component 時只把他想成 <strong>會產出一大串的文字</strong>，想要做到 sass 的 @mixin 功能，改成寫 function 回傳想要的字串。<br>所以這次的目標是 :</p><blockquote><p>object 透過 key 拿到 <code>@media</code> 的字串，例 <a href="http://breakpoint.md">breakpoint.md</a> 對應 min-width : 768px</p></blockquote><p>參考 : <a href="https://dev.to/cagatayunal/how-to-use-css-media-query-breakpoint-in-styled-components-9of">How to use CSS Media Query Breakpoint in Styled-Components</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先寫好對應的尺寸</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sizes = &#123;</span><br><span class="line">    <span class="attr">xxl</span>: <span class="number">1440</span>,</span><br><span class="line">    <span class="attr">xl</span>: <span class="number">996</span>,</span><br><span class="line">    <span class="attr">md</span>: <span class="number">768</span>,</span><br><span class="line">    <span class="attr">sm</span>: <span class="number">576</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @media 固定的格式，從手機往上寫 &#123;size&#125; 拿來做替換</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;@media screen and (min-width: &#123;size&#125;px)&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> br = <span class="title class_">Object</span>.<span class="title function_">keys</span>(sizes).<span class="title function_">reduce</span>(<span class="function">(<span class="params">p, n</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/* 轉換過後的 sizes : [&#x27;xxl&#x27;,&#x27;xl&#x27;,...]</span></span><br><span class="line"><span class="comment">我們只要</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">n1 : sizes[n1]</span></span><br><span class="line"><span class="comment">n2 : sizes[n2]</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用取代的方式</span></span><br><span class="line">    p[n] = prefix.<span class="title function_">replace</span>(<span class="string">&quot;&#123;size&#125;&quot;</span>, sizes[n]);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure><p>不想這麼麻煩也可以直接透過 template 帶值<br><code>@media screen and (min-width: $&#123;sizes[n]&#125;px)</code><br>在 styled-component 內我們就可以直接使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; br &#125; <span class="keyword">from</span> <span class="string">&quot;../../Device&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FrameBody</span> = <span class="title function_">styled</span>(<span class="title class_">InfoCard</span>)<span class="string">`</span></span><br><span class="line"><span class="string">&#123;/* 直接寫 */&#125;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;br.md&#125;</span> &#123;</span></span><br><span class="line"><span class="string">        padding: 1em 1.2em;</span></span><br><span class="line"><span class="string">        cursor: pointer;</span></span><br><span class="line"><span class="string">        transition: filter 0.3s ease-out;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>這樣做 RWD 就可以比較簡單了🥰</p><h2 id="結語-15">結語</h2><p>每次練習都會覺得自己又更進步一些<br>重新思考自己的製作流程<br>最後覺得 CSS 的部份有點雜，可以抽出相同的樣式再重構<br>後續有時間再修改</p><h2 id="參考資料">參考資料</h2><ol><li><a href="https://dev.to/cagatayunal/how-to-use-css-media-query-breakpoint-in-styled-components-9of">How to use CSS Media Query Breakpoint in Styled-Components</a></li><li><a href="https://airbnb.io/javascript/react/#class-vs-reactcreateclass-vs-stateless">Airbnb JavaScript Style Guide</a></li><li><a href="https://github.com/facebook/react/issues/13445">expected a string (for built-in components) or a class/function</a></li><li><a href="https://create-react-app.dev/">Create React App</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-45&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;這是在 &lt;a href=&quot;https://www.frontendmentor.io/solutions/responsive-reactjs-styledcomponent-BkFnvCvr9&quot;&gt;frontend mentor 的挑戰題&lt;/a&gt;&lt;br&gt;
使用 React + styled-components&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://meitung473.github.io/time-tracking-dashboard-main/&quot;&gt;網頁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/meitung473/time-tracking-dashboard-main&quot;&gt;github repo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://dsm01pap006files.storage.live.com/y4m9LQmpdiru45ZO2sTWfVBoSuRS1cfQoRCmHTFQxc-7aQWX0hkbq0r2q3tefJlGHA3SeXfA_G4CV5PHZIagjALPplvZ3s9MO6tpWyEEYyL2J7ep3EbhiNczfUybFUlxBTjvVQybnsXtFwrgoLmqEFJBftLbJvhzcipVkL-hdLjY23wEqHVpwrW0vNREUMTmt-y?width=1024&amp;amp;height=585&amp;amp;cropmode=none&quot; alt=&quot;完成圖&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="React" scheme="https://blog.rosa.tw/tags/React/"/>
    
    <category term="styled-components" scheme="https://blog.rosa.tw/tags/styled-components/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - Prototype 物件導向 (IV) 原型的繼承</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-04"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-04</id>
    <published>2022-04-19T04:33:33.000Z</published>
    <updated>2022-07-27T05:30:49.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-41">前言</h2><p>上一篇知道原型與原型鏈的內容<br>如果我們要讓東西繼承，除了透過 new 建立物件直接幫我們繼承之外<br>還有 <code>Object.setPrototypeOf</code> 以及 <code>Object.create()</code></p><span id="more"></span>  <h2 id="原型如何繼承">原型如何繼承 ?</h2><ol><li><code>Object.setPrototypeOf(&lt;繼承者&gt;,&lt;被繼承者&gt;)</code> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person1, person2);</span><br></pre></td></tr></table></figure></li><li><code>Object.create(proto,屬性物件)</code> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person 物件</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Default_Name&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hi, I&#x27;m &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透過 Object.create() 將 Person 作為原型物件來建立一個新的物件</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>);</span><br><span class="line"><span class="comment">// 沒有 this.name</span></span><br><span class="line">p.<span class="title function_">sayHello</span>();   <span class="comment">// &quot;Hi, I&#x27;m Default_Name&quot;</span></span><br><span class="line"></span><br><span class="line">p.<span class="property">name</span> = <span class="string">&#x27;Rosa&#x27;</span>;</span><br><span class="line">p.<span class="title function_">sayHello</span>();   <span class="comment">// &quot;Hi, I&#x27;m Rosa&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Object-setPrototypeOf">Object.setPrototypeOf()</h2><p>上一篇我們提到 <code>[[Prototype]]</code> 是隱藏屬性<br>ES5 之前是使用 <code>__proto__</code>，ES6 新增 <code>getPrototypeOf()</code> 與 <code>setPrototypeOf()</code> 讓我們可以直接改變物件的 prototype</p><h3 id="in-某屬性是否可以透過這個物件存取">in  : 某屬性是否可以透過這個物件存取</h3><p>我們知道物件的屬性或方法不一定是本身物件的<br>而是來自原型鏈往上找到的<br>如此一來，建構物件就能使用原型鏈上的屬性<br>那怎麼確定能存取到呢 ?<br>沒錯，就是透過 <code>in</code> !</p><blockquote><p>屬性名稱必須是「字串」</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">a : <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 =&#123;</span><br><span class="line">b : <span class="number">2</span> ,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;a&quot;</span> <span class="keyword">in</span> person1) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;b&quot;</span> <span class="keyword">in</span> person1) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如果要讓 person1 也能讀取到 b 就必須改變其原型<br>可以透過 <code>Object.setPrototypeOf()</code> 直接改變<br>不過建議非必要不要直接改變物件的 prototype</p><h3 id="Object-setPrototypeOf-2">Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf(&lt;繼承者&gt;,&lt;被繼承者原型&gt;)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person1,person2)</span><br></pre></td></tr></table></figure><p>JavaScript 的原型物件是物件內部屬性，<strong>無法直接存取</strong> (通常標示為 <code>[[Prototype]]</code>)，但是可以透過 setPrototypeOf 指定物件之間的原型關係</p><blockquote><p>原型繼承的規則裡，<strong>同一個物件無法指定兩種原型物件</strong>。</p></blockquote><p>試著去存取「不存在」的屬性時，那麼 JavaScript 就會往它的 <code>[[Prototype]]</code> 原型物件去尋找 (prototype chain)</p><p>讓 <code>person1</code> 同時有 b 也有 c 屬性</p><blockquote><p>讓 b 去繼承 c，a 再繼承 b，就能同時擁有 b 與 c</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">a : <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 =&#123;</span><br><span class="line">b : <span class="number">2</span> ,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person3 = &#123;</span><br><span class="line">c : <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person2,person3)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person1,person2)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">c</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c&quot;</span> <span class="keyword">in</span> person1) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="hasOwnProperty-是否為物件本身的方法或屬性">hasOwnProperty() 是否為物件本身的方法或屬性</h3><p>有些屬性與方法是來自 prototype 繼承的<br>要確定是不是屬於自己本身用 <code>hasOwnProperty</code><br><code>objself.hasOwnProperty(&lt;property&gt;)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">a : <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 =&#123;</span><br><span class="line">b : <span class="number">2</span> ,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person1,person2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">b</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 屬性 b 並非建立於 person1 物件中，而是透過繼承的方式取得的 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;b&#x27;</span>)) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="Object-create">Object.create()</h2><p>新建物件後的 <code>[[Prototype]]</code> 就會是我們所指定的那個原型物件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> rosa = <span class="title class_">Object</span>.<span class="title function_">creat</span>(<span class="title class_">Person</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// constructor 的 prototype</span></span><br></pre></td></tr></table></figure><p>也可以是 <code>null</code>，這樣就會變成非常一般的物件 (“Very plain” objects)<br>不帶有任何 prototype 甚至是 <code>Object.prototype</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">toString</span>()) <span class="comment">//Error</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// false</span></span><br><span class="line">conosle.<span class="title function_">log</span>(obj) <span class="comment">//非常空的物件</span></span><br><span class="line">obj.<span class="property">a</span> = <span class="number">2</span> <span class="comment">// 還是可以給予屬性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123;a:2&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) <span class="comment">// [&#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure><p>但並不代表 Object 有關的方法都不能呼叫<br>而是要看方法是否在 prototype 裡<br>像是 Object.keys 依然可以使用</p><h3 id="造一個-Object-create">造一個 Object.create()</h3><p><code>Object.create()</code> 簡單實作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">create</span> = <span class="keyword">function</span> (<span class="params">proto</span>)&#123;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">F.<span class="property"><span class="keyword">prototype</span></span> = proto;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>透過一個封裝過的建構式建構出來的物件，並把 <code>prototype</code> 指向作為參數的 <code>proto</code>。</p><h2 id="Object-create-v-s-new">Object.create() v.s new ?</h2><p>兩個都是建立物件，哪裡不一樣 ?</p><blockquote><p><code>new</code> operator 跟 <code>Object.create</code> 的差別在於會不會執行 constructor</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 建立的時候，也印出 hi</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>) <span class="comment">// 指是建立了而已</span></span><br></pre></td></tr></table></figure><h2 id="參考-16">參考</h2><ol><li><a href="https://zh.javascript.info/prototype-methods#very-plain">原型方法，没有 <strong>proto</strong> 的对象</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10194356">重新認識 JavaScript: Day 25 原型與繼承</a></li><li><a href="https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/javascript-new-operator-implementation-8c0d15f2b899">new operator — JavaScript | 為了瞭解原理，那就來實作一個 new 吧！</a></li><li><a href="https://blog.csdn.net/blueblueskyhua/article/details/73135938">你不知道的javascript之Object.create 和new区别</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-41&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上一篇知道原型與原型鏈的內容&lt;br&gt;
如果我們要讓東西繼承，除了透過 new 建立物件直接幫我們繼承之外&lt;br&gt;
還有 &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; 以及 &lt;code&gt;Object.create()&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - Prototype 物件導向 (III) 原型 &amp; 原型鏈</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-03"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-03</id>
    <published>2022-04-19T04:33:30.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-42">前言</h2><p>JavaScript 的核心就在原型 !<br>原型使得物件都能使用在原型鏈上的屬性及方法<br>本身物件也可以再擴充<br>透過本篇了解原型的使用方法</p><span id="more"></span><h2 id="什麼是-prototype">什麼是 prototype ?</h2><p><img data-src="https://dsm01pap006files.storage.live.com/y4mZUP0lakeV0ZyTOBA3FOhGoj0nLq4_-h6RClQix2hTtsj-YL9kg-RwmOfya_emwZ1jekhk9jIrt-JrTQQfyiPEwOfYlVWWxlFZHdaAgkONuvg-kxkJgmo67BaKWfhEePd-7sT21E5ITCGSdla3HTIiK8NillkQBfzy2mTCrs5ZtISAl-h5eV-JiE6ySo075Ow?width=946&amp;height=563&amp;cropmode=none" alt="prototype"><br>參考圖 : <a href="https://ithelp.ithome.com.tw/articles/10194356">重新認識 JavaScript: Day 25 原型與繼承</a></p><p>從 01 篇知道 prototype 可以讓不同的物件共享原型的同一個方法或屬性<br>prototype 就像是從 function 產生的集裝箱<br>讓 function 建立出來的物件都可以拿到同樣的東西</p><blockquote><p><strong>函式也是物件</strong>，所以可以透過 prototype 來擴充每一個透過這個函式所建構的物件</p></blockquote><p>好像難以連結，不過我們時時刻刻都在使用 prototype 的概念<br>有想過為什麼基本型別的值 (number、string、bool) 可以 <strong>像 object 一樣呼較方法獲取到屬性</strong>呢 ?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="property">length</span> );</span><br></pre></td></tr></table></figure><p>沒錯，就是透過 prototype 原型提供的方法來繼承<br>在 JavaScript 呼叫方法或屬性之前，會透過基本型別包裹器 (Primitive Wrapper)<br>被轉型為該類別的「物件」，由對應的物件提供的方法是透過原型鏈 (prototype chain)<br>讓我們可以對基本型別的值呼叫方法</p><ul><li>類似這樣</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str.length 模擬過程</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// 變成物件</span></span><br><span class="line">str.<span class="property">length</span> <span class="comment">// 拿到屬性</span></span><br><span class="line">str = <span class="literal">null</span> <span class="comment">// 銷毀</span></span><br><span class="line">str = <span class="string">&#x27;Hello&#x27;</span> <span class="comment">// 恢復成基本型別</span></span><br></pre></td></tr></table></figure><h2 id="prototype-怎麼來">prototype 怎麼來 ?</h2><p><strong>函式建立時會自動產生 prototype 屬性</strong>。<br>產生的物件並&quot;不&quot;代表物件的 prototype 屬性就是這個函式的原型物件<br>而是透過 <code>new</code> 出來的物件會有 <code>[[Prototype]]</code> 的隱藏屬性<br>是指 <strong>建構式</strong> 的 prototype</p><blockquote><p><code>constructor.prototype</code></p></blockquote><p>上面的敘述很令人混亂對吧 ?<br>先舉個例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">getName</span> =<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rosa = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Rosa&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="title function_">getName</span>()) <span class="comment">// Rosa</span></span><br></pre></td></tr></table></figure><p><code>rosa</code> 是從 Person 建構出來的物件</p><blockquote><p>所以 rosa 的原型是 Person</p></blockquote><p>回到第一句話<br><strong>函式建立時會自動產生 prototype 屬性</strong></p><p>對著 <code>Person</code> 函式取 prototype ，確實是有的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// Person 本身</span></span><br></pre></td></tr></table></figure><p>prototype 讓 rosa 可以直接拿到 <code>Person</code> 裡面的方法 (getName)</p><p>那第二句是什麼意思 ?<br>試著讓 <code>rosa</code> 呼叫 <code>toString()</code>，但是 Person 並沒有這個方法呀 ?!<br>我們說過 rosa 的原型是 Person</p><blockquote><p>但 <strong>不</strong> 代表建構出來的物件 (rosa) 的 prototype 屬性就是這個函式 (Person) 的原型物件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">lgo</span>(rosa.<span class="title function_">toString</span>()) <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure><p>rosa 這裡取來的屬性或方法是來自 <code>Object.prototype</code> 傳下來的</p><p>接著第三句 <strong>建構式</strong> 的 prototype 是什麼意思 ?<br>試著對 <code>rosa</code> 取 prototype<br>新手一開始會以為 <code>rosa</code> 的 prototype 是等於 <code>Person</code> 的 prototype<br>特別要搞清楚這裡的 prototype 是指什麼(我一開始也搞混了)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>回到第一句，回想 <code>.prototype</code> 是誰產生的 ?<br>對，是 <strong>函式</strong><br>那 rosa 物件是透過建構式的方式而來<br>prototype 是隱藏屬性，沒辦法透過建構出來的物件直接取得</p><p><img data-src="https://dsm01pap006files.storage.live.com/y4mL7f71rE-gVfp4ze955AsP5mGlQNR1PYAJH4jUShpBHgc6U4Wq0pK2oYpDCsmDsGL0r2AxpMx3WXujkLUwZtgTEX_C1HPGIei28YZq0VvVXXwaTb7DT7K2RM-5ywv0SCz41iHsWPYdEp4lRb2YP19GWxtllx_EEBLXmJXO65f5jsuWSyQcLed8gq4Xo3YG0e3?width=692&amp;height=620&amp;cropmode=none" alt="藏在 contructor"></p><h2 id="取得物件的-prototype">取得物件的 prototype</h2><p>既然不能直接透過 <code>rosa.prototype</code> 取得原型<br>如果我們要知道 rosa 是繼承誰的 prototype 可以透過三種的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(rosa)) <span class="comment">// 現在比較好的拿到的方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// 從建構式拿到 [[Prototype]] 的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="property">__proto__</span>) <span class="comment">// 原本各家瀏覽器實作，後來 ES6 保留的方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(rosa)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === rosa.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === rosa.<span class="property">__proto__</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="原型鏈-Prototype-Chain">原型鏈 Prototype Chain</h2><p>原型可以讓本來 <strong>沒有某屬性的物件去存取其他物件的屬性</strong></p><h3 id="proto-溝通的原則">__proto__ : 溝通的原則</h3><p>如果本身物件沒有屬性或方法使用，可以透過原型鍊 (prototype chain) 來取得<br>那是怎麼傳的呢 ?</p><p>原本 JavaScript 沒有提供標準方法直接存取物件的 <code>[[Prototype]]</code>。<br><code>__proto__</code> 是瀏覽器實作的的，並非 EMCAScript 的標準，不是所有的環境都有這個值。</p><blockquote><p>ES5 以後的是使用 <code>Object.getPrototypeOf()</code><br>ES6 為了向下兼容，<code>__proto__</code> 也是承認的，但環境的不同支援度不同，還是用 <code>getPrototypeOf</code><br><code>__proto__</code> 是 <code>[[Prototype]]</code> 底下的屬性，屬於 setter/getter</p></blockquote><p><code>__proto__</code> 這個特殊屬性或者是 <code>Object.getPrototypeOf()</code> 都是取得某個物件的原型物件 <code>[[Prototype]]</code> 的方式。</p><p>官方比較建議使用 <code>Object.getPrototypeOf()</code>，因為 <code>__proto__</code> 比較耗效能</p><p>除了拿到物件原型的 prototype，<br>還可以透過 <code>.__proto__</code> 看原型們如何溝通</p><p><strong>範例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name</span>)&#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says meow`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lily = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;lily&#x27;</span>)</span><br><span class="line">lily.<span class="title function_">hello</span>()</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Bob</span> = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="title class_">Bob</span>.<span class="title function_">hello</span>()</span><br></pre></td></tr></table></figure><h3 id="模擬溝通">模擬溝通</h3><p>想執行 <code>lily.hello()</code><br>會依照這樣的順序尋找</p><ol><li>找 lily 本身是不是有 hello function ?<br>👉 沒有，往上一層找</li><li>找 <code>lily.__proto__</code> 是不是有 hello ?<br>👉 沒有的話，再往上一層找<br>知道 <strong>lily._<em>proto_</em> = Cat.prototype</strong></li><li>找 <code>lily.__proto__.__proto__</code> 是不是有 hello ?<br>=&gt; <code>lily.__proto__.__proto__ = Cat.prototype.__proto__</code>。<br>=&gt; <code>lily.__proto__.__proto__  = Object.prototype</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>往上找像是用鏈結的方式，所以才稱 prototype chain<br>我們找到 Object.prototype 就停止了</p><blockquote><p>那 <code>Object.prototype.__proto__</code> 呢?</p></blockquote><h3 id="最頂層的原型物件-Object-prototype">最頂層的原型物件: Object.prototype</h3><p>往上找 <code>__proto__</code>，什麼時候才會停止 ?<br>會發現 <code>Object.prototype.__proto__</code> 等於 <code>null</code>，代表 Object 是最頂層了。</p><p>在 JavaScript 幾乎所有的物件 (環境宿主物件除外)會順著原型鍊找到最頂層<br><code>Object.prototype</code> 才停止，因為 <code>Object.prototype</code> 是 JavaScript 所有物件的起源。</p><p>在 <code>Object.prototype</code> 提供的所有方法，在 JavaScript 的所有物件的可以呼叫它。</p><ul><li><code>Object.prototype.hasOwnProperty()</code> : 是否為自己的屬性或方法</li><li><code>Object.prototype.toString()</code> : 轉型成字串</li><li><code>Object.prototype.valueOf()</code> : 取得 <strong>基本型別</strong> 的值</li></ul><p>幾乎所有的值可以使用的。<br>即便建立物件時，沒有定義這些方法，但基於原型鏈的繼承，我們還是可以呼叫這些方法。</p><h2 id="instanceof-是否在物件的原型鏈上">instanceof : 是否在物件的原型鏈上</h2><p>instanceof 除了檢查 <code>constructor.prototype</code> 是不是在物件的原型鏈上<br>也能檢查 <strong>複合式物件的基本型別</strong></p><ul><li>檢查基本型別</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">100</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num) <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num <span class="keyword">instanceof</span> <span class="title class_">Number</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">valueOf</span>()) <span class="comment">// 100，基本型別的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num.<span class="title function_">valueOf</span>()) <span class="comment">//&#x27;number&#x27;</span></span><br></pre></td></tr></table></figure><p><code>valueOf()</code> 可以拿到基本型別的值</p><ul><li>檢查是不是在原型鏈上，同理使用 <code>class</code> 的結構也可以檢查</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> rosa = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa <span class="keyword">instanceof</span> <span class="title class_">User</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="物件本身-v-s-原型鏈-出現同名屬性物件">物件本身 v.s 原型鏈 : 出現同名屬性物件 ?</h2><p>物件實體與原型具有相同的屬性或方法</p><blockquote><p><strong>優先存取自己的屬性或方法</strong>，如果沒有才會再順著原型鏈向上尋找。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Yo!&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hi!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="title function_">sayHello</span>()) <span class="comment">// Yo!</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 原型的方法擴充</span></span><br><span class="line"><span class="string">class 級別的擁有 extend 往下擴充  </span></span><br><span class="line"><span class="string">實例出實體後，會尋找存在的原型，並且一層層往上找。</span></span><br><span class="line"><span class="string">如果要替原型定義其他的方法可以這樣寫    </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">// 原始</span></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says meow`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定在最上層，讓往下的都可以使用</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> =<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says meow`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Object 是最頂層，其實在這邊定義也可以。<br>如果不是同一類型都需要使用，這種方法也可以導致奇怪的問題發生</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">push</span>(<span class="string">&#x27;lol&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> arr= []</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">0</span>]) <span class="comment">// &#x27;lol&#x27;</span></span><br></pre></td></tr></table></figure><p>每一個 array 產生時已經被加上 <code>'lol'</code><br>使用上合法，但不是一個好操作</p><p>以上如果有誤，歡迎指教 QQ</p><h2 id="參考-17">參考</h2><ol><li><a href="https://ithelp.ithome.com.tw/articles/10194356">重新認識 JavaScript: Day 25 原型與繼承</a></li><li><a href="https://lidemy.com/courses/enrolled/390599">JS201 進階 JavaScript：那些你一直搞不懂的地方</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-42&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;JavaScript 的核心就在原型 !&lt;br&gt;
原型使得物件都能使用在原型鏈上的屬性及方法&lt;br&gt;
本身物件也可以再擴充&lt;br&gt;
透過本篇了解原型的使用方法&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - class 物件導向 (II) 繼承</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-02"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-02</id>
    <published>2022-04-19T04:33:24.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-40">前言</h2><p>上一篇我們提到 class 像是幫我們製作藍圖<br>有車子基本構造的藍圖<br>是不是能透過藍圖能做出其他車種的藍圖呢 ?</p><p>可以，就是繼承 !</p><span id="more"></span><h2 id="extends">extends</h2><p>要讓子物件擁有父物件的內容可以透過 <code>extends</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">newClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">OldClass</span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>範例 :</strong><br>Dog 繼承 Animal</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> makes a noise.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line"><span class="title function_">sit</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> sits.`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Mitzie&#x27;</span>);</span><br><span class="line">d.<span class="title function_">speak</span>();<span class="comment">// &#x27;Mitzie barks.&#x27;</span></span><br><span class="line">d.<span class="title function_">sit</span>(); <span class="comment">// &#x27;Mitzie sits.&#x27;</span></span><br></pre></td></tr></table></figure><p>Dog 繼承 Animal 的方法了，因此在 Dog 呼叫 speak 是可以的。</p><p>extends 背後會幫我們連接物件的 prototype<br>使我們可以取得父物件的方法或屬性。</p><blockquote><p>JavaScript 使用 prototyped-based 不能讓物件一次繼承兩種<br>但有一個方法叫 <code>mixin</code> 利用拷貝的概念達到目的</p></blockquote><p>因為我還不會，先擱著 QQ，待補<br>參考 :</p><ul><li><a href="https://zh.javascript.info/mixins">Mixin 模式</a></li></ul><h2 id="super">super()</h2><p>如果要在一開始就 <strong>呼叫父層的方法</strong>，必須加入<code>super()</code>，代表在繼承的子層初始化時，將舊數值蓋過去，要傳進的參數也要帶入。</p><blockquote><p>簡單來說，<code>super</code> 就是上一層的 <code>constructor</code></p></blockquote><ul><li>沒有 <code>super()</code> 的情況下，想在新物件生成時呼叫原型方法的 <code>speak()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> makes a noise.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">speak</span>() <span class="comment">// 建構時在這裡呼叫原型的方法  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sit</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> sits.`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Mitzie&#x27;</span>);</span><br><span class="line">d.<span class="title function_">speak</span>(); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>就會跑出</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Must call <span class="keyword">super</span> constructor <span class="keyword">in</span> derived <span class="keyword">class</span> <span class="symbol">before</span> <span class="symbol">accessing</span> &#x27;<span class="symbol">this</span>&#x27; <span class="symbol">or</span> <span class="symbol">returning</span> <span class="symbol">from</span> <span class="symbol">derived</span> <span class="symbol">constructor</span></span><br></pre></td></tr></table></figure><p>會提示你要記得加入 super，不然 <code>this</code> 使用時會出現問題</p><ul><li>加上 super 以及要初始化的值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> makes a noise.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="variable language_">super</span>(name)</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">speak</span>() <span class="comment">// 建構時在這裡呼叫原型的方法  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sit</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> sits.`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Mitzie&#x27;</span>);</span><br><span class="line">d.<span class="title function_">speak</span>(); <span class="comment">// &#x27;Mitzie makes a noise.&#x27;</span></span><br></pre></td></tr></table></figure><p>如果 super 裡面沒有傳入 <code>name</code><br><code>this</code> 是 Dog 本身，但是不具有 <code>name</code> 這個值，就會是 <code>undefined</code></p><h2 id="應用-3">應用</h2><p>繼承可以用在有 <strong>共同屬性</strong> 的時候，想再加一些附加功能，透過繼承不用完全重寫。</p><h2 id="參考-15">參考</h2><ul><li><a href="https://lidemy.com/courses/enrolled/390599">JS201 進階 JavaScript：那些你一直搞不懂的地方</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-40&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上一篇我們提到 class 像是幫我們製作藍圖&lt;br&gt;
有車子基本構造的藍圖&lt;br&gt;
是不是能透過藍圖能做出其他車種的藍圖呢 ?&lt;/p&gt;
&lt;p&gt;可以，就是繼承 !&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="OOP" scheme="https://blog.rosa.tw/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - class 物件導向 (I) 初探 OOP</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-01"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-01</id>
    <published>2022-04-19T04:33:15.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-39">前言</h2><p>JavaScript 是物件導向的語言<br>但跟其他的物件導向語言使用 class 有點不同</p><p>恩 ? Javascript 不是也用 class 嗎 ?<br>不，<code>class</code> 是語法糖，到 ES6 才問世<br>真正的 JavaScript 是使用 prototype 來達成物件導向</p><p>本系列將從現代開發用的 <code>class</code> 來了解<br>再到認識真的原汁原味 <code>prototype</code> 的作法</p><span id="more"></span><h2 id="class-的物件導向">class 的物件導向</h2><p><code>Object-oriented programming</code> 簡稱 OOP<br>物件導向的優點在於更 <strong>直覺</strong>，更模組化</p><p>ES6 是使用 class<br>ES5 以前並沒有 class，而是使用 <code>prototype</code> (原型) 的方式。<br><code>class</code> 像是藍圖，而 <code>new</code> 則是把藍圖裡的東西實例出來</p><blockquote><p>類別型的物件都是<strong>大寫開頭</strong>，這是常用的寫法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義貓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line"><span class="comment">// 每隻貓有名字</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每隻貓打招呼會喵喵叫</span></span><br><span class="line"><span class="title function_">hello</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says meow`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建立一隻叫 lily 的貓，把它存在 lily 這個變數</span></span><br><span class="line"><span class="keyword">let</span> lily = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;lily&#x27;</span>)</span><br><span class="line">lily.<span class="title function_">hello</span>() <span class="comment">// lily says meow</span></span><br><span class="line"><span class="keyword">let</span> bob = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line">bob.<span class="title function_">hello</span>() <span class="comment">// bob says meow</span></span><br></pre></td></tr></table></figure><ol><li><code>class</code> : 物件的藍圖<br>裡面的涵式不需要寫 <code>function</code> 的字，可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions#description">function shorthand</a></li><li><code>new</code> : 把藍圖實做出來，放到自訂義變數中，之後這個變數也擁有藍圖包含的功能。<br>用 <code>.</code> (dot) 連接，像 <code>object</code> 來呼叫。</li><li><code>new XXX(建構子參數)</code> : 建構子是 class 內部的涵式，可以加入參數，類似初始化。<br>對應 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//這是建構子</span></span><br><span class="line"><span class="title function_">construtor</span>(<span class="params"><span class="variable language_">arguments</span></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">arguments</span> = <span class="variable language_">arguments</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>constructor</code> : 可以看做基本資料(設定檔)，<code>this.name = name</code><br>把 new 帶入的引數作為內部建構子參數使用。</p></blockquote></li><li><code>this</code> : 分成 class 內部的 <code>this</code> 與外部的 <code>this</code>。這邊著重內部的 this。<br><code>this</code> 是對應被實體出來的主體。<br>lily 被指向叫做 lily 的貓<br>反之 bob 也是，並不是指同一個物件<br>但是內部方法是共用同一個 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lily.<span class="property">hello</span> === <span class="title class_">Bob</span>.<span class="property">hello</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><p>對於已經建立的物件再修改內部建構的值非常不建議</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lily.<span class="property">name</span> = <span class="string">&quot;rosa&quot;</span> (👎)  </span><br></pre></td></tr></table></figure><p>雖然可以修改掉內部的 <code>this.name</code> 的值<br>一般來說在建立實體時都會設定好，較少再直接透過個別更改</p><h2 id="沒有-class-的物件導向">沒有 class 的物件導向</h2><p>在 ES5 並沒有 class 的做法<br>如果沒有使用 prototype 的寫法<br>我們可以透過 function 來建構</p><blockquote><p>function 也是物件，所以可以透過 <code>.</code> 拿到屬性或方法</p></blockquote><ul><li>改寫上面的 Cat class</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name</span>) &#123;</span><br><span class="line"><span class="comment">// 用 _ (dash) 通常指被封裝在函式內的變數，類似私有變數，一般不會直接修改</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">_name</span>,</span><br><span class="line">    <span class="attr">hello</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says meow`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Lily</span> = <span class="title class_">Cat</span>(<span class="string">&quot;Lily&quot;</span>);</span><br><span class="line"><span class="title class_">Lily</span>.<span class="title function_">hello</span>();</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Bob</span> = <span class="title class_">Cat</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"><span class="title class_">Bob</span>.<span class="title function_">hello</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lily</span>.<span class="property">hello</span> === <span class="title class_">Bob</span>.<span class="property">hello</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>讓物件能呼叫方法用 <code>function</code> 回傳 function 的方式<br>但是這個方法 <strong>非常消耗記憶體</strong><br>每一個產生的 function 都是不同的 function</p><h2 id="對比圖">對比圖</h2><p><img data-src="https://dsm01pap006files.storage.live.com/y4mPsTnRBXXRDKUTn4h4YIRTBAE1Q3K4imjKAv-NaRLxF9KjYvNc3TJj5u-GvDWoZUpm_TBcByzdTcbSFqiAJtRNy43xJRnNoug9RKxYtHqxvCm-JrazXLtBM82gThGBaH8-SjTQbaFr0zZr4tGF2CuwLIl0u7I3soTI3iJ8usyN9oWE1SV6GyXIBp3snhf2Ply?width=1024&amp;height=325&amp;cropmode=none" alt="右 : ES5 ，左 : ES6"></p><p>右邊因為每一個實體都是重新創建一個新物件方法，明明要呼叫的指向實體是同一個而已。<br>改善這部分會使用到 <code>prototype</code>，讓建構的物件都有共同的方法與屬性</p><ul><li>有無使用 prototype 的寫法</li></ul><p><img data-src="https://dsm01pap006files.storage.live.com/y4meCfDywgqAcUJCJFA07OVsJ4OvfDl-Qu_nPbSoDEocZ_v0aTe19CwejVfn_H2ZHF8PR5mb1xI4pjAwUuAQLb-NdFX5VB-_AmcjbZbIrfTn8wy1Cf5im0Lr8--yFtVkM8wsSdEd-N4TO9cPP64dTTXfH0td0OWI8XuyKow6jmPGLxam61-1dH2JWOpXzMFCDg3?width=1024&amp;height=308&amp;cropmode=none" alt="左 : function 直接回傳物件，右 : 透過 prototype"></p><p>最大的差別在於產生的物件 <strong>是不是共用同一個方法</strong><br>右邊的透過 prototype 方法是都指向同一個</p><p>建立物件時右邊是使用了 <code>new</code>，幫將物件的原型綁在建構函式上</p><h2 id="new-藍圖的實作">new : 藍圖的實作</h2><p>new 到底做了什麼是呢 ?</p><ul><li>new 不 new ?</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等同於 class 的 construtor</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">buy</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`you buy a new <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> toyota = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;toyota&#x27;</span>)</span><br><span class="line">toyota.<span class="title function_">buy</span>()</span><br><span class="line"><span class="keyword">let</span> honda = <span class="title class_">Car</span>(<span class="string">&#x27;honda&#x27;</span>) <span class="comment">// 錯誤</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>沒 new 會出現 <code>Class constructor Car cannot be invoked without 'new'</code><br>代表沒有初始化。</p><h3 id="複習一下-call">複習一下 call</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hello</span>() <span class="comment">//這邊印出的 this 是全域物件  </span></span><br><span class="line">hello.<span class="title function_">call</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">//123，this 變成傳進去的東西</span></span><br></pre></td></tr></table></figure><p><code>.call</code> 是呼叫函式的另一種方法<br>透過這樣的方式可以將 this 綁在傳入的物件上</p><h3 id="手動造一個-new">手動造一個 new</h3><p>知道 call 跟 this 的關係，就能了解 <code>constructor</code> 的初始化。</p><ul><li>目標 : 不用 new 做一樣的功能</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> toyota = <span class="title function_">newCar</span>(<span class="string">&#x27;toyota&#x27;</span>)</span><br><span class="line">toyota.<span class="title function_">buy</span>()</span><br></pre></td></tr></table></figure><ul><li>用 newCar</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">buy</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`you buy a new <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">newCar</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> obj =&#123;&#125;</span><br><span class="line"><span class="title class_">Car</span>.<span class="title function_">call</span>(obj,name)</span><br><span class="line">obj.<span class="property">__proto__</span> = <span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new 其實做了 :</p><ol><li>建立一個 obj</li><li><code>.call(obj,name)</code>，呼叫建構子。把 obj 當作 <code>this</code>，name 作為參數，完成 <code>constructor</code> 的初始化。<blockquote><p>沒有這一項無法指向實體，<code>this</code> 綁定問題</p></blockquote></li><li>用 <code>__proto__</code> 導向至 prototype，跟原型進行搭橋，才能使用到該原型方法。</li><li><code>return obj</code> ，實例 (instance) 出來的東西。</li></ol><h2 id="結語-14">結語</h2><p>現代開發大多還是使用 class<br>但並非代表 JavaScript 就是用 class(類別) 來建立<br>背後依然是 function 與指定 prototype 的實作</p><p>想更了解 JavaScript 認識 prototype 是不可少的<br>同時我也查了為什麼 JavaScript 作者使用 prototype 的設計<br>而不是用類別 ，是出於什麼考量?</p><p>在<a href="https://stackoverflow.com/questions/8433459/what-s-the-purpose-of-prototype">這篇</a> 找到的的解釋是 class-based 是要 <strong>重頭設計物件</strong>，而 prototype-based 可以透過現有已建立的物件再建立，總得來說效能上更快。</p><h2 id="參考-14">參考</h2><ul><li><a href="https://lidemy.com/courses/enrolled/390599">JS201 進階 JavaScript：那些你一直搞不懂的地方</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-39&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;JavaScript 是物件導向的語言&lt;br&gt;
但跟其他的物件導向語言使用 class 有點不同&lt;/p&gt;
&lt;p&gt;恩 ? Javascript 不是也用 class 嗎 ?&lt;br&gt;
不，&lt;code&gt;class&lt;/code&gt; 是語法糖，到 ES6 才問世&lt;br&gt;
真正的 JavaScript 是使用 prototype 來達成物件導向&lt;/p&gt;
&lt;p&gt;本系列將從現代開發用的 &lt;code&gt;class&lt;/code&gt; 來了解&lt;br&gt;
再到認識真的原汁原味 &lt;code&gt;prototype&lt;/code&gt; 的作法&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="OOP" scheme="https://blog.rosa.tw/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - this (II) call、appaly、bind</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-this-II"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-this-II</id>
    <published>2022-04-15T03:07:53.000Z</published>
    <updated>2022-07-27T05:30:49.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-44">前言</h2><p>除了透過執行環境與上下文來綁定之外<br>this 是可以改變的<br>改變 this 有三種方式</p><span id="more"></span><h2 id="call-apply">call &amp; apply</h2><p>上一篇有簡略提過 <code>.call()</code><br>等同於 function 直接執行<br>而且是有帶 <code>this</code><br>第一個參數是指定 <code>this</code>，後面及是 <code>arguments</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 這樣是一樣的</span></span><br><span class="line"><span class="title function_">test</span>() === test.<span class="title function_">call</span>()</span><br><span class="line"><span class="title function_">test</span>() === test.<span class="title function_">apply</span>()</span><br></pre></td></tr></table></figure><p>這兩個執行是差不多的<br>差在後面的參數類型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test =&#123;</span><br><span class="line">a : <span class="number">1</span>,</span><br><span class="line"><span class="title function_">log</span>(<span class="params">num</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>,num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line"><span class="attr">a</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">test.<span class="title function_">log</span>(<span class="number">5</span>) <span class="comment">// 1 , 5</span></span><br><span class="line"><span class="comment">// 改變 this </span></span><br><span class="line">test.<span class="property">log</span>.<span class="title function_">apply</span>(obj,[<span class="number">5</span>]) <span class="comment">// 5 , 5</span></span><br><span class="line">test.<span class="property">log</span>.<span class="title function_">call</span>(obj,<span class="number">5</span>) <span class="comment">// 5 , 5</span></span><br></pre></td></tr></table></figure><ul><li><code>call</code> : 後面都用逗號隔開<br><code>.call(thisValue,args[0],args[1])</code></li><li><code>apply</code> : 前面為 this，後面參數為類陣列。<br><code>.apply(thisValue,[args[0],args[1]])</code></li></ul><h3 id="call-跟-apply-為什麼同時存在">call 跟 apply 為什麼同時存在 ?</h3><p>例子是來自 <a href="https://blog.huli.tw/2020/04/18/javascript-function-is-awesome/">覺得 JavaScript function 很有趣的我是不是很奇怪</a><br>這篇也探討很有趣的 JS 問題</p><ul><li>Math.max 的參數可以吃隨意數值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>如果我們要從陣列中找出最大值呢 ?<br>直接呼叫會導致錯誤<br>可以運用 apply 的參數是 <strong>陣列</strong> 的方式帶入<br>或者用 ES6 展開</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>,arr)) <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(...arr)) <span class="comment">// 6 , 展開 </span></span><br></pre></td></tr></table></figure><p>總是會有不同的情境可以使用</p><h2 id="bind">bind</h2><p>把 this 的值先綁死，不管後面怎麼 call<br>都不會變動。</p><blockquote><p>bind 回傳的是一個 <strong>function</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line"><span class="attr">a</span>:<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">test</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = obj.<span class="property">test</span>.<span class="title function_">bind</span>(o) <span class="comment">// function</span></span><br><span class="line"><span class="title function_">b</span>() <span class="comment">// 10</span></span><br><span class="line">b.<span class="title function_">call</span>(obj) <span class="comment">// 依舊是 10</span></span><br></pre></td></tr></table></figure><p>非嚴格模式底下，無論是用 call、apply 還是 bind<br>傳進去的如果是 primitive 都會被轉成 <strong>object</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">hello.<span class="title function_">call</span>(<span class="number">123</span>) <span class="comment">// [Number: 123]</span></span><br><span class="line"><span class="keyword">const</span> myHello = hello.<span class="title function_">bind</span>(<span class="string">&#x27;my&#x27;</span>)</span><br><span class="line"><span class="title function_">myHello</span>() <span class="comment">// [String: &#x27;my&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="箭頭函式-v-s-bind">箭頭函式 v.s bind</h2><p>初學時會認為 arrow funciton 有指向自己，綁定的意味<br>但兩者有很大的區別</p><ul><li><code>.bind(this)</code> : 呼叫之前就先綁定，讓被呼叫的都有固定的 <code>this</code>。</li><li>arrow function this : 箭頭函式沒有建立任何的 this，簡單來說是根本沒有自己的 this。<br>在箭頭函式使用 this，會像變數一樣，往外部尋找。</li></ul><h2 id="參考-19">參考</h2><ol><li><a href="https://blog.huli.tw/2019/02/23/javascript-what-is-this/">淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂 - Huli</a></li><li><a href="https://blog.huli.tw/2020/04/18/javascript-function-is-awesome/">覺得 JavaScript function 很有趣的我是不是很奇怪</a></li><li><a href="https://zh.javascript.info/arrow-functions">深入理解箭头函数</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-44&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;除了透過執行環境與上下文來綁定之外&lt;br&gt;
this 是可以改變的&lt;br&gt;
改變 this 有三種方式&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - this (I) 基礎概念</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-this-I"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-this-I</id>
    <published>2022-04-15T03:07:39.000Z</published>
    <updated>2022-07-27T05:30:49.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-43">前言</h2><p>在學習 JavaScript 時很多課程會建議不要急著先用 <code>this</code><br>因為 this 會跑出讓新手無法預期的結果<br>在某些情況下使用 this 反而更棘手<br>藉由本次來初步了解這個奇妙的 <strong>this</strong>!</p><span id="more"></span><h2 id="什麼是-this">什麼是 this ?</h2><ul><li>關鍵字</li><li>function 執行時，自動生成的內部物件</li><li>隨 function 執行場合不同，this 指向的值也會不同</li><li>大多數情況，this 代表的就是呼叫 function 的物件 (Owner Object of the function)。</li></ul><p>總得來說 :</p><blockquote><p>this 會因 <strong>執行的環境與上下文</strong> (context) 的不同，而有不同的結果<br>翻譯機 : <strong>跟 function 在哪裡呼叫有關</strong></p></blockquote><p>空說 this 有點難以了解，this 其實在哪裡都可以使用(非嚴格模式下)<br>JavaScript 並沒有特別限制 this 綁定在哪，所以 this 是會變來變去的<br>正因如此才顯得有點麻煩</p><h2 id="不同情況下的-this">不同情況下的 this</h2><h3 id="物件導向的-this">物件導向的 this</h3><p>this 就是 <code>instance</code> 本身，被 <strong>實例</strong> 出來的那個。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getValue</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> toyota = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;toyota&#x27;</span>)</span><br><span class="line">toyota.<span class="title function_">getValue</span>()</span><br></pre></td></tr></table></figure><p>這個例子就是 <code>toyota</code> 物件本身</p><h3 id="物件導向之外的-this">物件導向之外的 this</h3><p>脫離 <code>class</code> 後，可以再細分成</p><ol><li>一般 function 中的 this</li><li>DOM 事件中的 this</li><li><code>object</code> 的 this</li><li>arrow function 的 this <strong>(特別)</strong> ⭐</li></ol><blockquote><p>殺手鐧 : 可以用 <code>.call()</code> 來知道 this 的意義</p></blockquote><p><code>.call()</code> 是執行 function 另一種方式<br><code>.call(context,args[0],args[1])</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">p1,p2</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,p1,p2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// undefined 1 2</span></span><br><span class="line">test.<span class="title function_">call</span>(<span class="literal">undefined</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// undefined 1 2</span></span><br></pre></td></tr></table></figure><p>這兩個是一樣的，會發現原來一般呼叫 function 會少了 this<br>而這個 this 就是看執行的環境與上下文 (context) 而來的</p><p><strong>物件中的 function 呢 ?</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">p1,p2</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,p1,p2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">func : test</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">func</span>.<span class="title function_">call</span>(obj)</span><br></pre></td></tr></table></figure><p>根據上面說的</p><blockquote><p><code>this</code> 代表的就是呼叫 function 的物件</p></blockquote><p>物件呼叫，呼叫的 method 前面是 obj<br>所以 call 裡面的 this 位置是 <code>obj</code></p><h4 id="一般-function-中的-this">一般 function 中的 this</h4><p>根據環境不同，結果不同<br>但是都是 global 的物件<br>在 <strong>非嚴格模式</strong> 下</p><ul><li>node.js : <code>this = global</code><br><img data-src="https://dsm01pap006files.storage.live.com/y4mBY1X7hZFvUS0mwa7p25amxq2Q5tXcp0SRBAKj7cJNx_37JCdjvCWa0cMAjfVWWbH4a8_YsBV0qOgYrNgcg6zJ5FhgIGuLqLlMT8euJQKJx8Dr9WTfy2FGVzvqh4ES1YzVoXlfdOCNR8Q_ndRIiDSyucw5IxbNHFsKeU5KRB71oZ9e096hhsMhYq6JT-FlHeR?width=1022&amp;height=617&amp;cropmode=none" alt="global 物件"></li><li>瀏覽器 : <code>this = window</code><br><img data-src="https://dsm01pap006files.storage.live.com/y4mkwi-WphtCQHHgZoUP5u8Q0AkSyEZZcX6U6ErkFF5AKuF0z1us2zGqqo2w-Ir8auT0FL7AbZxjEfLh3Y4wyVYyLU38xVibSCWD1r70lghQMdlCieK35uGdQSgT5HKX5iStqZw2ekAtQWqgxktoKIFmMjFBf-L3h8PkZ505ii9ON4qS1jF7nRxrEJz42_hQ7AL?width=662&amp;height=300&amp;cropmode=none" alt="window 是瀏覽器的全域物件"></li></ul><blockquote><p><strong>嚴格模式</strong> 下的 this 指向全域物件是 <code>undefined</code><br>因為 this 沒有綁定誰，所以會是 <code>undefined</code>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>() <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 轉成 call</span></span><br><span class="line">test.<span class="title function_">call</span>() <span class="comment">// undefined ,沒有帶入東西，嚴格模式下是 undefined</span></span><br></pre></td></tr></table></figure><h4 id="DOM-事件中的-this">DOM 事件中的 this</h4><p>對應到事件觸發的 <strong>元素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>)</span><br><span class="line">.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以 click 為例， <code>this</code> 會導向被按到的 <strong>元素</strong> 本身</p><p>但是在事件裡 <strong>呼叫其他 function</strong> 時就要特別注意了<br>由於內部的 function 沒有綁定物件， this 會是全域物件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line"><span class="comment">// ajax 的 this 是 window 全域物件</span></span><br><span class="line">$.<span class="title function_">ajax</span>(<span class="string">&#x27;url&#x27;</span>,<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">textContent</span>,res) </span><br><span class="line">&#125;)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>可以透過其他變數將 <code>this</code> 先存起來，直接在內部呼叫的函式替換。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line"><span class="comment">// 把這邊的 this 存起來，指向的是元素本身</span></span><br><span class="line"><span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line"><span class="comment">// ajax 的 this 是 window</span></span><br><span class="line">$.<span class="title function_">ajax</span>(<span class="string">&#x27;url&#x27;</span>,<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line"><span class="comment">// 把 元素本身的 this 帶進來</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(that.<span class="property">textContent</span>,res) </span><br><span class="line">&#125;)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>下一篇會提到如何用函式的方式綁定 this</p><ul><li>轉成 <code>.call</code><br><code>el</code> 是 document 子結點取得的，這邊也可以看做一個物件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,handler,<span class="literal">false</span>)</span><br><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;type&#x27;</span>,handler.<span class="title function_">call</span>(el),<span class="literal">false</span>) <span class="comment">// 放入的是 元素 本身</span></span><br></pre></td></tr></table></figure><h4 id="object-的-this">object 的 this</h4><p>指 obj 本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">test : <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// obj</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">test</span>()</span><br><span class="line"><span class="comment">// 轉成 call</span></span><br><span class="line">obj.<span class="property">test</span>.<span class="title function_">call</span>(obj)</span><br></pre></td></tr></table></figure><h4 id="arrow-function-的-this">arrow function 的 this</h4><blockquote><p>arrow function 沒有自己的 this<br>而是用外部的 this</p></blockquote><p>箭頭函式之所以在 this 表現奇怪<br>跟其他狀況的 this 不同的是 <strong>不是哪裡被呼叫有關</strong><br>而是 <strong>在哪定義</strong> 有關<br>如果前面已定義了，就會用那個值<br>來看看例子</p><ul><li>一般 function</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hello</span>&#123;</span><br><span class="line"> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line"> &#125;,<span class="number">2000</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">hello</span>()</span><br><span class="line">a.<span class="title function_">test</span>()</span><br></pre></td></tr></table></figure><p>很明顯的 <code>new</code> 建構出來的物件<br>前面有提到是 <strong>實例</strong> 本身<br>但是裡面呼叫 function 的  this 呢 ?<br>是指 <strong>全域物件</strong><br>setTimeout 並沒有透過其他物件呼叫<br>就像在外部呼叫 <code>setTimeout</code></p><p>既然是 hello 這個物件的東西<br>我們希望 <code>this</code> 指向的是 hello 本身建構出來的物件<br><code>arrow function</code> 就派上用場了</p><ul><li>用 <code>arrow function</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hello</span>&#123;</span><br><span class="line"> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// hello&#123;&#125;</span></span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// hello&#123;&#125;</span></span><br><span class="line"> &#125;,<span class="number">2000</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">hello</span>()</span><br><span class="line">a.<span class="title function_">test</span>()</span><br></pre></td></tr></table></figure><p>arrow function 本身沒有 this<br>而是根據定義在哪，this 就是那個值<br>通常也是指箭頭函是外部的 this</p><h2 id="this-與前後文本-context-的綁定基本原則">this 與前後文本 (context) 的綁定基本原則</h2><p>this 綁定原則大概可以分四大種</p><ul><li><strong>預設綁定</strong> (Default Binding)</li><li><strong>隱含式綁定</strong> (Implicit Binding)</li><li><strong>顯式綁定</strong> (Explicit Binding)</li><li>「<strong>new」關鍵字綁定</strong></li></ul><h3 id="預設綁定">預設綁定</h3><p>宣告在 global scope 的變數，跟全域物件屬性是相同的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 直接讀</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 透過全域物件底下的屬性讀取</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>因為預設綁定，當 function 被呼叫的當下如果沒有值或是在 <code>func.call(null)</code> 或 <code>func.call(undefined)</code> 此類的情況下，此時裡面的 <code>this</code> 會<strong>自動指定至全域物件</strong>。</p><p>如果是嚴格模式， this 綁定全域物件是 <code>undefined</code></p><h3 id="隱含式綁定">隱含式綁定</h3><p>function 被宣告的地方是在 global scope 中，只要它 <strong>成為某個物件的參考屬性</strong> (reference property)，在那個 function 被呼叫的當下，該 function 即被那個物件所包含。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a  = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">a</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: func <span class="comment">// 引用 global 的 function</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>();  <span class="comment">// 2 , this是 obj 本身</span></span><br><span class="line"><span class="keyword">var</span> func2 = obj.<span class="property">foo</span>;</span><br><span class="line"><span class="title function_">func2</span>();    <span class="comment">// undefined ， 這邊的 func 是 global 的，this 是 window，a 是找不到的</span></span><br></pre></td></tr></table></figure><p>決定 this 的關鍵不在於它屬於哪個物件，而是</p><blockquote><p>在於 function「呼叫的時機點」</p></blockquote><p>透過物件呼叫某個方法 (method) 的時候，此時 this 就是那個物件 (owner object)。</p><h3 id="顯式綁定">顯式綁定</h3><ol><li><code>.bind()</code></li><li><code>.call()</code></li><li><code>.apply()</code></li></ol><p>這類直接指定 this 的 function 都可被歸類至顯式綁定的類型。</p><h3 id="new-關鍵字綁定">new 關鍵字綁定</h3><p>當一個 <code>function</code> 前面帶有 <code>new</code> 被呼叫時，會發生：</p><ul><li>會產生一個新的物件 (物件被建構出來)</li><li>這個新建構的物件會被設為那個 function 的 <code>this</code> 綁定目標，也就是 <code>this</code> 會指向新建構的物件。</li><li>除非這個 function 指定回傳 (return) 了他自己的替代物件，否則這個透過 <code>new</code> 產生的物件會被自動回傳。</li></ul><p>關於 <code>new</code>，參考 : <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new#description">MDN 對 new 的說明</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title function_">foo</span>( <span class="number">123</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj.<span class="property">a</span> );      <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><h2 id="this-的應用-Cascade-組合技">this 的應用 : Cascade 組合技</h2><p>Cascade 也有人稱作 <strong>「Fluent Interface」</strong><br>可以讓 method 串串樂</p><p>JavaScript 允許函式 <code>return undefined</code><br>那改成 <code>return this</code> 呢 ?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calNum = <span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">num</span> = num;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">newNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> += newNum;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sub</span> = <span class="keyword">function</span>(<span class="params">newNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> -= newNum;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">multi</span> = <span class="keyword">function</span>(<span class="params">newNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> *= newNum;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">division</span> = <span class="keyword">function</span>(<span class="params">newNum</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> /= newNum;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 透過 new 建立實體，this 是 calNum本身</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">calNum</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 分開呼叫</span></span><br><span class="line">a.<span class="title function_">add</span>(<span class="number">50</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a.<span class="property">num</span> ); <span class="comment">// 150</span></span><br><span class="line">a.<span class="title function_">sub</span>(<span class="number">100</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a.<span class="property">num</span> ); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><p>當回傳 this 時，指的是物件本身，可以往後串在一起，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="title function_">add</span>(<span class="number">50</span>).<span class="title function_">sub</span>(<span class="number">100</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a.<span class="property">num</span> ); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><p>JQuery 中的也是用 method chain (方法鏈) 這樣的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;div&#x27;</span>).<span class="title function_">addClass</span>(<span class="string">&#x27;is-active&#x27;</span>)</span><br><span class="line">        .<span class="title function_">removeClass</span>(<span class="string">&#x27;is-hide&#x27;</span>)</span><br><span class="line">        .<span class="title function_">text</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br></pre></td></tr></table></figure><p>或者 <code>Array</code> 的內建函式<br>是可以串聯不同的方法<br>而且回傳的都是 <strong>同類型</strong> 的陣列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">el</span> =&gt;</span> e*<span class="number">2</span>)</span><br><span class="line">   .<span class="title function_">filter</span>(<span class="function"><span class="params">el</span> =&gt;</span> el &gt;= <span class="number">4</span>) <span class="comment">// [4,6]</span></span><br></pre></td></tr></table></figure><h2 id="總結-24">總結</h2><p>除了轉成 <code>.call()</code> 來判斷 this<br>對於 this 也可以朝幾種方向來判斷</p><ol><li>function 的呼叫，是透過 <code>new</code> 進行的嗎？<br>如果是，那 this 就是被建構出來的物件。</li><li>function 是以 .call() 或 .apply() 的方式呼叫的嗎？ 或是 function 透過 .bind() 指定？<br>如果是，那 this 就是被指定的物件。</li><li>function 被呼叫時，是否存在於某個物件？<br>如果是，那 this 就是那個物件。</li><li>如果沒有滿足以上條件，此 function 裡的 this 就一定是全域物件<br>在嚴格模式下則是 undefined。</li></ol><h2 id="參考-18">參考</h2><ol><li><a href="https://blog.huli.tw/2019/02/23/javascript-what-is-this/">淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂 - Huli</a></li><li><a href="https://zhuanlan.zhihu.com/p/23804247">this 的值到底是什么？一次说清楚</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10193193">重新認識 JavaScript: Day 20 What’s “THIS” in JavaScript (鐵人精華版)</a></li><li><a href="https://zh.javascript.info/object-methods">对象方法，“this”</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-43&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在學習 JavaScript 時很多課程會建議不要急著先用 &lt;code&gt;this&lt;/code&gt;&lt;br&gt;
因為 this 會跑出讓新手無法預期的結果&lt;br&gt;
在某些情況下使用 this 反而更棘手&lt;br&gt;
藉由本次來初步了解這個奇妙的 &lt;strong&gt;this&lt;/strong&gt;!&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - Closure 閉包(II) 常見陷阱題</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-Closure-II"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-Closure-II</id>
    <published>2022-04-13T13:51:51.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-37">前言</h2><p>之前學習閉包沒辦法很容易連結到<br>尤其 Function 有一堆名詞變異體<br>總會好奇實際的應用情境</p><p>那發生什麼問題才會使用到 Closure 呢?<br>又怎麼在真正的專案解決問題 ?</p><span id="more"></span><h2 id="問題-在迴圈中呼叫函式">問題 : 在迴圈中呼叫函式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">  arr[i] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">arr[<span class="number">0</span>]();</span><br><span class="line">arr[<span class="number">1</span>]();</span><br></pre></td></tr></table></figure><p>複習一下 :</p><blockquote><p><code>var</code> 的切分單位是 <code>function</code></p></blockquote><p>直覺來說會覺得 <code>i</code> 是會按順序列出<br>結果是 <code>5 5</code><br>因為 for 設立的 <code>i</code> 會存在 global 中</p><p><strong>試著把運作拆開來</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>當迴圈跑完時， <code>i</code> 是 5，<code>var i  = 5</code><br>因為 5 不符合迴圈條件跳出<br>所以不管 <code>arr[?]()</code>，直接印出 <code>i</code> 是 5</p><h3 id="解決方法">解決方法</h3><h4 id="閉包">閉包</h4><p>把 function 獨立出來</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"> arr[i] = <span class="title function_">logN</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//閉包，記住當下的 i</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logN</span>(<span class="params">num</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]() <span class="comment">//0</span></span><br><span class="line">arr[<span class="number">1</span>]() <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h4 id="IIFE">IIFE</h4><p>IIFE(Immediately Invoked Function Expression) 定義完就回傳的 function</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">//拿到當下的 i</span></span><br><span class="line">  arr[i] = (<span class="keyword">function</span> (<span class="params">num</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]() <span class="comment">//0</span></span><br><span class="line">arr[<span class="number">1</span>]() <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>把原本有名的函式改為匿名函式，用<code>()</code>包裹 function，尾巴是帶入參數<code>(參數)</code>，沒有的話為空</p><h4 id="ES6-的-let">ES6 的 let</h4><p>上面出現的原因都是 <code>var</code> 的 scope 問題<br>ES6 的 let 將作用域限制在 block <code>&#123;&#125;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; arr[i] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">arr[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">arr[<span class="number">1</span>](); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>只要 <code>var -&gt; let</code> ， 就解決問題了，離開之後就不會保留。</p></blockquote><h2 id="Closure-應用">Closure 應用</h2><h3 id="Cache-暫存">Cache 暫存</h3><p>計算量大的時候避免重新計算，預先把已算好的值存起來</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">complex</span>(<span class="params">num</span>)&#123;</span><br><span class="line">  <span class="comment">// 複雜計算</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;calculate&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> num*num*num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cache</span>(<span class="params">func</span>)&#123;</span><br><span class="line">  <span class="comment">// 查看是不是有算過</span></span><br><span class="line">  <span class="keyword">var</span> ans =&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="comment">//有的話回傳索引裡的值</span></span><br><span class="line">    <span class="keyword">if</span>(ans[num])&#123;</span><br><span class="line">      <span class="keyword">return</span> ans[num]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 沒有的話才做重新計算</span></span><br><span class="line">    ans[num] = <span class="title function_">func</span>(num)</span><br><span class="line">    <span class="keyword">return</span> ans[num]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cacheComplex = <span class="title function_">cahe</span>(complex)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cacheComplex</span>(<span class="number">20</span>)) <span class="comment">// 第一次計算</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cacheComplex</span>(<span class="number">20</span>)) <span class="comment">// 從 cache 拿到的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cacheComplex</span>(<span class="number">20</span>)) <span class="comment">// 從 cache 拿到的值</span></span><br></pre></td></tr></table></figure><p>用 <code>console.time</code> 計時執行的時間<br>比起直接用 complex 算再重新算<br>會發現第二次的計算的時間明顯縮短很多</p><h3 id="隱匿資訊">隱匿資訊</h3><p>想隱匿一些資訊，讓別人不可以直接更改。<br>把方法以及變數封裝在內部，別人要調用只能呼叫你規定好的方法。</p><ul><li>以簡易計算機為例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">initNum</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> sum = initNum</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line"> <span class="attr">add</span>:<span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> sum +=num</span><br><span class="line">&#125;,</span><br><span class="line"> <span class="attr">minus</span>:<span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> sum -=num</span><br><span class="line">&#125;,</span><br><span class="line"> <span class="attr">mutiply</span>:<span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> sum *=num</span><br><span class="line">&#125;,</span><br><span class="line"> <span class="attr">divided</span>:<span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> sum/=num</span><br><span class="line">&#125;,</span><br><span class="line"> <span class="attr">getresult</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter1 = <span class="title function_">calculate</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> counter2 = <span class="title function_">calculate</span>(<span class="number">10</span>)</span><br><span class="line">counter1.<span class="title function_">add</span>(<span class="number">5</span>)</span><br><span class="line">counter2.<span class="title function_">mutiply</span>(<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter1.<span class="title function_">getresult</span>()) <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter2.<span class="title function_">getresult</span>()) <span class="comment">// 200</span></span><br></pre></td></tr></table></figure><p>一個簡單的計算機 (?)🤔<br>counter1 跟 counter2 並不會影響到彼此<br>我們只能透過現有的方法來修改 sum 的值</p><h2 id="總結-22">總結</h2><p>閉包讓我感覺是很神奇的東西<br>看起來不熟悉，但實際上我們都用到了🤔</p><h2 id="參考-12">參考</h2><ul><li><a href="https://lidemy.com/courses/enrolled/390599"> [JS201] 進階 JavaScript：那些你一直搞不懂的地方 </a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-37&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;之前學習閉包沒辦法很容易連結到&lt;br&gt;
尤其 Function 有一堆名詞變異體&lt;br&gt;
總會好奇實際的應用情境&lt;/p&gt;
&lt;p&gt;那發生什麼問題才會使用到 Closure 呢?&lt;br&gt;
又怎麼在真正的專案解決問題 ?&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - Closure 閉包(I) 基礎概念</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-Closure-I"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-Closure-I</id>
    <published>2022-04-13T13:51:39.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-36">前言</h2><p>Closure 是 JavaScript 很重要的基礎<br>藉由本篇幫助自己釐清 Closure 的概念</p><span id="more"></span><h2 id="先認識-Scope-Chain">先認識 Scope Chain</h2><p><a href="https://blog.rosa.tw/Frontend/JavaScript/JavaScript-Hoisting-II/?highlight=scope#%E4%BD%9C%E7%94%A8%E5%9F%9F-Scope">Scope</a> 是變數生存的範圍，如果在自己層級找不到就會一層一層往外找，直到 Global 為止。</p><p>這種行為就稱為「<strong>範圍鏈</strong>」(Scope Chain)。</p><blockquote><p>範圍鏈是在函式<strong>被定義的當下決定</strong> (lexical scope 來決定)的，不是在被呼叫的時候決定。</p></blockquote><h3 id="範例-2">範例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;global&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> a  = <span class="string">&#x27;change&#x27;</span></span><br><span class="line"><span class="title function_">test</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// change</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//global</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">change</span>()</span><br></pre></td></tr></table></figure><p>一開始會以為 <code>test()</code> 在 change 裡面呼叫，取得的變數 a 是 change 對不對 ?</p><p>NO NO NO,再重複一次 !</p><blockquote><p>範圍鏈是在函式<strong>被定義的當下決定</strong> 的，不是在被呼叫的時候決定。</p></blockquote><p><code>test</code> 函式在 Lexical Environments 是 gloabal 的下一層，Scope Chain 是根據 Lexical scope 決定，往上找是 gloabl 那層，所以結果才會是 <code>'global'</code></p><h2 id="為什麼要有-Closure">為什麼要有 Closure ?</h2><blockquote><p>反問 👉 <strong>沒有 Closure 會怎樣 ?</strong></p></blockquote><p>我們知道 Execution Context 執行環境在執行完 function 後，Stack 會抽掉，有關這個 function 的一切變數也會被回收而且不可再使用。</p><ul><li>如果要使用 function 裡的變數呢 ? (<code>private variable</code> 的概念)</li></ul><p>直覺可能會丟到 <code>global</code> 進行宣告，但當專案結構逐漸龐大，久而久之會造成 <strong>全域變數汙染</strong></p><p><strong>那閉包的出現解決了…</strong> :</p><ul><li>自由變數 (free variable)，只有在 function 內部可讀取變數，在外部則無法讀取。</li><li>變數暫存，減少重複的複雜計算</li></ul><h2 id="Closure-的優缺點">Closure 的優缺點</h2><ul><li><p>優點 :</p><ol><li>避免 <strong>全域變數汙染</strong></li><li>提供 <strong>自由變數</strong>，讓該 function 執行完後，變數的作用域不會因 function 結束被回收，而是會繼續存在。</li><li>避免重複執行龐大的計算<br>可以記錄前一次計算的狀態，下一次再呼叫不用重算一次 (cache 的概念)。</li><li>在多人協作的時候，有些隱密的資訊不想讓人去修改，可以使用封裝閉包的方式。<br>別人必須依照固定的寫法來取得資料，且不能修改到內部的資訊。<br>在開源資料或 API 的方法常使用這樣的方式，以免改動到內部數值。</li></ol></li><li><p>缺點 :</p><ol><li>可能保留到一些不必要的變數或資訊，造成資源多餘消耗。</li><li>只能使用涵式提供的方法，因為內部的資訊被隱蔽，在更動上較不彈性。<br>(但是相反如果不想要被改動會是優點)</li></ol></li></ul><h2 id="什麼是閉包">什麼是閉包 ?</h2><p>除了自己本身的程式碼外，也可以取得了<strong>內部函式「當時環境」的變數值</strong>，記住了執行當時的環境，這就是「閉包」。</p><h2 id="簡單的-Closure-範例">簡單的 Closure 範例</h2><ul><li>沒有使用閉包</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rate = <span class="number">.75</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">itmePrice</span>(<span class="params">price</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> price &gt;= <span class="number">100</span> ? price*rate : price</span><br><span class="line">&#125;</span><br><span class="line">rate = <span class="number">.1</span> </span><br><span class="line"><span class="keyword">let</span> bag = <span class="title function_">itmePrice</span>(<span class="number">150</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bag)</span><br></pre></td></tr></table></figure><blockquote><p>可以透過直接修改數值 (👎)<br>任何人都可以在外部進行修改</p></blockquote><ul><li>使用閉包</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">itmePrice</span>(<span class="params">price</span>)&#123;</span><br><span class="line"><span class="comment">// 把 rate 變成私有變數</span></span><br><span class="line"><span class="keyword">var</span> rate = <span class="number">.75</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> price &gt;= <span class="number">100</span> ? price*rate : price</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bag = <span class="title function_">itmePrice</span>(<span class="number">150</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bag</span>())</span><br></pre></td></tr></table></figure><blockquote><p>只要呼叫需要的東西即可 (👍)<br>不會被外部修改</p></blockquote><h2 id="參考-11">參考</h2><ol><li><a href="https://blog.huli.tw/2018/12/08/javascript-closure/">所有的函式都是閉包：談 JS 中的作用域與 Closure - Huli</a></li><li><a href="https://javascript.info/closure#lexical-environment">Variable scope, closure</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10193009">重新認識 JavaScript: Day 19 閉包 Closure</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-36&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Closure 是 JavaScript 很重要的基礎&lt;br&gt;
藉由本篇幫助自己釐清 Closure 的概念&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - 事件機制原理 &amp; 事件代理</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-EventFlow-EventListener"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-EventFlow-EventListener</id>
    <published>2022-04-12T02:24:14.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-38">前言</h2><p>事件是什麼 ? 為什麼要用事件代理呢 ?<br>在不了解事件的流程與運作機制，是不是遇過點一下元素<br>結果跑出兩次以上的結果<br>透過本篇幫自己釐清事件各種大小事</p><span id="more"></span>  <h2 id="EventFlow-網頁元素接收事件的順序">EventFlow : 網頁元素接收事件的順序</h2><p><img data-src="https://dsm01pap006files.storage.live.com/y4m9V74R0Rbxh2VocqOo5K1vnxJNiyqAL1pr2Vw2o2yxenGxG5Uq3iMSm5n1bXDNs7hubkxY7rtnZfQtgz3tSNPDcX22k_WWBKKto5w_fnALPe1MSGDNDjlF11Yr7svwp8O0b8PmsLyMikVMa0Be3EWrsugI0ZsfWzkq9aYgX7R48Jm2YL0dJs6VWHvl3tqxowk?width=1208&amp;height=1160&amp;cropmode=none" alt="EventFlow"></p><ul><li><code>Capture phase</code> : 捕獲階段指由 <strong>上到下</strong> 傳下去的</li><li><code>Target phase</code> : 目標階段，本身被作用的目標才會在這個階段</li><li><code>Bubbling phase</code> : 冒泡階段 指由 <strong>下往上</strong> 傳去的</li></ul><p>透過 <code>e.eventPhase</code> 可以看見事件的階段<br>當我點下 link</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;link capturing&#x27;</span>,e.<span class="property">eventPhase</span>);</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;link bubbling&#x27;</span>,e.<span class="property">eventPhase</span>);</span><br><span class="line">&#125;)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box capturing&#x27;</span>,e.<span class="property">eventPhase</span>);</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box bubbling&#x27;</span>,e.<span class="property">eventPhase</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">box capturing <span class="number">1</span>  <span class="comment">// CAPTURING_PHASE</span></span><br><span class="line">link capturing <span class="number">2</span> <span class="comment">// AT_TARGET </span></span><br><span class="line">link bubbling <span class="number">2</span> <span class="comment">// AT_TARGET </span></span><br><span class="line">box bubbling <span class="number">3</span> <span class="comment">// BUBBLING_PHASE</span></span><br></pre></td></tr></table></figure><p>出現的代碼就是事件的不同階段</p><h3 id="事件冒泡-Event-Bubbling">事件冒泡 (Event Bubbling)</h3><p>啟動事件的元素往上傳遞到 <strong>根節點</strong> (document)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>TITLE<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>CLICK<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>冒泡傳遞方向 :<br>CLICK 事件本身元素 👉 body 👉 html 👉 document</p><h3 id="事件捕獲-Event-Capturing">事件捕獲 (Event Capturing)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>TITLE<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>CLICK<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>捕獲傳遞方向 :<br>document 👉html 👉 body 👉CLICK 事件本身元素</p><h3 id="事件是哪種機制">事件是哪種機制 ?</h3><p>兩種都會，當我按下按鈕，如果外層元素也有綁定 <strong>事件</strong>，同時也會被觸發</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.outer&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.inner&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>結果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">hi <span class="comment">// 冒泡而觸發</span></span><br></pre></td></tr></table></figure><p>點擊 <code>inner</code> 時，同時出現 hello 跟 hi<br>因為冒泡的關係，outer 也被觸發。</p><h3 id="事件的捕獲-冒泡順序">事件的捕獲 &amp; 冒泡順序 ?</h3><ul><li>對於 <strong>非觸發事件</strong> 本身的元素</li></ul><blockquote><p>先捕獲後冒泡</p></blockquote><ul><li>事件本身<br>在以往的文章中都是 <strong>按照程式碼執行的順序</strong><br>當我試著執行後卻發現即使把冒泡放在前面，捕獲放後<br>一樣都是 <strong>先捕獲再冒泡</strong><br>仔細一查，才發現原來是 Chorme 89 以後的版本都會先捕獲再冒泡<br>89 之前的版本就會是看程式碼執行的順序<blockquote><p>出現這樣的狀況是因為 shadow DOM 引起的，詳細原因請參考 <a href="https://juejin.cn/post/6965682915141386254#heading-2">這篇</a></p></blockquote></li></ul><p>所以，新版的瀏覽器不管是哪個都是 <strong>先捕獲再冒泡</strong></p><h2 id="事件的註冊綁定">事件的註冊綁定</h2><ol><li><code>on-event</code> : 有 HTML 中 inline on-event；JS on-event 接 function</li><li><code>EventListener</code> : addEventListener、removeEventListener…等</li></ol><h3 id="on-event">on-event</h3><ol><li>Html <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> </span></span><br><span class="line"><span class="tag"><span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;click&#x27;)&quot;</span>&gt;</span>click </span><br><span class="line">me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>目前很少這樣寫，其一原因是不好維護</li><li>非 Html <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>)</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>我們最常看見 <code>window.onload</code> 也是事件的 on-event</p><h3 id="EventListener">EventListener</h3><h4 id="addEventListener">addEventListener</h4><p>有三個參數</p><ol><li>事件名稱</li><li>事件處理器 (觸發時執行的 function)</li><li>Boolen ，以 「捕獲」 或「冒泡」 機制執行， <code>false</code> (不指定) 為 冒泡</li></ol><blockquote><p>第三個布林值，不是改變事件傳遞的方式，而是在 <strong>哪裡進行監聽</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HI&#x27;</span>); &#125;);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HI&#x27;</span>); &#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 捕獲 </span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HELLO&#x27;</span>); &#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="removeListener">removeListener</h4><p>跟 addEventListener 一樣，如果要解除的話 handler 的 function 必須是同一個實體才行</p><blockquote><p><strong>為什麼說是同一實體 ?</strong><br>回想這個例子 <code>&#123;&#125; === &#123;&#125; // false</code><br>function 也是 Object 的一種<br>匿名函式沒有指定給變數時，都是屬於不同的記憶體位址</p></blockquote><p>事件監聽使用匿名函式的寫法，就像潑出去的水，回不來了 🤔</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HI&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件，但是沒用</span></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HI&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>解決此問題，把 handler 的 function <strong>獨立出來</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> clickhandler = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HI&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,clickhandler&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 移除事件，ok!</span></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>,clickhandler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="on-event-v-s-EventListener">on-event v.s EventListener</h3><ul><li><p><code>EventListener</code> : 可以重複指定多個「處理器」(handler) 給同一個元素的同一個事件</p></li><li><p><code>on-event</code> : 只認一個，後面多寫的會覆蓋前面的事件</p></li><li><p>on-event</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi!&#x27;</span>) <span class="comment">// 不會出現</span></span><br><span class="line">&#125;;</span><br><span class="line">btn.<span class="property">onclick</span>= <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello!&#x27;</span>) <span class="comment">// 會出現 hello</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li>EventListener</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi!&#x27;</span>) <span class="comment">// 出現 hi</span></span><br><span class="line">&#125;&#125;);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello!&#x27;</span>) <span class="comment">// 再出現 hello</span></span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="EventHandler-中的-“event”">EventHandler 中的 “event”</h2><p>事件物件會依照 <strong>觸發的事件</strong>(click、change) ，內容會有稍微不同<br>通常看到 <code>event</code> 寫成 <code>e</code> 、<code>evt</code> 是為了方便，也可以自訂譯名稱<br>只是大家會選擇有意義的名稱且好記</p><p>可以試著在事件觸發印出 <code>e</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">常見的屬性   </span></span><br><span class="line"><span class="string">-   `</span>type<span class="string">` : 表示事件的名稱</span></span><br><span class="line"><span class="string">-   `</span>target<span class="string">` : 表示觸發事件的元素</span></span><br><span class="line"><span class="string">-   `</span>bubbles<span class="string">` : 表示這事件是否是在「冒泡」階段觸發 (`</span><span class="literal">true</span><span class="string">` / `</span><span class="literal">false</span><span class="string">`)</span></span><br><span class="line"><span class="string">-   `</span>pageX<span class="string">` / `</span>pageY<span class="string">` : 表示事件觸發時，滑鼠座標在網頁的相對位置  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 阻擋預設行為 event.preventDefault()</span></span><br><span class="line"><span class="string">&gt;並不會阻止事件向上傳遞 (事件冒泡) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.link&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"></span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box&#x27;</span>) <span class="comment">// 依然會出現</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>on-event</code> 在 eventhandler function 的<strong>最後</strong>加上 <code>return false;</code> 也會有 <code>event.preventDefault()</code> 的效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.link&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等於 e.preventDefault()</span></span><br><span class="line">link.<span class="property">onclick</span>=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="應用範例一-表單-submit-前的檢查">應用範例一 : 表單 submit 前的檢查</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        帳號</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        密碼</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用者按下 submit 按鈕會送出表單<br>前端可以先做驗證，確認使用者的輸入是不是符合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;form&quot;</span>)</span><br><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&#x27;submit&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="comment">//先阻止送出</span></span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;[name=&#x27;username&#x27;]&quot;</span>).<span class="property">value</span></span><br><span class="line">    <span class="keyword">let</span> password = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;[name=&#x27;password&#x27;]&quot;</span>).<span class="property">value</span></span><br><span class="line">    <span class="comment">// 檢查欄位</span></span><br><span class="line">    <span class="keyword">if</span>(!username) <span class="keyword">return</span> <span class="title function_">alert</span>(<span class="string">&#x27;請輸入使用者帳號&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(!password) <span class="keyword">return</span> <span class="title function_">alert</span>(<span class="string">&#x27;請輸入密碼&#x27;</span>)</span><br><span class="line">    <span class="comment">// 都有輸入就送出</span></span><br><span class="line">    form.<span class="title function_">submit</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="應用範例二-避免超連結造成網頁跳轉">應用範例二 : 避免超連結造成網頁跳轉</h4><p>按下 <code>a</code> 的時候會找網頁的錨點，如果沒有的話會跳 <code>#</code> 井字號<br>如果不想要出現井字號呢 ?<br>有些是對外連結，有些是內連結使用，總不能阻擋每個吧 !</p><p>這邊用我使用 <code>class</code> 分開外部連結</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;www.example.com&quot;</span>&gt;</span>我是普通超連結<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>gotoTop<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 選沒有 link class 的 a 標籤</span></span><br><span class="line"><span class="keyword">let</span> actionLink = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;a:not(.link)&#x27;</span>)</span><br><span class="line">actionLink.<span class="title function_">forEach</span>( <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    a.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">        e.<span class="title function_">preventDefault</span>();</span><br><span class="line">        <span class="comment">// 判斷各個 actionLink 要做的事</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>這樣就可以分出哪些是外部連結，哪些是內網頁連結，而且不會出現 <code>#</code> 井字號 😃</p><h3 id="阻擋事件冒泡傳遞-event-stopPropagation">阻擋事件冒泡傳遞 event.stopPropagation()</h3><blockquote><p>阻止的動作，加在冒泡發生的元素上</p></blockquote><p>如果不要讓 box 出現，加在想停止冒泡的地方 <code>event.stopPropagation()</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.link&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這裡會發生冒泡，要阻止上傳</span></span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box&#x27;</span>) <span class="comment">// 不會出現</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可以試著註解 <code>e.stopPropagation();</code> 會發現當你按下 link<br>因為 link 冒泡機制導致 box 的事件也觸發而印出 <code>'box'</code></p><h4 id="阻止任何的傳遞-event-stopImmediatePropagation">阻止任何的傳遞 event.stopImmediatePropagation()</h4><p>如果同一個元素有掛兩個 <code>addEventListener</code><br>點擊時兩個都會在 <code>Target phase</code><br>A 跟 B 事件一樣會觸發<br>在 A 加入 <code>stopImmediatePropagation()</code> 會把 B 停掉</p><p>以上面的例子來說，link 掛兩個事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A 事件</span></span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i am A&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// B 事件</span></span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i am B&#x27;</span>) <span class="comment">//不會出現，在 A target pharse 阻止 B 冒泡階段發生</span></span><br><span class="line">&#125;)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box&#x27;</span>) <span class="comment">// 不會出現，因為阻止了冒泡</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="應用範例-label-input">應用範例 : label &amp; input</h4><p>label 跟 input 的組合需要多一個 id<br>為了不浪費 id，我們常常會用 label 把 input 包起來。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>/&gt;</span></span><br><span class="line">開關</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>label</code> 綁上監聽事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> labelone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line"></span><br><span class="line">labelone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>神奇的是，hi 會出現兩次<br>checkbox 也會接收到 click 事件，改變了狀態<br>發生冒泡到 label 元素，再次觸發 label 的事件</p><p><strong>重點複習</strong></p><blockquote><p><strong>阻止的動作，加在冒泡發生的元素上</strong></p></blockquote><p>冒泡發生的是 <strong>input</strong> ，所以 <code>stopPropagation</code> 是要加在 input 而非 label</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> labelone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> inputone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"></span><br><span class="line">labelone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">inputone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="事件-“本身”-指的是-target-v-s-currentTarget-this">事件 “本身” 指的是 ? target v.s currentTarget (this)</h3><p>我們知道在 function 當中是可以使用 <code>this</code><br>那這邊的 <code>this</code> 是指什麼呢 ?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> labelone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line"></span><br><span class="line">labelone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tagName</span>) <span class="comment">// LABEL</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><code>this</code> 代表的會是「觸發事件的<strong>目標</strong>」元素<br>也就是 <code>event.currentTarget</code> 而不是 <code>e.target</code>。</p></blockquote><p>那 <code>e.target</code> 指的是 ?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> labelone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line">labelone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">tagName</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tagName</span>, <span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> inputone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">inputone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">tagName</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tagName</span>, <span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>點擊 label</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;LABEL&quot;</span> <span class="number">1</span> <span class="comment">// e.target</span></span><br><span class="line"><span class="string">&quot;LABEL&quot;</span> <span class="number">1</span> <span class="comment">// this</span></span><br><span class="line"><span class="string">&quot;INPUT&quot;</span> <span class="number">2</span> <span class="comment">// e.target</span></span><br><span class="line"><span class="string">&quot;INPUT&quot;</span> <span class="number">2</span> <span class="comment">// this</span></span><br><span class="line"><span class="string">&quot;INPUT&quot;</span> <span class="number">1</span> <span class="comment">// checkbox 冒泡上來的而觸發 labelone，e.target</span></span><br><span class="line"><span class="string">&quot;LABEL&quot;</span> <span class="number">1</span> <span class="comment">// checkbox 冒泡上來的而觸發 labelone， this</span></span><br></pre></td></tr></table></figure><blockquote><p><code>e.target</code> 其實是「觸發事件的元素」</p></blockquote><p>如果不考慮事件傳遞的情況下，<code>this</code> 實質上就等同於 <code>e.target</code> 了。</p><h2 id="事件指派-Event-Delegation">事件指派 (Event Delegation)</h2><p>用 JavaScript 新增的元素並不會綁到事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.list&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> items = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.list-item&#x27;</span>);</span><br><span class="line"><span class="comment">// 一個個手動加入</span></span><br><span class="line">items.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">textContent</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newItem = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;LI&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> txt = <span class="variable language_">document</span>.<span class="title function_">creatTextNode</span>(<span class="string">&#x27;new&#x27;</span>);</span><br><span class="line">newIten.<span class="title function_">appendChild</span>(txt)</span><br><span class="line">list.<span class="title function_">appendChild</span>(newItem)</span><br></pre></td></tr></table></figure><p><code>newItem</code> 不會有 click 事件<br>為避免每次新增要重新綁定事件，又要移除監聽，造成 memory leak 的嚴重問題<br><strong>事件指派</strong> 是比較好的做法。</p><p><strong>事件代理人</strong> 透過判斷 <strong>目標節點</strong>，再執行動作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.list&#x27;</span>);</span><br><span class="line"><span class="comment">// list 直接看底下的子元素</span></span><br><span class="line">list.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(e.<span class="property">target</span>.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>()===<span class="string">&#x27;li&#x27;</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">textContent</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newItem = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;LI&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> txt = <span class="variable language_">document</span>.<span class="title function_">creatTextNode</span>(<span class="string">&#x27;new&#x27;</span>);</span><br><span class="line"></span><br><span class="line">newIten.<span class="title function_">appendChild</span>(txt)</span><br><span class="line">list.<span class="title function_">appendChild</span>(newItem)</span><br></pre></td></tr></table></figure><p>搭拉 ! <code>newItem</code> 就有點擊的效果</p><h2 id="總結-23">總結</h2><p>事件是 JavaScript 的基本，當我們了解機制的運作<br>遇到奇怪的觸發多次時，記得想起事件的流程</p><blockquote><p>先捕獲再冒泡</p></blockquote><p>還有相關的</p><ul><li>阻止預設行為 <code>preventDefault</code></li><li>阻擋冒泡行為 <code>stopPropagtion</code></li></ul><h2 id="參考-13">參考</h2><ol><li><a href="https://ithelp.ithome.com.tw/articles/10191970">重新認識 JavaScript: Day 14 事件機制的原理</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10192015">重新認識 JavaScript: Day 15 隱藏在 “事件” 之中的秘密</a></li><li><a href="https://blog.techbridge.cc/2017/07/15/javascript-event-propagation/">DOM 的事件傳遞機制：捕獲與冒泡</a></li><li><a href="https://juejin.cn/post/6965682915141386254#heading-2">Chrome 89 更新事件触发顺序，导致99%的文章都错了（包括MDN）</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-38&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;事件是什麼 ? 為什麼要用事件代理呢 ?&lt;br&gt;
在不了解事件的流程與運作機制，是不是遇過點一下元素&lt;br&gt;
結果跑出兩次以上的結果&lt;br&gt;
透過本篇幫自己釐清事件各種大小事&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
</feed>
