<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>健忘雜記</title>
  
  <subtitle>紀錄學習與生活</subtitle>
  <link href="https://blog.rosa.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.rosa.tw/"/>
  <updated>2022-07-28T03:57:32.120Z</updated>
  <id>https://blog.rosa.tw/</id>
  
  <author>
    <name>Rosa Hong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>筆記 | JavaScript - fetch 獲取遠端資料</title>
    <link href="https://blog.rosa.tw/2022/06/JavaScript/JavaScript-fetch"/>
    <id>https://blog.rosa.tw/2022/06/JavaScript/JavaScript-fetch</id>
    <published>2022-06-22T04:45:11.000Z</published>
    <updated>2022-07-28T03:57:32.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-45">前言</h2><p>想要獲取遠端的資料可以使用 AJAX ，在 ES6 之前大多會使用 JQuery 的 <code>$.ajax</code>  或者原生的 XHR，而在 HTML5 則提供 fetch 使用，更多時候會使用 axios 套件。<br>本篇記錄 fetch 的使用方式與常見的使用誤區。</p><span id="more"></span><h2 id="fetch">fetch</h2><p>fetch 是 HTML5 原生獲取遠端的方式，其操作也十分簡單</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url)</span><br><span class="line"><span class="title function_">fetch</span>(url,&#123;obj&#125;) <span class="comment">// 第二個參數為 options</span></span><br></pre></td></tr></table></figure><p>沒有 options 的物件，只有網址的話是 <code>GET</code>。<br>fetch 回傳的是一個 Promise 物件，Promise 簡單來說是 <strong>處理非同步操作的特殊物件</strong>，有關於 Promise 之後會再補充。</p><h3 id="then-catch">then &amp; catch</h3><p>如果要拿到回傳的 response ，可以透過 <code>then</code>。要接 .then 前面的物件必要類型為 Promise，而 <code>fetch()</code> 回傳的就是一個 Promise 物件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> endPoint = <span class="string">&#x27;https://restcountries.com/v3.1/name/Taiwan&#x27;</span></span><br><span class="line"><span class="title function_">fetch</span>(endPoint).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>是 <code>fetch().then</code> 而不是 <strong>fetch.then</strong>，是 fetch 這個函式裡面回傳 Promise</p></blockquote><p>then 接收的參數是 Promise 中 resolve 或是 reject 的函式運行的結果，通常是 resolve，如果是 reject 則會用 <code>.catch</code> 來作錯誤處理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(endPoint).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>會被丟進 catch 處理的 err 並不是像 XHR status 404 或 500 這類的，而是可能網路連線錯誤或者網址有誤導致不能發出 request 。</p><h3 id="HTTP-狀態碼處理-Response-status-Response-ok">HTTP 狀態碼處理 Response.status &amp;  Response.ok</h3><p>只要是 HTTP 狀態碼 400 以上的我們通常會在 XHR 做錯誤處理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">err</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure><p>但是 fetch 不管狀態碼多少，只要有正確的發出請求後回傳的 response 都會進入 resolve ，如果要處理像 onerror 的錯誤可以透過 .then 中 response 的 status 或 ok。</p><ul><li>response.status : 回傳結果的 HTTP code</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(endPoint).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>) <span class="comment">// 200 代表成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>response.ok : 回傳 boolean ，如果 HTTP code 在 200~299 就回傳 true</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(endPoint).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(response.<span class="property">ok</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Response-text-json">Response.text() &amp; .json()</h3><p>可以將 response 解析成想要的形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(endPoint).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> response.<span class="title function_">text</span>()</span><br><span class="line"><span class="comment">// return response.json() 兩者擇一</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>.text()</code> : 直接印出文字</li><li><code>.json()</code> : 自動幫我們解析 json 格式的資料</li></ul><p>其他種類的格式 :</p><ul><li><code>.blob()</code>：把資料轉成Blob物件</li><li><code>.formData()</code>：把資料轉成FormData物件</li><li><code>.arrayBuffer()</code>：把資料轉成二進制數組</li></ul><blockquote><p>這些方法 <strong>只能擇一</strong>，一但被解析過就不能重複再使用其他的函式解析了。</p></blockquote><h2 id="POST">POST</h2><p>POST 也很簡單，跟 <code>$.ajax()</code> 的操作很像</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二個參數可以攜帶 header 、body 或 Http 等資訊</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;<span class="attr">name</span>:<span class="string">&#x27;Rosa&#x27;</span>&#125;</span><br><span class="line"><span class="title function_">fetch</span>(endPoint,&#123;</span><br><span class="line"><span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data),</span><br><span class="line">  <span class="attr">headers</span>: <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>fetch 的 options 還有包含其他常見的 HTTP 處理，<br>在 body 中如果我們要上傳的格式是 JSON 檔，記得要將內容轉換成 JSON 格式。</p><blockquote><p><strong>GET 與 HEAD 是沒有 body 的</strong></p></blockquote><h2 id="fetch-的-Headers">fetch 的 Headers</h2><p>以往在 XHR 要加上 Header</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">XMLHttpRequest</span>.<span class="title function_">setRequestHeader</span>(header, value);</span><br></pre></td></tr></table></figure><p>在 fetch 要加上 Header，可以直接加，或者 new 出一個 Header 容器來放置所需的內容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接使用 headers</span></span><br><span class="line"><span class="title function_">fetch</span>(url,&#123;</span><br><span class="line"><span class="attr">headers</span>:&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//透過實例出一個 Headers</span></span><br><span class="line"><span class="title function_">fetch</span>(url,&#123;</span><br><span class="line"><span class="attr">headers</span>: <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Content-Type">Content Type</h3><p>表單 或是 JSON 格式資料</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON</span></span><br><span class="line">&#x27;Content-Type&#x27;<span class="punctuation">:</span> &#x27;application/json&#x27;</span><br><span class="line"><span class="comment">// 表單</span></span><br><span class="line">&#x27;Content-Type&#x27;<span class="punctuation">:</span> &#x27;application/x-www-form-urlencoded&#x27; </span><br></pre></td></tr></table></figure><h3 id="credentials">credentials</h3><p>預設上不會自動帶上或接收任何 cookies，如果網站依賴 session 會導致請求回傳未經認證，想把 cookies 一起帶上，要加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url,&#123;</span><br><span class="line"><span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="對-mode-的誤解">對 mode 的誤解</h2><p>發送 request 可能會遇到 CORS 的限制，fetch 中mode 提供 <code>'no-cors'</code> 的方法，乍看之下會以為能突破 CORS 限制，既不會跳出錯誤 (不會跳到 .catch)，也能發出 request ，但 <strong>response 的 status 是 0 ，body 是空的</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url,&#123;</span><br><span class="line"><span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line"><span class="attr">headers</span>: <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line"><span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">&#125;),</span><br><span class="line"><span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;Rosa&#x27;</span>&#125;),</span><br><span class="line">mode : <span class="string">&#x27;no-cors&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="title function_">json</span>())</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></table></figure><blockquote><p>麻瓜翻譯機 :<br>不會回傳錯誤，也不會突破 CORS 的限制<br>避免發生錯誤，硬要丟出一個 request ，還你一個安心 response，裡面包含沒東西的 body 以及 status 為 0 。</p></blockquote><p>CORS 的限制是後端要解決，前端無法直接實現掛跨 CORS。</p><h2 id="為什麼-XMLHttpRequest-還是存在">為什麼 XMLHttpRequest 還是存在 ?</h2><p>我們都知道 XHR 寫起來有點囉嗦，在 fetch 問世之後，除了支援舊的瀏覽器會使用到 XHR，現代開發大多還是使用 fetch，但是 XMLHttpRequest 並沒有被廢棄，因為 fetch 還是有些功能是無法做到的。</p><p>**fetch 做不到 : **</p><ol><li>上傳進度追蹤，fetch 必須搭配其他的 API 才能做到，</li><li>錯誤的回應處理<br>fetch 不管 HTTP 404 還是 500 ，也還是會 resolve，代表 <strong>你確實有送出 request</strong>，<code>.catch</code> 會抓到的錯誤只會是 <strong>網路錯誤或其他會中斷 request 的情況</strong>。對於錯誤的處理不是那麼直覺。</li><li>中斷  (absort) fetch<br>目前沒有直接中斷 fetch (Promise) 的方法，不像 XHR 提供 <code>.absort()</code>，但是 WebAPIs 有提供 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/AbortController#browser_compatibility">AbortController</a> 可以讓 fetch 做到中斷，目前為實驗性(?)<br><a href="https://mdn.github.io/dom-examples/abort-api/">MDN 提供的範例</a>，讓你突然不想看影片的時候，停止發出 request。</li><li>逾時處理 (timeout)<br>XHR 逾期的時候可以暫停發出請求，第三點也提到 fetch 因為沒有中斷的功能，無法做到。</li></ol><h2 id="補充-幾種發-request-的方法">補充 : 幾種發 request 的方法</h2><p>以下都會使用 GET 為例</p><ol><li>XHR <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(url)</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">response</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(response.<span class="property">state</span>&gt;=<span class="number">200</span> &amp;&amp; response.<span class="property">state</span> &lt;=<span class="number">400</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure></li><li>JQuery <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">method : <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">url : url</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">done</span>(<span class="keyword">function</span>(<span class="params">response</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">fail</span>(<span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>fetch <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>axios <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(url)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line"> &#125;)</span><br><span class="line"> .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="結語-14">結語</h2><p>在我學習 JavaScript 這段期間，講到遠端取資料，很多教學並不會提到 fetch 或是 XMLHttpRequest，反而是叫你直接使用 axios，畢竟重新造輪子是很麻煩的 🥴，不過 fetch 無疑的是會越來越完善，不論是用何者工具或手法必有一定誕生的理由，了解原理後開發都可以更得心應手。</p><p>我蠻喜歡<a href="https://www.ithome.com.tw/voice/121435">良葛格 下的這番結論</a></p><blockquote><p>舊東西誕生在舊的時代，適時地解決了當時的問題，而後從中累積了不少的使用經驗，因而誕生了新的技術、概念或規範，急著預言舊東西將會逝去，並不會讓開發者看起來更為耀眼，只會讓開發者看不清楚新東西的本質罷了。</p></blockquote><h2 id="參考-19">參考</h2><ol><li>從 fetch 解決什麼問題來看 : <a href="https://www.ithome.com.tw/voice/121435">從XHR到Fetch | iThome</a></li><li>Huli 大的 fetch 系列影片<ul><li><a href="https://youtu.be/_8cLWMAQe3A">Fetch 與 Promise 補充系列（一）：初探 Fetch</a></li><li><a href="https://youtu.be/Ovv9tPhiW_0">Fetch 與 Promise 補充系列（二）：fetch 的 POST 與錯誤處理</a></li><li><a href="https://youtu.be/5A9ogWY7J7w">Fetch 與 Promise 補充系列（三）：fetch 的使用注意事項</a></li></ul></li><li>XHR v.s fetch，單純只是好奇查詢 XD <a href="https://blog.openreplay.com/ajax-battle-xmlhttprequest-vs-the-fetch-api">Ajax Battle: XMLHttpRequest vs the Fetch API </a></li><li><a href="https://zh.javascript.info/fetch">Fetch</a></li><li>很推的詳細文字版學習 : <a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/ajax_fetch.html">AJAX與Fetch API · 從ES6開始的JavaScript學習生活 (gitbooks.io)</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-45&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;想要獲取遠端的資料可以使用 AJAX ，在 ES6 之前大多會使用 JQuery 的 &lt;code&gt;$.ajax&lt;/code&gt;  或者原生的 XHR，而在 HTML5 則提供 fetch 使用，更多時候會使用 axios 套件。&lt;br&gt;
本篇記錄 fetch 的使用方式與常見的使用誤區。&lt;/p&gt;</summary>
    
    
    
    <category term="Front-end" scheme="https://blog.rosa.tw/categories/Front-end/"/>
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/categories/Front-end/JavaScript/"/>
    
    
    <category term="fetch" scheme="https://blog.rosa.tw/tags/fetch/"/>
    
    <category term="AJAX" scheme="https://blog.rosa.tw/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - Event Loop 事件循環 (I)</title>
    <link href="https://blog.rosa.tw/2022/06/06/JavaScript-Event-Loop-01"/>
    <id>https://blog.rosa.tw/2022/06/06/JavaScript-Event-Loop-01</id>
    <published>2022-06-17T16:54:45.000Z</published>
    <updated>2022-07-28T02:04:00.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-30">前言</h2><p>在 JavaScript 中，非同步的操作是很常見的，舉凡滑鼠事件、發出請求獲取資料…等，反過來問，如果這些操作是 <strong>同步</strong> 的，你可能操作後，畫面就像被卡住了，要等到目前的程式執行完畢才能繼續瀏覽。</p><p>Event Loop 的概念如何幫我們了解這件事，具體怎麼做呢 ? 本篇主要是幫助我自己釐清 Event Loop 的概念。</p><span id="more"></span><h2 id="為什麼會有-Event-Loop">為什麼會有 Event Loop ?</h2><p>JS 的語言特性是</p><ol><li>Single Thread (單線程)</li><li>Synchronous (同步)</li></ol><p>有時候語意上很令人誤解，同步 <strong>並不是同時做很多事</strong>，而是你只能一次做一件事。那為什麼我們可以在 <strong>瀏覽器</strong> 中操作按鈕獲取資料的同時又能做別的事 ?</p><p>沒錯，特別指出 <strong>瀏覽器</strong>，因為在不同的執行環境下，才能讓我們執行非同步的操作。(node 也是一種 JavaScript 執行環境，其中也有提供非同步的 API 來操作)</p><p>JavaScript 在 Runtime (執行環境) 是同步的，而是瀏覽器提供 Web APIs 讓我們透過 Event Loop 搭配非同步操作，才能&quot;同時&quot;處理很多事。</p><h3 id="關於-Event-Loop-的名詞">關於 Event Loop 的名詞</h3><h4 id="Stack-堆疊">Stack (堆疊)</h4><p>Stack 是資料結構的一種，遵守 LIFO (Last In,First Out)。</p><p>JavaScript 中的 Call Stack 會記錄目前執行到程式的部分，因為 JavaScript 是 Single Thread (單線程) ，只會有一個 Call Stack。</p><p><strong>那 Call Stack 怎麼運作呢 ?</strong><br>當執行某個函式，會將目前執行的函式放在 Stack 的最上層，如果函式執行 <code>return</code> 就會從 Stack 最上方抽離。</p><p><strong>範例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="title function_">a</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="title function_">b</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">c</span>();</span><br></pre></td></tr></table></figure><p>跟著程式走 :</p><ol><li>執行 c() ，把 c() 放入 Call Stack 中 1</li></ol><table><thead><tr><th>order</th><th>stack</th></tr></thead><tbody><tr><td>1</td><td>c () <strong>(now)</strong></td></tr></tbody></table><ol start="2"><li>印出 ‘c’，接著執行 b()，把 b() 放入 Call Stack 中</li></ol><table><thead><tr><th>order</th><th>stack</th></tr></thead><tbody><tr><td>2</td><td>b() <strong>(now)</strong></td></tr><tr><td>1</td><td>c ()</td></tr></tbody></table><ol start="3"><li>印出 ‘b’，接著執行 a()，把 a() 放入 Call Stack 中</li></ol><table><thead><tr><th>order</th><th>stack</th></tr></thead><tbody><tr><td>3</td><td>a() <strong>(now)</strong></td></tr><tr><td>2</td><td>b()</td></tr><tr><td>1</td><td>c ()</td></tr></tbody></table><ol start="4"><li>印出 ‘a’，a() 後面沒有程式碼，代表執行完畢，抽離 Stack 中</li></ol><table><thead><tr><th>order</th><th>stack</th></tr></thead><tbody><tr><td><s>3</s></td><td><s>a() ----&gt; 抽離</s></td></tr><tr><td>2</td><td>b()</td></tr><tr><td>1</td><td>c ()</td></tr></tbody></table><ol start="5"><li>後面跟步驟 4 一樣，依序抽離，直到 c() 執行完畢，後面也沒有程式碼，最後 Call Stack 為空</li></ol><p>解釋了上面提及的 Stack <strong>Last In,First Out</strong> 的原因。</p><h4 id="Task-Queue-任務佇列">Task Queue (任務佇列)</h4><p>又稱作 Callback Queue，在 Web APIs 的 function 執行完後，把 callback (接著要執行的 function) 放到 Task Queue 等待。</p><p>👉<a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D">參考 Loupe 視覺化工具</a></p><p>在這個例子中，有 setTimeout 與 click 事件。當程式執行時 :</p><ol><li>Button 事件並沒有觸發，callback function 並不會執行，先放置到 Web APIs 等待</li><li>第 7 行排進 Call Stack ，印出 ‘Hi !’，執行完畢移出 Call Stack 外</li><li>setTimeOut 放置到 Web APIs 等待，並且開始算 5 秒鐘</li><li>第 13 行排進 Call Stack ，印出 ‘Welcome to loupe.’，執行完畢移出 Call Stack 外，到這邊靜態的程式碼都執行完畢，Call Stack 變成空的 。(同一時間 setTimeOut 還在跑秒數)</li><li>過了大概 5 秒鐘， 把第 9 行 setTimeOut 的 callback <code>timeout()</code> 放到 Callback Queue。</li><li><strong>此時 Call Stack 為空的，把 Task Queue 第一順位的 timeout() 搬到 Call Stack 執行</strong> (此時會看見橘色的旋轉鈕轉動，代表 Event Loop)</li><li>第 10 行排進 Call Stack ，印出 ‘Click the button’，timeout() 執行完畢，移出 Call Stack 外，Stack 又變成空的。</li></ol><p><strong>如果這時候按下按鈕呢 ?</strong></p><ol><li>按下後，onClick 事件執行，排進 Call Stack</li><li>執行第 2 行 setTimeout ，把 setTimeout 放置到 Web APIs 等待，並且開始算 2 秒鐘，onClick 事件執行完畢，移出 Call Stack 外，Stack 又變成空的</li><li>過了大概 2 秒鐘， 把 setTimeOut 的 callback <code>timer()</code> 放到 Callback Queue。</li><li><strong>此時 Call Stack 為空的，把 Task Queue 第一順位的 timer() 搬到 Call Stack 執行</strong></li><li>第 3 行排進 Call Stack，印出 ‘You click the button !’，執行完畢，移出 Call Stack 外，Stack 又變成空的。</li></ol><p>以上是一步步跟著的 Event Loop 的基本運作</p><h4 id="Blocking-阻塞">Blocking (阻塞)</h4><blockquote><p>那如果一直按按鈕呢 ?</p></blockquote><p>會發現一個個 onClick 事件的 callback 會被排進 Callback Queue 正在排隊等待，setTimeout 同時也在排隊，也要等待 onClick 事件結束，移出 Call Stack 外，透過 Event Loop 檢查 Call Stack 是否為空…(略)，重複一直執行。</p><p>這時候畫面就好像靜止了，setTimeout 的 2 秒也不是很精準，這就是發生了 Blocking 。</p><p>如果會以為同時印出，要回想 <strong>JavaScript 是同步的</strong> 這句話，執行的結果會是依序出現，不會一下子 “啪!” 全部出來。</p><h5 id="阻塞常見的例子-無限滾動載入資料">阻塞常見的例子 : 無限滾動載入資料</h5><p>如果直接 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">// Ajax 獲取資料</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>發現每一滑，都會觸發 callback 。就像你一直按按鈕，然後發出請求資料，排進 Web APIs 並且等待資料的 response ，再排進 Callback Queue，這時候會造成 Blocking。為避免一直觸發 scroll 事件，通常會搭配 lodash 的 debounce。</p><h3 id="小結-Event-Loop-是…">小結 : Event Loop 是…</h3><p>一種機制，讓 JavaScript 可以同時做很多事</p><blockquote><p>當 Call Stack 為空時，把 Callback Queue 等待的 callback function 放進 Call Stack 來執行</p></blockquote><h2 id="幾個-Event-Loop-的例子">幾個 Event Loop 的例子</h2><p>來自 <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">What the heck is the event loop anyway?</a> 提到的範例</p><h3 id="沒那麼精準的-setTimeout-與-setInterval">沒那麼精準的 setTimeout 與 setInterval</h3><p>setTimeout 與 setInterval 都是 Web APIs ，會排進 Callback Queue 並且等到 Call Stack 為空的時候才執行。所以不能保證一定精準 x 秒後執行，但至少執行間距的最小秒數是 x 秒。</p><p><strong>常見的 0 秒 setTimeout</strong><br>乍看之下會以為 0 秒是立即執行，其實不然。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br></pre></td></tr></table></figure><p>結果是 <code>hi</code> 先印出，再印出 <code>hello</code>。</p><p>跟著步驟走 :</p><ol><li>setTimeout 放入 Web APIs 等待 0 秒後，放入 Task Queue 等待</li><li><code>console.log('hi')</code> 排進 Call Stack，並且執行</li><li>印出 ‘hi’ ，執行結束，移出 Stack 外</li><li>此時的 Call Stack 是空的，而且 Task Queue 的第一位是 setTimeout 的 callback ，排進 Call Stack</li><li>執行 <code>console.log('hello')</code></li><li>印出 ‘hello’，執行結束，移出 Stack 外</li><li>程式碼執行結束</li></ol><p>這也是為什麼 setTimeout  沒那麼 精準的原因，因為必須等到  Call Stack 為空才會執行，導致中間可能會有誤差。</p><h3 id="多個-setTimeout">多個 setTimeout</h3><p>遇到 setTimeout 常會問 console.log 的結果是 ?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><ol><li>每間隔 1 秒後，依序印出 ‘hi’ (1 秒 ‘hi’，隔 1 秒 ‘hi’…)</li><li>在 4 秒後，同時印出 <figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span>(hi)</span><br></pre></td></tr></table></figure></li><li>至少間距 1 秒以後，一次印出 4 次的 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br></pre></td></tr></table></figure></li></ol><p>.<br>.<br>.<br>.<br>.<br>.<br>.<br>結果是<strong>至少間距 1 秒以後，一次印出 4 次的 hi</strong> 。經過 1 秒後即使已經排定到 Callback Queue，但是如果這時候 Call Stack 還不是空的，Queue 就會發生 Blocking 塞車在這裡等待，等到 Stack 空再依序印出 hi。如果 1 秒短到看不見，可以調成更久的時間。</p><h3 id="同步與非同步的-callback">同步與非同步的 callback</h3><p>我覺得這個例子很有意思，我們知道頻繁的呼叫 callback function 會造成 Blocking 的情形，但是 <strong>Call Stack 塞車或是 Callback Queue 塞車有什麼差別呢 ?</strong></p><p>透過這個例子我自己覺得更清楚知道有了 Event Loop 到底幫助在哪。</p><p>在這裡的 callback function 有兩種</p><ol><li>在函式中呼叫另一個函式 (同步的 callback，都在 Call Stack 執行完畢) <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>像是跟 Web APIs 有關的，例 : click 事件後的 callback function 不會馬上執行，而是等到 Event Loop 後才會。<br>(非同步的 callback  差別在於，有排隊到 Callback Queue 再到 Call Stack) <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="同步的-callback-發生了什麼事">同步的 callback 發生了什麼事</h4><p>如上面的第一個 callback 範例，我們必須等到 forEach 印完所有元素，才能做其他的事。這段時間造成 Call Stack 的 Blocking，導致畫面不能動作。</p><p>一般來說，瀏覽器會在每 16.6 毫秒的時候重新渲染畫面，但這時候 Call Stack 還在處理事情，導致畫面的解析被延遲，在影片中講者有開啟模擬畫面 render 的模擬，render 一直被占據紅線。</p><h4 id="改成非同步的-callback-差別在哪">改成非同步的 callback 差別在哪 ?</h4><p>上面不斷強調 Event Loop 是 Call Stack 為空時，才會把 Callback Queue 推上 Stack 執行。而在 Call Stack 空的期間，提供瀏覽器執行畫面重新渲染的機會，才不會因為忙碌導致卡住。</p><blockquote><p>簡單來說 : <strong>畫面渲染的優先度是高於 Callback Queue 的 callback function</strong></p></blockquote><p>這也是為什麼在影片講者提到不要造成耗時的程式碼放在 Call Stack ，因為 Call Stack 賽車沒辦法重新渲染畫面。</p><p>也可以參考這篇 Jack 大的實作範例二，文章也有提到什麼時候會 rendering，助於瞭解整個流程<br>👉 <a href="https://yu-jack.github.io/2020/02/03/javascript-runtime-event-loop-browser/#%E7%AF%84%E4%BE%8B%E4%BA%8C">Event Loop 運行機制解析 - 瀏覽器篇 - 技術雜記 Technology Notes - Jack Yu | 傑克</a></p><h2 id="結語-3">結語</h2><p>目前提到瀏覽器的 Event Loop ，至於 Node 的 Event Loop 我還沒研究，未來會再研究補充。不過還有 mircoTask 與 macroTask 還沒補完 QQ，才能算是了解 Event Loop。</p><p>如果有誤麻煩請寄信告訴我，我會非常感謝</p><h2 id="參考-16">參考</h2><ol><li><a href="https://pjchender.blogspot.com/2017/08/javascript-learn-event-loop-stack-queue.html">[筆記] 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式 | PJCHENder 那些沒告訴你的小細節</a></li><li>講解 Event Loop 的影片(有中文字幕) : <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">What the heck is the event loop anyway? | Philip Roberts | JSConf EU - YouTube</a></li><li>模擬 Event Loop 的網頁 : <a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D">latentflip.com</a></li><li><a href="https://yu-jack.github.io/2020/02/03/javascript-runtime-event-loop-browser/#%E7%AF%84%E4%BE%8B%E4%BA%8C">Event Loop 運行機制解析 - 瀏覽器篇 - 技術雜記 Technology Notes - Jack Yu | 傑克</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-30&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在 JavaScript 中，非同步的操作是很常見的，舉凡滑鼠事件、發出請求獲取資料…等，反過來問，如果這些操作是 &lt;strong&gt;同步&lt;/strong&gt; 的，你可能操作後，畫面就像被卡住了，要等到目前的程式執行完畢才能繼續瀏覽。&lt;/p&gt;
&lt;p&gt;Event Loop 的概念如何幫我們了解這件事，具體怎麼做呢 ? 本篇主要是幫助我自己釐清 Event Loop 的概念。&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="06" scheme="https://blog.rosa.tw/categories/2022/06/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - 運算子 ?. 與 ??</title>
    <link href="https://blog.rosa.tw/2022/06/06/JavaScript-null-undefined-operator"/>
    <id>https://blog.rosa.tw/2022/06/06/JavaScript-null-undefined-operator</id>
    <published>2022-06-15T06:31:13.000Z</published>
    <updated>2022-07-27T14:15:29.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-32">前言</h2><p>對於 undefined 或是 null 的處理，我比較常使用 <code>||</code> (OR) 或是 <code>&amp;&amp;</code> (AND) 的寫法，找資料的時候很常看見 <code>??</code> 以及 <code>?.</code> 的寫法。實在是太好奇了，於是找了資料學習並且記錄下來 。</p><span id="more"></span><h2 id="Optional-chaining">Optional chaining (?.)</h2><p>如果要查找 <strong>Object 的某項是否存在</strong>。我們可能會遍歷整個物件，但不用這麼麻煩，可以使用 <code>obj?.</code> ，如果物件是 null 或是 undefined 就做別的處理，在判斷值存在與否就很好用。</p><p>例 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj?.<span class="property">b</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span> + (obj?.<span class="property">b</span> || <span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>那在巢狀的結構中如果不用 <code>?.</code> ，必須先判斷前面的是不是存在</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span> &amp;&amp; obj.<span class="property">a</span>.<span class="property">b</span>) <span class="comment">// obj.a 存在才往下一步</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>?.<span class="property">b</span>) <span class="comment">// 使用 ?.</span></span><br></pre></td></tr></table></figure><p>透過 (?.) 的方式 JavaScript 內部會透過隱式 (implicitly) 去確認 obj.a 是不是 null 或是 undefined，而不用顯式 (explicitly) 確認 obj.a 存不存在再去判斷下一個。</p><h3 id="為什麼要有">為什麼要有 (?.)</h3><p>從一般的判斷來說，我們可以用 <code>||</code>  來決定值存不存在，因而來設定 <strong>預設值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> product =&#123;</span><br><span class="line">name : <span class="string">&#x27;Rosa&#x27;</span>,</span><br><span class="line">cost : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> total = product.<span class="property">cost</span> || <span class="number">50</span> <span class="comment">// ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(total)</span><br></pre></td></tr></table></figure><p>雖然 <code>||</code> 很好用，但是 <code>||</code> 會強制轉型，也就是 falsy 。數字 0 在判斷中會被轉為 false ，因此在上面的例子，數字 0 也會被判斷成 false 而預設成 50。</p><p>可能會想說那判斷 <code>&gt;=0</code> 不就可以了 ?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = product.<span class="property">cost</span> &gt;= <span class="number">0</span> ? product.<span class="property">cost</span> : <span class="number">50</span> </span><br></pre></td></tr></table></figure><p>是可以，但會重複寫兩次 <code>product.cost</code>🥴。<br>BUT !!! 如果有 <strong>負數</strong> 呢 ? 總不能判斷不是 0 吧。<br>邏輯寫法就更綁手綁腳，但我們實際只確認是不是空值或是為賦值而已。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = (product.<span class="property">cost</span> === <span class="literal">null</span> || product.<span class="property">cost</span> === <span class="literal">undefined</span>) ? <span class="number">50</span> : product.<span class="property">cost</span></span><br></pre></td></tr></table></figure><p>因此 short-hand 的 <code>?.</code> 誕生，讓我們可以更快判斷。</p><blockquote><p>IE 並不支援 <code>?.</code> ，如果要使用就是 <strong>依序判斷是否為 null 或是 undefined</strong></p></blockquote><h3 id="fuction-call-的">fuction call 的 (?.)</h3><p>MDN 有提到是如果使用套件的 API，可以使用這種方式，可以確認 function 是否存在再執行，以免發生錯誤。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayhello = &#123;</span><br><span class="line"><span class="title function_">hello</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayhello.<span class="property">hi</span>?.()) <span class="comment">// undefined ，不會發生錯誤</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayhello?.<span class="title function_">hello</span>()) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>但是如果 hi 本身並不是 function 就會發生 <code>is not a function</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sayhello.<span class="property">hi</span> = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayhello.<span class="property">hi</span>?.()) <span class="comment">// hi is not a function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayhello?.<span class="title function_">hello</span>()) <span class="comment">// 不會執行，因為上面出現錯誤</span></span><br></pre></td></tr></table></figure><p>手動矯正 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sayhello.<span class="property">hi</span> = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> sayhello.<span class="property">hi</span>=== <span class="string">&#x27;function&#x27;</span> ? sayhello.<span class="title function_">hi</span>() : sayhello.<span class="property">hi</span> ) <span class="comment">// &#x27;123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayhello?.<span class="title function_">hello</span>())  <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h3 id="什麼時候不應該用">什麼時候不應該用 (?.)</h3><ol><li>沒有被 <strong>宣告</strong> 的變數 : 對變數使用，會發生錯誤，因為 a 並不存在 (is not defined)，並不能這樣判斷。 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a?.<span class="property">b</span>) <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure></li><li>重新賦值 (left-hand side) : 不能這樣使用 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">2</span>&#125;</span><br><span class="line">obj?.<span class="property">a</span>  = <span class="number">1</span>  <span class="comment">// Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure></li><li>本身是 null <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> prop = a?.[x++]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// 0 並不會增加</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>這邊我有點不太了解，因此我試了空物件，x 遞增是  1 🤔，a 依然是空物件。後來我找到 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">運算子優先序 - JavaScript | MDN (mozilla.org)</a>，簡單來說 <strong>越高階的運算子會按照規則先執行</strong>。<br><code>?.</code> 是 18 ,判斷是從左至右。a 已經是 null 了，所以不會執行。但是如果是空物件 <code>&#123;&#125;</code>，?. 會執行，不是 null 也不是 undefined。而<code>[ ]</code> 跟 <code>?.</code> 的層級相同，<code>[x]</code> 存在所以也會執行 ， <code>++</code> 也會執行。(這邊有點不太確定，待補)</li></ol><p>另一個有關優先序的常見例子是 <code>(function()&#123;var a = b = 5&#125;)()</code>，在非嚴格模式下， global 依序印出 b 跟 a ，b 是 5 ，a 是 is not defined。因為 <code>=</code> 是 right-to-left，也就是 b 在未宣告下賦值，<code>var  a</code> 因作用域的關係，自然在 global 是 not defined。</p><blockquote><p>MDN 也提到不應該過度使用 (?.)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj?.[<span class="string">&#x27;Rosa&#x27;</span>]?.<span class="property">number</span> ? obj.[<span class="string">&#x27;Rosa&#x27;</span>].<span class="property">number</span> : obj?.[<span class="string">&#x27;Rosa&#x27;</span>]) <span class="comment">// 👎，因為在 obj.[&#x27;Rosa&#x27;] 不存在就可以停止了，不用串串樂來確認</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj?.[<span class="string">&#x27;Rosa&#x27;</span>] ? obj.[<span class="string">&#x27;Rosa&#x27;</span>].<span class="property">number</span> : <span class="literal">undefined</span>) <span class="comment">// V</span></span><br></pre></td></tr></table></figure><h2 id="Nullish-coalescing-operator">Nullish coalescing operator (??)</h2><p>可用來判斷 <strong>某個值是 null 或是 undefined</strong></p><h3 id="為什麼要有-2">為什麼要有 (??)</h3><p>跟上面提到 <code>||</code> 的判斷是一樣的，如果是數字 0 會被強制轉型比較成 false，如果只是想檢查 null 或是 undefined，?? 就會比較方便 。</p><p><strong>舉例來說</strong></p><ol><li>先讓 input 有 0 或是有值</li><li>手動把 input 的值完全清空， <code>e.target.value</code> 會是 <strong>空字串</strong>，但是我不想讓空字串也通過</li></ol><p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="ZErwEBe" data-user="shan473" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">  <span>See the Pen <a href="https://codepen.io/shan473/pen/ZErwEBe">  練習 ?? &amp; ?.</a> by YanShanHong (<a href="https://codepen.io/shan473">@shan473</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script><h3 id="function-call-的">function call 的 (??)</h3><p>來自 MDN 的範例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A was called&#x27;</span>); <span class="keyword">return</span> <span class="literal">undefined</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B was called&#x27;</span>); <span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;C was called&#x27;</span>); <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">A</span>() ?? <span class="title function_">C</span>() );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">B</span>() ?? <span class="title function_">C</span>() );</span><br></pre></td></tr></table></figure><p>根據 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">運算子優先序</a></p><blockquote><p><code>??</code> 是 <code>left-hand side</code> ，也就是 <strong>從左邊判斷開始</strong>。</p></blockquote><p>其結果是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;A was called&quot;</span></span><br><span class="line"><span class="string">&quot;C was called&quot;</span></span><br><span class="line"><span class="string">&quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;B was called&quot;</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>跟著跑一次 :</p><ol><li>A() 執行，印出 “A was called”</li><li>?? 的左邊是 undefined 所以決定執行 C()</li><li>C() 執行，印出 “C was called”</li><li>?? 左邊是 undefined 所以是 C() 回傳的結果 ‘foo’</li><li>B() 執行，印出 “B was called”</li><li>?? 的左邊是 false ，不符合 null 或是 undefined，C() 並不會執行</li><li>回傳 B() 的結果</li></ol><h3 id="不要直接用-OR-或-AND-一起使用">不要直接用 OR (||) 或 AND (&amp;&amp;) 一起使用 (??)</h3><p>OR 跟 AND 運算子的優先度比 <strong>??</strong> 還低，因此一起使用會發生錯誤，即使前面的結果是 null 或是 undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> || <span class="literal">undefined</span> ?? <span class="string">&quot;foo&quot;</span>) <span class="comment">// 錯誤</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> || <span class="literal">undefined</span> ?? <span class="string">&quot;foo&quot;</span>) <span class="comment">// 錯誤</span></span><br></pre></td></tr></table></figure><p>想讓前面先判斷可以用 <code>()</code> grouping 包起來，grouping 的優先度是最高的，所以會先執行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">null</span> || <span class="literal">undefined</span>) ?? <span class="string">&quot;foo&quot;</span>) <span class="comment">// &#x27;foo&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">true</span> || <span class="literal">undefined</span>) ?? <span class="string">&quot;foo&quot;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Polyfills">Polyfills</h2><p>如果瀏覽器不支援 (如 : IE)，可以使用 Polyfills，只要判斷 null 以及 undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = (somevalue !== <span class="literal">null</span> || somevalue !== <span class="literal">undefined</span>) ? somevalue ? <span class="title class_">DefaultValue</span></span><br></pre></td></tr></table></figure><h2 id="總結-22">總結</h2><ol><li><code>?.</code> 是中找尋 Object 類型 (object 、array 、function 等等)的值如果是 null 或是 undefined，結果是右邊的值。亦可用在 function call (<strong>object.method?.()</strong>) 上</li><li><code>?.</code> 不管存不存在，不能用來重新賦值</li><li><code>??</code> 是判斷任何值如果是 null 或是 undefined，結果是右邊的值</li><li><code>??</code> 不要直接跟 OR 或是 AND 一起使用，要用先把 ?? 左邊的括號起來先執行</li><li>兩種 IE 不支援 QQ</li></ol><h2 id="參考-18">參考</h2><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">Optional chaining (?.) - JavaScript | MDN</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_Coalescing_Operator">Nullish coalescing operator (??) - JavaScript | MDN</a></li><li><a href="https://javascript.info/optional-chaining">Optional chaining ‘?.’ (javascript.info)</a></li><li><a href="https://javascript.info/nullish-coalescing-operator">Nullish coalescing operator ‘??’ (javascript.info)</a></li><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">運算子優先序 - JavaScript | MDN (mozilla.org)</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-32&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;對於 undefined 或是 null 的處理，我比較常使用 &lt;code&gt;||&lt;/code&gt; (OR) 或是 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (AND) 的寫法，找資料的時候很常看見 &lt;code&gt;??&lt;/code&gt; 以及 &lt;code&gt;?.&lt;/code&gt; 的寫法。實在是太好奇了，於是找了資料學習並且記錄下來 。&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="06" scheme="https://blog.rosa.tw/categories/2022/06/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>紀錄 | Frontend Mentor 挑戰題 - Time tracking dashboard</title>
    <link href="https://blog.rosa.tw/2022/04/04/Practice-to-Master-01"/>
    <id>https://blog.rosa.tw/2022/04/04/Practice-to-Master-01</id>
    <published>2022-04-29T04:00:01.000Z</published>
    <updated>2022-07-27T05:30:49.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-27">前言</h2><p>這是在 <a href="https://www.frontendmentor.io/solutions/responsive-reactjs-styledcomponent-BkFnvCvr9">frontend mentor 的挑戰題</a><br>使用 React + styled-components</p><ul><li><a href="https://meitung473.github.io/time-tracking-dashboard-main/">網頁</a></li><li><a href="https://github.com/meitung473/time-tracking-dashboard-main">github repo</a></li></ul><p><img data-src="https://dsm01pap006files.storage.live.com/y4m9LQmpdiru45ZO2sTWfVBoSuRS1cfQoRCmHTFQxc-7aQWX0hkbq0r2q3tefJlGHA3SeXfA_G4CV5PHZIagjALPplvZ3s9MO6tpWyEEYyL2J7ep3EbhiNczfUybFUlxBTjvVQybnsXtFwrgoLmqEFJBftLbJvhzcipVkL-hdLjY23wEqHVpwrW0vNREUMTmt-y?width=1024&amp;height=585&amp;cropmode=none" alt="完成圖"></p><span id="more"></span><h2 id="專案建置">專案建置</h2><ol><li><strong>create-react-app</strong> : 一鍵建立好環境</li><li><strong>eslint</strong> : 加上 <code>Protype</code> 來檢查類型</li></ol><h2 id="我的流程">我的流程</h2><ol><li>Design - 照著參考圖刻出 figma 版型及元件</li><li>JS - 完成 filter 的功能，拿出想要的資料</li><li>JS - 照 figma 切出 component 架構</li><li>CSS - mobile 刻板</li><li>CSS - RWD</li><li>上傳至 frontend mentor + 撰寫 Readme</li></ol><h2 id="額外練習-figma-切版">額外練習 figma : 切版</h2><p>一邊練習切版以及 figma 的使用<br>本次學習 &amp; 練習</p><ul><li>元件 <code>component</code> :</li><li>變體 <strong>variants</strong> : 用程式概念想有點像 obj  <code>key-value</code> pair，可透過先建立好的類似類型，再替換選項。<br>常用的例子 : 有無圖案，實心空心，方向。<br>figma 是 <code>[property,value]</code> 來替換。<blockquote><p>obj 的 key 不能重複， <strong>figma 的 property 也是不能重複</strong>。<br>如果不在同一個 frame 裡的元件不能結為變體</p></blockquote></li><li><strong>auto layout</strong> : 有點像 css 的 flex</li><li><strong>asset</strong> : 將重複的物件作做成元件，放到元件庫</li><li>巢狀結構 : 用 <code>/</code> 斜線來代表類似的元件群組</li></ul><p>最後切出來的元件<br><img data-src="https://dsm01pap006files.storage.live.com/y4mZHL-B7h3iluUZzub-BxoLDbrZc2Wp43yRJd2NVsXDW2zIV5XhtSM4KNshxjCkPBfsHoSgqnK2Kdxg1pBBWw0T5RjD-TTXkiNZn69EENIX9dqbxu3K51pbNjKeNhyHJ1bpXSDwFX9c_cUoC8vv_UUaPUbmLmE9C2qcbYmNRl93CPWgVuKOBRb8U8crh2FSTTU?width=656&amp;height=1024&amp;cropmode=none" alt="Asset"></p><p>菜鳥設計稿 🥴，照著圖片檔慢慢切出來<br><img data-src="https://dsm01pap006files.storage.live.com/y4mwTdZBRAfGvMzTnynXGFrQ4yShvVgoGM-PJdXLOnF-3zi3OCyKeWiW1TYFmpurDs8l3lReNkOzMNTIDjoFCNdWNQbukzoR0iXkfmz9edOCJrqOrnH-aS2aT-17DZPd3W4cOL2lLovbNjta_rMsjlzeAgNDWQf458D4AxkOyiGYVlSHwfLTq1slPvuG8YDTHV4?width=1024&amp;height=800&amp;cropmode=none" alt="設計稿"><br>上半部都是變體的設定</p><h3 id="變體設定">變體設定</h3><p>變體部分是透過 nested 的方式，從元件最小的部分到整塊卡片都是可以切換</p><ol><li>卡片種類，我把每一種都先做樣板，可以直接替換卡片。<br>發現用處不大 XD，因為卡片都只有一張…，替換順序倒是蠻有幫助的。</li><li>滑鼠移入 <code>:hover</code> active &amp; inactive。<br>我直接做在 setting component 上</li><li>Profile 底下的時間節點切換，把 daily 、 weekly 等等的跟 setting 一樣分成 active 跟 inactive。</li><li>電腦版型  &amp; 手機版型 卡片，用處也不大。當時是想說如果多一種版型可以思考…</li><li>背景的 icon 切換，這是在做個別卡片原件快速切換用的而已</li></ol><p>在把上述的合併起來，在面板可以自由切換 😃<br>接下來就是進到寫程式的環節🥰</p><h2 id="React-部分">React 部分</h2><p>練習題較少用到使用到 React Hooks<br>大部分還是 CSS 居多<br>只有使用 <code>useState</code>、<code>useMemo</code> 而已</p><h3 id="svg-當作-component-匯入">svg 當作 component 匯入</h3><p><a href="https://create-react-app.dev/docs/adding-images-fonts-and-files/">官方</a> 要引入圖片有兩種方式</p><ol><li>當作 component 匯入 (svg)</li><li>直接匯入圖檔來源</li></ol><p>圖檔是 svg ，這邊我採用 component 的方式，主要是想改變 hover 時的填色</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 當作元件匯入</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">ReactComponent</span> <span class="keyword">as</span> <span class="title class_">Play</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./images/icon-play.svg&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/*作為元件使用*/&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Play</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>關於第二點，使用 <code>src</code> 引入圖檔<br>因為 deploy 之後 <code>index.html</code> 的路徑無法對上，有的人會建議把圖檔放在 <code>public</code> 上，在透過相對路徑引入。<br>或者讓 webpack 幫我們透過 JavaScript module (file loader)來處理，不過要注意的是，路徑的起始點是 <code>./</code>，所以後續在 deploy 時要設定 <code>homepage</code> 來矯正路徑</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 這邊是相對路徑字串</span></span><br><span class="line"><span class="keyword">import</span> play <span class="keyword">from</span> <span class="string">&#x27;./images/icon-play.svg&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/*作為路徑使用*/&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;play&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;Play icon&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="從外部匯入的-Element-轉成正確的-React-component">從外部匯入的 Element 轉成正確的 React component</h3><p>這邊我需要找到對應的樣式跟 icon 圖，起初我是回傳 <code>[Icon[type], theme.primary[type]]</code><br>預想中是在 component 中要拿到 <code>&lt;Play/&gt;</code> 這樣的 svg as component<br>轉出來的是 component <code>&#123;Play&#125;</code> 這樣可以，看起來好像一般的值，我想改成 tag 的形式，加上 <code>&lt;&gt;</code> 反而變成  <code>React Element</code> 。<br>從<a href="https://github.com/facebook/react/issues/13445#issuecomment-414389398">官方的 issues 這篇</a> 有提到，是因為 <strong>格式錯誤</strong><br>加上 tag 的方法實際上變成這樣 <code>&lt;&lt;Play/&gt;/&gt;</code>，可以用 function 先把元件輸出再使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// svg as component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Icon</span> = &#123;</span><br><span class="line">    <span class="title class_">Exercise</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Exercise</span> /&gt;</span></span>,</span><br><span class="line">    <span class="title class_">Play</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Play</span> /&gt;</span></span>,</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 拿到該圖檔跟顏色</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">type2Style</span>(<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type.<span class="title function_">includes</span>(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">        type = type.<span class="title function_">replace</span>(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// React Element -&gt; Component，把 React Component </span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">BgIcon</span> = (<span class="params"></span>) =&gt; <span class="title class_">Icon</span>[type];</span><br><span class="line">    <span class="keyword">return</span> [<span class="title class_">BgIcon</span>, theme.<span class="property">primary</span>[type]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="資料轉化">資料轉化</h3><p>這部分是想要熟悉如何去使用 Object &amp; Array 的 function<br>把自己想要的資料召喚出來，目前已知的是按鈕切換取得資料，<code>useState</code> 在 set 的時候做 re-render 讓我們可以看到資料改變後畫面也改變。</p><ul><li>Click Event</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 1. 觀察 timeframe 改變時設定的值</span></span><br><span class="line">    <span class="keyword">const</span> [timeframe, setTimeframe] = <span class="title function_">useState</span>(<span class="function">() =&gt;</span></span><br><span class="line">        <span class="title class_">Type2Data</span>(timetype.<span class="property">daily</span>, data)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 2. 點擊後改變 type</span></span><br><span class="line">    <span class="keyword">const</span> [type, setType] = <span class="title function_">useState</span>(timetype.<span class="property">daily</span>);</span><br><span class="line">    <span class="comment">// 3. 傳入 type 值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">clickhandler</span> = (<span class="params">type</span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">setTimeframe</span>(<span class="function">() =&gt;</span> <span class="title class_">Type2Data</span>(type, data));</span><br><span class="line">        <span class="title function_">setType</span>(<span class="function">() =&gt;</span> type);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeProvider</span> <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">TimerLayout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;/* 4. 把 handler 當作 props 傳給元件的 button */&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">ProfileCard</span> <span class="attr">clickhandler</span>=<span class="string">&#123;clickhandler&#125;</span> <span class="attr">type</span>=<span class="string">&#123;type&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;timeframe.map((&#123; last, title, prev, current &#125;, i) =&gt; (</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">TimeframeCard</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">key</span>=<span class="string">&#123;i&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">data</span>=<span class="string">&#123;&#123;</span> <span class="attr">last</span>, <span class="attr">title</span>, <span class="attr">prev</span>, <span class="attr">current</span> &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    /&gt;</span></span></span><br><span class="line"><span class="language-xml">                ))&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">TimerLayout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ThemeProvider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>轉換資料的 function</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Type2Data</span>(<span class="params">type, data</span>) &#123;</span><br><span class="line"><span class="comment">// 初始值是陣列</span></span><br><span class="line">    <span class="keyword">return</span> data.<span class="title function_">reduce</span>(<span class="function">(<span class="params">p, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 把官方給的 data.json 解構</span></span><br><span class="line">        <span class="keyword">const</span> &#123; title, timeframes &#125; = n;</span><br><span class="line">        <span class="comment">// 2. 畫面上需要轉換 timeframe 的文字</span></span><br><span class="line">        <span class="keyword">let</span> type2text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> timetype.<span class="property">daily</span>:</span><br><span class="line">                type2text = <span class="string">&quot;day&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> timetype.<span class="property">weekly</span>:</span><br><span class="line">                type2text = <span class="string">&quot;week&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> timetype.<span class="property">monthly</span>:</span><br><span class="line">                type2text = <span class="string">&quot;month&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 把符合的 timeframe 資料抓出來，後續要透過 map 把資料印出來</span></span><br><span class="line">        p.<span class="title function_">push</span>(&#123;</span><br><span class="line">            <span class="attr">last</span>: type2text,</span><br><span class="line">            title,</span><br><span class="line">            <span class="attr">prev</span>: timeframes[type].<span class="property">previous</span>,</span><br><span class="line">            <span class="attr">current</span>: timeframes[type].<span class="property">current</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搭拉 ! 當我按下按鈕，state 改變進行 re-render<br><img data-src="https://i.imgur.com/P9Aj0ae.gif" alt="切換 timeframe"></p><h3 id="useMemo-把資料記起來">useMemo : 把資料記起來</h3><p>由於我的圖片以及顏色是透過計算而來，而不是寫死的， 每次 state 改變時也會 re-render ，導致每次都重新計算一次😓。<br>但是 <strong>樣式內容是不變</strong> 的，所以用 <code>useMemo</code> 包起來，紀錄樣式資料</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TimeframeCard</span>(<span class="params">&#123; data &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; last, title, current, prev &#125; = data;</span><br><span class="line">    <span class="comment">// 避免 re-render 又跑一次</span></span><br><span class="line">    <span class="keyword">const</span> [<span class="title class_">BgIcon</span>, <span class="title class_">BgColor</span>] = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">type2Style</span>(title), [title]);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">TimeframeCardContainer</span> <span class="attr">bgcolor</span>=<span class="string">&#123;BgColor&#125;</span> <span class="attr">br</span>=<span class="string">&#123;br&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">BgIcon</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">FrameBody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">FrameHeader</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">FrameHeaderTitle</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">FrameHeaderTitle</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Setting</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">FrameHeader</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">FrameContent</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">CurrentText</span>&gt;</span>&#123;current&#125;hrs<span class="tag">&lt;/<span class="name">CurrentText</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">PrevText</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        Last &#123;last&#125; - &#123;prev&#125;hrs</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">PrevText</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">FrameContent</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">FrameBody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">TimeframeCardContainer</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>後來寫文時，我覺得這邊寫的不是很好，既然是固定的，我為什麼要透過計算來取得樣式呢🥴<br>回想當初在寫，多想到如果改成客製化卡片，樣式內容就會改變，以目前的練習題並沒有這個需求😅<br>也許可以作為之後的 :Todo</p><h3 id="Deploy-部屬網站">Deploy : 部屬網站</h3><p><code>package.json</code> 需要設定 homepage 將路徑重新設定，否則輸出的 build 裡面的 index.html 引入的東西會找不到。<br><a href="https://create-react-app.dev/docs/deployment/#building-for-relative-paths">Deployment 官方教學</a></p><ul><li>package.json</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;my-app&quot;</span>,</span><br><span class="line">  <span class="comment">// 我發布在網頁上的路徑</span></span><br><span class="line">+ <span class="string">&quot;homepage&quot;</span>: <span class="string">&quot;https://meitung473.github.io/time-tracking-dashboard-main/&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS部分">CSS部分</h2><p>包含 styled-component 以及一些 CSS 遇到的問題</p><h3 id="normalize-css">normalize.css</h3><p>我記得在 create-react-app 使用 normalize 在 <code>index.css</code> 加上 :</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import-normalize</span></span><br></pre></td></tr></table></figure><p>結果 IDE 提示格式錯誤以外，感覺好像都沒作用<br><img data-src="https://dsm01pap006files.storage.live.com/y4muj1fnDJhMGuehE88QmzA1uezUw5o7ocb8_KQf52VuXLdBQFYupbRyS3943vlDwAYqGq1KtqHfS80RjlFnRRYsuOvLIUb1Nd-Rog1ThCib7FhPDbyqo_bYip_65arJPHfXKV5Q4g4iJGC1JO8kls0kAU8JQXlHFxFogThYvQFB2GRkhdoUH31i7XUKHkXADaH?width=1024&amp;height=115&amp;cropmode=none" alt="IDE 提示格式錯誤"><br>我是按照官方的 <a href="https://create-react-app.dev/docs/adding-css-reset/#browser-support">教學</a><br>打開 devtool 反而是多了 <code>where:</code> 的樣式，所以並不是沒有<br><img data-src="https://dsm01pap006files.storage.live.com/y4mzXONRr23Eb4GiE7hLxjSlL9TuG5SxD6Xhhcl5xYKY__SAR-WM9kUhCeYYOZQpf1O6AFdFl27BwQM1_6LlbadtlQvNV1T-VtH7aIhhR0MP35pOqAxyfMIjPgTVbN0UhbGShKwyy-LxhksBAcP-GSYnocw-tj-k3YF6zbeelM3Tn2MOfTm-p5cIGAwkqtW9xUl?width=1024&amp;height=147&amp;cropmode=none" alt="where:"></p><p>我查到 <a href="https://stackoverflow.com/questions/56532121/normalize-css-does-not-fully-add-reset-to-react-app">這篇</a> 解釋為什麼 normalize.css 其實有不同份，如果在另外安裝 <a href="https://github.com/necolas/normalize.css">normalize.css</a> ，引入為什麼作用是因為 <strong>根本沒有指向到這版</strong>。</p><p>目前的 React 是使用 <code>@csstool/normalize</code> 而不是 <code>necolas/normalize</code> 版的<br>關於這兩份的差別，<a href="https://github.com/csstools/normalize.css/issues/3">共同作者解釋</a> 是移除一些固定格式的設定像是 (<code>body&#123;margin:0&#125;</code>) ，以及兼顧瀏覽器的兼容性問題。 🤔</p><p>另外我也查了一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:where">:where</a> 偽元素，為什麼 normalize 會使用這個。<br>以往在寫 CSS 必須注意權重的問題，而 <code>:where</code> 的權重是 0 ，不管設定的 CSS 權重後來的值都可以覆蓋過去， 相較 <code>:is()</code> 來的更適合設定預設值。<br>目前幾乎所有的瀏覽器都有支援，IE 因為今年六月要被淘汰了，就沒差了吧 🥴</p><h3 id="styled-components-media-query">styled-components @media query</h3><p>在之前學習是寫成個別一行，再一個個 import 到需要改動的元件裡面做修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> breakpoint_md = <span class="string">&quot;@media screen and (min-width: 768px)&quot;</span>;</span><br></pre></td></tr></table></figure><p>不過都 CSS-in-JS 了，不如把它變得更加程式化一點。<br>我在寫 styled-component 時只把他想成 <strong>會產出一大串的文字</strong>，想要做到 sass 的 @mixin 功能，改成寫 function 回傳想要的字串。<br>所以這次的目標是 :</p><blockquote><p>object 透過 key 拿到 <code>@media</code> 的字串，例 <a href="http://breakpoint.md">breakpoint.md</a> 對應 min-width : 768px</p></blockquote><p>參考 : <a href="https://dev.to/cagatayunal/how-to-use-css-media-query-breakpoint-in-styled-components-9of">How to use CSS Media Query Breakpoint in Styled-Components</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先寫好對應的尺寸</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sizes = &#123;</span><br><span class="line">    <span class="attr">xxl</span>: <span class="number">1440</span>,</span><br><span class="line">    <span class="attr">xl</span>: <span class="number">996</span>,</span><br><span class="line">    <span class="attr">md</span>: <span class="number">768</span>,</span><br><span class="line">    <span class="attr">sm</span>: <span class="number">576</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @media 固定的格式，從手機往上寫 &#123;size&#125; 拿來做替換</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;@media screen and (min-width: &#123;size&#125;px)&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> br = <span class="title class_">Object</span>.<span class="title function_">keys</span>(sizes).<span class="title function_">reduce</span>(<span class="function">(<span class="params">p, n</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/* 轉換過後的 sizes : [&#x27;xxl&#x27;,&#x27;xl&#x27;,...]</span></span><br><span class="line"><span class="comment">我們只要</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">n1 : sizes[n1]</span></span><br><span class="line"><span class="comment">n2 : sizes[n2]</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用取代的方式</span></span><br><span class="line">    p[n] = prefix.<span class="title function_">replace</span>(<span class="string">&quot;&#123;size&#125;&quot;</span>, sizes[n]);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure><p>不想這麼麻煩也可以直接透過 template 帶值<br><code>@media screen and (min-width: $&#123;sizes[n]&#125;px)</code><br>在 styled-component 內我們就可以直接使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; br &#125; <span class="keyword">from</span> <span class="string">&quot;../../Device&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FrameBody</span> = <span class="title function_">styled</span>(<span class="title class_">InfoCard</span>)<span class="string">`</span></span><br><span class="line"><span class="string">&#123;/* 直接寫 */&#125;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;br.md&#125;</span> &#123;</span></span><br><span class="line"><span class="string">        padding: 1em 1.2em;</span></span><br><span class="line"><span class="string">        cursor: pointer;</span></span><br><span class="line"><span class="string">        transition: filter 0.3s ease-out;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>這樣做 RWD 就可以比較簡單了🥰</p><h2 id="結語-2">結語</h2><p>每次練習都會覺得自己又更進步一些<br>重新思考自己的製作流程<br>最後覺得 CSS 的部份有點雜，可以抽出相同的樣式再重構<br>後續有時間再修改</p><h2 id="參考資料">參考資料</h2><ol><li><a href="https://dev.to/cagatayunal/how-to-use-css-media-query-breakpoint-in-styled-components-9of">How to use CSS Media Query Breakpoint in Styled-Components</a></li><li><a href="https://airbnb.io/javascript/react/#class-vs-reactcreateclass-vs-stateless">Airbnb JavaScript Style Guide</a></li><li><a href="https://github.com/facebook/react/issues/13445">expected a string (for built-in components) or a class/function</a></li><li><a href="https://create-react-app.dev/">Create React App</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-27&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;這是在 &lt;a href=&quot;https://www.frontendmentor.io/solutions/responsive-reactjs-styledcomponent-BkFnvCvr9&quot;&gt;frontend mentor 的挑戰題&lt;/a&gt;&lt;br&gt;
使用 React + styled-components&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://meitung473.github.io/time-tracking-dashboard-main/&quot;&gt;網頁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/meitung473/time-tracking-dashboard-main&quot;&gt;github repo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://dsm01pap006files.storage.live.com/y4m9LQmpdiru45ZO2sTWfVBoSuRS1cfQoRCmHTFQxc-7aQWX0hkbq0r2q3tefJlGHA3SeXfA_G4CV5PHZIagjALPplvZ3s9MO6tpWyEEYyL2J7ep3EbhiNczfUybFUlxBTjvVQybnsXtFwrgoLmqEFJBftLbJvhzcipVkL-hdLjY23wEqHVpwrW0vNREUMTmt-y?width=1024&amp;amp;height=585&amp;amp;cropmode=none&quot; alt=&quot;完成圖&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="React" scheme="https://blog.rosa.tw/tags/React/"/>
    
    <category term="styled-components" scheme="https://blog.rosa.tw/tags/styled-components/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - Prototype 物件導向 (IV) 原型的繼承</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-04"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-04</id>
    <published>2022-04-19T04:33:33.000Z</published>
    <updated>2022-07-27T05:30:49.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-25">前言</h2><p>上一篇知道原型與原型鏈的內容<br>如果我們要讓東西繼承，除了透過 new 建立物件直接幫我們繼承之外<br>還有 <code>Object.setPrototypeOf</code> 以及 <code>Object.create()</code></p><span id="more"></span>  <h2 id="原型如何繼承">原型如何繼承 ?</h2><ol><li><code>Object.setPrototypeOf(&lt;繼承者&gt;,&lt;被繼承者&gt;)</code> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person1, person2);</span><br></pre></td></tr></table></figure></li><li><code>Object.create(proto,屬性物件)</code> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person 物件</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Default_Name&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hi, I&#x27;m &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透過 Object.create() 將 Person 作為原型物件來建立一個新的物件</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>);</span><br><span class="line"><span class="comment">// 沒有 this.name</span></span><br><span class="line">p.<span class="title function_">sayHello</span>();   <span class="comment">// &quot;Hi, I&#x27;m Default_Name&quot;</span></span><br><span class="line"></span><br><span class="line">p.<span class="property">name</span> = <span class="string">&#x27;Rosa&#x27;</span>;</span><br><span class="line">p.<span class="title function_">sayHello</span>();   <span class="comment">// &quot;Hi, I&#x27;m Rosa&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Object-setPrototypeOf">Object.setPrototypeOf()</h2><p>上一篇我們提到 <code>[[Prototype]]</code> 是隱藏屬性<br>ES5 之前是使用 <code>__proto__</code>，ES6 新增 <code>getPrototypeOf()</code> 與 <code>setPrototypeOf()</code> 讓我們可以直接改變物件的 prototype</p><h3 id="in-某屬性是否可以透過這個物件存取">in  : 某屬性是否可以透過這個物件存取</h3><p>我們知道物件的屬性或方法不一定是本身物件的<br>而是來自原型鏈往上找到的<br>如此一來，建構物件就能使用原型鏈上的屬性<br>那怎麼確定能存取到呢 ?<br>沒錯，就是透過 <code>in</code> !</p><blockquote><p>屬性名稱必須是「字串」</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">a : <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 =&#123;</span><br><span class="line">b : <span class="number">2</span> ,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;a&quot;</span> <span class="keyword">in</span> person1) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;b&quot;</span> <span class="keyword">in</span> person1) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如果要讓 person1 也能讀取到 b 就必須改變其原型<br>可以透過 <code>Object.setPrototypeOf()</code> 直接改變<br>不過建議非必要不要直接改變物件的 prototype</p><h3 id="Object-setPrototypeOf-2">Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf(&lt;繼承者&gt;,&lt;被繼承者原型&gt;)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person1,person2)</span><br></pre></td></tr></table></figure><p>JavaScript 的原型物件是物件內部屬性，<strong>無法直接存取</strong> (通常標示為 <code>[[Prototype]]</code>)，但是可以透過 setPrototypeOf 指定物件之間的原型關係</p><blockquote><p>原型繼承的規則裡，<strong>同一個物件無法指定兩種原型物件</strong>。</p></blockquote><p>試著去存取「不存在」的屬性時，那麼 JavaScript 就會往它的 <code>[[Prototype]]</code> 原型物件去尋找 (prototype chain)</p><p>讓 <code>person1</code> 同時有 b 也有 c 屬性</p><blockquote><p>讓 b 去繼承 c，a 再繼承 b，就能同時擁有 b 與 c</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">a : <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 =&#123;</span><br><span class="line">b : <span class="number">2</span> ,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person3 = &#123;</span><br><span class="line">c : <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person2,person3)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person1,person2)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">c</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c&quot;</span> <span class="keyword">in</span> person1) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="hasOwnProperty-是否為物件本身的方法或屬性">hasOwnProperty() 是否為物件本身的方法或屬性</h3><p>有些屬性與方法是來自 prototype 繼承的<br>要確定是不是屬於自己本身用 <code>hasOwnProperty</code><br><code>objself.hasOwnProperty(&lt;property&gt;)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">a : <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 =&#123;</span><br><span class="line">b : <span class="number">2</span> ,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person1,person2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">b</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 屬性 b 並非建立於 person1 物件中，而是透過繼承的方式取得的 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;b&#x27;</span>)) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="Object-create">Object.create()</h2><p>新建物件後的 <code>[[Prototype]]</code> 就會是我們所指定的那個原型物件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> rosa = <span class="title class_">Object</span>.<span class="title function_">creat</span>(<span class="title class_">Person</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// constructor 的 prototype</span></span><br></pre></td></tr></table></figure><p>也可以是 <code>null</code>，這樣就會變成非常一般的物件 (“Very plain” objects)<br>不帶有任何 prototype 甚至是 <code>Object.prototype</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">toString</span>()) <span class="comment">//Error</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// false</span></span><br><span class="line">conosle.<span class="title function_">log</span>(obj) <span class="comment">//非常空的物件</span></span><br><span class="line">obj.<span class="property">a</span> = <span class="number">2</span> <span class="comment">// 還是可以給予屬性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123;a:2&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) <span class="comment">// [&#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure><p>但並不代表 Object 有關的方法都不能呼叫<br>而是要看方法是否在 prototype 裡<br>像是 Object.keys 依然可以使用</p><h3 id="造一個-Object-create">造一個 Object.create()</h3><p><code>Object.create()</code> 簡單實作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">create</span> = <span class="keyword">function</span> (<span class="params">proto</span>)&#123;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">F.<span class="property"><span class="keyword">prototype</span></span> = proto;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>透過一個封裝過的建構式建構出來的物件，並把 <code>prototype</code> 指向作為參數的 <code>proto</code>。</p><h2 id="Object-create-v-s-new">Object.create() v.s new ?</h2><p>兩個都是建立物件，哪裡不一樣 ?</p><blockquote><p><code>new</code> operator 跟 <code>Object.create</code> 的差別在於會不會執行 constructor</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 建立的時候，也印出 hi</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>) <span class="comment">// 指是建立了而已</span></span><br></pre></td></tr></table></figure><h2 id="參考-11">參考</h2><ol><li><a href="https://zh.javascript.info/prototype-methods#very-plain">原型方法，没有 <strong>proto</strong> 的对象</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10194356">重新認識 JavaScript: Day 25 原型與繼承</a></li><li><a href="https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/javascript-new-operator-implementation-8c0d15f2b899">new operator — JavaScript | 為了瞭解原理，那就來實作一個 new 吧！</a></li><li><a href="https://blog.csdn.net/blueblueskyhua/article/details/73135938">你不知道的javascript之Object.create 和new区别</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-25&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上一篇知道原型與原型鏈的內容&lt;br&gt;
如果我們要讓東西繼承，除了透過 new 建立物件直接幫我們繼承之外&lt;br&gt;
還有 &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; 以及 &lt;code&gt;Object.create()&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - Prototype 物件導向 (III) 原型 &amp; 原型鏈</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-03"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-03</id>
    <published>2022-04-19T04:33:30.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-24">前言</h2><p>JavaScript 的核心就在原型 !<br>原型使得物件都能使用在原型鏈上的屬性及方法<br>本身物件也可以再擴充<br>透過本篇了解原型的使用方法</p><span id="more"></span><h2 id="什麼是-prototype">什麼是 prototype ?</h2><p><img data-src="https://dsm01pap006files.storage.live.com/y4mZUP0lakeV0ZyTOBA3FOhGoj0nLq4_-h6RClQix2hTtsj-YL9kg-RwmOfya_emwZ1jekhk9jIrt-JrTQQfyiPEwOfYlVWWxlFZHdaAgkONuvg-kxkJgmo67BaKWfhEePd-7sT21E5ITCGSdla3HTIiK8NillkQBfzy2mTCrs5ZtISAl-h5eV-JiE6ySo075Ow?width=946&amp;height=563&amp;cropmode=none" alt="prototype"><br>參考圖 : <a href="https://ithelp.ithome.com.tw/articles/10194356">重新認識 JavaScript: Day 25 原型與繼承</a></p><p>從 01 篇知道 prototype 可以讓不同的物件共享原型的同一個方法或屬性<br>prototype 就像是從 function 產生的集裝箱<br>讓 function 建立出來的物件都可以拿到同樣的東西</p><blockquote><p><strong>函式也是物件</strong>，所以可以透過 prototype 來擴充每一個透過這個函式所建構的物件</p></blockquote><p>好像難以連結，不過我們時時刻刻都在使用 prototype 的概念<br>有想過為什麼基本型別的值 (number、string、bool) 可以 <strong>像 object 一樣呼較方法獲取到屬性</strong>呢 ?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="property">length</span> );</span><br></pre></td></tr></table></figure><p>沒錯，就是透過 prototype 原型提供的方法來繼承<br>在 JavaScript 呼叫方法或屬性之前，會透過基本型別包裹器 (Primitive Wrapper)<br>被轉型為該類別的「物件」，由對應的物件提供的方法是透過原型鏈 (prototype chain)<br>讓我們可以對基本型別的值呼叫方法</p><ul><li>類似這樣</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str.length 模擬過程</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// 變成物件</span></span><br><span class="line">str.<span class="property">length</span> <span class="comment">// 拿到屬性</span></span><br><span class="line">str = <span class="literal">null</span> <span class="comment">// 銷毀</span></span><br><span class="line">str = <span class="string">&#x27;Hello&#x27;</span> <span class="comment">// 恢復成基本型別</span></span><br></pre></td></tr></table></figure><h2 id="prototype-怎麼來">prototype 怎麼來 ?</h2><p><strong>函式建立時會自動產生 prototype 屬性</strong>。<br>產生的物件並&quot;不&quot;代表物件的 prototype 屬性就是這個函式的原型物件<br>而是透過 <code>new</code> 出來的物件會有 <code>[[Prototype]]</code> 的隱藏屬性<br>是指 <strong>建構式</strong> 的 prototype</p><blockquote><p><code>constructor.prototype</code></p></blockquote><p>上面的敘述很令人混亂對吧 ?<br>先舉個例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">getName</span> =<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rosa = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Rosa&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="title function_">getName</span>()) <span class="comment">// Rosa</span></span><br></pre></td></tr></table></figure><p><code>rosa</code> 是從 Person 建構出來的物件</p><blockquote><p>所以 rosa 的原型是 Person</p></blockquote><p>回到第一句話<br><strong>函式建立時會自動產生 prototype 屬性</strong></p><p>對著 <code>Person</code> 函式取 prototype ，確實是有的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// Person 本身</span></span><br></pre></td></tr></table></figure><p>prototype 讓 rosa 可以直接拿到 <code>Person</code> 裡面的方法 (getName)</p><p>那第二句是什麼意思 ?<br>試著讓 <code>rosa</code> 呼叫 <code>toString()</code>，但是 Person 並沒有這個方法呀 ?!<br>我們說過 rosa 的原型是 Person</p><blockquote><p>但 <strong>不</strong> 代表建構出來的物件 (rosa) 的 prototype 屬性就是這個函式 (Person) 的原型物件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">lgo</span>(rosa.<span class="title function_">toString</span>()) <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure><p>rosa 這裡取來的屬性或方法是來自 <code>Object.prototype</code> 傳下來的</p><p>接著第三句 <strong>建構式</strong> 的 prototype 是什麼意思 ?<br>試著對 <code>rosa</code> 取 prototype<br>新手一開始會以為 <code>rosa</code> 的 prototype 是等於 <code>Person</code> 的 prototype<br>特別要搞清楚這裡的 prototype 是指什麼(我一開始也搞混了)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>回到第一句，回想 <code>.prototype</code> 是誰產生的 ?<br>對，是 <strong>函式</strong><br>那 rosa 物件是透過建構式的方式而來<br>prototype 是隱藏屬性，沒辦法透過建構出來的物件直接取得</p><p><img data-src="https://dsm01pap006files.storage.live.com/y4mL7f71rE-gVfp4ze955AsP5mGlQNR1PYAJH4jUShpBHgc6U4Wq0pK2oYpDCsmDsGL0r2AxpMx3WXujkLUwZtgTEX_C1HPGIei28YZq0VvVXXwaTb7DT7K2RM-5ywv0SCz41iHsWPYdEp4lRb2YP19GWxtllx_EEBLXmJXO65f5jsuWSyQcLed8gq4Xo3YG0e3?width=692&amp;height=620&amp;cropmode=none" alt="藏在 contructor"></p><h2 id="取得物件的-prototype">取得物件的 prototype</h2><p>既然不能直接透過 <code>rosa.prototype</code> 取得原型<br>如果我們要知道 rosa 是繼承誰的 prototype 可以透過三種的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(rosa)) <span class="comment">// 現在比較好的拿到的方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// 從建構式拿到 [[Prototype]] 的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="property">__proto__</span>) <span class="comment">// 原本各家瀏覽器實作，後來 ES6 保留的方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(rosa)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === rosa.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === rosa.<span class="property">__proto__</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="原型鏈-Prototype-Chain">原型鏈 Prototype Chain</h2><p>原型可以讓本來 <strong>沒有某屬性的物件去存取其他物件的屬性</strong></p><h3 id="proto-溝通的原則">__proto__ : 溝通的原則</h3><p>如果本身物件沒有屬性或方法使用，可以透過原型鍊 (prototype chain) 來取得<br>那是怎麼傳的呢 ?</p><p>原本 JavaScript 沒有提供標準方法直接存取物件的 <code>[[Prototype]]</code>。<br><code>__proto__</code> 是瀏覽器實作的的，並非 EMCAScript 的標準，不是所有的環境都有這個值。</p><blockquote><p>ES5 以後的是使用 <code>Object.getPrototypeOf()</code><br>ES6 為了向下兼容，<code>__proto__</code> 也是承認的，但環境的不同支援度不同，還是用 <code>getPrototypeOf</code><br><code>__proto__</code> 是 <code>[[Prototype]]</code> 底下的屬性，屬於 setter/getter</p></blockquote><p><code>__proto__</code> 這個特殊屬性或者是 <code>Object.getPrototypeOf()</code> 都是取得某個物件的原型物件 <code>[[Prototype]]</code> 的方式。</p><p>官方比較建議使用 <code>Object.getPrototypeOf()</code>，因為 <code>__proto__</code> 比較耗效能</p><p>除了拿到物件原型的 prototype，<br>還可以透過 <code>.__proto__</code> 看原型們如何溝通</p><p><strong>範例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name</span>)&#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says meow`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lily = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;lily&#x27;</span>)</span><br><span class="line">lily.<span class="title function_">hello</span>()</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Bob</span> = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="title class_">Bob</span>.<span class="title function_">hello</span>()</span><br></pre></td></tr></table></figure><h3 id="模擬溝通">模擬溝通</h3><p>想執行 <code>lily.hello()</code><br>會依照這樣的順序尋找</p><ol><li>找 lily 本身是不是有 hello function ?<br>👉 沒有，往上一層找</li><li>找 <code>lily.__proto__</code> 是不是有 hello ?<br>👉 沒有的話，再往上一層找<br>知道 <strong>lily._<em>proto_</em> = Cat.prototype</strong></li><li>找 <code>lily.__proto__.__proto__</code> 是不是有 hello ?<br>=&gt; <code>lily.__proto__.__proto__ = Cat.prototype.__proto__</code>。<br>=&gt; <code>lily.__proto__.__proto__  = Object.prototype</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>往上找像是用鏈結的方式，所以才稱 prototype chain<br>我們找到 Object.prototype 就停止了</p><blockquote><p>那 <code>Object.prototype.__proto__</code> 呢?</p></blockquote><h3 id="最頂層的原型物件-Object-prototype">最頂層的原型物件: Object.prototype</h3><p>往上找 <code>__proto__</code>，什麼時候才會停止 ?<br>會發現 <code>Object.prototype.__proto__</code> 等於 <code>null</code>，代表 Object 是最頂層了。</p><p>在 JavaScript 幾乎所有的物件 (環境宿主物件除外)會順著原型鍊找到最頂層<br><code>Object.prototype</code> 才停止，因為 <code>Object.prototype</code> 是 JavaScript 所有物件的起源。</p><p>在 <code>Object.prototype</code> 提供的所有方法，在 JavaScript 的所有物件的可以呼叫它。</p><ul><li><code>Object.prototype.hasOwnProperty()</code> : 是否為自己的屬性或方法</li><li><code>Object.prototype.toString()</code> : 轉型成字串</li><li><code>Object.prototype.valueOf()</code> : 取得 <strong>基本型別</strong> 的值</li></ul><p>幾乎所有的值可以使用的。<br>即便建立物件時，沒有定義這些方法，但基於原型鏈的繼承，我們還是可以呼叫這些方法。</p><h2 id="instanceof-是否在物件的原型鏈上">instanceof : 是否在物件的原型鏈上</h2><p>instanceof 除了檢查 <code>constructor.prototype</code> 是不是在物件的原型鏈上<br>也能檢查 <strong>複合式物件的基本型別</strong></p><ul><li>檢查基本型別</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">100</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num) <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num <span class="keyword">instanceof</span> <span class="title class_">Number</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">valueOf</span>()) <span class="comment">// 100，基本型別的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num.<span class="title function_">valueOf</span>()) <span class="comment">//&#x27;number&#x27;</span></span><br></pre></td></tr></table></figure><p><code>valueOf()</code> 可以拿到基本型別的值</p><ul><li>檢查是不是在原型鏈上，同理使用 <code>class</code> 的結構也可以檢查</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> rosa = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa <span class="keyword">instanceof</span> <span class="title class_">User</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="物件本身-v-s-原型鏈-出現同名屬性物件">物件本身 v.s 原型鏈 : 出現同名屬性物件 ?</h2><p>物件實體與原型具有相同的屬性或方法</p><blockquote><p><strong>優先存取自己的屬性或方法</strong>，如果沒有才會再順著原型鏈向上尋找。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Yo!&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hi!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="title function_">sayHello</span>()) <span class="comment">// Yo!</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 原型的方法擴充</span></span><br><span class="line"><span class="string">class 級別的擁有 extend 往下擴充  </span></span><br><span class="line"><span class="string">實例出實體後，會尋找存在的原型，並且一層層往上找。</span></span><br><span class="line"><span class="string">如果要替原型定義其他的方法可以這樣寫    </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">// 原始</span></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says meow`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定在最上層，讓往下的都可以使用</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> =<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says meow`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Object 是最頂層，其實在這邊定義也可以。<br>如果不是同一類型都需要使用，這種方法也可以導致奇怪的問題發生</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">push</span>(<span class="string">&#x27;lol&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> arr= []</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">0</span>]) <span class="comment">// &#x27;lol&#x27;</span></span><br></pre></td></tr></table></figure><p>每一個 array 產生時已經被加上 <code>'lol'</code><br>使用上合法，但不是一個好操作</p><p>以上如果有誤，歡迎指教 QQ</p><h2 id="參考-10">參考</h2><ol><li><a href="https://ithelp.ithome.com.tw/articles/10194356">重新認識 JavaScript: Day 25 原型與繼承</a></li><li><a href="https://lidemy.com/courses/enrolled/390599">JS201 進階 JavaScript：那些你一直搞不懂的地方</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-24&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;JavaScript 的核心就在原型 !&lt;br&gt;
原型使得物件都能使用在原型鏈上的屬性及方法&lt;br&gt;
本身物件也可以再擴充&lt;br&gt;
透過本篇了解原型的使用方法&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - class 物件導向 (II) 繼承</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-02"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-02</id>
    <published>2022-04-19T04:33:24.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-22">前言</h2><p>上一篇我們提到 class 像是幫我們製作藍圖<br>有車子基本構造的藍圖<br>是不是能透過藍圖能做出其他車種的藍圖呢 ?</p><p>可以，就是繼承 !</p><span id="more"></span><h2 id="extends">extends</h2><p>要讓子物件擁有父物件的內容可以透過 <code>extends</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">newClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">OldClass</span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>範例 :</strong><br>Dog 繼承 Animal</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> makes a noise.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line"><span class="title function_">sit</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> sits.`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Mitzie&#x27;</span>);</span><br><span class="line">d.<span class="title function_">speak</span>();<span class="comment">// &#x27;Mitzie barks.&#x27;</span></span><br><span class="line">d.<span class="title function_">sit</span>(); <span class="comment">// &#x27;Mitzie sits.&#x27;</span></span><br></pre></td></tr></table></figure><p>Dog 繼承 Animal 的方法了，因此在 Dog 呼叫 speak 是可以的。</p><p>extends 背後會幫我們連接物件的 prototype<br>使我們可以取得父物件的方法或屬性。</p><blockquote><p>JavaScript 使用 prototyped-based 不能讓物件一次繼承兩種<br>但有一個方法叫 <code>mixin</code> 利用拷貝的概念達到目的</p></blockquote><p>因為我還不會，先擱著 QQ，待補<br>參考 :</p><ul><li><a href="https://zh.javascript.info/mixins">Mixin 模式</a></li></ul><h2 id="super">super()</h2><p>如果要在一開始就 <strong>呼叫父層的方法</strong>，必須加入<code>super()</code>，代表在繼承的子層初始化時，將舊數值蓋過去，要傳進的參數也要帶入。</p><blockquote><p>簡單來說，<code>super</code> 就是上一層的 <code>constructor</code></p></blockquote><ul><li>沒有 <code>super()</code> 的情況下，想在新物件生成時呼叫原型方法的 <code>speak()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> makes a noise.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">speak</span>() <span class="comment">// 建構時在這裡呼叫原型的方法  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sit</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> sits.`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Mitzie&#x27;</span>);</span><br><span class="line">d.<span class="title function_">speak</span>(); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>就會跑出</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Must call <span class="keyword">super</span> constructor <span class="keyword">in</span> derived <span class="keyword">class</span> <span class="symbol">before</span> <span class="symbol">accessing</span> &#x27;<span class="symbol">this</span>&#x27; <span class="symbol">or</span> <span class="symbol">returning</span> <span class="symbol">from</span> <span class="symbol">derived</span> <span class="symbol">constructor</span></span><br></pre></td></tr></table></figure><p>會提示你要記得加入 super，不然 <code>this</code> 使用時會出現問題</p><ul><li>加上 super 以及要初始化的值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> makes a noise.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="variable language_">super</span>(name)</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">speak</span>() <span class="comment">// 建構時在這裡呼叫原型的方法  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sit</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> sits.`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Mitzie&#x27;</span>);</span><br><span class="line">d.<span class="title function_">speak</span>(); <span class="comment">// &#x27;Mitzie makes a noise.&#x27;</span></span><br></pre></td></tr></table></figure><p>如果 super 裡面沒有傳入 <code>name</code><br><code>this</code> 是 Dog 本身，但是不具有 <code>name</code> 這個值，就會是 <code>undefined</code></p><h2 id="應用-2">應用</h2><p>繼承可以用在有 <strong>共同屬性</strong> 的時候，想再加一些附加功能，透過繼承不用完全重寫。</p><h2 id="參考-8">參考</h2><ul><li><a href="https://lidemy.com/courses/enrolled/390599">JS201 進階 JavaScript：那些你一直搞不懂的地方</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-22&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上一篇我們提到 class 像是幫我們製作藍圖&lt;br&gt;
有車子基本構造的藍圖&lt;br&gt;
是不是能透過藍圖能做出其他車種的藍圖呢 ?&lt;/p&gt;
&lt;p&gt;可以，就是繼承 !&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="OOP" scheme="https://blog.rosa.tw/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - class 物件導向 (I) 初探 OOP</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-01"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-Object-oriented-programming-01</id>
    <published>2022-04-19T04:33:15.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-23">前言</h2><p>JavaScript 是物件導向的語言<br>但跟其他的物件導向語言使用 class 有點不同</p><p>恩 ? Javascript 不是也用 class 嗎 ?<br>不，<code>class</code> 是語法糖，到 ES6 才問世<br>真正的 JavaScript 是使用 prototype 來達成物件導向</p><p>本系列將從現代開發用的 <code>class</code> 來了解<br>再到認識真的原汁原味 <code>prototype</code> 的作法</p><span id="more"></span><h2 id="class-的物件導向">class 的物件導向</h2><p><code>Object-oriented programming</code> 簡稱 OOP<br>物件導向的優點在於更 <strong>直覺</strong>，更模組化</p><p>ES6 是使用 class<br>ES5 以前並沒有 class，而是使用 <code>prototype</code> (原型) 的方式。<br><code>class</code> 像是藍圖，而 <code>new</code> 則是把藍圖裡的東西實例出來</p><blockquote><p>類別型的物件都是<strong>大寫開頭</strong>，這是常用的寫法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義貓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line"><span class="comment">// 每隻貓有名字</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每隻貓打招呼會喵喵叫</span></span><br><span class="line"><span class="title function_">hello</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says meow`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建立一隻叫 lily 的貓，把它存在 lily 這個變數</span></span><br><span class="line"><span class="keyword">let</span> lily = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;lily&#x27;</span>)</span><br><span class="line">lily.<span class="title function_">hello</span>() <span class="comment">// lily says meow</span></span><br><span class="line"><span class="keyword">let</span> bob = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line">bob.<span class="title function_">hello</span>() <span class="comment">// bob says meow</span></span><br></pre></td></tr></table></figure><ol><li><code>class</code> : 物件的藍圖<br>裡面的涵式不需要寫 <code>function</code> 的字，可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions#description">function shorthand</a></li><li><code>new</code> : 把藍圖實做出來，放到自訂義變數中，之後這個變數也擁有藍圖包含的功能。<br>用 <code>.</code> (dot) 連接，像 <code>object</code> 來呼叫。</li><li><code>new XXX(建構子參數)</code> : 建構子是 class 內部的涵式，可以加入參數，類似初始化。<br>對應 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//這是建構子</span></span><br><span class="line"><span class="title function_">construtor</span>(<span class="params"><span class="variable language_">arguments</span></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">arguments</span> = <span class="variable language_">arguments</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>constructor</code> : 可以看做基本資料(設定檔)，<code>this.name = name</code><br>把 new 帶入的引數作為內部建構子參數使用。</p></blockquote></li><li><code>this</code> : 分成 class 內部的 <code>this</code> 與外部的 <code>this</code>。這邊著重內部的 this。<br><code>this</code> 是對應被實體出來的主體。<br>lily 被指向叫做 lily 的貓<br>反之 bob 也是，並不是指同一個物件<br>但是內部方法是共用同一個 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lily.<span class="property">hello</span> === <span class="title class_">Bob</span>.<span class="property">hello</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><p>對於已經建立的物件再修改內部建構的值非常不建議</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lily.<span class="property">name</span> = <span class="string">&quot;rosa&quot;</span> (👎)  </span><br></pre></td></tr></table></figure><p>雖然可以修改掉內部的 <code>this.name</code> 的值<br>一般來說在建立實體時都會設定好，較少再直接透過個別更改</p><h2 id="沒有-class-的物件導向">沒有 class 的物件導向</h2><p>在 ES5 並沒有 class 的做法<br>如果沒有使用 prototype 的寫法<br>我們可以透過 function 來建構</p><blockquote><p>function 也是物件，所以可以透過 <code>.</code> 拿到屬性或方法</p></blockquote><ul><li>改寫上面的 Cat class</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name</span>) &#123;</span><br><span class="line"><span class="comment">// 用 _ (dash) 通常指被封裝在函式內的變數，類似私有變數，一般不會直接修改</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">_name</span>,</span><br><span class="line">    <span class="attr">hello</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says meow`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Lily</span> = <span class="title class_">Cat</span>(<span class="string">&quot;Lily&quot;</span>);</span><br><span class="line"><span class="title class_">Lily</span>.<span class="title function_">hello</span>();</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Bob</span> = <span class="title class_">Cat</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"><span class="title class_">Bob</span>.<span class="title function_">hello</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lily</span>.<span class="property">hello</span> === <span class="title class_">Bob</span>.<span class="property">hello</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>讓物件能呼叫方法用 <code>function</code> 回傳 function 的方式<br>但是這個方法 <strong>非常消耗記憶體</strong><br>每一個產生的 function 都是不同的 function</p><h2 id="對比圖">對比圖</h2><p><img data-src="https://dsm01pap006files.storage.live.com/y4mPsTnRBXXRDKUTn4h4YIRTBAE1Q3K4imjKAv-NaRLxF9KjYvNc3TJj5u-GvDWoZUpm_TBcByzdTcbSFqiAJtRNy43xJRnNoug9RKxYtHqxvCm-JrazXLtBM82gThGBaH8-SjTQbaFr0zZr4tGF2CuwLIl0u7I3soTI3iJ8usyN9oWE1SV6GyXIBp3snhf2Ply?width=1024&amp;height=325&amp;cropmode=none" alt="右 : ES5 ，左 : ES6"></p><p>右邊因為每一個實體都是重新創建一個新物件方法，明明要呼叫的指向實體是同一個而已。<br>改善這部分會使用到 <code>prototype</code>，讓建構的物件都有共同的方法與屬性</p><ul><li>有無使用 prototype 的寫法</li></ul><p><img data-src="https://dsm01pap006files.storage.live.com/y4meCfDywgqAcUJCJFA07OVsJ4OvfDl-Qu_nPbSoDEocZ_v0aTe19CwejVfn_H2ZHF8PR5mb1xI4pjAwUuAQLb-NdFX5VB-_AmcjbZbIrfTn8wy1Cf5im0Lr8--yFtVkM8wsSdEd-N4TO9cPP64dTTXfH0td0OWI8XuyKow6jmPGLxam61-1dH2JWOpXzMFCDg3?width=1024&amp;height=308&amp;cropmode=none" alt="左 : function 直接回傳物件，右 : 透過 prototype"></p><p>最大的差別在於產生的物件 <strong>是不是共用同一個方法</strong><br>右邊的透過 prototype 方法是都指向同一個</p><p>建立物件時右邊是使用了 <code>new</code>，幫將物件的原型綁在建構函式上</p><h2 id="new-藍圖的實作">new : 藍圖的實作</h2><p>new 到底做了什麼是呢 ?</p><ul><li>new 不 new ?</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等同於 class 的 construtor</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">buy</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`you buy a new <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> toyota = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;toyota&#x27;</span>)</span><br><span class="line">toyota.<span class="title function_">buy</span>()</span><br><span class="line"><span class="keyword">let</span> honda = <span class="title class_">Car</span>(<span class="string">&#x27;honda&#x27;</span>) <span class="comment">// 錯誤</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>沒 new 會出現 <code>Class constructor Car cannot be invoked without 'new'</code><br>代表沒有初始化。</p><h3 id="複習一下-call">複習一下 call</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hello</span>() <span class="comment">//這邊印出的 this 是全域物件  </span></span><br><span class="line">hello.<span class="title function_">call</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">//123，this 變成傳進去的東西</span></span><br></pre></td></tr></table></figure><p><code>.call</code> 是呼叫函式的另一種方法<br>透過這樣的方式可以將 this 綁在傳入的物件上</p><h3 id="手動造一個-new">手動造一個 new</h3><p>知道 call 跟 this 的關係，就能了解 <code>constructor</code> 的初始化。</p><ul><li>目標 : 不用 new 做一樣的功能</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> toyota = <span class="title function_">newCar</span>(<span class="string">&#x27;toyota&#x27;</span>)</span><br><span class="line">toyota.<span class="title function_">buy</span>()</span><br></pre></td></tr></table></figure><ul><li>用 newCar</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">buy</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`you buy a new <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">newCar</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> obj =&#123;&#125;</span><br><span class="line"><span class="title class_">Car</span>.<span class="title function_">call</span>(obj,name)</span><br><span class="line">obj.<span class="property">__proto__</span> = <span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new 其實做了 :</p><ol><li>建立一個 obj</li><li><code>.call(obj,name)</code>，呼叫建構子。把 obj 當作 <code>this</code>，name 作為參數，完成 <code>constructor</code> 的初始化。<blockquote><p>沒有這一項無法指向實體，<code>this</code> 綁定問題</p></blockquote></li><li>用 <code>__proto__</code> 導向至 prototype，跟原型進行搭橋，才能使用到該原型方法。</li><li><code>return obj</code> ，實例 (instance) 出來的東西。</li></ol><h2 id="結語">結語</h2><p>現代開發大多還是使用 class<br>但並非代表 JavaScript 就是用 class(類別) 來建立<br>背後依然是 function 與指定 prototype 的實作</p><p>想更了解 JavaScript 認識 prototype 是不可少的<br>同時我也查了為什麼 JavaScript 作者使用 prototype 的設計<br>而不是用類別 ，是出於什麼考量?</p><p>在<a href="https://stackoverflow.com/questions/8433459/what-s-the-purpose-of-prototype">這篇</a> 找到的的解釋是 class-based 是要 <strong>重頭設計物件</strong>，而 prototype-based 可以透過現有已建立的物件再建立，總得來說效能上更快。</p><h2 id="參考-9">參考</h2><ul><li><a href="https://lidemy.com/courses/enrolled/390599">JS201 進階 JavaScript：那些你一直搞不懂的地方</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-23&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;JavaScript 是物件導向的語言&lt;br&gt;
但跟其他的物件導向語言使用 class 有點不同&lt;/p&gt;
&lt;p&gt;恩 ? Javascript 不是也用 class 嗎 ?&lt;br&gt;
不，&lt;code&gt;class&lt;/code&gt; 是語法糖，到 ES6 才問世&lt;br&gt;
真正的 JavaScript 是使用 prototype 來達成物件導向&lt;/p&gt;
&lt;p&gt;本系列將從現代開發用的 &lt;code&gt;class&lt;/code&gt; 來了解&lt;br&gt;
再到認識真的原汁原味 &lt;code&gt;prototype&lt;/code&gt; 的作法&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="OOP" scheme="https://blog.rosa.tw/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - this (II) call、appaly、bind</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-this-II"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-this-II</id>
    <published>2022-04-15T03:07:53.000Z</published>
    <updated>2022-07-27T05:30:49.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-26">前言</h2><p>除了透過執行環境與上下文來綁定之外<br>this 是可以改變的<br>改變 this 有三種方式</p><span id="more"></span><h2 id="call-apply">call &amp; apply</h2><p>上一篇有簡略提過 <code>.call()</code><br>等同於 function 直接執行<br>而且是有帶 <code>this</code><br>第一個參數是指定 <code>this</code>，後面及是 <code>arguments</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 這樣是一樣的</span></span><br><span class="line"><span class="title function_">test</span>() === test.<span class="title function_">call</span>()</span><br><span class="line"><span class="title function_">test</span>() === test.<span class="title function_">apply</span>()</span><br></pre></td></tr></table></figure><p>這兩個執行是差不多的<br>差在後面的參數類型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test =&#123;</span><br><span class="line">a : <span class="number">1</span>,</span><br><span class="line"><span class="title function_">log</span>(<span class="params">num</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>,num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line"><span class="attr">a</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">test.<span class="title function_">log</span>(<span class="number">5</span>) <span class="comment">// 1 , 5</span></span><br><span class="line"><span class="comment">// 改變 this </span></span><br><span class="line">test.<span class="property">log</span>.<span class="title function_">apply</span>(obj,[<span class="number">5</span>]) <span class="comment">// 5 , 5</span></span><br><span class="line">test.<span class="property">log</span>.<span class="title function_">call</span>(obj,<span class="number">5</span>) <span class="comment">// 5 , 5</span></span><br></pre></td></tr></table></figure><ul><li><code>call</code> : 後面都用逗號隔開<br><code>.call(thisValue,args[0],args[1])</code></li><li><code>apply</code> : 前面為 this，後面參數為類陣列。<br><code>.apply(thisValue,[args[0],args[1]])</code></li></ul><h3 id="call-跟-apply-為什麼同時存在">call 跟 apply 為什麼同時存在 ?</h3><p>例子是來自 <a href="https://blog.huli.tw/2020/04/18/javascript-function-is-awesome/">覺得 JavaScript function 很有趣的我是不是很奇怪</a><br>這篇也探討很有趣的 JS 問題</p><ul><li>Math.max 的參數可以吃隨意數值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>如果我們要從陣列中找出最大值呢 ?<br>直接呼叫會導致錯誤<br>可以運用 apply 的參數是 <strong>陣列</strong> 的方式帶入<br>或者用 ES6 展開</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>,arr)) <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(...arr)) <span class="comment">// 6 , 展開 </span></span><br></pre></td></tr></table></figure><p>總是會有不同的情境可以使用</p><h2 id="bind">bind</h2><p>把 this 的值先綁死，不管後面怎麼 call<br>都不會變動。</p><blockquote><p>bind 回傳的是一個 <strong>function</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line"><span class="attr">a</span>:<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">test</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = obj.<span class="property">test</span>.<span class="title function_">bind</span>(o) <span class="comment">// function</span></span><br><span class="line"><span class="title function_">b</span>() <span class="comment">// 10</span></span><br><span class="line">b.<span class="title function_">call</span>(obj) <span class="comment">// 依舊是 10</span></span><br></pre></td></tr></table></figure><p>非嚴格模式底下，無論是用 call、apply 還是 bind<br>傳進去的如果是 primitive 都會被轉成 <strong>object</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">hello.<span class="title function_">call</span>(<span class="number">123</span>) <span class="comment">// [Number: 123]</span></span><br><span class="line"><span class="keyword">const</span> myHello = hello.<span class="title function_">bind</span>(<span class="string">&#x27;my&#x27;</span>)</span><br><span class="line"><span class="title function_">myHello</span>() <span class="comment">// [String: &#x27;my&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="箭頭函式-v-s-bind">箭頭函式 v.s bind</h2><p>初學時會認為 arrow funciton 有指向自己，綁定的意味<br>但兩者有很大的區別</p><ul><li><code>.bind(this)</code> : 呼叫之前就先綁定，讓被呼叫的都有固定的 <code>this</code>。</li><li>arrow function this : 箭頭函式沒有建立任何的 this，簡單來說是根本沒有自己的 this。<br>在箭頭函式使用 this，會像變數一樣，往外部尋找。</li></ul><h2 id="參考-12">參考</h2><ol><li><a href="https://blog.huli.tw/2019/02/23/javascript-what-is-this/">淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂 - Huli</a></li><li><a href="https://blog.huli.tw/2020/04/18/javascript-function-is-awesome/">覺得 JavaScript function 很有趣的我是不是很奇怪</a></li><li><a href="https://zh.javascript.info/arrow-functions">深入理解箭头函数</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-26&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;除了透過執行環境與上下文來綁定之外&lt;br&gt;
this 是可以改變的&lt;br&gt;
改變 this 有三種方式&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - this (I) 基礎概念</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-this-I"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-this-I</id>
    <published>2022-04-15T03:07:39.000Z</published>
    <updated>2022-07-27T05:30:49.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-28">前言</h2><p>在學習 JavaScript 時很多課程會建議不要急著先用 <code>this</code><br>因為 this 會跑出讓新手無法預期的結果<br>在某些情況下使用 this 反而更棘手<br>藉由本次來初步了解這個奇妙的 <strong>this</strong>!</p><span id="more"></span><h2 id="什麼是-this">什麼是 this ?</h2><ul><li>關鍵字</li><li>function 執行時，自動生成的內部物件</li><li>隨 function 執行場合不同，this 指向的值也會不同</li><li>大多數情況，this 代表的就是呼叫 function 的物件 (Owner Object of the function)。</li></ul><p>總得來說 :</p><blockquote><p>this 會因 <strong>執行的環境與上下文</strong> (context) 的不同，而有不同的結果<br>翻譯機 : <strong>跟 function 在哪裡呼叫有關</strong></p></blockquote><p>空說 this 有點難以了解，this 其實在哪裡都可以使用(非嚴格模式下)<br>JavaScript 並沒有特別限制 this 綁定在哪，所以 this 是會變來變去的<br>正因如此才顯得有點麻煩</p><h2 id="不同情況下的-this">不同情況下的 this</h2><h3 id="物件導向的-this">物件導向的 this</h3><p>this 就是 <code>instance</code> 本身，被 <strong>實例</strong> 出來的那個。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getValue</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> toyota = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;toyota&#x27;</span>)</span><br><span class="line">toyota.<span class="title function_">getValue</span>()</span><br></pre></td></tr></table></figure><p>這個例子就是 <code>toyota</code> 物件本身</p><h3 id="物件導向之外的-this">物件導向之外的 this</h3><p>脫離 <code>class</code> 後，可以再細分成</p><ol><li>一般 function 中的 this</li><li>DOM 事件中的 this</li><li><code>object</code> 的 this</li><li>arrow function 的 this <strong>(特別)</strong> ⭐</li></ol><blockquote><p>殺手鐧 : 可以用 <code>.call()</code> 來知道 this 的意義</p></blockquote><p><code>.call()</code> 是執行 function 另一種方式<br><code>.call(context,args[0],args[1])</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">p1,p2</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,p1,p2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// undefined 1 2</span></span><br><span class="line">test.<span class="title function_">call</span>(<span class="literal">undefined</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// undefined 1 2</span></span><br></pre></td></tr></table></figure><p>這兩個是一樣的，會發現原來一般呼叫 function 會少了 this<br>而這個 this 就是看執行的環境與上下文 (context) 而來的</p><p><strong>物件中的 function 呢 ?</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">p1,p2</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,p1,p2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">func : test</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">func</span>.<span class="title function_">call</span>(obj)</span><br></pre></td></tr></table></figure><p>根據上面說的</p><blockquote><p><code>this</code> 代表的就是呼叫 function 的物件</p></blockquote><p>物件呼叫，呼叫的 method 前面是 obj<br>所以 call 裡面的 this 位置是 <code>obj</code></p><h4 id="一般-function-中的-this">一般 function 中的 this</h4><p>根據環境不同，結果不同<br>但是都是 global 的物件<br>在 <strong>非嚴格模式</strong> 下</p><ul><li>node.js : <code>this = global</code><br><img data-src="https://dsm01pap006files.storage.live.com/y4mBY1X7hZFvUS0mwa7p25amxq2Q5tXcp0SRBAKj7cJNx_37JCdjvCWa0cMAjfVWWbH4a8_YsBV0qOgYrNgcg6zJ5FhgIGuLqLlMT8euJQKJx8Dr9WTfy2FGVzvqh4ES1YzVoXlfdOCNR8Q_ndRIiDSyucw5IxbNHFsKeU5KRB71oZ9e096hhsMhYq6JT-FlHeR?width=1022&amp;height=617&amp;cropmode=none" alt="global 物件"></li><li>瀏覽器 : <code>this = window</code><br><img data-src="https://dsm01pap006files.storage.live.com/y4mkwi-WphtCQHHgZoUP5u8Q0AkSyEZZcX6U6ErkFF5AKuF0z1us2zGqqo2w-Ir8auT0FL7AbZxjEfLh3Y4wyVYyLU38xVibSCWD1r70lghQMdlCieK35uGdQSgT5HKX5iStqZw2ekAtQWqgxktoKIFmMjFBf-L3h8PkZ505ii9ON4qS1jF7nRxrEJz42_hQ7AL?width=662&amp;height=300&amp;cropmode=none" alt="window 是瀏覽器的全域物件"></li></ul><blockquote><p><strong>嚴格模式</strong> 下的 this 指向全域物件是 <code>undefined</code><br>因為 this 沒有綁定誰，所以會是 <code>undefined</code>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>() <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 轉成 call</span></span><br><span class="line">test.<span class="title function_">call</span>() <span class="comment">// undefined ,沒有帶入東西，嚴格模式下是 undefined</span></span><br></pre></td></tr></table></figure><h4 id="DOM-事件中的-this">DOM 事件中的 this</h4><p>對應到事件觸發的 <strong>元素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>)</span><br><span class="line">.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以 click 為例， <code>this</code> 會導向被按到的 <strong>元素</strong> 本身</p><p>但是在事件裡 <strong>呼叫其他 function</strong> 時就要特別注意了<br>由於內部的 function 沒有綁定物件， this 會是全域物件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line"><span class="comment">// ajax 的 this 是 window 全域物件</span></span><br><span class="line">$.<span class="title function_">ajax</span>(<span class="string">&#x27;url&#x27;</span>,<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">textContent</span>,res) </span><br><span class="line">&#125;)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>可以透過其他變數將 <code>this</code> 先存起來，直接在內部呼叫的函式替換。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line"><span class="comment">// 把這邊的 this 存起來，指向的是元素本身</span></span><br><span class="line"><span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line"><span class="comment">// ajax 的 this 是 window</span></span><br><span class="line">$.<span class="title function_">ajax</span>(<span class="string">&#x27;url&#x27;</span>,<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line"><span class="comment">// 把 元素本身的 this 帶進來</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(that.<span class="property">textContent</span>,res) </span><br><span class="line">&#125;)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>下一篇會提到如何用函式的方式綁定 this</p><ul><li>轉成 <code>.call</code><br><code>el</code> 是 document 子結點取得的，這邊也可以看做一個物件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,handler,<span class="literal">false</span>)</span><br><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;type&#x27;</span>,handler.<span class="title function_">call</span>(el),<span class="literal">false</span>) <span class="comment">// 放入的是 元素 本身</span></span><br></pre></td></tr></table></figure><h4 id="object-的-this">object 的 this</h4><p>指 obj 本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">test : <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// obj</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">test</span>()</span><br><span class="line"><span class="comment">// 轉成 call</span></span><br><span class="line">obj.<span class="property">test</span>.<span class="title function_">call</span>(obj)</span><br></pre></td></tr></table></figure><h4 id="arrow-function-的-this">arrow function 的 this</h4><blockquote><p>arrow function 沒有自己的 this<br>而是用外部的 this</p></blockquote><p>箭頭函式之所以在 this 表現奇怪<br>跟其他狀況的 this 不同的是 <strong>不是哪裡被呼叫有關</strong><br>而是 <strong>在哪定義</strong> 有關<br>如果前面已定義了，就會用那個值<br>來看看例子</p><ul><li>一般 function</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hello</span>&#123;</span><br><span class="line"> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line"> &#125;,<span class="number">2000</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">hello</span>()</span><br><span class="line">a.<span class="title function_">test</span>()</span><br></pre></td></tr></table></figure><p>很明顯的 <code>new</code> 建構出來的物件<br>前面有提到是 <strong>實例</strong> 本身<br>但是裡面呼叫 function 的  this 呢 ?<br>是指 <strong>全域物件</strong><br>setTimeout 並沒有透過其他物件呼叫<br>就像在外部呼叫 <code>setTimeout</code></p><p>既然是 hello 這個物件的東西<br>我們希望 <code>this</code> 指向的是 hello 本身建構出來的物件<br><code>arrow function</code> 就派上用場了</p><ul><li>用 <code>arrow function</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hello</span>&#123;</span><br><span class="line"> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// hello&#123;&#125;</span></span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// hello&#123;&#125;</span></span><br><span class="line"> &#125;,<span class="number">2000</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">hello</span>()</span><br><span class="line">a.<span class="title function_">test</span>()</span><br></pre></td></tr></table></figure><p>arrow function 本身沒有 this<br>而是根據定義在哪，this 就是那個值<br>通常也是指箭頭函是外部的 this</p><h2 id="this-與前後文本-context-的綁定基本原則">this 與前後文本 (context) 的綁定基本原則</h2><p>this 綁定原則大概可以分四大種</p><ul><li><strong>預設綁定</strong> (Default Binding)</li><li><strong>隱含式綁定</strong> (Implicit Binding)</li><li><strong>顯式綁定</strong> (Explicit Binding)</li><li>「<strong>new」關鍵字綁定</strong></li></ul><h3 id="預設綁定">預設綁定</h3><p>宣告在 global scope 的變數，跟全域物件屬性是相同的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 直接讀</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 透過全域物件底下的屬性讀取</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>因為預設綁定，當 function 被呼叫的當下如果沒有值或是在 <code>func.call(null)</code> 或 <code>func.call(undefined)</code> 此類的情況下，此時裡面的 <code>this</code> 會<strong>自動指定至全域物件</strong>。</p><p>如果是嚴格模式， this 綁定全域物件是 <code>undefined</code></p><h3 id="隱含式綁定">隱含式綁定</h3><p>function 被宣告的地方是在 global scope 中，只要它 <strong>成為某個物件的參考屬性</strong> (reference property)，在那個 function 被呼叫的當下，該 function 即被那個物件所包含。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a  = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">a</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: func <span class="comment">// 引用 global 的 function</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>();  <span class="comment">// 2 , this是 obj 本身</span></span><br><span class="line"><span class="keyword">var</span> func2 = obj.<span class="property">foo</span>;</span><br><span class="line"><span class="title function_">func2</span>();    <span class="comment">// undefined ， 這邊的 func 是 global 的，this 是 window，a 是找不到的</span></span><br></pre></td></tr></table></figure><p>決定 this 的關鍵不在於它屬於哪個物件，而是</p><blockquote><p>在於 function「呼叫的時機點」</p></blockquote><p>透過物件呼叫某個方法 (method) 的時候，此時 this 就是那個物件 (owner object)。</p><h3 id="顯式綁定">顯式綁定</h3><ol><li><code>.bind()</code></li><li><code>.call()</code></li><li><code>.apply()</code></li></ol><p>這類直接指定 this 的 function 都可被歸類至顯式綁定的類型。</p><h3 id="new-關鍵字綁定">new 關鍵字綁定</h3><p>當一個 <code>function</code> 前面帶有 <code>new</code> 被呼叫時，會發生：</p><ul><li>會產生一個新的物件 (物件被建構出來)</li><li>這個新建構的物件會被設為那個 function 的 <code>this</code> 綁定目標，也就是 <code>this</code> 會指向新建構的物件。</li><li>除非這個 function 指定回傳 (return) 了他自己的替代物件，否則這個透過 <code>new</code> 產生的物件會被自動回傳。</li></ul><p>關於 <code>new</code>，參考 : <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new#description">MDN 對 new 的說明</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title function_">foo</span>( <span class="number">123</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj.<span class="property">a</span> );      <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><h2 id="this-的應用-Cascade-組合技">this 的應用 : Cascade 組合技</h2><p>Cascade 也有人稱作 <strong>「Fluent Interface」</strong><br>可以讓 method 串串樂</p><p>JavaScript 允許函式 <code>return undefined</code><br>那改成 <code>return this</code> 呢 ?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calNum = <span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">num</span> = num;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">newNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> += newNum;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sub</span> = <span class="keyword">function</span>(<span class="params">newNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> -= newNum;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">multi</span> = <span class="keyword">function</span>(<span class="params">newNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> *= newNum;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">division</span> = <span class="keyword">function</span>(<span class="params">newNum</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> /= newNum;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 透過 new 建立實體，this 是 calNum本身</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">calNum</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 分開呼叫</span></span><br><span class="line">a.<span class="title function_">add</span>(<span class="number">50</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a.<span class="property">num</span> ); <span class="comment">// 150</span></span><br><span class="line">a.<span class="title function_">sub</span>(<span class="number">100</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a.<span class="property">num</span> ); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><p>當回傳 this 時，指的是物件本身，可以往後串在一起，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="title function_">add</span>(<span class="number">50</span>).<span class="title function_">sub</span>(<span class="number">100</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a.<span class="property">num</span> ); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure><p>JQuery 中的也是用 method chain (方法鏈) 這樣的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;div&#x27;</span>).<span class="title function_">addClass</span>(<span class="string">&#x27;is-active&#x27;</span>)</span><br><span class="line">        .<span class="title function_">removeClass</span>(<span class="string">&#x27;is-hide&#x27;</span>)</span><br><span class="line">        .<span class="title function_">text</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br></pre></td></tr></table></figure><p>或者 <code>Array</code> 的內建函式<br>是可以串聯不同的方法<br>而且回傳的都是 <strong>同類型</strong> 的陣列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">el</span> =&gt;</span> e*<span class="number">2</span>)</span><br><span class="line">   .<span class="title function_">filter</span>(<span class="function"><span class="params">el</span> =&gt;</span> el &gt;= <span class="number">4</span>) <span class="comment">// [4,6]</span></span><br></pre></td></tr></table></figure><h2 id="總結-21">總結</h2><p>除了轉成 <code>.call()</code> 來判斷 this<br>對於 this 也可以朝幾種方向來判斷</p><ol><li>function 的呼叫，是透過 <code>new</code> 進行的嗎？<br>如果是，那 this 就是被建構出來的物件。</li><li>function 是以 .call() 或 .apply() 的方式呼叫的嗎？ 或是 function 透過 .bind() 指定？<br>如果是，那 this 就是被指定的物件。</li><li>function 被呼叫時，是否存在於某個物件？<br>如果是，那 this 就是那個物件。</li><li>如果沒有滿足以上條件，此 function 裡的 this 就一定是全域物件<br>在嚴格模式下則是 undefined。</li></ol><h2 id="參考-13">參考</h2><ol><li><a href="https://blog.huli.tw/2019/02/23/javascript-what-is-this/">淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂 - Huli</a></li><li><a href="https://zhuanlan.zhihu.com/p/23804247">this 的值到底是什么？一次说清楚</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10193193">重新認識 JavaScript: Day 20 What’s “THIS” in JavaScript (鐵人精華版)</a></li><li><a href="https://zh.javascript.info/object-methods">对象方法，“this”</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-28&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在學習 JavaScript 時很多課程會建議不要急著先用 &lt;code&gt;this&lt;/code&gt;&lt;br&gt;
因為 this 會跑出讓新手無法預期的結果&lt;br&gt;
在某些情況下使用 this 反而更棘手&lt;br&gt;
藉由本次來初步了解這個奇妙的 &lt;strong&gt;this&lt;/strong&gt;!&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - Closure 閉包(II) 常見陷阱題</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-Closure-II"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-Closure-II</id>
    <published>2022-04-13T13:51:51.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-21">前言</h2><p>之前學習閉包沒辦法很容易連結到<br>尤其 Function 有一堆名詞變異體<br>總會好奇實際的應用情境</p><p>那發生什麼問題才會使用到 Closure 呢?<br>又怎麼在真正的專案解決問題 ?</p><span id="more"></span><h2 id="問題-在迴圈中呼叫函式">問題 : 在迴圈中呼叫函式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">  arr[i] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">arr[<span class="number">0</span>]();</span><br><span class="line">arr[<span class="number">1</span>]();</span><br></pre></td></tr></table></figure><p>複習一下 :</p><blockquote><p><code>var</code> 的切分單位是 <code>function</code></p></blockquote><p>直覺來說會覺得 <code>i</code> 是會按順序列出<br>結果是 <code>5 5</code><br>因為 for 設立的 <code>i</code> 會存在 global 中</p><p><strong>試著把運作拆開來</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>當迴圈跑完時， <code>i</code> 是 5，<code>var i  = 5</code><br>因為 5 不符合迴圈條件跳出<br>所以不管 <code>arr[?]()</code>，直接印出 <code>i</code> 是 5</p><h3 id="解決方法">解決方法</h3><h4 id="閉包">閉包</h4><p>把 function 獨立出來</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"> arr[i] = <span class="title function_">logN</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//閉包，記住當下的 i</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logN</span>(<span class="params">num</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]() <span class="comment">//0</span></span><br><span class="line">arr[<span class="number">1</span>]() <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h4 id="IIFE">IIFE</h4><p>IIFE(Immediately Invoked Function Expression) 定義完就回傳的 function</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">//拿到當下的 i</span></span><br><span class="line">  arr[i] = (<span class="keyword">function</span> (<span class="params">num</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]() <span class="comment">//0</span></span><br><span class="line">arr[<span class="number">1</span>]() <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>把原本有名的函式改為匿名函式，用<code>()</code>包裹 function，尾巴是帶入參數<code>(參數)</code>，沒有的話為空</p><h4 id="ES6-的-let">ES6 的 let</h4><p>上面出現的原因都是 <code>var</code> 的 scope 問題<br>ES6 的 let 將作用域限制在 block <code>&#123;&#125;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; arr[i] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">arr[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">arr[<span class="number">1</span>](); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>只要 <code>var -&gt; let</code> ， 就解決問題了，離開之後就不會保留。</p></blockquote><h2 id="Closure-應用">Closure 應用</h2><h3 id="Cache-暫存">Cache 暫存</h3><p>計算量大的時候避免重新計算，預先把已算好的值存起來</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">complex</span>(<span class="params">num</span>)&#123;</span><br><span class="line">  <span class="comment">// 複雜計算</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;calculate&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> num*num*num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cache</span>(<span class="params">func</span>)&#123;</span><br><span class="line">  <span class="comment">// 查看是不是有算過</span></span><br><span class="line">  <span class="keyword">var</span> ans =&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="comment">//有的話回傳索引裡的值</span></span><br><span class="line">    <span class="keyword">if</span>(ans[num])&#123;</span><br><span class="line">      <span class="keyword">return</span> ans[num]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 沒有的話才做重新計算</span></span><br><span class="line">    ans[num] = <span class="title function_">func</span>(num)</span><br><span class="line">    <span class="keyword">return</span> ans[num]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cacheComplex = <span class="title function_">cahe</span>(complex)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cacheComplex</span>(<span class="number">20</span>)) <span class="comment">// 第一次計算</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cacheComplex</span>(<span class="number">20</span>)) <span class="comment">// 從 cache 拿到的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cacheComplex</span>(<span class="number">20</span>)) <span class="comment">// 從 cache 拿到的值</span></span><br></pre></td></tr></table></figure><p>用 <code>console.time</code> 計時執行的時間<br>比起直接用 complex 算再重新算<br>會發現第二次的計算的時間明顯縮短很多</p><h3 id="隱匿資訊">隱匿資訊</h3><p>想隱匿一些資訊，讓別人不可以直接更改。<br>把方法以及變數封裝在內部，別人要調用只能呼叫你規定好的方法。</p><ul><li>以簡易計算機為例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">initNum</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> sum = initNum</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line"> <span class="attr">add</span>:<span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> sum +=num</span><br><span class="line">&#125;,</span><br><span class="line"> <span class="attr">minus</span>:<span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> sum -=num</span><br><span class="line">&#125;,</span><br><span class="line"> <span class="attr">mutiply</span>:<span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> sum *=num</span><br><span class="line">&#125;,</span><br><span class="line"> <span class="attr">divided</span>:<span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> sum/=num</span><br><span class="line">&#125;,</span><br><span class="line"> <span class="attr">getresult</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter1 = <span class="title function_">calculate</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> counter2 = <span class="title function_">calculate</span>(<span class="number">10</span>)</span><br><span class="line">counter1.<span class="title function_">add</span>(<span class="number">5</span>)</span><br><span class="line">counter2.<span class="title function_">mutiply</span>(<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter1.<span class="title function_">getresult</span>()) <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter2.<span class="title function_">getresult</span>()) <span class="comment">// 200</span></span><br></pre></td></tr></table></figure><p>一個簡單的計算機 (?)🤔<br>counter1 跟 counter2 並不會影響到彼此<br>我們只能透過現有的方法來修改 sum 的值</p><h2 id="總結-19">總結</h2><p>閉包讓我感覺是很神奇的東西<br>看起來不熟悉，但實際上我們都用到了🤔</p><h2 id="參考-7">參考</h2><ul><li><a href="https://lidemy.com/courses/enrolled/390599"> [JS201] 進階 JavaScript：那些你一直搞不懂的地方 </a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-21&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;之前學習閉包沒辦法很容易連結到&lt;br&gt;
尤其 Function 有一堆名詞變異體&lt;br&gt;
總會好奇實際的應用情境&lt;/p&gt;
&lt;p&gt;那發生什麼問題才會使用到 Closure 呢?&lt;br&gt;
又怎麼在真正的專案解決問題 ?&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - Closure 閉包(I) 基礎概念</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-Closure-I"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-Closure-I</id>
    <published>2022-04-13T13:51:39.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-19">前言</h2><p>Closure 是 JavaScript 很重要的基礎<br>藉由本篇幫助自己釐清 Closure 的概念</p><span id="more"></span><h2 id="先認識-Scope-Chain">先認識 Scope Chain</h2><p><a href="https://blog.rosa.tw/Frontend/JavaScript/JavaScript-Hoisting-II/?highlight=scope#%E4%BD%9C%E7%94%A8%E5%9F%9F-Scope">Scope</a> 是變數生存的範圍，如果在自己層級找不到就會一層一層往外找，直到 Global 為止。</p><p>這種行為就稱為「<strong>範圍鏈</strong>」(Scope Chain)。</p><blockquote><p>範圍鏈是在函式<strong>被定義的當下決定</strong> (lexical scope 來決定)的，不是在被呼叫的時候決定。</p></blockquote><h3 id="範例">範例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;global&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> a  = <span class="string">&#x27;change&#x27;</span></span><br><span class="line"><span class="title function_">test</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// change</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//global</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">change</span>()</span><br></pre></td></tr></table></figure><p>一開始會以為 <code>test()</code> 在 change 裡面呼叫，取得的變數 a 是 change 對不對 ?</p><p>NO NO NO,再重複一次 !</p><blockquote><p>範圍鏈是在函式<strong>被定義的當下決定</strong> 的，不是在被呼叫的時候決定。</p></blockquote><p><code>test</code> 函式在 Lexical Environments 是 gloabal 的下一層，Scope Chain 是根據 Lexical scope 決定，往上找是 gloabl 那層，所以結果才會是 <code>'global'</code></p><h2 id="為什麼要有-Closure">為什麼要有 Closure ?</h2><blockquote><p>反問 👉 <strong>沒有 Closure 會怎樣 ?</strong></p></blockquote><p>我們知道 Execution Context 執行環境在執行完 function 後，Stack 會抽掉，有關這個 function 的一切變數也會被回收而且不可再使用。</p><ul><li>如果要使用 function 裡的變數呢 ? (<code>private variable</code> 的概念)</li></ul><p>直覺可能會丟到 <code>global</code> 進行宣告，但當專案結構逐漸龐大，久而久之會造成 <strong>全域變數汙染</strong></p><p><strong>那閉包的出現解決了…</strong> :</p><ul><li>自由變數 (free variable)，只有在 function 內部可讀取變數，在外部則無法讀取。</li><li>變數暫存，減少重複的複雜計算</li></ul><h2 id="Closure-的優缺點">Closure 的優缺點</h2><ul><li><p>優點 :</p><ol><li>避免 <strong>全域變數汙染</strong></li><li>提供 <strong>自由變數</strong>，讓該 function 執行完後，變數的作用域不會因 function 結束被回收，而是會繼續存在。</li><li>避免重複執行龐大的計算<br>可以記錄前一次計算的狀態，下一次再呼叫不用重算一次 (cache 的概念)。</li><li>在多人協作的時候，有些隱密的資訊不想讓人去修改，可以使用封裝閉包的方式。<br>別人必須依照固定的寫法來取得資料，且不能修改到內部的資訊。<br>在開源資料或 API 的方法常使用這樣的方式，以免改動到內部數值。</li></ol></li><li><p>缺點 :</p><ol><li>可能保留到一些不必要的變數或資訊，造成資源多餘消耗。</li><li>只能使用涵式提供的方法，因為內部的資訊被隱蔽，在更動上較不彈性。<br>(但是相反如果不想要被改動會是優點)</li></ol></li></ul><h2 id="什麼是閉包">什麼是閉包 ?</h2><p>除了自己本身的程式碼外，也可以取得了<strong>內部函式「當時環境」的變數值</strong>，記住了執行當時的環境，這就是「閉包」。</p><h2 id="簡單的-Closure-範例">簡單的 Closure 範例</h2><ul><li>沒有使用閉包</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rate = <span class="number">.75</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">itmePrice</span>(<span class="params">price</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> price &gt;= <span class="number">100</span> ? price*rate : price</span><br><span class="line">&#125;</span><br><span class="line">rate = <span class="number">.1</span> </span><br><span class="line"><span class="keyword">let</span> bag = <span class="title function_">itmePrice</span>(<span class="number">150</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bag)</span><br></pre></td></tr></table></figure><blockquote><p>可以透過直接修改數值 (👎)<br>任何人都可以在外部進行修改</p></blockquote><ul><li>使用閉包</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">itmePrice</span>(<span class="params">price</span>)&#123;</span><br><span class="line"><span class="comment">// 把 rate 變成私有變數</span></span><br><span class="line"><span class="keyword">var</span> rate = <span class="number">.75</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> price &gt;= <span class="number">100</span> ? price*rate : price</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bag = <span class="title function_">itmePrice</span>(<span class="number">150</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bag</span>())</span><br></pre></td></tr></table></figure><blockquote><p>只要呼叫需要的東西即可 (👍)<br>不會被外部修改</p></blockquote><h2 id="參考-4">參考</h2><ol><li><a href="https://blog.huli.tw/2018/12/08/javascript-closure/">所有的函式都是閉包：談 JS 中的作用域與 Closure - Huli</a></li><li><a href="https://javascript.info/closure#lexical-environment">Variable scope, closure</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10193009">重新認識 JavaScript: Day 19 閉包 Closure</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-19&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Closure 是 JavaScript 很重要的基礎&lt;br&gt;
藉由本篇幫助自己釐清 Closure 的概念&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - 事件機制原理 &amp; 事件代理</title>
    <link href="https://blog.rosa.tw/2022/04/04/JavaScript-EventFlow-EventListener"/>
    <id>https://blog.rosa.tw/2022/04/04/JavaScript-EventFlow-EventListener</id>
    <published>2022-04-12T02:24:14.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-20">前言</h2><p>事件是什麼 ? 為什麼要用事件代理呢 ?<br>在不了解事件的流程與運作機制，是不是遇過點一下元素<br>結果跑出兩次以上的結果<br>透過本篇幫自己釐清事件各種大小事</p><span id="more"></span>  <h2 id="EventFlow-網頁元素接收事件的順序">EventFlow : 網頁元素接收事件的順序</h2><p><img data-src="https://dsm01pap006files.storage.live.com/y4m9V74R0Rbxh2VocqOo5K1vnxJNiyqAL1pr2Vw2o2yxenGxG5Uq3iMSm5n1bXDNs7hubkxY7rtnZfQtgz3tSNPDcX22k_WWBKKto5w_fnALPe1MSGDNDjlF11Yr7svwp8O0b8PmsLyMikVMa0Be3EWrsugI0ZsfWzkq9aYgX7R48Jm2YL0dJs6VWHvl3tqxowk?width=1208&amp;height=1160&amp;cropmode=none" alt="EventFlow"></p><ul><li><code>Capture phase</code> : 捕獲階段指由 <strong>上到下</strong> 傳下去的</li><li><code>Target phase</code> : 目標階段，本身被作用的目標才會在這個階段</li><li><code>Bubbling phase</code> : 冒泡階段 指由 <strong>下往上</strong> 傳去的</li></ul><p>透過 <code>e.eventPhase</code> 可以看見事件的階段<br>當我點下 link</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;link capturing&#x27;</span>,e.<span class="property">eventPhase</span>);</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;link bubbling&#x27;</span>,e.<span class="property">eventPhase</span>);</span><br><span class="line">&#125;)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box capturing&#x27;</span>,e.<span class="property">eventPhase</span>);</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box bubbling&#x27;</span>,e.<span class="property">eventPhase</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">box capturing <span class="number">1</span>  <span class="comment">// CAPTURING_PHASE</span></span><br><span class="line">link capturing <span class="number">2</span> <span class="comment">// AT_TARGET </span></span><br><span class="line">link bubbling <span class="number">2</span> <span class="comment">// AT_TARGET </span></span><br><span class="line">box bubbling <span class="number">3</span> <span class="comment">// BUBBLING_PHASE</span></span><br></pre></td></tr></table></figure><p>出現的代碼就是事件的不同階段</p><h3 id="事件冒泡-Event-Bubbling">事件冒泡 (Event Bubbling)</h3><p>啟動事件的元素往上傳遞到 <strong>根節點</strong> (document)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>TITLE<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>CLICK<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>冒泡傳遞方向 :<br>CLICK 事件本身元素 👉 body 👉 html 👉 document</p><h3 id="事件捕獲-Event-Capturing">事件捕獲 (Event Capturing)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>TITLE<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>CLICK<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>捕獲傳遞方向 :<br>document 👉html 👉 body 👉CLICK 事件本身元素</p><h3 id="事件是哪種機制">事件是哪種機制 ?</h3><p>兩種都會，當我按下按鈕，如果外層元素也有綁定 <strong>事件</strong>，同時也會被觸發</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.outer&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.inner&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>結果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">hi <span class="comment">// 冒泡而觸發</span></span><br></pre></td></tr></table></figure><p>點擊 <code>inner</code> 時，同時出現 hello 跟 hi<br>因為冒泡的關係，outer 也被觸發。</p><h3 id="事件的捕獲-冒泡順序">事件的捕獲 &amp; 冒泡順序 ?</h3><ul><li>對於 <strong>非觸發事件</strong> 本身的元素</li></ul><blockquote><p>先捕獲後冒泡</p></blockquote><ul><li>事件本身<br>在以往的文章中都是 <strong>按照程式碼執行的順序</strong><br>當我試著執行後卻發現即使把冒泡放在前面，捕獲放後<br>一樣都是 <strong>先捕獲再冒泡</strong><br>仔細一查，才發現原來是 Chorme 89 以後的版本都會先捕獲再冒泡<br>89 之前的版本就會是看程式碼執行的順序<blockquote><p>出現這樣的狀況是因為 shadow DOM 引起的，詳細原因請參考 <a href="https://juejin.cn/post/6965682915141386254#heading-2">這篇</a></p></blockquote></li></ul><p>所以，新版的瀏覽器不管是哪個都是 <strong>先捕獲再冒泡</strong></p><h2 id="事件的註冊綁定">事件的註冊綁定</h2><ol><li><code>on-event</code> : 有 HTML 中 inline on-event；JS on-event 接 function</li><li><code>EventListener</code> : addEventListener、removeEventListener…等</li></ol><h3 id="on-event">on-event</h3><ol><li>Html <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> </span></span><br><span class="line"><span class="tag"><span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;click&#x27;)&quot;</span>&gt;</span>click </span><br><span class="line">me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>目前很少這樣寫，其一原因是不好維護</li><li>非 Html <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>)</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>我們最常看見 <code>window.onload</code> 也是事件的 on-event</p><h3 id="EventListener">EventListener</h3><h4 id="addEventListener">addEventListener</h4><p>有三個參數</p><ol><li>事件名稱</li><li>事件處理器 (觸發時執行的 function)</li><li>Boolen ，以 「捕獲」 或「冒泡」 機制執行， <code>false</code> (不指定) 為 冒泡</li></ol><blockquote><p>第三個布林值，不是改變事件傳遞的方式，而是在 <strong>哪裡進行監聽</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HI&#x27;</span>); &#125;);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HI&#x27;</span>); &#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 捕獲 </span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HELLO&#x27;</span>); &#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="removeListener">removeListener</h4><p>跟 addEventListener 一樣，如果要解除的話 handler 的 function 必須是同一個實體才行</p><blockquote><p><strong>為什麼說是同一實體 ?</strong><br>回想這個例子 <code>&#123;&#125; === &#123;&#125; // false</code><br>function 也是 Object 的一種<br>匿名函式沒有指定給變數時，都是屬於不同的記憶體位址</p></blockquote><p>事件監聽使用匿名函式的寫法，就像潑出去的水，回不來了 🤔</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HI&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件，但是沒用</span></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HI&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>解決此問題，把 handler 的 function <strong>獨立出來</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> clickhandler = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HI&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,clickhandler&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 移除事件，ok!</span></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>,clickhandler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="on-event-v-s-EventListener">on-event v.s EventListener</h3><ul><li><p><code>EventListener</code> : 可以重複指定多個「處理器」(handler) 給同一個元素的同一個事件</p></li><li><p><code>on-event</code> : 只認一個，後面多寫的會覆蓋前面的事件</p></li><li><p>on-event</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi!&#x27;</span>) <span class="comment">// 不會出現</span></span><br><span class="line">&#125;;</span><br><span class="line">btn.<span class="property">onclick</span>= <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello!&#x27;</span>) <span class="comment">// 會出現 hello</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li>EventListener</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi!&#x27;</span>) <span class="comment">// 出現 hi</span></span><br><span class="line">&#125;&#125;);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello!&#x27;</span>) <span class="comment">// 再出現 hello</span></span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="EventHandler-中的-“event”">EventHandler 中的 “event”</h2><p>事件物件會依照 <strong>觸發的事件</strong>(click、change) ，內容會有稍微不同<br>通常看到 <code>event</code> 寫成 <code>e</code> 、<code>evt</code> 是為了方便，也可以自訂譯名稱<br>只是大家會選擇有意義的名稱且好記</p><p>可以試著在事件觸發印出 <code>e</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">常見的屬性   </span></span><br><span class="line"><span class="string">-   `</span>type<span class="string">` : 表示事件的名稱</span></span><br><span class="line"><span class="string">-   `</span>target<span class="string">` : 表示觸發事件的元素</span></span><br><span class="line"><span class="string">-   `</span>bubbles<span class="string">` : 表示這事件是否是在「冒泡」階段觸發 (`</span><span class="literal">true</span><span class="string">` / `</span><span class="literal">false</span><span class="string">`)</span></span><br><span class="line"><span class="string">-   `</span>pageX<span class="string">` / `</span>pageY<span class="string">` : 表示事件觸發時，滑鼠座標在網頁的相對位置  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 阻擋預設行為 event.preventDefault()</span></span><br><span class="line"><span class="string">&gt;並不會阻止事件向上傳遞 (事件冒泡) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.link&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"></span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box&#x27;</span>) <span class="comment">// 依然會出現</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>on-event</code> 在 eventhandler function 的<strong>最後</strong>加上 <code>return false;</code> 也會有 <code>event.preventDefault()</code> 的效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.link&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等於 e.preventDefault()</span></span><br><span class="line">link.<span class="property">onclick</span>=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="應用範例一-表單-submit-前的檢查">應用範例一 : 表單 submit 前的檢查</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        帳號</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        密碼</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用者按下 submit 按鈕會送出表單<br>前端可以先做驗證，確認使用者的輸入是不是符合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;form&quot;</span>)</span><br><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&#x27;submit&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="comment">//先阻止送出</span></span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;[name=&#x27;username&#x27;]&quot;</span>).<span class="property">value</span></span><br><span class="line">    <span class="keyword">let</span> password = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;[name=&#x27;password&#x27;]&quot;</span>).<span class="property">value</span></span><br><span class="line">    <span class="comment">// 檢查欄位</span></span><br><span class="line">    <span class="keyword">if</span>(!username) <span class="keyword">return</span> <span class="title function_">alert</span>(<span class="string">&#x27;請輸入使用者帳號&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(!password) <span class="keyword">return</span> <span class="title function_">alert</span>(<span class="string">&#x27;請輸入密碼&#x27;</span>)</span><br><span class="line">    <span class="comment">// 都有輸入就送出</span></span><br><span class="line">    form.<span class="title function_">submit</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="應用範例二-避免超連結造成網頁跳轉">應用範例二 : 避免超連結造成網頁跳轉</h4><p>按下 <code>a</code> 的時候會找網頁的錨點，如果沒有的話會跳 <code>#</code> 井字號<br>如果不想要出現井字號呢 ?<br>有些是對外連結，有些是內連結使用，總不能阻擋每個吧 !</p><p>這邊用我使用 <code>class</code> 分開外部連結</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;www.example.com&quot;</span>&gt;</span>我是普通超連結<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>gotoTop<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 選沒有 link class 的 a 標籤</span></span><br><span class="line"><span class="keyword">let</span> actionLink = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;a:not(.link)&#x27;</span>)</span><br><span class="line">actionLink.<span class="title function_">forEach</span>( <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    a.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">        e.<span class="title function_">preventDefault</span>();</span><br><span class="line">        <span class="comment">// 判斷各個 actionLink 要做的事</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>這樣就可以分出哪些是外部連結，哪些是內網頁連結，而且不會出現 <code>#</code> 井字號 😃</p><h3 id="阻擋事件冒泡傳遞-event-stopPropagation">阻擋事件冒泡傳遞 event.stopPropagation()</h3><blockquote><p>阻止的動作，加在冒泡發生的元素上</p></blockquote><p>如果不要讓 box 出現，加在想停止冒泡的地方 <code>event.stopPropagation()</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.link&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這裡會發生冒泡，要阻止上傳</span></span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box&#x27;</span>) <span class="comment">// 不會出現</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可以試著註解 <code>e.stopPropagation();</code> 會發現當你按下 link<br>因為 link 冒泡機制導致 box 的事件也觸發而印出 <code>'box'</code></p><h4 id="阻止任何的傳遞-event-stopImmediatePropagation">阻止任何的傳遞 event.stopImmediatePropagation()</h4><p>如果同一個元素有掛兩個 <code>addEventListener</code><br>點擊時兩個都會在 <code>Target phase</code><br>A 跟 B 事件一樣會觸發<br>在 A 加入 <code>stopImmediatePropagation()</code> 會把 B 停掉</p><p>以上面的例子來說，link 掛兩個事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A 事件</span></span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i am A&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// B 事件</span></span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i am B&#x27;</span>) <span class="comment">//不會出現，在 A target pharse 阻止 B 冒泡階段發生</span></span><br><span class="line">&#125;)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box&#x27;</span>) <span class="comment">// 不會出現，因為阻止了冒泡</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="應用範例-label-input">應用範例 : label &amp; input</h4><p>label 跟 input 的組合需要多一個 id<br>為了不浪費 id，我們常常會用 label 把 input 包起來。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>/&gt;</span></span><br><span class="line">開關</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>label</code> 綁上監聽事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> labelone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line"></span><br><span class="line">labelone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>神奇的是，hi 會出現兩次<br>checkbox 也會接收到 click 事件，改變了狀態<br>發生冒泡到 label 元素，再次觸發 label 的事件</p><p><strong>重點複習</strong></p><blockquote><p><strong>阻止的動作，加在冒泡發生的元素上</strong></p></blockquote><p>冒泡發生的是 <strong>input</strong> ，所以 <code>stopPropagation</code> 是要加在 input 而非 label</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> labelone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> inputone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"></span><br><span class="line">labelone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">inputone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="事件-“本身”-指的是-target-v-s-currentTarget-this">事件 “本身” 指的是 ? target v.s currentTarget (this)</h3><p>我們知道在 function 當中是可以使用 <code>this</code><br>那這邊的 <code>this</code> 是指什麼呢 ?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> labelone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line"></span><br><span class="line">labelone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tagName</span>) <span class="comment">// LABEL</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><code>this</code> 代表的會是「觸發事件的<strong>目標</strong>」元素<br>也就是 <code>event.currentTarget</code> 而不是 <code>e.target</code>。</p></blockquote><p>那 <code>e.target</code> 指的是 ?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> labelone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line">labelone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">tagName</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tagName</span>, <span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> inputone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">inputone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">tagName</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tagName</span>, <span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>點擊 label</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;LABEL&quot;</span> <span class="number">1</span> <span class="comment">// e.target</span></span><br><span class="line"><span class="string">&quot;LABEL&quot;</span> <span class="number">1</span> <span class="comment">// this</span></span><br><span class="line"><span class="string">&quot;INPUT&quot;</span> <span class="number">2</span> <span class="comment">// e.target</span></span><br><span class="line"><span class="string">&quot;INPUT&quot;</span> <span class="number">2</span> <span class="comment">// this</span></span><br><span class="line"><span class="string">&quot;INPUT&quot;</span> <span class="number">1</span> <span class="comment">// checkbox 冒泡上來的而觸發 labelone，e.target</span></span><br><span class="line"><span class="string">&quot;LABEL&quot;</span> <span class="number">1</span> <span class="comment">// checkbox 冒泡上來的而觸發 labelone， this</span></span><br></pre></td></tr></table></figure><blockquote><p><code>e.target</code> 其實是「觸發事件的元素」</p></blockquote><p>如果不考慮事件傳遞的情況下，<code>this</code> 實質上就等同於 <code>e.target</code> 了。</p><h2 id="事件指派-Event-Delegation">事件指派 (Event Delegation)</h2><p>用 JavaScript 新增的元素並不會綁到事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.list&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> items = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.list-item&#x27;</span>);</span><br><span class="line"><span class="comment">// 一個個手動加入</span></span><br><span class="line">items.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">textContent</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newItem = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;LI&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> txt = <span class="variable language_">document</span>.<span class="title function_">creatTextNode</span>(<span class="string">&#x27;new&#x27;</span>);</span><br><span class="line">newIten.<span class="title function_">appendChild</span>(txt)</span><br><span class="line">list.<span class="title function_">appendChild</span>(newItem)</span><br></pre></td></tr></table></figure><p><code>newItem</code> 不會有 click 事件<br>為避免每次新增要重新綁定事件，又要移除監聽，造成 memory leak 的嚴重問題<br><strong>事件指派</strong> 是比較好的做法。</p><p><strong>事件代理人</strong> 透過判斷 <strong>目標節點</strong>，再執行動作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.list&#x27;</span>);</span><br><span class="line"><span class="comment">// list 直接看底下的子元素</span></span><br><span class="line">list.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(e.<span class="property">target</span>.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>()===<span class="string">&#x27;li&#x27;</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">textContent</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newItem = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;LI&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> txt = <span class="variable language_">document</span>.<span class="title function_">creatTextNode</span>(<span class="string">&#x27;new&#x27;</span>);</span><br><span class="line"></span><br><span class="line">newIten.<span class="title function_">appendChild</span>(txt)</span><br><span class="line">list.<span class="title function_">appendChild</span>(newItem)</span><br></pre></td></tr></table></figure><p>搭拉 ! <code>newItem</code> 就有點擊的效果</p><h2 id="總結-18">總結</h2><p>事件是 JavaScript 的基本，當我們了解機制的運作<br>遇到奇怪的觸發多次時，記得想起事件的流程</p><blockquote><p>先捕獲再冒泡</p></blockquote><p>還有相關的</p><ul><li>阻止預設行為 <code>preventDefault</code></li><li>阻擋冒泡行為 <code>stopPropagtion</code></li></ul><h2 id="參考-6">參考</h2><ol><li><a href="https://ithelp.ithome.com.tw/articles/10191970">重新認識 JavaScript: Day 14 事件機制的原理</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10192015">重新認識 JavaScript: Day 15 隱藏在 “事件” 之中的秘密</a></li><li><a href="https://blog.techbridge.cc/2017/07/15/javascript-event-propagation/">DOM 的事件傳遞機制：捕獲與冒泡</a></li><li><a href="https://juejin.cn/post/6965682915141386254#heading-2">Chrome 89 更新事件触发顺序，导致99%的文章都错了（包括MDN）</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-20&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;事件是什麼 ? 為什麼要用事件代理呢 ?&lt;br&gt;
在不了解事件的流程與運作機制，是不是遇過點一下元素&lt;br&gt;
結果跑出兩次以上的結果&lt;br&gt;
透過本篇幫自己釐清事件各種大小事&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSSZeroToOneSeries  | 10 | 破格式設計</title>
    <link href="https://blog.rosa.tw/2022/04/04/CSSSeriesZeroToOne-10"/>
    <id>https://blog.rosa.tw/2022/04/04/CSSSeriesZeroToOne-10</id>
    <published>2022-04-10T04:36:53.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本篇成果-14">本篇成果</h2><p><a href="https://codepen.io/shan473/pen/QWOZgzP">Codepen</a><br><img data-src="https://dsm01pap006files.storage.live.com/y4mc1SNrsZu-Jd9u35WNRJfQgL79lh5rKUE-T708KZoUgmfj1e0iFbqwtXItGPmNayXFew5OcaISpno8uR1h5a0KOuWpfs9NvwytLMedU4ijzl-h2mJT3AKapQU7kA5rNBSPp_QOV-6viFwczOvlSgU65TDbCQlby6ccQSZ4Rvcith2HND8fQOqhBUHkD3FrJAo?width=1024&amp;height=586&amp;cropmode=none" alt="破格式設計"></p><span id="more"></span><h3 id="margin-值的數量">margin 值的數量</h3><ul><li>兩個數值<br>margin : &lt;上下&gt;  &lt;左右&gt;</li><li>四個數值<br>margin : &lt;上&gt; &lt;右&gt; &lt;下&gt; &lt;左&gt;</li><li>三個數值<br>margin : &lt;上&gt; &lt;左右&gt; &lt;下&gt;</li></ul><p>比較常用到置中 <code>margin : 0 auto</code>，auto 是把剩餘的空間分配給左右，因此才會置中。<br>實際上 margin : auto ，雖然是寫全部自動分配，但是 <a href="https://www.zhihu.com/question/21644198">上下並沒有作用</a>。</p><p>css 的預設 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode">write-mode (書寫模式)</a> 的方向是 <strong>水平</strong> 的，當我們用 margin-top : auto 或 margin-bottom : auto ，因為高度並無固定值，無法參照，剩餘空間也是 0 。</p><h3 id="line-height-單行垂直居中">line-height 單行垂直居中</h3><p>如果是文字單行居中容器，可以把 <code>line-height</code> 設定跟容器高一樣</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="border-區塊位置計算-要記得扣掉">border 區塊位置計算 : 要記得扣掉</h3><p>實作是 icon 的利用 <code>:before</code> 的 border 做圓框，粗度是 10 px。<br><code>top : 0、left : 0</code>，把版面定位到父層起始左上角一樣，此時 border 粗度上下左右都會增長 10px，如果要置中，必須把 border 多出來的在 top、left 扣掉，元素才能擺到中間填滿。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.icon</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">position</span> : absolute;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line"><span class="attribute">top</span>: -<span class="number">10px</span>;</span><br><span class="line"><span class="attribute">left</span>: -<span class="number">10px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">width</span> : <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="border-上下左右的呈現方式">border 上下左右的呈現方式</h3><p>以半圓框為例，我們知道 border 的切齊點是對角線 (下圖)，變成圓形的話，上下左右並不是剛好從 0 切齊到 90 度<br>如果想要得到半圓，必須是鄰近兩個 border 再做旋轉 45 度。</p><ul><li>width、height 為 0 ，單純的 border</li></ul><p><img data-src="https://dsm01pap006files.storage.live.com/y4mVu7eeg2awMupFoD5T_nq55dVmzodISxqWR8paqvV46NhzCf4-VPLWZ0Xlm_JLUFsOCEGTcqVb6SoH4icdXFX9V3ZLR39nFB5YYYyNr-ENP529_4MNud_lE-ksXUdUOblMf7y8cah3KcaOjNIgJr_9l8o-fXeE4FZotOCa1CSDMl5pHcz4tP-0UtZeuurM5DG?width=496&amp;height=488&amp;cropmode=none" alt="純 border 圓形"></p><blockquote><p>正確的半圓是相鄰兩邊的 border 組合出來的<br>像是 <a href="../CSSSeriesZeroToOne-03/#%E8%A3%9C%E5%85%85-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E9%99%B0%E5%BD%B1">03 篇</a>能出現陰影的三角形一樣的概念</p></blockquote><h3 id="子層物件整體高度超出父層-padding-擠回去">子層物件整體高度超出父層 : padding 擠回去</h3><p>因為 icon margin-top 是 -75 px，比原本父層凸出 75 px ，必須在整體的 padding 把多的補回去，把子容器的元素都包含在內。</p><h2 id="參考-5">參考</h2><ol><li><a href="https://www.zhihu.com/question/21644198">为什么「margin:auto」可以让块级元素水平居中？</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;本篇成果-14&quot;&gt;本篇成果&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/shan473/pen/QWOZgzP&quot;&gt;Codepen&lt;/a&gt;&lt;br&gt;
&lt;img src=&quot;https://dsm01pap006files.storage.live.com/y4mc1SNrsZu-Jd9u35WNRJfQgL79lh5rKUE-T708KZoUgmfj1e0iFbqwtXItGPmNayXFew5OcaISpno8uR1h5a0KOuWpfs9NvwytLMedU4ijzl-h2mJT3AKapQU7kA5rNBSPp_QOV-6viFwczOvlSgU65TDbCQlby6ccQSZ4Rvcith2HND8fQOqhBUHkD3FrJAo?width=1024&amp;amp;height=586&amp;amp;cropmode=none&quot; alt=&quot;破格式設計&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="CSS" scheme="https://blog.rosa.tw/tags/CSS/"/>
    
    <category term="CSSZeroToOneSeries" scheme="https://blog.rosa.tw/tags/CSSZeroToOneSeries/"/>
    
  </entry>
  
  <entry>
    <title>CSSZeroToOneSeries | 09 | 方塊酥版</title>
    <link href="https://blog.rosa.tw/2022/04/04/CSSSeriesZeroToOne-09"/>
    <id>https://blog.rosa.tw/2022/04/04/CSSSeriesZeroToOne-09</id>
    <published>2022-04-10T04:36:49.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本篇成果-13">本篇成果</h2><p><a href="https://codepen.io/shan473/pen/wvPYowG?editors=0100">Codepen</a><br><img data-src="https://dsm01pap006files.storage.live.com/y4mRHJR5nKjd7Mry0fH-Eevw_EuUBALAe_xSDwFAsLc-jhOf9MVukfDscCyR0aOVgn_lXXMo0TTA9P005lZ17bfeeA1u1cH1pUKDVEDHN8e9zgJptSKT1iav8eWY0i6YhYCS8uM0UuTvFQpSWlDK4sLzuIjHGVDA8aLixITKrKveAHX73wjxjTY1VgK64Xx19fM?width=1024&amp;height=585&amp;cropmode=none" alt="方塊酥版"></p><span id="more"></span><h3 id="float-2">float</h3><p>子層設定 float 的時候，會脫離原本的排版序，會導致父層的高度錯誤或抓不到，就要清除浮動 (clearfix)，以免後面的元素不照順序擠上來。</p><h4 id="清除浮動-overflow">清除浮動 : overflow</h4><blockquote><p>父層消除 float</p></blockquote><p>父層 <code>overflow:hidden</code> ，讓父層可以抓到子層的高度。<br>overflow 是處理多餘的內容，hidden 隱藏起來</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>左邊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>右邊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我要在下面<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>:hidden;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fa0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">80%</span>;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:right</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清除浮動-多一個-clearfix-元素">清除浮動 : 多一個 clearfix 元素</h4><blockquote><p>重點在於子元素，如果下一個想要按照自己的流向排，可以在前面加上 <code>clearfix</code> 斬斷 float 的排版</p></blockquote><p>在想要正常排版在子元素屁股後面，設定 <code>clear : both</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>float 左邊<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>float 右邊<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clearfix&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>按照老方法往下排<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line"> <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line"> <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line"><span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按下開關可以看有無 float 的效果</p><iframe height="300" style="width: 100%;" scrolling="no" title="float clearfix" src="https://codepen.io/shan473/embed/NWwObjj?default-tab=result&theme-id=dark" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shan473/pen/NWwObjj">  float clearfix</a> by YanShanHong (<a href="https://codepen.io/shan473">@shan473</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><h4 id="清除浮動-父層-after">清除浮動 : 父層 :after</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>左邊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>右邊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我要在下面<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>:hidden;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fa0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &gt;<span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line"><span class="attribute">content</span> :<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="attribute">display</span>:block;</span><br><span class="line"><span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>偽元素一定要設定 <code>block</code>，讓寬度撐開</p></blockquote><h3 id="波浪號選擇器">~ 波浪號選擇器</h3><p>波浪號是兄弟選擇器，在同一層的後面兄弟都選起來</p><p>常用 <strong>第一個  ~  到底的元素</strong> 都選起來，<a href="../CSSSeriesZeroToOne-08.md">08 篇</a> 的麵包屑除了 <code>(p + p)</code>，波浪號也可以使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>no.1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>no.2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>no.3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>no.4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child ~<span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一種是想選到同一層的某個東西(們)，除了直接選取外，也可以透過 波浪號</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是 span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是 span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>我是連結<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>我是連結<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是 span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>~<span class="selector-tag">a</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="not-排擠你">:not : 排擠你</h3><p>屬於逆向思考，如果要選取除了第一個以外的其他方框，除了用波浪號</p><ul><li>一般波浪號排擠</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>波浪號式排擠<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>一號走開<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>一號走開<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>一號走開<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>~<span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>:not</code> : 排擠，麻瓜翻譯機，要選到 <strong>非第一個的 p</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:first</span>-child)&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="試著用-Grid">試著用 Grid</h2><p>同樣的架構，把 float 去除，利用軌道線進行排版。<br><a href="https://codepen.io/shan473/pen/ZEvRByL?editors=0100">Codepen</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>:grid;</span><br><span class="line">  <span class="attribute">grid-template</span>: <span class="built_in">repeat</span>(<span class="number">3</span>,<span class="number">1</span>fr) / <span class="built_in">repeat</span>(<span class="number">4</span>,<span class="number">1</span>fr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:first</span>-child&#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: <span class="number">1</span> / <span class="number">1</span> / <span class="number">3</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="參考-3">參考</h2><ol><li><a href="https://medium.com/ui-ux%E7%B7%B4%E5%8A%9F%E5%9D%8A/%E8%A7%A3%E9%99%A4-float-%E5%B1%AC%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95-5e29cc30777d">解除 float 屬性的方法. 使用 float 屬性一定要清除浮動，否則會有版面錯置或失去高度的情況</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;本篇成果-13&quot;&gt;本篇成果&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/shan473/pen/wvPYowG?editors=0100&quot;&gt;Codepen&lt;/a&gt;&lt;br&gt;
&lt;img src=&quot;https://dsm01pap006files.storage.live.com/y4mRHJR5nKjd7Mry0fH-Eevw_EuUBALAe_xSDwFAsLc-jhOf9MVukfDscCyR0aOVgn_lXXMo0TTA9P005lZ17bfeeA1u1cH1pUKDVEDHN8e9zgJptSKT1iav8eWY0i6YhYCS8uM0UuTvFQpSWlDK4sLzuIjHGVDA8aLixITKrKveAHX73wjxjTY1VgK64Xx19fM?width=1024&amp;amp;height=585&amp;amp;cropmode=none&quot; alt=&quot;方塊酥版&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="CSS" scheme="https://blog.rosa.tw/tags/CSS/"/>
    
    <category term="CSSZeroToOneSeries" scheme="https://blog.rosa.tw/tags/CSSZeroToOneSeries/"/>
    
  </entry>
  
  <entry>
    <title>CSSZeroToOneSeries | 08 | 網站麵包屑</title>
    <link href="https://blog.rosa.tw/2022/04/04/CSSSeriesZeroToOne-08"/>
    <id>https://blog.rosa.tw/2022/04/04/CSSSeriesZeroToOne-08</id>
    <published>2022-04-10T04:36:38.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本篇成果-12">本篇成果</h2><p><a href="https://codepen.io/shan473/pen/MWOqRoJ">Codepen</a><br><img data-src="https://dsm01pap006files.storage.live.com/y4m2Ut7v52DvB4HXKmhJiPfdh0fC0SYoIg5T6XnWySFOIDNRpNgeG6BkVMmRRZ1qoFlUYVdtq9et8hdrrwbuKF_IqtJFFUTFY2ZI0HDP4tw4ma1Jx9JaMbE6WmvD7YYOv32FJlbpmUwIGLUMzWi1CyKgXyGm598Nl1TZPipEnVfdXC5t8p5GdEi7KevsBdw7Zou?width=1024&amp;height=585&amp;cropmode=none" alt="麵包屑"></p><span id="more"></span><h2 id="before-偽元素">::before 偽元素</h2><p><code>::before</code> 或是 <code>:before</code> 寫法都可以<br>利用 <code>content</code> 內容產生的箭頭，可以隨時替換<br>箭頭也屬裝飾性，不用再特別寫 html tag</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.breadcrumb</span> <span class="selector-tag">li</span> + <span class="selector-tag">li</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line"><span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>content 覺得圖案太少，也可以利用網頁編碼 UTF-8 的特殊字元來顯示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.breadcrumb</span> <span class="selector-tag">li</span> + <span class="selector-tag">li</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;\003E&#x27;</span>;</span><br><span class="line"><span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這兩者是一樣的，但前提是要在 html 加入 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code> 設定編碼<br>參考 : <a href="https://www.toptal.com/designers/htmlarrows/">快速編碼箭頭</a></p><h2 id="再深入偽元素">再深入偽元素</h2><h3 id="偽元素出現的位置">偽元素出現的位置 ?</h3><p>偽元素需要經過瀏覽器的運算跟渲染之後才會出現，所以 <strong>檢視原始碼</strong> 是看不到的</p><h3 id="content">content</h3><p>偽元素一定要有 <code>content</code> ，不然就不會出現了<br>其中 content 包含各式各樣的屬性</p><ol><li>none</li><li>normal</li><li><code>string</code></li><li>url</li><li><code>counter</code></li><li><code>attr</code></li><li>open-quote</li><li>close-quote</li><li>no-open-quote</li><li>no-close-quote</li></ol><p>這邊舉例常見的幾個樣式</p><h3 id="string">string</h3><p>一般的文字或是空內容，拿來裝飾元素<br>像本篇的箭頭就是 string</p><h3 id="counter-讓-css-數數">counter : 讓 css 數數</h3><p>在父層新建一個 reset 計時器<br><code>counter-reset : &lt;計時器名稱&gt; &lt;起始值&gt;</code>，如果沒有寫起始值是從 0 開始</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">counter-reset</span>: Section <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其實也可以多層</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">counter-reset</span>: Section <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span>&#123;</span><br><span class="line">  <span class="attribute">counter-reset</span>: P <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;Section&#x27;</span> <span class="built_in">counter</span>(Section)<span class="string">&#x27; .&#x27;</span>;</span><br><span class="line"><span class="attribute">counter-increment</span>: Section <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;P&#x27;</span> <span class="built_in">counter</span>(Section)<span class="string">&#x27;-&#x27;</span><span class="built_in">counter</span>(P)<span class="string">&#x27; .&#x27;</span>;</span><br><span class="line"><span class="attribute">counter-increment</span>: P <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子層的偽元素可以使用 counter 進行計數</p><ul><li>content : counter(<code>&lt;計數器名稱&gt;</code>)</li><li>counter-increment : <code>&lt;計數器名稱&gt; &lt;要增加的數字&gt;</code> 也可以是負數</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">counter-reset</span>: Title;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;Title &#x27;</span><span class="built_in">counter</span>(Title)<span class="string">&#x27; .&#x27;</span>;</span><br><span class="line">  <span class="attribute">counter-increment</span>: Title <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="attr">attr</h3><p>可以拿到 <code>data-</code> 屬性的值，如果跟資料有關的不要放在偽元素，瀏覽器在解析時是讀取不到的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">data-title</span>=<span class="string">&quot;商店&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">data-title</span>=<span class="string">&quot;品項&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">data-title</span>=<span class="string">&quot;貨物&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(data-title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe height="300" style="width: 100%;" scrolling="no" title="css counter" src="https://codepen.io/shan473/embed/podGNON?default-tab=result&theme-id=dark" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shan473/pen/podGNON">  css counter</a> by YanShanHong (<a href="https://codepen.io/shan473">@shan473</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><h3 id="url-沒作用的圖片">url 沒作用的圖片</h3><p>content 中的 <a href="http://csscoke.com/2013/09/22/%E4%BD%BF%E7%94%A8before-%E8%88%87-after%E4%BE%86%E8%A3%BD%E4%BD%9C%E5%8F%AF%E5%88%97%E5%8D%B0%E7%9A%84logo%E5%9C%96%E7%89%87/">url 圖片雖然能被列印出來</a>，但不能調整寬高尺寸，只能利用 scale 來縮放。</p><p>根據 <a href="https://segmentfault.com/q/1010000004569689">這篇文</a>，偽元素預設是 inline 的一種，就算調成 block，因為 content 並不是實際計算範圍，block 算的是匿名元素的 <code>width</code> 跟 <code>height</code></p><p>真的想放圖片可以使用 background-imge，再透過 background-size 調整大小，但是就不能被影印</p><h3 id="注意">注意</h3><p>為了 SEO 著想，偽元素出現在裝飾性上就好，資訊類就不建議了</p><h2 id="兄弟選擇器-，我的隔壁">兄弟選擇器 (+) ，我的隔壁</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>排擠我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>我有<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>我有<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是防守員<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>排擠我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>我有<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> + <span class="selector-tag">a</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 sass 會寫 <code>&amp; + &amp;</code>，通常是排除第一個，因為第一個的前面並沒有元素</p><p>或者寫 <code>:not</code> 把第一個給排除掉</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:first</span>-child)</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="網頁色彩-HSL">網頁色彩 HSL</h2><p><code>hsl (色相角度&lt;0~360&gt; , 色彩飽和度 , 色彩的明度 )</code><br>色彩是 RGB，分別各佔 120 度</p><p><a href="http://csscoke.com/2015/01/01/rgb-hsl-hex/"><img data-src="https://dsm01pap006files.storage.live.com/y4mzaFTHqTQKFWQ2sQ_sISqYOCtvikOQA4Dmli4z7vpaNjUQ7Nirr4UbVRGbiS9uCI9vba3kPgs7-_xx4wqwjkXxMs-VnajXcBBhswICqcXV54qi9lLN5lSAO_A-G5MdHISuaULUSfhoHKbgA1KFfLD6bcojrfSyoJJqCwIodr7i0AGpp8ainTKi0Fl7MV7y3XO?width=500&amp;height=424&amp;cropmode=none" alt="HSL 色相環圖片"> 來自《RGB、HSL、Hex 網頁色彩碼，看完這篇全懂了 | CSS可樂》</a></p><ul><li><code>Hue</code> : 色相</li><li><code>Saturation</code> : 飽和度。 預設是 100%，越低越接近灰黑</li><li><code>Lightness</code> : 亮度。 預設是 50%。 有點像相機的曝光度，增加白色或黑色的量</li></ul><p>例 :  綠色  <code>hsl (120,100%,50%)</code></p><h2 id="參考-2">參考</h2><ol><li><a href="https://segmentfault.com/q/1010000004569689">伪类before/after中的图片大小是不是不能设置的? - SegmentFault 思否</a></li><li><a href="http://csscoke.com/2013/09/22/%E4%BD%BF%E7%94%A8before-%E8%88%87-after%E4%BE%86%E8%A3%BD%E4%BD%9C%E5%8F%AF%E5%88%97%E5%8D%B0%E7%9A%84logo%E5%9C%96%E7%89%87/">使用::before 與 ::after來製作可列印的logo圖片</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;本篇成果-12&quot;&gt;本篇成果&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/shan473/pen/MWOqRoJ&quot;&gt;Codepen&lt;/a&gt;&lt;br&gt;
&lt;img src=&quot;https://dsm01pap006files.storage.live.com/y4m2Ut7v52DvB4HXKmhJiPfdh0fC0SYoIg5T6XnWySFOIDNRpNgeG6BkVMmRRZ1qoFlUYVdtq9et8hdrrwbuKF_IqtJFFUTFY2ZI0HDP4tw4ma1Jx9JaMbE6WmvD7YYOv32FJlbpmUwIGLUMzWi1CyKgXyGm598Nl1TZPipEnVfdXC5t8p5GdEi7KevsBdw7Zou?width=1024&amp;amp;height=585&amp;amp;cropmode=none&quot; alt=&quot;麵包屑&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="CSS" scheme="https://blog.rosa.tw/tags/CSS/"/>
    
    <category term="CSSZeroToOneSeries" scheme="https://blog.rosa.tw/tags/CSSZeroToOneSeries/"/>
    
  </entry>
  
  <entry>
    <title>CSSZeroToOneSeries | 07 | 導覽列 &amp; 變化導覽列</title>
    <link href="https://blog.rosa.tw/2022/04/04/CSSSeriesZeroToOne-07"/>
    <id>https://blog.rosa.tw/2022/04/04/CSSSeriesZeroToOne-07</id>
    <published>2022-04-09T14:46:25.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本篇成果-11">本篇成果</h2><p><a href="https://codepen.io/shan473/pen/abVaLWx">Codepen</a><br><img data-src="https://dsm01pap006files.storage.live.com/y4m9T4H16Ta75kDzYcQq5DvDiixK4mUT7-zgyeMbwFltHZbFafI5uejyNEI2PKXuVsHwbitph6KpHB-W1twOqWHvFYJXV0ZHqpaK31pEbAbsnH7ffzVJrY4jCn-DQT8BuQlWSI7mhiwxpMOte8vgXL82SlBMc9CDVnRs4GQaX5zSfAIPFEVdD6wo429FOHMt4kh?width=1024&amp;height=133&amp;cropmode=none" alt="導覽列"></p><p>LOGO 放中央的四種不同寫法導覽列<br><a href="https://codepen.io/shan473/pen/NWwLwmZ">Codepen</a><br><img data-src="https://dsm01pap006files.storage.live.com/y4mxh2kVWQGz5Y5blS98ignQpvNJzpOWFoegrfNdnwioXN37pRMs_UAXWIjV38dGFgg2z4HSQGInRsfJzwzxhUc1-TL4o4jsjhWV_PINth18C_qZ2JEo-KuJm3UAaU8ePorHvVKZABYHV6LJ9mgFTP4YdVPGUP2DmOSCmHehmX01KVzjrVlFs-xp9IVKe_3hKWO?width=660&amp;height=444&amp;cropmode=none" alt="變化導覽列"></p><span id="more"></span><h3 id="max-width-最大寬度">max-width : 最大寬度</h3><p>避免現代螢幕過寬(高解析度螢幕)導致元素被擠在邊邊，如果原本是 width 是填滿的情況，使用 <code>display : flex，justify-content : space-between</code>，元素會被分散在螢幕的邊邊角角。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="input-focus">input : focus</h3><p>input 在打字時會有預設的外框線 <strong>(outline)</strong>，可以把框線消失，讓視覺體驗更加。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span>:foucs&#123;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a-tag-不能-transform-的原因">a tag 不能 transform 的原因</h3><p>幫連結加上浮上去的漸變動畫， a 的預設 display 是 <code> inline</code>，會發現直接加上去 a 並不會有變化。</p><p>實際上 inline 屬性的元素並不支援，修改 display 屬性就可以了。</p><p>參考 :</p><ul><li><a href="https://stackoverflow.com/questions/14883250/css-transform-doesnt-work-on-inline-elements">CSS transform doesn’t work on inline elements - Stack Overflow</a></li></ul><blockquote><p>根據 CSS 規格書，有提到區塊元素或者 <code>inline-auto</code> 這類才可以 transform。</p></blockquote><h3 id="border-畫線效果">border 畫線效果</h3><p>position 讓我們可以利用 top、bottom、left、right 四邊進行定位，也可以撐開全版面。<br>也可以利用偽元素的 <code>left</code>、<code>right</code> 來創造線條收縮的效果。</p><blockquote><p>為什麼用偽元素 ? 這邊的底線只是 <strong>裝飾作用</strong> 不具任何資訊，盡量不要創造新的 tag 來裝</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">right</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="built_in">var</span>(--txtColor); </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transition</span><span class="selector-pseudo">:left</span> .<span class="number">3s</span> ease,<span class="attribute">right</span> .<span class="number">3</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">right</span>:<span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>後來想想這樣的寫法不太好，原因在於 <a href="https://csstriggers.com/top"><code>top</code></a> 這類定位是會 <code>reflow</code> (重排)，效能上比較不好，選擇只有 <code>repaint</code> (重繪) 的 <a href="https://csstriggers.com/transform">transform</a></p></blockquote><p>改成 transform</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.1em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: center;</span><br><span class="line">  <span class="attribute">transition</span>: transform .<span class="number">3s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(.<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>transition 不要使用 <code>all</code>，針對要件漸變的部分設定就好，以免效能上的浪費。</p></blockquote><h2 id="導覽列變化手法">導覽列變化手法</h2><ol><li>把 LOGO 擺中間</li><li>flexbox 改變 order</li><li>直接改寫 HTML 結構</li><li>利用絕對定位</li></ol><p>個人最喜歡 flexbox 的部份，既不修改結構，又保有彈性修改，哪天想讓 LOGO 到最前面只要修改 <code>order</code> 即可。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;本篇成果-11&quot;&gt;本篇成果&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/shan473/pen/abVaLWx&quot;&gt;Codepen&lt;/a&gt;&lt;br&gt;
&lt;img src=&quot;https://dsm01pap006files.storage.live.com/y4m9T4H16Ta75kDzYcQq5DvDiixK4mUT7-zgyeMbwFltHZbFafI5uejyNEI2PKXuVsHwbitph6KpHB-W1twOqWHvFYJXV0ZHqpaK31pEbAbsnH7ffzVJrY4jCn-DQT8BuQlWSI7mhiwxpMOte8vgXL82SlBMc9CDVnRs4GQaX5zSfAIPFEVdD6wo429FOHMt4kh?width=1024&amp;amp;height=133&amp;amp;cropmode=none&quot; alt=&quot;導覽列&quot;&gt;&lt;/p&gt;
&lt;p&gt;LOGO 放中央的四種不同寫法導覽列&lt;br&gt;
&lt;a href=&quot;https://codepen.io/shan473/pen/NWwLwmZ&quot;&gt;Codepen&lt;/a&gt;&lt;br&gt;
&lt;img src=&quot;https://dsm01pap006files.storage.live.com/y4mxh2kVWQGz5Y5blS98ignQpvNJzpOWFoegrfNdnwioXN37pRMs_UAXWIjV38dGFgg2z4HSQGInRsfJzwzxhUc1-TL4o4jsjhWV_PINth18C_qZ2JEo-KuJm3UAaU8ePorHvVKZABYHV6LJ9mgFTP4YdVPGUP2DmOSCmHehmX01KVzjrVlFs-xp9IVKe_3hKWO?width=660&amp;amp;height=444&amp;amp;cropmode=none&quot; alt=&quot;變化導覽列&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="CSS" scheme="https://blog.rosa.tw/tags/CSS/"/>
    
    <category term="CSSZeroToOneSeries" scheme="https://blog.rosa.tw/tags/CSSZeroToOneSeries/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | 初探 CSS Grid</title>
    <link href="https://blog.rosa.tw/2022/04/04/CSS-Grid"/>
    <id>https://blog.rosa.tw/2022/04/04/CSS-Grid</id>
    <published>2022-04-09T10:55:08.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-18">前言</h2><p>眾所皆知 flex 是排版神器，尤其在一維的排版非常好用<br>那在二維的排版呢 ?<br>就不得提到 grid，雖然 grid 在舊的瀏覽器支援性沒到很高，現代瀏覽器是幾乎都有支援。(<a href="https://caniuse.com/css-grid">caniuse</a>)</p><span id="more"></span>  <h2 id="grid-container-容器布局">grid-container 容器布局</h2><p>要建立網格，起手式先建造一個容器，準備讓子項網格排列</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item1&quot;</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item2&quot;</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item3&quot;</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item4&quot;</span>&gt;</span>item4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item5&quot;</span>&gt;</span>item5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="display-grid">display : grid</h3><p>grid 是二維的版面排版，透過 columns 跟 rows 來安排，直接 加上 grid 不會有變化。</p><p>display 有關 grid 的有 2 個值，就像 <code>inline-flex</code> 跟 <code>flex</code></p><ol><li><code>inline-grid</code></li><li><code>grid</code> : 2D 布局</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: grid | inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="格線軌道（Grid-Track）">格線軌道（Grid Track）</h3><p>在 grid 中有不同的布局方式，來決定網格的架構</p><ol><li>軌道</li><li>fr 分塊，利用百分比算格數，具有彈性</li></ol><h3 id="明式格線（explicit-grid）">明式格線（explicit grid）</h3><p>明式是自定義軌道，有明就會有暗，暗式是 CSS 幫我們建立的線。</p><h4 id="grid-template-columns-橫向軌道">grid-template-columns : 橫向軌道</h4><p>橫向網格的寬度。<br>合法的絕對單位 :</p><ul><li>%</li><li>px</li><li>em</li><li>rem</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line"><span class="attribute">grid-template-columns</span> : <span class="number">100px</span> <span class="number">100px</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>橫向放入三個元素，各別有寬度。</p><ul><li><p><code>fr</code> : 可用空間的分塊（fraction）。全都 <code>fr</code> 的單位就像切分成幾分之幾，但是類似帶有 flex-grow 、flex-shrink 的功能。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line"><span class="attribute">grid-template-columns</span>: <span class="number">2</span>fr <span class="number">3</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>橫向呈現兩個元素，前者占 2/5，後者 3/5</p></li><li><p><code>auto</code> : 如果是搭配 fr 單位，會是子元素分配剩餘的空間</p></li></ul><p>如果有重複的版面，除了一個個手打，也可以利用 repeat 快速重複</p><ul><li><code>repeat(&lt;次數&gt;,&lt;單位&gt;)</code>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line"><span class="attribute">display</span>:grid;</span><br><span class="line"><span class="attribute">grid-template-columns</span> : <span class="built_in">repeat</span>(<span class="number">5</span>,<span class="number">1</span>fr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>容器會被橫向切成五塊。</li></ul><h4 id="gird-template-rows">gird-template-rows</h4><p>直排間的大小，跟 columns 很像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:grid;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span> : <span class="built_in">repeat</span>(<span class="number">5</span>,<span class="number">1</span>fr); </span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">5</span>,<span class="number">1</span>fr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n)&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n+<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延伸上一個 columns 的例子，這樣就完成 5X5 的網格版面。<br>做個簡單的就是黑白棋盤格<br><img data-src="https://dsm01pap006files.storage.live.com/y4mWjsi1VFCz1a4Y4PYgBdGH4nr_koMsXMKau9gYdZw6NHUWT6BZTF5VZzybgEZeTgEWRW7yShbHrosym0pS8SwRMoz8afSelU59UktSX_elpmKmC2GyvE1HQY_PVkefILEXPrnQoaOVZqP-h3mlpRPRv7Ma6NWNF8bWxiFgg0LCDBQ5pAgdUJKSyhR__iTjKM-?width=1024&amp;height=558&amp;cropmode=none" alt="軌道式布局"></p><h4 id="grid-template-混合式布局">grid-template : 混合式布局</h4><blockquote><p>先 row 再 column</p></blockquote><ul><li>grid-template : <code>&lt;rows-template&gt; / &lt;columns-template&gt;</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 軌道式 */</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line"><span class="comment">/* ...略 */</span></span><br><span class="line">  <span class="attribute">grid-template</span>: <span class="built_in">repeat</span>(<span class="number">5</span>,<span class="number">1</span>fr) / <span class="built_in">repeat</span>(<span class="number">5</span>,<span class="number">1</span>fr); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了軌道也可以用命名式的，上面的例子可以改成，下面會再提到命名式的寫法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 軌道式 */</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:grid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">grid-template</span>: </span><br><span class="line">    <span class="string">&quot;. . . . .&quot;</span></span><br><span class="line">    <span class="string">&quot;. . . . .&quot;</span></span><br><span class="line">    <span class="string">&quot;. . . . .&quot;</span></span><br><span class="line">    <span class="string">&quot;. . . . .&quot;</span></span><br><span class="line">    <span class="string">&quot;. . . . .&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://dsm01pap006files.storage.live.com/y4munCQNLVYAOI_NYCgXrtU1bv1eLPQS8Nb_33cNyi0-DhiHRAeXzLCZYZi73nysSdYiALn5Ht-_Hoj0uD1VBw3tiLw5HE95LAuvmENJX9hSx2GnjRXwx_yHe8D5LthivgCGVNW_EuGXFJ8I3fJAtqTZVAbSFx8Zxvx_1Av9IqqrTFpH78MQSYy0dVnBEuy4Eeo?width=1024&amp;height=558&amp;cropmode=none" alt="命名式布局"></p><h3 id="暗式格線（implicit-grid）">暗式格線（implicit grid）</h3><p>瀏覽器將剩餘的空間自行運用產生的<br>設定剩下沒有指定 template 的 rows</p><blockquote><p><strong>implicit grid 預設的寬度會根據內容的大小來改變</strong><br>如果 定格到超出的 track ，CSS 會自動補上 implicit grid</p></blockquote><h4 id="grid-auto-rows-grid-auto-columns">grid-auto-rows &amp;  grid-auto-columns</h4><p>容器預設寬高。</p><ul><li><code>minmax</code> 可以設定最小和最大值</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line"><span class="attribute">grid-auto-rows</span> : <span class="built_in">minmax</span>(`&lt;min&gt;,&lt;max&gt;`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="網格間距">網格間距</h3><h4 id="grid-gap">grid-gap</h4><ul><li><code>grid-gap-row</code> : 直向元素的間距</li><li><code>grid-gap-column</code> : 橫向元素的間距</li></ul><p>兩個合併設定 grid-gap :  <code>&lt;row&gt; &lt;column&gt;</code><br>一樣是 <strong>先 row 再 column</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line"><span class="attribute">grid-gap</span> : &lt;row-gap&gt; &lt;column-gap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="另一種布局-命名式">另一種布局 : 命名式</h2><h3 id="grid-template-areas-命名式布局">grid-template-areas : 命名式布局</h3><p>透過命名的方式給空間<br>在父層 <code>grid-template-areas</code> 定義版面<br>子層元素透過 <code>grid-area</code> 設定別名</p><p>常見的範例，快速排出 <strong>三欄式布局</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line"><span class="attribute">grid-template-areas</span> : </span><br><span class="line"><span class="string">&quot;header header&quot;</span></span><br><span class="line"><span class="string">&quot;sidebar content&quot;</span></span><br><span class="line"><span class="string">&quot;footer footer&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="grid-area-定格之命名式定格">grid-area : 定格之命名式定格</h3><p>上面有提到軌道式的合併寫法也可以 <code>grid-area</code> 起點 &amp; 終點，而在命名式布局可以對想要的元素命名，再到布局進行排列。</p><p>延續上面的三欄式布局，對個別的區塊 <strong>命名</strong><br>再個別設定區塊大小。  <a href="https://codepen.io/shan473/pen/yLpjwaK">Codepen 三欄式</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">200px</span> <span class="number">1</span>fr <span class="number">64px</span>;</span><br><span class="line"><span class="attribute">grid-template-areas</span> : </span><br><span class="line"><span class="string">&quot;header header&quot;</span></span><br><span class="line"><span class="string">&quot;sidebar content&quot;</span></span><br><span class="line"><span class="string">&quot;footer footer&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.header</span>&#123;</span><br><span class="line"><span class="attribute">grid-area</span> : header;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span>&#123;</span><br><span class="line"><span class="attribute">grid-area</span> : sidebar;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fa0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line"><span class="attribute">grid-area</span> : content ; </span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#0fa</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span>&#123;</span><br><span class="line"><span class="attribute">grid-area</span> : footer; </span><br><span class="line">  <span class="attribute">background-color</span>: violet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>個人覺得這種方式很直覺，做常規版面規劃就可以很快速😃</p><h2 id="grid-item-子項定格">grid-item 子項定格</h2><h3 id="grid-row-column-start-end-個別設定定格">grid-row/column start &amp; end 個別設定定格</h3><p>有兩種方式來讓格子被佔據</p><ol><li>軌道範圍</li><li>佔據格數</li></ol><h4 id="透過軸線起終點來指定佔據的範圍">透過軸線起終點來指定佔據的範圍</h4><ul><li><code>grid-column-start</code> :  column 的佔據軌道起點</li><li><code>grid-column-end</code> : column 的佔據軌道終點</li></ul><p>打開 Devtools 按下 grid 的格線視覺工具就可以看見<br><img data-src="https://dsm01pap006files.storage.live.com/y4mFIFKSjXekpoog3xRQ2ne9NlGlppe2cMmpEyFJah7PMyNkDaFqG3BIrKWtESIgciPHiZw_qqYVFJRFYWO0OHTqvcyjR_0APRrrlZb7mVrKDkTDLsBclQunblwKtk4aoAwiGEk-E8u68pOAqaRSyu6NQ2Cb69euzI-d_02dR7VNk2rk15g-bDZqscdaCPFbDn0?width=1024&amp;height=588&amp;cropmode=none" alt="Devtools grid"></p><p>合併寫法</p><ul><li><code>grid-column</code> : &lt;起點&gt; /  &lt;終點&gt;</li></ul><p>如果想要 <strong>占據整行</strong>，除了從 <strong>第一行 / 末行</strong> 這樣寫，也可以利用負數來達成。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span>&#123;</span><br><span class="line"><span class="attribute">grid-column</span> : <span class="number">1</span>/-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="span-數格數">span : 數格數</h4><p>預設 grid-column 是 <code>span 1</code>，就是按照 flow 占據一格</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-2</span>&#123;</span><br><span class="line"><span class="attribute">grid</span>-colum : span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="grid-area-軌道混合式定格">grid-area : 軌道混合式定格</h3><p>grid-area : <code>&lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;</code>。</p><p>按照老規矩 <strong>先 row 開始再 column</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line"><span class="attribute">grid-area</span> : <span class="number">1</span> / <span class="number">2</span> / <span class="number">3</span> / <span class="number">4</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="order-順序">order 順序</h2><p>跟 <code>flex</code> 一樣 grid 是可以改變順序的。</p><ul><li><code>order : 0</code> 照原本的排序</li><li><code>order : -1</code> : order 也可以是負值，屬於往前排。</li></ul><p>order 的起始點是從 <strong>整體的排列</strong> 後面開始算起。<br>首先要知道 grid 的排列順序，預設是 row ，也就是從 row 的尾巴開始，如果有兩列，就是從第二列的尾巴開始。</p><iframe height="300" style="width: 100%;" scrolling="no" title="Untitled" src="https://codepen.io/shan473/embed/vYpjMZW?default-tab=result&theme-id=dark" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shan473/pen/vYpjMZW">  Untitled</a> by YanShanHong (<a href="https://codepen.io/shan473">@shan473</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><h2 id="對齊">對齊</h2><h3 id="整體垂直與水平對齊">整體垂直與水平對齊</h3><p>設定在父層，控制 <strong>整個網格</strong> 的位置</p><ul><li><code>justify-content</code> : 所有的子項水平位置。</li><li><code>align-content</code> :  所有的子項垂直位置</li></ul><blockquote><p>flex-end(start) 這是給 flexbox 用的，gird 寫法是 start 跟 end</p></blockquote><p>設定在父層，控制 <strong>所有網格中的內容對齊</strong></p><ul><li><code>justify-items</code> : 預設是 stretch，個別設定會按照子項內容的 <strong>寬</strong> 再去水平對齊。</li><li><code>align-items</code> : 預設是 stretch，個別設定會按照子項內容的 <strong>高</strong> 再去垂直對齊。</li></ul><h3 id="個別設定子項內容對齊">個別設定子項內容對齊</h3><p>設定在子層，控制 <strong>個別網格中的內容對齊</strong><br>子項的內容物想要客製化的對齊，複寫 justify-items &amp; align-items 的控制。</p><ul><li><code>align-self</code> : 預設是 stretch，使用跟 align-items 差不多。</li><li><code>justufy-self</code> :  預設是 stretch，使用跟 justify-items 差不多。</li></ul><iframe height="300" style="width: 100%;" scrolling="no" title="Untitled" src="https://codepen.io/shan473/embed/PoEevZg?default-tab=result&theme-id=dark" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/shan473/pen/PoEevZg">  Untitled</a> by YanShanHong (<a href="https://codepen.io/shan473">@shan473</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><h2 id="z-index-圖層">z-index 圖層</h2><p>以往我們要用到 <code>z-index</code> 都會是在絕對定位的時候，在 grid 中是可以把項目堆疊的，透過 <code>z-index</code> 來前後順序。</p><p>預設的圖層順序是 html 結構 <strong>後面的會覆蓋前面的</strong>，可以直接透過 <code>z-index</code> 改變順序。</p><p>這個例子兩個有重疊的部分，item-5 寫上後蓋住了 item-1，為了讓 item-1 被看見，圖層寫得比 item-5 高就行了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span>&#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: <span class="number">1</span> / <span class="number">2</span> / <span class="number">1</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-5</span>&#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: <span class="number">1</span> / <span class="number">1</span> / <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="總結-17">總結</h2><p>本篇還有很多 grid 的應用還沒研究到，未來再專研 !<br>很推 <strong>CSS-tricks</strong> 上的文章，很多寫法都很實用</p><h2 id="練習">練習</h2><ul><li>以 <strong><a href="https://zh.wikipedia.org/wiki/%E7%9A%AE%E7%89%B9%C2%B7%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89">皮特·蒙德里安</a></strong> 的《紅、藍、黃的構成》做為練習，說到網格自然就想到這幅畫  XD。<br><a href="https://codepen.io/shan473/pen/KKZRmRm">Codepen</a><br><img data-src="https://dsm01pap006files.storage.live.com/y4meQohOpsPirn8FgIW6-32dz_PV_9ldr3h7XdfuoLRBgBMVuweq_tSNsV7Osnk8yDBjyZhV4cVT0RuzJnF4Mf5bLcYc5KKVnVXBuu0bOvra6l8WSV33Yu6krcT-r8yl7TlqLB1ir3IPN2crKR6HWWWwN7avpOZB6UabLXjVNMBVnGxMiRl_8PrB3Gs8xKtehAv?width=1022&amp;height=1024&amp;cropmode=none" alt="CSS 版-紅、藍、黃的構成"></li><li>額外來自 Frontend Mentor 的練習題，利用 grid 進行排版<br><a href="https://meitung473.github.io/testimonials-grid-section-main/">Frontend Mentor | Rosa Hong</a></li><li>grid-graden (已破關) : <a href="https://cssgridgarden.com/">Grid Garden - A game for learning CSS grid </a><blockquote><p>心得 :<br>遊戲式的 grid 很容易理解，<br>template 除了正數以外，也可以使用 <strong>負數</strong>。<br>個人遇到 26 關卡了一下，其他掌握住如何算軌道跟知道格數怎麼應用就沒什麼障礙。對齊的部份，都在另一個 flexbox frog。</p></blockquote></li></ul><h2 id="參考">參考</h2><ul><li>快速查表 :  <a href="https://grid.malven.co/">GRID: A simple visual cheatsheet for CSS Grid Layout (malven.co)</a></li><li>好筆記 : <a href="https://pjchender.dev/css/css-grid-layout/">[CSS] Grid Layout | PJCHENder 未整理筆記</a></li><li>非常詳盡的圖文並茂解說 : <a href="https://css-tricks.com/snippets/css/complete-guide-grid/">A Complete Guide to Grid | CSS-Tricks - CSS-Tricks</a> 。我也很推 flexbox 的教學</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-18&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;眾所皆知 flex 是排版神器，尤其在一維的排版非常好用&lt;br&gt;
那在二維的排版呢 ?&lt;br&gt;
就不得提到 grid，雖然 grid 在舊的瀏覽器支援性沒到很高，現代瀏覽器是幾乎都有支援。(&lt;a href=&quot;https://caniuse.com/css-grid&quot;&gt;caniuse&lt;/a&gt;)&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="04" scheme="https://blog.rosa.tw/categories/2022/04/"/>
    
    
    <category term="CSS" scheme="https://blog.rosa.tw/tags/CSS/"/>
    
    <category term="grid" scheme="https://blog.rosa.tw/tags/grid/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - 參數傳遞 call by value or call by reference &amp; call by sharing</title>
    <link href="https://blog.rosa.tw/2022/03/03/JavaScript-call-by-what"/>
    <id>https://blog.rosa.tw/2022/03/03/JavaScript-call-by-what</id>
    <published>2022-03-26T15:12:05.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-31">前言</h2><p>一直以來 JavaScript 的參數傳遞都蠻有爭議性的<br>可能聽過</p><blockquote><p>原始型態是 call by value；物件型態是 call by reference</p></blockquote><p>甚至有人說 JavaScript 只有 <code>call by sharing</code> 或是根本只有 <code>call by value</code><br>到底是哪種 ? 眾說紛紜，本篇針對這三種名詞進行解釋幫助自己去來理解</p><p>如果有誤再麻煩各路大大指點</p><span id="more"></span>   <h2 id="call-by-value-傳值">call by value : 傳值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line"></span><br><span class="line">a=<span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><ul><li>定義變數 a 並且賦予 5 這個值，假設會被存在記憶體 <code>00x1</code> 這個位址</li></ul><table><thead><tr><th>變數</th><th>記憶體位址</th><th>值</th></tr></thead><tbody><tr><td>a</td><td>00x1</td><td>5</td></tr></tbody></table><ul><li>定義變數 b 等於 a ，b 拷貝 a 的值，另外存在新的記憶體位址  <code>00x3</code></li></ul><table><thead><tr><th>變數</th><th>記憶體位址</th><th>值</th></tr></thead><tbody><tr><td>a</td><td>00x1</td><td>5</td></tr><tr><td>b</td><td>00x3</td><td>5 (copy from a)</td></tr></tbody></table><ul><li>當你改變 a 的值，因為 b 指向不同記憶體位置，所以跟 b 沒有關係</li></ul><table><thead><tr><th>變數</th><th>記憶體位址</th><th>值</th></tr></thead><tbody><tr><td>a</td><td>00x1</td><td>10</td></tr><tr><td>b</td><td>00x3</td><td>5</td></tr></tbody></table><p>即使修改 a 或 b 其中一項，a 、 b 值互不相干擾，稱作 <code>call by value</code><br>而且 JavaScript 對於 Primitive type 的操作都是 <code>call by value</code><br>拷貝 「<strong>值</strong>」 但不拷貝 「<strong>址</strong>」</p><p>這也為什麼說 Primitive type 是 <strong>immutable</strong> (不可變)<br>這邊指的不可變 b 雖然等於 a，但你修改 a 並不會去變動到其他的值</p><h3 id="Function-中參數的傳遞-by-value">Function 中參數的傳遞 : by value</h3><p><a href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/">Huli 大的文章</a> 中也舉例變數 function 做為參數，並在 funciton 中進行新賦值的問題</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">revalue</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">a = <span class="number">5</span>;</span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">revalue</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>把變數 a 跟變數 b 都當作參數傳進 <code>revalue</code> 這個 function，而參數只是複製傳進來的值，並不會影響到在外面的 a 跟 b。</p><blockquote><p>這邊的參數 a、b 作為傳進來的值的別名 (alias)而已，跟外部定義的 a、b 是無關的</p></blockquote><h2 id="call-by-reference-傳址">call by reference : 傳址</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line"><span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1</span><br><span class="line">obj1.<span class="property">a</span> = <span class="number">5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; === &#123;&#125;) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 === obj2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 object 型態的判斷來看，空物件不會等於空物件，因為記憶體儲存的位址不同<br>但這裡 <code>obj1 === obj2</code> 是 true 的時候，代表兩個變數是指向同一個地方 ，是一樣的。</p><p>接著看怎麼運作的</p><ul><li>定義變數 obj1 並且賦予 <code>&#123;a : 1&#125;</code> 這個值，記憶體 <code>00x1</code> 這個位址 ，會存有 <code>&#123;a: 1&#125;</code> 這個值。而 obj1 的值則引用 (reference) <code>00x1</code> 位子的值</li></ul><table><thead><tr><th>變數</th><th>記憶體位址</th><th>值</th></tr></thead><tbody><tr><td></td><td>00x1</td><td>{a: 1}</td></tr><tr><td>obj1</td><td>00x2</td><td>00x1</td></tr></tbody></table><ul><li>定義變數 obj2 等於 obj1，也就是參照同一個 <strong>位址</strong> 的值</li></ul><table><thead><tr><th>變數</th><th>記憶體位址</th><th>值</th></tr></thead><tbody><tr><td></td><td>00x1</td><td>{a: 1}</td></tr><tr><td>obj1</td><td>00x2</td><td>00x1</td></tr><tr><td>obj2</td><td>00x2</td><td>00x1</td></tr></tbody></table><ul><li>當 <code>obj1.a</code> 改變時，是改動到位在 <code>00x1</code> 記憶體的值 <code>&#123;a : 5&#125;</code>，因為 obj2 也參照這裡的位址的值，在運作上連同 obj2 也被改動到</li></ul><table><thead><tr><th>變數</th><th>記憶體位址</th><th>值</th></tr></thead><tbody><tr><td></td><td>00x1</td><td><code>&#123;a: 5&#125;</code></td></tr><tr><td>obj1</td><td>00x2</td><td>00x1</td></tr><tr><td>obj2</td><td>00x2</td><td>00x1</td></tr></tbody></table><p>由此可知當改動到 obj1.a 的值 obj2.a 也會改變稱作 call by reference<br>Object type 通常是 call by reference<br>拷貝 「<strong>值</strong>」 <strong>也拷貝址</strong></p><p>跟 Primitive type 相反的是 Object type 是 <strong>mutable</strong> (可變)<br>改動 a 的值卻也會變動到 b<br>在 <a href="https://www.slideshare.net/YiTaiLin/java-script-63031051">Tommy 大簡報第 12 頁有清楚的流程</a> 可以參考</p><h3 id="Function-中參數的傳遞-by-reference">Function 中參數的傳遞 : by reference</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line"><span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">revalue</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">obj.<span class="property">b</span> = <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">revalue</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1) <span class="comment">// &#123;a: 1,b :5 &#125;</span></span><br></pre></td></tr></table></figure><p>在 revalue 函式中我們對參數 obj 進行更新<br>而外部的 obj1 也會變動到，因為指向的記憶體位址是同一處。</p><ul><li>obj1 作為引數，帶入 obj 參數時，複製一份 obj1 進去</li></ul><table><thead><tr><th>變數</th><th>記憶體位址</th><th>值</th></tr></thead><tbody><tr><td></td><td>00x1</td><td>{a : 1}</td></tr><tr><td>obj1</td><td>00x2</td><td>00x1</td></tr><tr><td></td><td>00x4</td><td>funtion revalue()…</td></tr><tr><td>revalue</td><td>00x5</td><td>00x4</td></tr><tr><td>參數 <strong>obj</strong></td><td>00x2</td><td>00x1</td></tr></tbody></table><ul><li>obj.b = 5 (不是變數重新賦值 !)</li></ul><table><thead><tr><th>變數</th><th>記憶體位址</th><th>值</th></tr></thead><tbody><tr><td></td><td>00x1</td><td><code>&#123;a:1,b:5&#125;</code></td></tr><tr><td>obj1</td><td>00x2</td><td>00x1</td></tr><tr><td></td><td>00x4</td><td>funtion revalue()…</td></tr><tr><td>revalue</td><td>00x5</td><td>00x4</td></tr><tr><td>參數 <strong>obj</strong></td><td>00x2</td><td>00x1</td></tr></tbody></table><h3 id="例外狀況-重新賦值">例外狀況 : 重新賦值</h3><p>凡事總有個例外…</p><ol><li>Object Literals 重新賦值 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1</span><br><span class="line"></span><br><span class="line">obj2 = &#123;a : <span class="number">3</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 === obj2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>按照上面來說，參照同一記憶體位址， obj2 變動應該會連同 obj1 也改變，結果沒有。<ul><li>obj2 = obj1，obj2 複製 obj1</li></ul></li></ol><table><thead><tr><th>變數</th><th>記憶體位址</th><th>值</th></tr></thead><tbody><tr><td></td><td>00x1</td><td><code>&#123;a:1,b:5&#125;</code></td></tr><tr><td>obj1</td><td>00x2</td><td>00x1</td></tr><tr><td>obj2</td><td>00x2</td><td>00x1</td></tr></tbody></table><pre><code>- obj2 新賦值</code></pre><table><thead><tr><th>變數</th><th>記憶體位址</th><th>值</th></tr></thead><tbody><tr><td></td><td>00x1</td><td>{a:1}</td></tr><tr><td></td><td>00x5</td><td><code>&#123;a: 3&#125;</code></td></tr><tr><td>obj1</td><td>00x2</td><td>00x1</td></tr><tr><td>obj2</td><td>00x6</td><td>00x5</td></tr></tbody></table><pre><code>obj2 在新賦值時，物件創造新的記憶體位址賦予值，obj2 也創造一個新的記憶體位址並且複製物件位址到自己的值  obj1 跟 obj2 正式分道揚鑣 ~ 成為陌生人  </code></pre><ol start="2"><li>Function 中參數的傳遞 : Object 重新賦值</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line"><span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">revalue</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">obj=&#123; a : <span class="number">3</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">revalue</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1) <span class="comment">// &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure><p>在裡面重新賦值，外部的引數並不會改動到原本的值<br>跟著跑一遍</p><ul><li>obj1 作為引數，帶入 obj 參數時，複製一份 obj1 進去</li></ul><table><thead><tr><th>變數</th><th>記憶體位址</th><th>值</th></tr></thead><tbody><tr><td></td><td>00x1</td><td>{a : 1}</td></tr><tr><td>obj1</td><td>00x2</td><td>00x1</td></tr><tr><td></td><td>00x4</td><td>funtion revalue()…</td></tr><tr><td>revalue</td><td>00x5</td><td>00x4</td></tr><tr><td>參數 <strong>obj</strong></td><td>00x2</td><td><code>00x1</code></td></tr></tbody></table><ul><li>obj={ a : 3}  重新賦值</li></ul><table><thead><tr><th>變數</th><th>記憶體位址</th><th>值</th></tr></thead><tbody><tr><td></td><td>00x1</td><td>{ a : 1 }</td></tr><tr><td>obj1</td><td>00x2</td><td>00x1</td></tr><tr><td></td><td>00x4</td><td>funtion revalue()…</td></tr><tr><td>revalue</td><td>00x5</td><td>00x4</td></tr><tr><td>參數 <strong>obj</strong></td><td><code>00x8</code></td><td><code>00x6</code></td></tr><tr><td></td><td>00x6</td><td>{a : 3}</td></tr></tbody></table><ul><li>根據 Scope 作用域，函式的變數作用範圍等函式結束後就會釋放記憶體。</li></ul><table><thead><tr><th>變數</th><th>記憶體位址</th><th>值</th></tr></thead><tbody><tr><td></td><td>00x1</td><td>{ a : 1 }</td></tr><tr><td>obj1</td><td>00x2</td><td>00x1</td></tr><tr><td></td><td>00x4</td><td>funtion revalue()…</td></tr></tbody></table><p>obj1 依然不會變動到。</p><p>不過你發現了嗎 ?<br>Object Type 新賦值的行為是複製值而已，很像 call by value</p><h2 id="不是-by-value-也不是-by-renference-而是-by-sharing">不是 by value 也不是 by renference 而是 by sharing</h2><p>哦不，我的頭開始痛了<br>那我前面認識的難道是假的嗎 ?</p><p>不，sharing 就像綜合體一樣<br>按上面所述，我們可以把情況分成三種</p><ol><li>Primitive type 表現行為是 call by value</li><li>Object type 沒有新賦值的情況，而是對內容操作，表現行為像是 call by reference</li><li>Object type 重新賦值，表現則是 call by value，會建立一個新的記憶體位置，並且複製其(記憶體位址的)值</li></ol><p>可知 call by sharing 在不同情況下會就會有不同的表現行為</p><p>借一下 Huli 大的圖…<br><img data-src="https://dsm01pap006files.storage.live.com/y4mnEy3INPdoo5FZIkuPSKskoOVfwI9iapT5pvdWu6c0BSovTa8z0rEaeST_jxZaxA8prHXyxrT_9IWaaoniKLBb6GJz6tdT60tRupMq7E0LMnDVcO97Oc8H1Rk2WzVxmlnTRFYoLOjzbHqdeFe5cLtaWuG_x4SY9Mt6GLI8HYXkVicjUFYT5QsvmVzYogaIAxS?width=949&amp;height=702&amp;cropmode=none" alt="call by sharing"></p><p>文章中有提及其實 JavaScript 嚴格意義上是沒有 call by reference 的，因為函式的引數重新賦值並不會修改到外部變數的值。<br>(C++ 能修改到是跟指標有關)<br>由於我不是很熟 C 跟 C++… 先不做討論</p><p>由上圖可知，JavaScript 可以說</p><blockquote><p>Primitive 是 Pass by Value，Object 是 Pass by sharing。</p></blockquote><h2 id="全都是-call-by-value-的觀點">全都是 call by value 的觀點</h2><p>那全是 call by value 是怎麼回事 ?<br>造成爭論的點在於這邊的 value 並未定義說是 <strong>內容的值</strong> 還是 <strong>存放在變數記憶體位址裡的值</strong></p><ul><li>以 <strong>內容的值</strong> 觀點來看</li></ul><table><thead><tr><th>變數</th><th>記憶體位址</th><th>值</th></tr></thead><tbody><tr><td>a</td><td>00x1</td><td><strong>5(被複製到 b)</strong></td></tr><tr><td>b</td><td>00x3</td><td>5</td></tr></tbody></table><ul><li>以 <strong>記憶體位址裡的值</strong> 觀點來看</li></ul><table><thead><tr><th>變數</th><th>記憶體位址</th><th>值</th></tr></thead><tbody><tr><td></td><td><strong>00x1 (被複製)</strong></td><td>{a: 1}</td></tr><tr><td>obj1</td><td>00x5</td><td>00x1</td></tr><tr><td>obj2</td><td>00x5</td><td>00x1</td></tr></tbody></table><p>b 複製 a ， a 也是複製記憶體 <code>(00x1)</code> 位址這個值，所以也可以說是 <strong>call by value</strong><br>在定義上的不同，導致不同的觀點與結論</p><h2 id="參考-17">參考</h2><ol><li>帶你跑一次 : <a href="https://www.slideshare.net/YiTaiLin/java-script-63031051">簡單介紹JavaScript參數傳遞 (slideshare.net)</a></li><li>簡單論述 : <a href="https://ithelp.ithome.com.tw/articles/10191057">重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？</a></li><li>從各方面來看 : <a href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/">深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？</a></li><li>好懂得位址概念 : <a href="https://ithelp.ithome.com.tw/articles/10209104">你不可不知的 JavaScript 二三事#Day26：程式界的哈姆雷特 —— Pass by value, or Pass by reference？</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-31&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;一直以來 JavaScript 的參數傳遞都蠻有爭議性的&lt;br&gt;
可能聽過&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原始型態是 call by value；物件型態是 call by reference&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;甚至有人說 JavaScript 只有 &lt;code&gt;call by sharing&lt;/code&gt; 或是根本只有 &lt;code&gt;call by value&lt;/code&gt;&lt;br&gt;
到底是哪種 ? 眾說紛紜，本篇針對這三種名詞進行解釋幫助自己去來理解&lt;/p&gt;
&lt;p&gt;如果有誤再麻煩各路大大指點&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="03" scheme="https://blog.rosa.tw/categories/2022/03/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>筆記 | JavaScript - first class function (一級函式)</title>
    <link href="https://blog.rosa.tw/2022/03/03/JavaScript-First-Class-Function"/>
    <id>https://blog.rosa.tw/2022/03/03/JavaScript-First-Class-Function</id>
    <published>2022-03-26T05:34:14.000Z</published>
    <updated>2022-07-27T05:30:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-29">前言</h2><p>JavaScript 中的 function 是很神奇的東西<br>在初學時看到很多名詞<br>像 callback function(回呼函式)、First-Class Function(一級函式)、High-Order Function(高階函式)<br>還有 Closure(閉包) 等等的，總是會霧撒撒…<br>本篇來初步認識 function 中的 First-Class Function 概念</p><span id="more"></span><h2 id="一級函式">一級函式</h2><blockquote><p>函式可以被視為其他變數一樣，像是 function 可以指定成變數，也可以做為參數傳入別的 funciton。</p></blockquote><p>JavaScript 的 function 符合 first class function</p><ul><li>函式只是物件的一種</li><li>function 可以儲存成變數 (function expression) <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet =<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>function 可以當作參數傳入別的 function 中，這邊把 function 當作 <strong>值</strong> 來使用。<br>(這樣的方式會稱這個 function 是 callback function)  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;hello,&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">message,name</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">message</span>()+name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">greet</span>(hello,<span class="string">&#x27;rosa!&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>function 裡面又回傳另一個 function。<br>只要接收函式作為參數，或是回傳函式作為輸出的函式<br>就稱作高階函式 ( <strong>Higher-Order Function</strong> )<br>像是 Array 中的 <code>map</code> function  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">num</span>)=&gt;</span> num * <span class="number">2</span> )</span><br><span class="line"><span class="comment">// 實作</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrayMap</span>(<span class="params">fn,array</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> length = array.<span class="property">length</span></span><br><span class="line"><span class="keyword">let</span> newArray = [] </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span> ; i&lt;length ; i++)&#123;</span><br><span class="line">newArray.<span class="title function_">push</span>(<span class="title function_">fn</span>(array[i]))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">arrayMap</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> item * <span class="number">2</span> </span><br><span class="line">&#125;,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure></li><li>function 跟物件一樣有屬性 (property)<br>下面進行說明</li></ul><h2 id="函式也是物件的一種">函式也是物件的一種 ?</h2><p>範例 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;invoke this&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hello</span>() <span class="comment">// 直接執行</span></span><br><span class="line">hello.<span class="property">people</span>=<span class="string">&#x27;rosa&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hello.<span class="property">people</span>) <span class="comment">// output : rosa</span></span><br></pre></td></tr></table></figure><ol><li>執行 (invoke) 函式，是透過 <code>()</code></li><li>可以直接用 <code>.</code> 建立物件中的 key-value</li></ol><p>證明 function 是一種特殊的物件，也可以當作物件來使用。</p><h2 id="補充-函式回傳一個另一個函式">補充 : 函式回傳一個另一個函式</h2><p>調用函式與回傳的函式有幾種做法</p><ol><li>存成變數</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayhi</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello, Rosa!&#x27;</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myFunc = <span class="title function_">sayhi</span>() <span class="comment">// myFunc 接收的是一個 function</span></span><br><span class="line"><span class="title function_">myFunc</span>() <span class="comment">// 呼叫</span></span><br></pre></td></tr></table></figure><ol start="2"><li>雙括號直接呼叫</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayhi</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello, Rosa!&#x27;</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayhi</span>()()</span><br></pre></td></tr></table></figure><ol start="3"><li>IIFE (Immediately Invoked Function Expression): 定義完就回傳的 function</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayhi</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello, Rosa!&#x27;</span>)</span><br><span class="line">&#125;)() </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayhi</span>()</span><br></pre></td></tr></table></figure><p>IIFE 的例子很常在 JQuery 看見</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">$</span>) &#123;</span><br><span class="line">    <span class="comment">//$ = jQuery</span></span><br><span class="line">&#125;)(jQuery)</span><br></pre></td></tr></table></figure><h2 id="參考-15">參考</h2><ol><li><a href="https://pjchender.blogspot.com/2016/03/javascriptfunctionobjects.html">[筆記] JavaScript 中函式就是一種物件 ─ 談談 first class function（一等公民函式） ~ PJCHENder 那些沒告訴你的小細節</a></li><li><a href="https://developer.mozilla.org/zh-TW/docs/Glossary/First-class_Function">一級函式（First-class Function） - 術語表 | MDN (mozilla.org)</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10224519">JS 原力覺醒 Day19 - 一級函式與高階函式</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-29&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;JavaScript 中的 function 是很神奇的東西&lt;br&gt;
在初學時看到很多名詞&lt;br&gt;
像 callback function(回呼函式)、First-Class Function(一級函式)、High-Order Function(高階函式)&lt;br&gt;
還有 Closure(閉包) 等等的，總是會霧撒撒…&lt;br&gt;
本篇來初步認識 function 中的 First-Class Function 概念&lt;/p&gt;</summary>
    
    
    
    <category term="2022" scheme="https://blog.rosa.tw/categories/2022/"/>
    
    <category term="03" scheme="https://blog.rosa.tw/categories/2022/03/"/>
    
    
    <category term="JavaScript" scheme="https://blog.rosa.tw/tags/JavaScript/"/>
    
  </entry>
  
</feed>
