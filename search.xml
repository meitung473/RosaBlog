<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>筆記 | Obsidian 區域、群組與文字圖片的使用方式</title>
    <url>/2022/08/Obsidian-Excalidraw-image-url.html</url>
    <content><![CDATA[<blockquote>
<p>影片連結 : <a href="https://www.youtube.com/watch?v=yZQoJg2RCKI">Block reference parts of images just like text with Obsidian Excalidraw - YouTube</a></p>
</blockquote>
<h2 id="摘要-3">摘要</h2>
<p>解決我怎麼在同一個大張 Excalidraw 把不同的圖片匯出到 markdown 上。一開始我都是靠多個檔案連結，因為我以為只能 1 個檔案全部匯出成 PNG 或者 SVG ，才能在其他 markdown 匯入，但其實是可以 <strong>直接取需要的區塊</strong> 就好，把 Excalidraw 畫板對待成一般的 markdown 文件，把圖像可標記、可連結，是 markdown 文件的加強版工具。</p>
<span id="more"></span>
<h2 id="區塊-圖片嵌入的-3-種方法">區塊/圖片嵌入的 3 種方法</h2>
<p>Excalidraw  區塊/圖片嵌入的方法有 3 種</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text : [[file#^elementID]]</span><br><span class="line">area : [[file#area=Section heading]]</span><br><span class="line">group : [[file#^group=elementID]] </span><br></pre></td></tr></table></figure>
<ol>
<li><code>text</code> : 純粹文字，等同於 Obsidian 裡面的 block ID <code>(^elementID)</code>。</li>
<li><code>area</code> : 區塊性圖片，被截出來 (cutout) 的那一塊。有點抽象，泛指被覆蓋疊到區塊都算，至於區塊的計算我目前看不出所以然🤔，因為有時候某些元素也會被截掉，應該是對應 Excalidraw 偵測文字的邊圍之類的。</li>
<li><code>group</code> : 有被群組  <code>(ctrl + G)</code> 起來的才會抓到，個人最常用。</li>
</ol>
<h2 id="快捷產生區塊-圖片連結">快捷產生區塊/圖片連結</h2>
<p>工具列最旁邊的小 obsidian 標誌 + 搭配連結圖片圖示<br>
<img data-src="https://i.imgur.com/JCnnStN.png" alt="小黑曜石 + 視窗按鈕"></p>
<p>對應 3 種區塊圖片的方式 :</p>
<ol>
<li><code>text</code> : 直接按下按鈕</li>
<li><code>area</code> :  <kbd>shift</kbd> + 按鈕</li>
<li><code>group</code> :  <kbd>ctrl</kbd> + 按鈕</li>
</ol>
<h2 id="實際範例">實際範例</h2>
<p>針對畫板內容來實作不同的截圖方式。<br>
<img data-src="https://i.imgur.com/9mau5Ph.png" alt="|400x320"></p>
<h3 id="text-橘色區塊">text : 橘色區塊</h3>
<p>結果是找不到該區塊 😵<br>
<img data-src="https://i.imgur.com/RVloCQU.png" alt="出現找不到的錯誤訊息"></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">連結顯示的文字 : </span><br><span class="line"> ![[Excalidraw/區域、群組與文字圖片的使用方式.md#^zUw1QSHwfxMypXDbPBNBJ]]</span><br></pre></td></tr></table></figure>
<p>對應實際被標註的 element id 物件，把  Excalidraw 轉成 markdown 就能看見。<br>
<img data-src="https://i.imgur.com/Qt2nIkW.png" alt="|300x200"><br>
會發現實際被標註 id 的是 rectangle ，也就是 group 最外層的橘色方框，理所當然這裡不會有文字，會出現找不到的錯誤訊息。</p>
<blockquote>
<p>不可對圖形包裹的 group 取 text， 等同取非文字區域的文字，就是沒文字🤔</p>
</blockquote>
<p>如果是 <strong>多個文字框</strong> 被 group 起來 (只有文字組成)，並使用 text 的方式取圖片，是可以的，但只會取到第一個文字框。</p>
<h3 id="text-藍色區塊">text : 藍色區塊</h3>
<p>結果只有最後的文字被標註<br>
<img data-src="https://i.imgur.com/Izkkgqi.png" alt="|200x60"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![[Excalidraw/區域、群組與文字圖片的使用方式.md#^P94rSxUw]]</span><br></pre></td></tr></table></figure>
<ul>
<li>markdown 文件標示<br>
找回 markdown 標註的目標，會發現只有「顆顆」被標註到🤔<br>
<img data-src="https://i.imgur.com/ELtkPBQ.png" alt="|300x310"></li>
</ul>
<p>如果我們想要整個藍色區塊為圖片怎麼辦 ?</p>
<h3 id="area-藍色區塊">area : 藍色區塊</h3>
<p>確實取到藍色區塊，但是包含疊在畫面上的東西🤔<br>
<img data-src="https://i.imgur.com/dkS6rqh.png" alt="|300x350"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![[Excalidraw/區域、群組與文字圖片的使用方式.md#^area=P94rSxUw]]</span><br></pre></td></tr></table></figure>
<p>markdown 文件標示的跟 [[#text 針對藍色區塊]] markdown 一樣，因為後面的 element id 跟 text 截取藍色區塊是一樣的，但是 area 很明顯連大區塊 (heading) 都包含了。後面也會凸顯了為什麼 area 是 <code>cutout</code>  (畫面截出來的區域)，並且跟 group 有非常不同的地方。</p>
<h3 id="area-橘色區塊">area : 橘色區塊</h3>
<p>一樣涵蓋了被覆蓋到的部分。<br>
<img data-src="https://i.imgur.com/tRv7yrj.png" alt="|300x350"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![[Excalidraw/區域、群組與文字圖片的使用方式.md#^area=zUw1QSHwfxMypXDbPBNBJ]]</span><br></pre></td></tr></table></figure>
<p>注意這裡的 element id，跟上面 [[#text 橘色區塊]] 一樣，但也會跟底下的 group 一樣，都是對 rectangle 標註 id。</p>
<h3 id="group-橘色區塊">group : 橘色區塊</h3>
<p>確實取到橘色區塊，含一點白色邊框，但範圍不包含覆蓋的綠色圓圈。<br>
<img data-src="https://i.imgur.com/gTT38aq.png" alt="300|280"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">連結顯示的文字 : </span><br><span class="line"> ![[Excalidraw/區域、群組與文字圖片的使用方式.md#^group=zUw1QSHwfxMypXDbPBNBJ]]</span><br></pre></td></tr></table></figure>
<p>好，這邊 area 跟 group 的差別就很明顯了，對於 Obsidian 來說 <code>area</code> 是類似直接對視窗截圖 (說法不是到很精確)，而 group 只計算被群組的範圍，只要不包含都不會被算在內。</p>
<p>具體來說從 markdown 文件來看，group 的一起的文字與圖案，在 <code>json</code> 上的 <code>groupIds</code> 都會被標上一樣的 id，以辨識他們是渲染圖層上的同一組。</p>
<p>area 在 markdown 上可以看做找該區塊的 section heading 視為範圍，至於怎麼計算，應該是文字區塊的 <code>width x height</code> 加上 padding 範圍內的都截圖進去。</p>
<p>padding 的部分只支援 SVG ，可以在該 Excalidraw   的 markdown 文件加上  <code>excalidraw-export-svgpadding</code> 的 metadata，會覆寫預設設定，預設是 10。</p>
<h2 id="SVG-v-s-PNG">SVG v.s PNG</h2>
<p>在 group 與 area 不同的圖片格式會有不同的表現。<br>
<img data-src="https://i.imgur.com/1qYAhUj.png" alt="來源自影片的 1:57 "></p>
<p>上面的範例都只有用 SVG 解釋，但其實可以匯出 PNG，只要在設定把預設匯出 SVG 的按鈕關掉就可以了。<br>
<img data-src="https://i.imgur.com/N5auj8H.png" alt="SVG 預設匯出設定"></p>
<p>根據圖表 text 無論對非文字的取文字是都不行的。但此時如果用 <code>area</code> 去針對橘色區塊截圖，會發現截到 <em>整個畫版</em> 的圖，更簡單來說 <code>area</code> 辨別不出哪裡是個別區塊，只好整張截了。</p>
<p>可以說 PNG 把 markdown 文字標註的 id  <code>(^ids)</code> 忽略了，PNG 不認識字，只認 <strong>物件</strong>，此時對 area 來說整張圖就是一個物件。而 group 還是能截到正確區塊的原因，因為它是透過 json 的 id (別忘了 json 也是一種物件)，所以不會被影響。</p>
<h2 id="圖片原始尺寸">圖片原始尺寸</h2>
<p>影片最後作者提到應用 Excalidraw 插件 ─ <code>Set Dimensions</code> ，校正圖片正確的圖片尺寸，使黏貼在上面的元素能完好符合圖片本身。插件的功能是重新計算區塊大小，讓文字符合其比例。</p>
<p>以 威力在哪裡 為例😄，透過 <code>Set Dimensions</code> 把原始圖片尺寸復原回去，新增的元素就能以比較正確的比例出現。<br>
<img data-src="https://i.imgur.com/krH1Hcy.png" alt="圖源自網路"><br>
會覺得好像沒什麼差別，但我在打字時小圖片的藍色圖塊會被撐大，因為預設文字的比例關係，無法壓縮在壓縮。而原始圖片就沒這問題，在大圖上進行註解不用一直微調其他元素的尺寸。</p>
<h2 id="注意-貼上的圖片-連結圖片的-group">注意 : 貼上的圖片 + 連結圖片的 group</h2>
<p>當我用截圖複製進來的圖片，再用 Excalidraw 的 <code>group</code> 連結圖片，會出現的是截圖的圖片本身，而不是實際上 Excalidraw group 上的區塊。這時候要用 area 先把圖片區塊匯進去再手動改成 group ，才不會被判定成是截圖的單張圖片。</p>
<p>我出問題的步驟 :</p>
<ol>
<li>用 window 內建截圖並且複製圖片到 Excalidraw  貼上</li>
<li>含所有的內容一起群組</li>
<li>用 <code>group</code> 連結的方式貼上</li>
<li>😵 跳出截圖本身的本地文件連結，然後按 back 還回不去</li>
</ol>
<p>先改用 area 再改 group<br>
<img data-src="https://i.imgur.com/x83ulO7.png" alt="area 的範圍會被削到"></p>
<p>我在想是不是一張外部載入的圖片應該也是算一個 id ，所以再辨識時 id 應該是被貼到圖片上，而不是我圈起來的 group。至於 area 則是以區塊來截取，包含圖片與其他文字元素，當範圍確立之後，換成定義的 group 就能更精確的定到… 🤔。</p>
<h2 id="總結-15">總結</h2>
<p>圖片截圖有 3 種 :</p>
<ol>
<li><code>text</code> : 純文字截圖，但不能對非文字截。快捷 : 直接按下按鈕。</li>
<li><code>area</code> : 鄰近區塊截圖，只要看到的都截。快捷 :  <kbd>shift</kbd> + 按鈕。</li>
<li><code>group</code> :  只有被群組 (group) 的才截。 快捷 : <kbd>ctrl</kbd> + 按鈕</li>
</ol>
<p>Excalidraw Plugin 有更多好用的技巧與小工具，我之前都只是為了製造圖片並且匯出 SVG 來附在 markdown 上，直到我看了這部影片，才了解到這 Plugin 的強大。</p>
<p>圖片一直以來是 Obsidian 的硬傷，這麼說是因為無法 <strong>好好用文字來管理圖像</strong>，我們只能把他附加於某個資料夾底下，並且嵌入使用，沒用到的圖片就會放著長灰，也不能對圖片進行其他附加屬性。但 Excalidraw  使圖片具有可被標記的 tag 與 aliases 的方式，跟引入其他的 markdown 筆記段落一樣，更加彈性，重點是可以用搜尋以及 tag 來管理，另外也可以把一整個相關的筆記圖片都放在同一個檔案，變得非常方便。</p>
<p>不過這樣的便利只能留在 Obsidian 本身，像是我如果要搬運到 hexo 上發布， wikilinks 是無法被辨識的，圖片的效果也只能另外匯出來處理😵，只好期許有批量匯出圖片的插件誕生。</p>
<p>另外這部也是來自 Excalidraw-Plugin 作者的影片，他對視覺化的筆記方式有很多想法，甚至可以說是狂熱🤓 的地步，他的頻道與部落格上有很多 PKM 的技巧與再思考。近期我也很好奇 PKM 以及 GTD 這類的東西，YT 上都被推薦類似影片，未來會再來研究研究。</p>
]]></content>
      <categories>
        <category>Obsidian</category>
      </categories>
      <tags>
        <tag>Obsidian</tag>
        <tag>Obsidian-Plugin-Excalidraw</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - 宣告提升(I) - 我以為的以為</title>
    <url>/2022/01/01/JavaScript-Hoisting.html</url>
    <content><![CDATA[<h2 id="前言-16">前言</h2>
<p>宣告提升 (Hoisting) 在 JavaScript 中不得不知<br>
究竟 JavaScript 搞了什麼鬼<br>
導致你認為的值不是那個值捏 !<br>
其實這跟 JavaScript 如何運作也有關係<br>
不過先從最簡單的概念開始吧 ! :O</p>
<h2 id="何謂宣告提升？">何謂宣告提升？</h2>
<p>其實我覺得很抽象<br>
如果單看程式碼會不知道哪裡被提升<br>
以及怎麼被提升？</p>
<p>所謂的提升<br>
其實是 JavaScript 底層運作的機制<br>
必須了解執行環境 (Execution contexts) 跟 作用域 (Scope)<br>
再根據作用域鏈 (Scope Chain) 來看的<br>
不過關於這些東西慢慢地來說<br>
可以先透過幾個例子來了解宣告提升</p>
<h3 id="變數的宣告提升">變數的宣告提升</h3>
<p>這邊暫不討論 ES6 中的 <code>let</code> 與 <code>const</code><br>
以 ES5 的宣告變數 <code>var</code> 為例</p>
<p>基礎題</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">---</span><br><span class="line">result : <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>可以看成 :</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">a = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 幫我們在最上層補上了一個定義變數 a<br>
又因為 JavaScript 是一行行往下讀<br>
所以當執行到 console.log(a)<br>
a 是定義了但沒有值<br>
所以是 <code>undefined</code></p>
<p>那有宣告跟沒宣告的差別？</p>
<p>這樣什麼都沒有就會出錯</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">---</span><br><span class="line">result : a is not defined</span><br></pre></td></tr></table></figure>
<p>所以通常變數的宣告會在最上面<br>
除了版面不會太凌亂以外<br>
也是避免說忘記宣告<br>
尤其是在 function 裡頭</p>
<h3 id="常見問題">常見問題</h3>
<p>function 裡的變數如果未宣告會如何？<br>
可以看下面的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">test</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">	a = <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">result : <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>起初我以為 a 會是 <code>is not defined</code><br>
或是 <code>undefined</code><br>
但是 test 執行時先把變數 a 給提升<br>
並在函式內把 a 賦值 30<br>
也就是這個 a 提升已經到 global 了</p>
<blockquote>
<p>在 function 裡都沒有宣告<br>
但有賦值，就會在 global 的地方宣告該變數<br>
並且 <code>根據 Scope Chain</code> 往上找<br>
不過一般來說不會建議沒有宣告就賦值。</p>
</blockquote>
<h3 id="function-的宣告提升"><code>function</code> 的宣告提升</h3>
<p>除了變數的提升<br>
其實還有 function 也會提升</p>
<p>函式陳述式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">test</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;		</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">result : <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>一般來說要 <strong>使用之前要先宣告</strong><br>
但 function 可以先使用再宣告<br>
因為會宣告提升</p>
<p>可以看成把 <code>function</code> 放到呼叫之前<br>
其他程式語言是沒這樣的<br>
在 JavaScript 想呼叫隨時都可以呼叫 👌<br>
我是覺得很奇妙<br>
但一方面覺得這樣的設計在版面上可以更易讀</p>
<p>函式表達式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>()</span><br><span class="line">---</span><br><span class="line">result : <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>透過表達式宣告一個變數將 function 存起來<br>
這邊的 function 是一個沒有名字的匿名函式<br>
一般來說會這樣執行</p>
<p>如果是宣告變數把函式存起來<br>
提早先呼叫函式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">test</span>()</span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">result : test is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure>
<p>咦！不是 function 隨 call 隨用嗎？<br>
如果是函式表達式可以把整個分為兩塊</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test;</span><br><span class="line"><span class="title function_">test</span>()</span><br><span class="line">test = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是先宣告 test 再賦值<br>
由此可知宣告提升並不會連賦值都一起提升</p>
<p>再來看看有參數的函式呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>我知道！是 <code>undefined</code><br>
因為 a 會做宣告提升<br>
可以看成這樣</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a; <span class="comment">//undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>結果不對，其實是 <code>1</code><br>
這個 1 並不是來自函式的 <code>a=1</code><br>
而是參數的 <code>1</code><br>
由此可以知道函式裡有參數的話<br>
其實參數也會做宣告提升</p>
<p>至於提升的順序為何？<br>
如何提升？<br>
後面會再提到 :D</p>
<h2 id="小結">小結</h2>
<ol>
<li><code>var</code> 會做宣告提升</li>
<li><code>函式陳述式</code> 會做宣告提升</li>
<li><code>函式表達式</code> 是屬於賦值 (等號右邊)，不會做宣告提升</li>
<li>函式的 <code>參數</code> 也會做宣告提升</li>
</ol>
<p>這篇了解哪些會做宣告提升<br>
並且知道賦值的值並不會一起提升</p>
<hr>
<p>參考:</p>
<ul>
<li><a href="https://blog.techbridge.cc/2018/11/10/javascript-hoisting">我知道你懂 hoisting，可是你了解到多深？</a></li>
</ul>
]]></content>
      <categories>
        <category>2022</category>
        <category>01</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - 宣告提升(III) - let &amp; const 以及 TDZ</title>
    <url>/2022/01/01/JavaScript-Hoisting-III.html</url>
    <content><![CDATA[<h2 id="let-const-有宣告提升嗎">let &amp; const 有宣告提升嗎?</h2>
<ul>
<li>看起來沒有 hoisting</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line">---</span><br><span class="line">result : <span class="title class_">Cannot</span> access <span class="string">&#x27;a&#x27;</span> before initialization</span><br></pre></td></tr></table></figure>
<p>意思是 a 還未經初始化。<br>
照 <code>var</code> 的宣告提升<br>
下意識會覺得是 <code>undefined</code> 才對<br>
但怎麼也不是 <code>undefined</code> ?</p>
<ul>
<li>實際上是有提升</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">	<span class="keyword">let</span> a =<span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>()</span><br><span class="line">---</span><br><span class="line">result : <span class="title class_">Cannot</span> access <span class="string">&#x27;a&#x27;</span> before initialization</span><br></pre></td></tr></table></figure>
<p>照理來說在 <code>test</code> 沒找到 a<br>
會往 global (Scope Chain) 去找<br>
應該是 <code>10</code><br>
但是這邊卻是沒有結果<br>
代表 <code>let</code> 確實是有提升而且卡住了</p>
<p>換成 const 也一樣</p>
<h2 id="TDZ-暫時性死區">TDZ - 暫時性死區</h2>
<p>TDZ = Temporal Dead Zone</p>
<p>在 <strong>「提升之後」</strong> 以及 <strong>「賦值之前」</strong> 這段「期間」，如果你存取它就會拋出錯誤，而這段期間就稱做是 <code>TDZ</code></p>
<blockquote>
<p>所以使用 let 或是 const 一開始就要賦值好，以免拋出錯誤</p>
</blockquote>
<p>TDZ 的開始時間<br>
進到 function 的那一刻即是 TDZ<br>
的開始，直到賦值，才是 TDZ 結束。</p>
<hr>
<p>實例解釋</p>
<ul>
<li>TDZ 的起訖點</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">10</span> <span class="comment">//TDZ 🚩</span></span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">5</span></span><br><span class="line">	<span class="keyword">if</span>(a&gt;<span class="number">5</span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> c = <span class="number">1</span>  <span class="comment">// TDZ🪦</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>順序上的問題 : 非空間而是時間的順序</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fucntion <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="title function_">hello</span>()  <span class="comment">// TDZ 🚩</span></span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">5</span> <span class="comment">// TDZ 🪦</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>()</span><br><span class="line">---</span><br><span class="line">result : <span class="title class_">Cannot</span> access <span class="string">&#x27;a&#x27;</span> before initialization</span><br></pre></td></tr></table></figure>
<p>在執行 hello 的時候雖然有提升，但是仍在 a 的 <code>TDZ</code> 裡。</p>
<p>雖然印出值在宣告的下面<br>
以執行(時間)的順序仍在 TDZ 之內。</p>
<h2 id="總結-16">總結</h2>
<p>let 和 const 提升後並不會初始化成 <code>undefined</code>，必須直到賦值之後才跳脫 TDZ 的範圍，在那之前試圖取值都會跳出錯誤。</p>
]]></content>
      <categories>
        <category>2022</category>
        <category>01</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - 資料型態 (II) typeof</title>
    <url>/2022/01/01/JavaScript_typeof.html</url>
    <content><![CDATA[<h2 id="前言-17">前言</h2>
<p>typeof 是檢查類別的好幫手<br>
一學才知道 typeof 只是小小咖<br>
甚至在 stackoverflow 上有這麼一道題目</p>
<p><a href="https://stackoverflow.com/questions/48270127/can-a-1-a-2-a-3-ever-evaluate-to-true">Can (a== 1 &amp;&amp; a ==2 &amp;&amp; a==3) ever evaluate to true?</a></p>
<p>這怎麼可能，<code>1==2==3</code> !?<br>
先了解資料型態，再來了解這怎麼實現!</p>
<h2 id="typeof">typeof</h2>
<p>typeof 可以知道值的型態</p>
<p>在 <code>Object</code>、<code>Array</code>、<code>Date</code> 以及  <strong><code>null</code></strong><br>
都是 <code>Object</code><br>
<code>null</code> 是唯一的特例，下面會再提到</p>
<p><img data-src="https://dsm01pap006files.storage.live.com/y4mGp4At_MjbSIvnrU9AEgFCzvUmROBsIV5v1tGQaDaJY9tAVO1bZcprgUpUOG9btna_AAvZABPjZsB6FFu0hfNETi8bKXOole-CacnFbpoEsUE68p4L8pBfY_r0ptOJloSxkvkTjf6OAJsQ-O7HsfCfLUyxel4VPf35BpS5ZgsEhmrvZo3-fw9IwrOHeoFaey9?width=625&amp;height=390&amp;cropmode=none" alt="typeof各類型"></p>
<ul>
<li>如何真的判斷是 <strong>真</strong> 陣列 ?<br>
Array 會被算在 Object 範疇裡<br>
想要知道真的陣列物件可以使用<br>
<strong><code>Array.isArray(value)</code></strong></li>
</ul>
<p>或者更精確的判別類型<br>
<code>Object.prototype.toString.call(value)</code><br>
prototype 是 JavaScript 很重要的屬性<br>
是實作的一種基底<br>
<code>toString</code> 會把印出物件的屬性轉為字串</p>
<h3 id="null-眾人皆知的漏洞">null 眾人皆知的漏洞</h3>
<ul>
<li><strong>null</strong> 為什麼是 object ?<br>
是 javascript 程式設計上的錯誤<br>
底層實作的 <code>type tag</code> object 是 00<br>
但是 <code>null</code> 也是指向 0<br>
所以 <code>null</code> 也會被判別為 object<br>
是廣為人知的 bug</li>
</ul>
<p>ECMAScript 原本要改規則<br>
<code>typeof null===null</code><br>
但是被拒絕掉了 OAO</p>
<h3 id="更確切一點的型態">更確切一點的型態</h3>
<p><code>Object.prototype.toString.call(value)</code><br>
不管是哪種型態，都可以更正確的被判斷<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mmkfwiKEgP7WgOuN5z81LDBLH4oukWL2ubilP96ARJyClsALcHwh_PvT7MPCtpr0_7dJdQqrI828TQkxB_PfjkIpYpPT3vtTXQ1wUyiGkYK0-cc3NO7nMuB8BTVjtV-kVkboovg7L3y0yIwoTaC95RrR_Bx9LgK-8N1bcq-fciqoSNozQVeSaJ7z3xgt67CIC?width=772&amp;height=395&amp;cropmode=none" alt="toString各類型"></p>
<h3 id="避免出錯的-undefined">避免出錯的 undefined</h3>
<p>JavaScript 是單線程(非同步)的語言<br>
也就是程式會一行行往下執行<br>
但如果要印出沒有定義的變數<br>
必定會錯誤</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">---</span><br><span class="line">result : error </span><br></pre></td></tr></table></figure>
<p>但如果 typeof 某個定義的變數<br>
會是 undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a)</span><br><span class="line">---</span><br><span class="line">result : <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>離奇的是用 var 也是 <code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line">---</span><br><span class="line">result : <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>因為 var 會做宣告提升</p>
<ul>
<li>宣告提升  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var a;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">---</span><br><span class="line"><span class="attr">result</span>: <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
系統會幫你補上未定義的變數<br>
但還是不會賦值</li>
</ul>
<hr>
<p>避免變數沒有定義的情況下出現錯誤<br>
可以用 <code>typeof</code> 檢測</p>
<blockquote>
<p>記住 typeof 回傳的值類別是 <strong>字串</strong><br>
所以後面要是對比字串</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> a !==<span class="string">&#x27;undefined&#x27;</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">	<span class="comment">//dosomething...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>錯誤寫法<br>
會報錯，因為 a 沒有宣告</p>
<pre><code class="language-javascript">	if(a !== undefined)&#123;
		console.log(a)
		//dosomething...
	&#125;
</code></pre>
<hr>
<h2 id="總結-17">總結</h2>
<ol>
<li><code>typeof</code> 回傳的類型是字串</li>
<li><code>typeof null</code> 會回傳值會是 <code>object</code></li>
<li><code>Object.prototype.toString.call()</code> 可以取得較正確的資料型態，包含 <code>null</code> 也會傳 <code>null</code></li>
</ol>
<p>原來如此，typeof 並不是萬能的<br>
在查找 <code>Object.prototype.toString</code> 過程中<br>
也認識到不同類型進行比較時<br>
會轉型同類別再比較<br>
Object type 的轉型會經過兩種規則</p>
<ol>
<li>valueOf</li>
<li>toString</li>
</ol>
<p>之後要再深入研究這兩種的差別<br>
以及各類別的比較規則!</p>
]]></content>
      <categories>
        <category>2022</category>
        <category>01</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSSZeroToOneSeries | 01 | 圖文滿版區塊</title>
    <url>/2022/03/03/CSSSeriesZeroToOne-01.html</url>
    <content><![CDATA[<p>這個系列是從鐵人賽<a href="https://ithelp.ithome.com.tw/users/20112550/ironman/2623">金魚都能懂的這個網頁畫面怎麼切 - 金魚都能懂了你還怕學不會嗎</a>的筆記與實作<br>
原本要叫 Zreo to Hero，從迪士尼大力士的歌曲想到的<br>
但完成金魚系列好像撐不上 Hero XD<br>
就改成 Zero to One 了<br>
代表從零到入門的</p>
<p>起因是覺得自己的 CSS 結構跟用法沒有很妥善<br>
一些性質莫名亂用，簡單來說就是不懂 CSS<br>
透過一天天跟著實作了解 HTML 建置結構與 CSS 乾淨的寫法</p>
<blockquote>
<p>這個系列不做 RWD</p>
</blockquote>
<h2 id="本篇成果-11">本篇成果</h2>
<p><a href="https://codepen.io/shan473/pen/oNoEjNV?editors=0100">Codepen</a><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mFal1-hjaKzBYO0ceMmC3QyeuTEau2VqzDJF9KrNlLlaJqh1_6IA96aYDhEfXLD8hxMLGT-e2HeoUSEuxZzdB9J6Avk0LArKj0fgN4pP4drg_Qdza2-44tROHeK-PkxW5KrMWNXsxRYHNQIlD6Kw6MfCSVx-zj_uT7j_yf072F9X-qDfe2ro6EJNp59rN5m-z?width=1024&amp;height=585&amp;cropmode=none" alt="圖文滿版區塊"></p>
<span id="more"></span>
<h2 id="Reset-一下">Reset 一下</h2>
<p>刻板面之前要先 reset，這樣我們才能掌控間距大小<br>
最常見的是對這三者進行重置</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">list-style</span>:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="什麼是-Reset">什麼是 Reset ?</h3>
<p>每個瀏覽器會預先有 CSS 樣式，但是規格是不一樣，像是 padding 或 margin 究竟是加在 <code>html</code> 還是 <code>body</code> 呢 ?<br>
各個瀏覽器各自有自己的規範，因此在製作上需要先把 CSS Reset 一下，把所有標籤都規定成一樣，再去設計。</p>
<p>像是 li tag 會預設距離 <code>margin-left : 8px</code>，body 還沒 reset 情況下也會有 margin</p>
<h3 id="CSS-Reset-我把你全家變一樣">CSS Reset  :  我把你全家變一樣</h3>
<p>把所有預設外觀都變一樣<br>
所有標籤都必須自己手動加，可以自己掌控元素<br>
不論在哪一個瀏覽器都會把 CSS 歸零。<br>
最常見的是 meyer 的 reset.css</p>
<p>所有標籤的樣式都變一樣，好像有點太超過了，因此出現了 <strong>Normalize CSS</strong>。</p>
<p>=&gt; <a href="https://meyerweb.com/eric/tools/css/reset/">CSS Tools: Reset CSS (meyerweb.com)</a></p>
<h3 id="Normalize-CSS-差很大的修一下">Normalize CSS : 差很大的修一下</h3>
<p>不用到每個都 reset ，針對一些瀏覽器差異性較大屬性進行微調<br>
最大優點是既保留原有 html 標籤的情況下，做修改<br>
很多主流 CSS 框架也是採用 Normalize CSS</p>
<h2 id="萬年問題-inine-v-s-block">萬年問題 : inine v.s block</h2>
<ul>
<li>block : 佔據一整行</li>
<li>inline : 本身元素的寬度</li>
</ul>
<h3 id="inline">inline</h3>
<p>理論上元素跟別人排在一起，但也要看周遭的元素排列。</p>
<blockquote>
<p>最重要的是 <strong>設定寬高是沒用的</strong>，是依照內容去撐高</p>
</blockquote>
<p>具有 inline 屬性的標籤<br>
a 、span</p>
<p>如果加上 padding 跟 margin，並不會影響其他元素的排版狀況，只會把單純的背景撐開。</p>
<p>float 屬性會讓 block 排排站，可以想成是 3D 浮起來。</p>
<h3 id="block">block</h3>
<p>不管多寬都會佔掉一整列，跟 inline 最大區別是 <strong>可以設定寬高</strong></p>
<p>具有 block 屬性的標籤<br>
h(1~6)、p、div …等等</p>
<h3 id="混亂中立-inline-block">混亂中立 : inline-block</h3>
<p>解決 inline 不能設定寬高的，但是又可以跟別人排在一起<br>
繼承 inline 排在同一排，又繼承 block 可以設寬高。</p>
<h4 id="範例一-2">範例一</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">	<span class="selector-tag">h1</span>&#123;</span></span><br><span class="line"><span class="language-css">		<span class="attribute">display</span>： inline；</span></span><br><span class="line"><span class="language-css">	&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>h(1~6) 用 inline 還是沒有被排在一起，因為 p也是 block。<br>
如果 p 也是 inline，就會並排</p>
<h4 id="範例二-2">範例二</h4>
<p>a 變成 block ，會一整行都可以按，即使有寬度元素還是會佔好佔滿</p>
<h3 id="ul-預設是-block">ul : 預設是 block</h3>
<p>edge =&gt; 預設有 <code>padding : 16px;</code> <code>margin : 16px 0;</code></p>
<ul>
<li>如果是 <strong>inline</strong> =&gt; 底下的 li 照排，只是沒有包裹在 ul 容器裡，edge 預設會有 <code>padding-left : 40px</code>，margin 會歸零。</li>
<li>如果是 <strong>inline-block</strong> =&gt; 保有 block 元素</li>
</ul>
<h3 id="li-預設是-list-item">li  : 預設是 list-item</h3>
<p>不屬於兩大派別，而是 list-item</p>
<ul>
<li>如果是 inline ，<code>list-style-type</code>，會不見</li>
<li>如果是 block ，<code>list-style-type</code> 也會不見</li>
<li>如果是 inline-block ，<code>list-style-type</code> 也會不見</li>
</ul>
<p>所以這個 list-item 會包含 list-style-type 這個屬性<br>
可以用 div 跟 span 模仿 ul &amp; li</p>
<iframe height="300" style="width: 100%;" scrolling="no" title="Untitled" src="https://codepen.io/shan473/embed/ZEarWRK?default-tab=html%2Cresult&theme-id=dark" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/shan473/pen/ZEarWRK">
  Untitled</a> by YanShanHong (<a href="https://codepen.io/shan473">@shan473</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>
<h3 id="應用-導覽列">應用 : 導覽列</h3>
<p>把 a 設成 inline-block，這樣可以把高度撐開<br>
但是 HTML 空白字元會佔據 px ，只要把 HTML 擠在一起就不會有問題了<br>
<a href="https://codepen.io/shan473/pen/JjOpWab">Codepen</a></p>
<h2 id="vh">vh</h2>
<p>viewport 的高度，看到的頁面視窗高度<br>
最常看到 100vh，會佔據整個視窗高度</p>
<h2 id="flex-direction-flex-排序的方向">flex-direction : flex 排序的方向</h2>
<p>轉向的同時主軸線的 justify-content 跟次軸 align-items 也要跟著轉哦 !</p>
<ul>
<li>row : 橫向</li>
<li>column : 直向</li>
</ul>
<h2 id="background">background</h2>
<blockquote>
<p><code>background:</code><br>
linear-gradient(115deg,#9198e5 50%,transparent 50%) center center/100% 100% ,<br>
url(‘<a href="https://picsum.photos/1200/600?random=10">https://picsum.photos/1200/600?random=10</a>’) right center/100% 100%;</p>
</blockquote>
<ol>
<li>多個背景疊層用 <code>,</code> 隔開</li>
<li><code>linear-gradient(&lt;角度&gt;, $顏色1 $濃度,$顏色1 $濃度)</code><br>
可以擺放多個顏色跟濃度，角度不只 <code>deg</code> 也可以用 360 算的 <code>turn</code></li>
<li>後面擺放的順序是 <code>poition / size</code>
<ul>
<li><code>size</code> :
<ol>
<li>contain =&gt; 把大小等比例放大跟容器其中一邊等大</li>
<li>cover =&gt; 圖片真實的大小，不夠的會 repeat 到塞滿</li>
<li>% 數 =&gt; 相對容器的多少 %</li>
<li>直接設定 px</li>
<li>auto : 這個蠻複雜的先不討論 QQ</li>
</ol>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>03</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSSZeroToOneSeries</tag>
      </tags>
  </entry>
  <entry>
    <title>CSSZeroToOneSeries | 02 | 互動卡片</title>
    <url>/2022/03/03/CSSSeriesZeroToOne-02.html</url>
    <content><![CDATA[<h2 id="本篇成果-12">本篇成果</h2>
<p><a href="https://codepen.io/shan473/pen/LYOdJjV">Codepen</a><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mBJbcOCZ4CF8WqJt5NbdIirs1thioqss6qbUqW3ReiXiJK9hPjNOthclckHXTZPXb1Y7DFw_kR-UQQmMYqzIWBfGLog7LogLdEVu4TEuI-iaz_91LgvrZteMyvlcB3mxOq4RxeHRiFqrz0JlQOD0O3tLstdIvdeXoDZD7l2saSLi84O8Vhu92m_J2Fd4O1rgh?width=1024&amp;height=585&amp;cropmode=none" alt="互動圖卡"></p>
<span id="more"></span>
<h2 id="圖片間距問題">圖片間距問題</h2>
<p>img 是 inline 元素，但又可以按照圖片大小來設定寬高，所以又很像 inline-block。<br>
而且圖片是沒有 baseline 的，距離下方有會 1 px 的問題。</p>
<p>可以有 2 種情境</p>
<ol>
<li>文字 + 圖片</li>
<li>純圖片(s)</li>
</ol>
<h3 id="vertical-align-垂直對齊">vertical-align 垂直對齊</h3>
<p>設定 <code>vertical-align</code>。vertical-align 是對 <strong>inline</strong> 屬性的元素做垂直對齊的方式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">vertical-align</span> : middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>middle 或 bottom 都可以，只是把圖片往容器下面靠攏，而且不修改圖片的 display 屬性。<br>
在後面有文字的元素我覺得這個方法最適合。</p>
<h3 id="display-block">display: block</h3>
<p>1 px 是來自 inline 的問題，那把 display 修改成 block 就沒毛病了<br>
但如果是好幾張圖並排加上文字，這方法就不適用了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="font-size-0-line-height-0">font-size : 0 &amp; line-height : 0</h3>
<p>如果在沒有文字的情況下，在 <strong>父層</strong> 去除空白文字的空間</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.image-father</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>; || <span class="attribute">line-height</span>: <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="改動-html-結構，讓-inline-擠在一起">改動 html 結構，讓 inline 擠在一起</h3>
<p>不過在多張圖並排也可以利用 html 排列來解決問題，inline 屬性似乎會吃進 1 個 html 空格，這空格也不是 margin…</p>
<ul>
<li>img 元素間有空白</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>擺在一起，空白會消失</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我覺得蠻神奇的，平時在做導覽列 (navbar) 使用 a 標籤來排，也是同一概念<br>
因為 a 也是 inline 屬性，如果想讓 a 無縫隙並排擠在一起寫就行了<br>
上一篇的 <code>應用 : 導覽列</code> 就有示範到囉</p>
<h3 id="超級偷吃步-margin-top-1px">超級偷吃步 margin-top : -1px</h3>
<p>大部分在網路上看到的解決方案是把圖片往上挪 1 px 來解決<br>
起因是很多網頁有超大張 DM 海報要放在網頁，並且切成兩段<br>
造成中間銜接處有 1 px 空白</p>
<p>由於瀏覽器相容性問題，上面的招數只在 chrome 跟 Edge 試過<br>
像是 safiri 、firefox 或 opera 就沒試過了<br>
margin 是都可以用的，應該是最保險的</p>
<h2 id="position-迷思">position 迷思</h2>
<p>子層用 absolute ，父層不一定用 relative</p>
<blockquote>
<p>只是找上面不是 static (預設) 定位的元素</p>
</blockquote>
<h3 id="補充-常見技巧-蓋滿全版">補充 : 常見技巧 蓋滿全版</h3>
<p>有時候想蓋滿容器，不一定要用 100% 來使用<br>
如果遇到 inline 屬性既不能設高度也不能設寬度<br>
這時候就可以透過 position 加上定位值來撐開</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>2022</category>
        <category>03</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSSZeroToOneSeries</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | Sass 小技巧</title>
    <url>/2022/03/03/CSS-Sass-03-tips.html</url>
    <content><![CDATA[<p>根據鐵人賽<a href="https://ithelp.ithome.com.tw/users/20040221/ironman/562">《30天掌握Sass語法》</a> 各篇筆記總結<br>
在最後也建立一個屬於自己的 Sass template<br>
當然我的 Sass 旅途還沒結束 !</p>
<span id="more"></span>
<h2 id="sass-可以幫你算數">sass 可以幫你算數</h2>
<p>可以讓 sass 算數學，編譯後自動幫我們算好，可以包含 px、%、em<br>
pure css 雖然也可以算數 (calc) 但是對效能不好。</p>
<blockquote>
<p>sass 的 px 跟 em 不能混算</p>
</blockquote>
<h2 id="檔案編譯規則">檔案編譯規則</h2>
<p>加 <code>_</code> 底線是不轉換成 css 檔的引入檔，可以放<code>_variable</code> 等等檔案<br>
引入的時候不用加底線。</p>
<p>也可以把各頁獨立開來，或是各部件分開引入</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> reset</span><br><span class="line">@import layout</span><br><span class="line">@import index</span><br><span class="line">@import page</span><br></pre></td></tr></table></figure>
<p>最上方就是放 reset ，其餘樣式往後覆蓋</p>
<h2 id="extend-v-s-mixin">@extend v.s @mixin</h2>
<p>@extend 就是模板，不能帶參數，但可以把相同的樣式給群組起來，對檔案體積較小<br>
@mixin 就像 copy paste ，把同樣的東西複製貼上</p>
<p>如果有個別客製化的參數可以使用 @mixin</p>
<h2 id="節省寫前綴-prefix">節省寫前綴 prefix</h2>
<p>很多人是使用 plugin compass 產生，但是這套好像太久沒更新<br>
後來直接搭上 PostCSS 的順風車，幫你內建好<br>
不過也是可以自己寫</p>
<p>用 @mixin 與 @each 產生</p>
<ol>
<li>有 property name</li>
<li>value</li>
<li>prefix : 是一個 list，可以插入想要的 prefix</li>
</ol>
<p>前面兩者是 css 表達式，可以寫成 map 的形式，讓 prefix 可以一次寫多個</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$property</span> : (key:value,key,value)</span><br></pre></td></tr></table></figure>
<p>MDN 列出常見的 prefix</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-webkit-<span class="attribute">transition</span>: all <span class="number">4s</span> ease;</span><br><span class="line">-moz-<span class="attribute">transition</span>: all <span class="number">4s</span> ease;</span><br><span class="line">-ms-<span class="attribute">transition</span>: all <span class="number">4s</span> ease;</span><br><span class="line">-o-<span class="attribute">transition</span>: all <span class="number">4s</span> ease;</span><br><span class="line"><span class="attribute">transition</span>: all <span class="number">4s</span> ease;</span><br></pre></td></tr></table></figure>
<p>改成 @mixin ，單個 property</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> vendor-prefix(<span class="variable">$property</span>,<span class="variable">$value</span>,<span class="variable">$prefixes</span>:())</span><br><span class="line">	<span class="keyword">@each</span> <span class="variable">$prefix</span> in <span class="variable">$prefixes</span></span><br><span class="line">		#&#123;&#x27;-&#x27;+<span class="variable">$prefix</span>+&#x27;-&#x27;+<span class="variable">$property</span>&#125; : <span class="variable">$value</span></span><br><span class="line"></span><br><span class="line">	// 補上原本的</span><br><span class="line">	#&#123;<span class="variable">$property</span>&#125; : <span class="variable">$value</span> </span><br></pre></td></tr></table></figure>
<p>一次寫多個 property，把前面的 property 跟 value 合併起來</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> vendor-prefix(<span class="variable">$declarations</span>,<span class="variable">$prefixes</span>:())</span><br><span class="line">	<span class="keyword">@each</span> <span class="variable">$property</span>,<span class="variable">$value</span> in <span class="variable">$declarations</span></span><br><span class="line">		<span class="keyword">@each</span> <span class="variable">$prefix</span> in <span class="variable">$prefixes</span></span><br><span class="line">			#&#123;&#x27;-&#x27;+<span class="variable">$prefix</span>+&#x27;-&#x27;+<span class="variable">$property</span>&#125; : <span class="variable">$value</span></span><br><span class="line">	</span><br><span class="line">	#&#123;<span class="variable">$property</span>&#125; : <span class="variable">$value</span></span><br></pre></td></tr></table></figure>
<p>參考 :<br>
<a href="https://css-tricks.com/snippets/sass/mixin-prefix-properties/">Mixin to Prefix Properties | CSS-Tricks - CSS-Tricks</a></p>
<h2 id="RWD-寫法">RWD 寫法</h2>
<p>寫法有兩種</p>
<ol>
<li>傳統 : 寫在最上方分成不同的 breakpoint 檔案</li>
<li>@content : 用 @include 方式插在元件上繼續寫</li>
</ol>
<h3 id="寫一個-media-就好，元素屬性都另外再寫">寫一個 media 就好，元素屬性都另外再寫</h3>
<p>@media query 只有一個，一次都寫在裡面</p>
<ul>
<li>pc.sass</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1024px</span>)</span><br><span class="line">	.box</span><br><span class="line">		~~~~~~~</span><br></pre></td></tr></table></figure>
<ul>
<li>pad.sass</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>)</span><br><span class="line">	.box</span><br><span class="line">		~~~~~~~</span><br></pre></td></tr></table></figure>
<h3 id="統一生成斷點，插在元素裡面寫">統一生成斷點，插在元素裡面寫</h3>
<p>mixin</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> breakpoint(<span class="variable">$point</span>)</span><br><span class="line">	<span class="keyword">@if</span> <span class="variable">$point</span> == pc</span><br><span class="line">		<span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1024px</span>)</span><br><span class="line">			<span class="keyword">@content</span></span><br><span class="line">	<span class="keyword">@else</span> if <span class="variable">$point</span> == pad</span><br><span class="line">		<span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>)</span><br><span class="line">			<span class="keyword">@content</span></span><br><span class="line">	<span class="keyword">@else</span> if <span class="variable">$point</span> == mobile</span><br><span class="line">		<span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">320px</span>)</span><br><span class="line">			<span class="keyword">@content</span></span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span></span><br><span class="line">	<span class="attribute">width</span>: <span class="number">500px</span></span><br><span class="line">	height: <span class="number">500px</span></span><br><span class="line">	@include <span class="built_in">breakpoint</span>(pc)</span><br><span class="line">		width: <span class="number">1000px</span></span><br><span class="line">		height: <span class="number">1000px</span></span><br><span class="line">	@include <span class="built_in">breakpoint</span>(pad)</span><br><span class="line">		width: <span class="number">300px</span></span><br><span class="line">		height: <span class="number">300px</span></span><br></pre></td></tr></table></figure>
<ul>
<li>優點 : 撰寫上比較方便，因為是寫在元素裡面</li>
<li>缺點 : 會一直重複生成 @media 對檔案大小不是很友善，大專案如果有追求效能不太適合</li>
</ul>
<h2 id="sass-檔案結構">sass 檔案結構</h2>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> mixin </span><br><span class="line"><span class="keyword">@import</span> reset</span><br><span class="line"><span class="keyword">@import</span> layout</span><br></pre></td></tr></table></figure>
<p>mixin 放一些主要要引入的變數，mixin 沒呼叫就不會產生任何東西<br>
可以在一開始引入</p>
<p>參考這份結構 <a href="https://gist.github.com/AdamMarsden/7b85e8d5bdb5bef969a0">Sass Architecture Structure</a></p>
<ul>
<li>vendor : 其他的 plugin。boostrap 等等的第三方套件。</li>
<li>utils : 基本的 <code>__variable</code>、<code>__mixin</code>、<code>__function</code></li>
<li>base : css reset 或是 文字規範 (h1~h6)</li>
<li>component : 小零件，像是按鈕、</li>
<li>layout : 每一頁面共同元素。導覽列、網頁底部、</li>
<li>pages : css 組裝，不同頁面有用到的元素透過 layout 、 component 組合</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;utils/variable&#x27;</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;utils/mixin&#x27;</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;base/reset&#x27;</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;component/button&#x27;</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;layout/navbar&#x27;</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;pages/index&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="color-好幫手-draken-lignten">color 好幫手 draken &amp; lignten</h2>
<p>有時候需要建置顏色資料庫<br>
相同色系但有不同深淺或是些微變化<br>
不用一直複製新的色票<br>
可以透過 sass 內建函式來幫我們達成</p>
<p>sass 內建可以調整 <strong>明暗、飽和(saturate) 或 色象環 (hue)</strong> 等等的功能<br>
而且可以用組合式的<br>
如果很熟悉 hsl 的方法就知道運作模式 <code>hsl(&lt;hue 色相環&gt;,飽和度,亮度)</code></p>
<ul>
<li>darken &amp; lignten : 值 0 ~ 50，想降低亮度就用 darken</li>
<li>desaturate &amp; saturate :  根據原本色彩的飽和去做疊加，如果原本色彩的飽和本身就很高，再增加飽和也沒意義</li>
<li>adjust_hue  : 以目前色環的顏色方向再去疊加</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">background</span> : <span class="built_in">adjust_hue</span>(<span class="built_in">desaturate</span>(<span class="built_in">lighten</span>(blue,<span class="number">10</span>),<span class="number">10</span>),<span class="number">120</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根據步驟來說</p>
<ol>
<li>被調整的是 藍色，亮度調整 10 %</li>
<li>降低飽和 10%</li>
<li>色相環轉動 120 度，藍色是 240 ，再轉 120 就到紅色</li>
</ol>
<p>最後結果會是 hsl(0,90%,60%)<br>
想快速產生也可以用 <a href="https://sassme.jim-nielsen.com/">SassMe</a></p>
<h3 id="建立色彩資料庫">建立色彩資料庫</h3>
<p>像 tailwindcss 有很豐富的顏色，透過不同數值調整參數<br>
我們也可以使用 @for 迴圈來變化，並且使用在 html 加上 class 直接套用<br>
使用上很方便，但檔案就會越來越肥 QQ<br>
這時候就會選擇 boostrap 或是 tailwindcss :D…</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$primary</span> : blue</span><br><span class="line">@for <span class="variable">$i</span> from <span class="number">1</span> through <span class="number">4</span></span><br><span class="line">  .primary-d-#&#123;<span class="variable">$i</span>*<span class="number">10</span>&#125;</span><br><span class="line">    <span class="attribute">background</span> : <span class="built_in">darken</span>(<span class="variable">$primary</span> ,<span class="variable">$i</span> * <span class="number">10</span>)</span><br><span class="line">  .primary-l-#&#123;<span class="variable">$i</span>*<span class="number">10</span>&#125;</span><br><span class="line">    <span class="attribute">background</span> : <span class="built_in">lighten</span>(<span class="variable">$primary</span> ,<span class="variable">$i</span> * <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h2 id="sass-合作問題">sass 合作問題</h2>
<ul>
<li>如果合作人不會寫 sass ?<br>
用 scss 寫，scss 跟一般 css 檔案沒什麼差別，把 .css 改成 .scss。<br>
要使用檔案 import 進來就 ok 的。</li>
<li>共用樣式或測試<br>
做成 @extend 引入做測試</li>
</ul>
<h2 id="設計網站版本">設計網站版本</h2>
<p>如果網站中不同頁面有不同的樣式，傳統上會準備兩分 .css 檔，透過後者覆蓋前者的特性，把預設的蓋掉。</p>
<p>比如說不同的電商網站根據不同種類的網頁套用不同樣式顏色。<br>
<code>food.css</code>、<code>clothes.css</code> 等等</p>
<ul>
<li>優點 : 分檔案好管理</li>
<li>缺點 :
<ol>
<li>多發出 request</li>
<li>CSS 結構很胖</li>
</ol>
</li>
</ul>
<h3 id="nth-index">nth &amp; index</h3>
<p>index 找到第幾位，對應 nth 來應用</p>
<p>這邊以四季為例</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$season</span>: spring , summer , fall , winter</span><br><span class="line"><span class="variable">$primary-color</span> : green , yellow , orange , grey</span><br><span class="line"><span class="variable">$secondary-color</span>: <span class="number">#fff</span> , <span class="number">#05f</span> , <span class="number">#00f</span> , <span class="number">#000</span></span><br><span class="line"><span class="variable">$now-season</span> : <span class="built_in">index</span>(<span class="variable">$season</span>,spring)</span><br><span class="line"></span><br><span class="line">//-------------</span><br><span class="line">.navbar</span><br><span class="line">  width: <span class="number">100%</span></span><br><span class="line">  height: <span class="number">100px</span></span><br><span class="line">  font-size: <span class="number">60px</span></span><br><span class="line">  background: <span class="built_in">nth</span>(<span class="variable">$primary-color</span>,<span class="variable">$now-season</span>)</span><br><span class="line">  color: <span class="built_in">nth</span>(<span class="variable">$secondary-color</span>,<span class="variable">$now-season</span>)</span><br></pre></td></tr></table></figure>
<h2 id="使用-if-提升-Mixin-靈活度">使用 @if 提升 @Mixin 靈活度</h2>
<p>產生簡單圖案，降低 request 請求數量<br>
不用再另外做圖，避免不同尺寸的裝置造成失真</p>
<ul>
<li>生成圓形</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">%<span class="attribute">border-radius</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span></span><br><span class="line"></span><br><span class="line">@mixin <span class="built_in">circle</span>(<span class="variable">$size</span>,<span class="variable">$color</span>)</span><br><span class="line">  width: <span class="variable">$size</span></span><br><span class="line">  height: <span class="variable">$size</span></span><br><span class="line">  background-color: <span class="variable">$color</span></span><br><span class="line">  @extend %border-radius</span><br><span class="line"></span><br><span class="line">.box</span><br><span class="line">	+<span class="built_in">circle</span>(<span class="number">50px</span>,red)</span><br></pre></td></tr></table></figure>
<ul>
<li>生成三角形</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> triangle(<span class="variable">$size</span>,<span class="variable">$pos</span>,<span class="variable">$color</span>,<span class="variable">$ratio</span> :<span class="number">1</span>)</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span></span><br><span class="line">  <span class="keyword">@if</span> <span class="variable">$pos</span> == top</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="variable">$size</span>*<span class="variable">$ratio</span> solid <span class="variable">$color</span></span><br><span class="line">    <span class="attribute">border-left</span>: <span class="variable">$size</span>/<span class="number">2</span> solid transparent</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="variable">$size</span>/<span class="number">2</span> solid transparent</span><br><span class="line">  <span class="keyword">@else</span> if <span class="variable">$pos</span> == top-left</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="variable">$size</span> solid <span class="variable">$color</span></span><br><span class="line">    <span class="attribute">border-left</span>: <span class="variable">$size</span> solid transparent</span><br><span class="line">  <span class="keyword">@else</span> if <span class="variable">$pos</span> == top-right</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="variable">$size</span> solid <span class="variable">$color</span></span><br><span class="line">    <span class="attribute">border-right</span>: <span class="variable">$size</span> solid transparent</span><br><span class="line">  <span class="keyword">@else</span> if <span class="variable">$pos</span> == bottom</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="variable">$size</span>*<span class="variable">$ratio</span> solid <span class="variable">$color</span></span><br><span class="line">    <span class="attribute">border-left</span>: <span class="variable">$size</span>/<span class="number">2</span> solid transparent</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="variable">$size</span>/<span class="number">2</span> solid transparent</span><br><span class="line">  <span class="keyword">@else</span> if <span class="variable">$pos</span> == bottom-left</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="variable">$size</span> solid <span class="variable">$color</span></span><br><span class="line">    <span class="attribute">border-right</span>: <span class="variable">$size</span> solid transparent</span><br><span class="line">  <span class="keyword">@else</span> if <span class="variable">$pos</span> == bottom-right</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="variable">$size</span> solid <span class="variable">$color</span></span><br><span class="line">    <span class="attribute">border-left</span>: <span class="variable">$size</span> solid transparent</span><br><span class="line">  <span class="keyword">@else</span> if <span class="variable">$pos</span> == right</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="variable">$size</span>/<span class="number">2</span> solid transparent </span><br><span class="line">    <span class="attribute">border-left</span>: <span class="variable">$size</span>*<span class="variable">$ratio</span> solid <span class="variable">$color</span></span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="variable">$size</span>/<span class="number">2</span> solid transparent</span><br><span class="line">  <span class="keyword">@else</span> if <span class="variable">$pos</span> == left</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="variable">$size</span>/<span class="number">2</span> solid transparent </span><br><span class="line">    <span class="attribute">border-right</span>: <span class="variable">$size</span>*<span class="variable">$ratio</span> solid <span class="variable">$color</span></span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="variable">$size</span>/<span class="number">2</span> solid transparent</span><br><span class="line">// ------------------------</span><br><span class="line">    </span><br><span class="line">.box</span><br><span class="line">  +triangle(<span class="number">100px</span>,top-left,red)</span><br></pre></td></tr></table></figure>
<ul>
<li>參考 : <a href="https://css-tricks.com/snippets/css/css-triangle/">CSS Triangle | CSS-Tricks - CSS-Tricks</a></li>
</ul>
<h3 id="應用-2">應用</h3>
<ol>
<li><a href="https://codepen.io/shan473/pen/YzYwjZR?editors=0100">對話框</a>，搭配上面的三角形 @mixin <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span></span><br><span class="line"> <span class="attribute">width</span>: <span class="number">100px</span></span><br><span class="line"> height: <span class="number">100px</span></span><br><span class="line"> background-color: <span class="number">#ccc</span></span><br><span class="line"> position: relative</span><br><span class="line"> border-radius: <span class="number">10px</span></span><br><span class="line"> &amp;:before</span><br><span class="line">   content: <span class="string">&#x27;&#x27;</span></span><br><span class="line">   position: absolute</span><br><span class="line">   top:<span class="number">100%</span></span><br><span class="line">   left:<span class="number">30%</span></span><br><span class="line">   +<span class="built_in">triangle</span>(<span class="number">20px</span>,bottom,<span class="number">#ccc</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><a href="https://codepen.io/shan473/pen/YzYwjZR?editors=0100">麵包屑 (breadcrumb)</a> :</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span></span><br><span class="line">.breadcrumb</span><br><span class="line">  display: flex</span><br><span class="line">  justify-content: center</span><br><span class="line">  align-items: center</span><br><span class="line">  flex-wrap: wrap</span><br><span class="line">  padding: <span class="number">20px</span></span><br><span class="line">  li</span><br><span class="line">    list-style: none</span><br><span class="line">    background-color: <span class="number">#054</span></span><br><span class="line">    padding: <span class="number">10px</span> <span class="number">20px</span> <span class="number">10px</span> <span class="number">40px</span> </span><br><span class="line">    position: relative</span><br><span class="line">    &amp; + li</span><br><span class="line">      margin-left: <span class="number">40px</span></span><br><span class="line">    &amp;:before</span><br><span class="line">        left: <span class="number">0%</span></span><br><span class="line">        +<span class="built_in">triangle</span>(<span class="number">40px</span>,right,<span class="number">#000</span>)</span><br><span class="line">    &amp;:after</span><br><span class="line">        left: <span class="number">100%</span></span><br><span class="line">        +<span class="built_in">triangle</span>(<span class="number">40px</span>,right,<span class="number">#054</span>)</span><br><span class="line">    &amp;:first-child:before</span><br><span class="line">      all: initial</span><br><span class="line">    &amp;:last-child:after</span><br><span class="line">      all: initial</span><br><span class="line">    a</span><br><span class="line">      text-decoration: none</span><br><span class="line">      margin-left: <span class="number">20px</span></span><br><span class="line">      color: <span class="number">#fff</span></span><br><span class="line">      font-weight: bold</span><br><span class="line">    &amp;:before,&amp;:after</span><br><span class="line">      content: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      position: absolute</span><br><span class="line">      top: <span class="number">0</span></span><br><span class="line">      bottom: <span class="number">0</span></span><br><span class="line">      margin: auto</span><br><span class="line">    &amp;:first-child</span><br><span class="line">      border-radius: <span class="number">10px</span> <span class="number">0px</span> <span class="number">0</span> <span class="number">10px</span> </span><br><span class="line">      padding-left: <span class="number">10px</span></span><br><span class="line">    &amp;:last-child</span><br><span class="line">      border-radius: <span class="number">0</span> <span class="number">10px</span> <span class="number">10px</span> <span class="number">0</span></span><br><span class="line">      padding-right: <span class="number">20px</span></span><br></pre></td></tr></table></figure>
<h2 id="for-random">@for+random()</h2>
<p><a href="https://codepen.io/shan473/pen/WNdrLWy?editors=0100">balls</a><br>
利用 shadow 來產生分身，有點像 texture  把東西蓋上去做整體位移<br>
用 function 生成隨機的變數，在疊加上去做 box-shadow 的位移</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> randoms(<span class="variable">$n</span>)</span><br><span class="line">  <span class="variable">$value</span>: #&#123;<span class="built_in">random</span>(<span class="number">2000</span>)&#125;+px #&#123;<span class="built_in">random</span>(<span class="number">2000</span>)&#125;+px <span class="selector-id">#fff</span></span><br><span class="line">  <span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> through <span class="variable">$n</span></span><br><span class="line">    <span class="variable">$value</span> :  #&#123;<span class="variable">$value</span>&#125; , #&#123;<span class="built_in">random</span>(<span class="number">2000</span>)&#125;+px #&#123;<span class="built_in">random</span>(<span class="number">2000</span>)&#125;+px <span class="selector-id">#fff</span></span><br><span class="line">  <span class="keyword">@return</span> <span class="variable">$value</span></span><br><span class="line"></span><br><span class="line">body</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span></span><br><span class="line">.ball</span><br><span class="line">  <span class="attribute">position</span>: absolute</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span></span><br><span class="line">.ball-big</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span></span><br><span class="line">  <span class="attribute">box-shadow</span>: randoms(<span class="number">300</span>)</span><br><span class="line">  animation : drop <span class="number">50s</span> infinite linear</span><br><span class="line">.ball-medium</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">5px</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5px</span></span><br><span class="line">  <span class="attribute">box-shadow</span>: randoms(<span class="number">500</span>)</span><br><span class="line">  animation : drop <span class="number">15s</span> infinite linear</span><br><span class="line">.ball-small</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2px</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2px</span></span><br><span class="line">  <span class="attribute">box-shadow</span>: randoms(<span class="number">700</span>)</span><br><span class="line">  animation : drop <span class="number">10s</span> infinite linear</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> drop</span><br><span class="line">  <span class="number">0%</span></span><br><span class="line">  <span class="number">100%</span></span><br><span class="line">    <span class="attribute">transform</span>: translate(<span class="number">0</span>,-<span class="number">2000px</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Sass開發流程設計">Sass開發流程設計</h2>
<h3 id="切圖、規劃Layout">切圖、規劃Layout</h3>
<p>美術</p>
<ol>
<li>互動部分是否有設計出來 (hover、dropdown 等等)</li>
<li>背景圖要切透明 (避免不規則形狀)</li>
<li>字體字型，如果不是預設 web font 有無替代的</li>
</ol>
<p>事先規劃 :</p>
<ul>
<li>layout 如何合作設計 ? 共同的元素 ?</li>
<li>預先規劃 html 架構</li>
<li>畫面手寫輔助思考</li>
<li>圖片可以分成 png &amp; jpg (或者 svg)</li>
</ul>
<h3 id="結構規劃、全域變數設定">結構規劃、全域變數設定</h3>
<p>變數名稱 跟 內容不要有關<br>
像是顏色的變數，不要以顏色種類命名<br>
一般來說有設計稿有主色、次級色或是顏色的用途</p>
<ul>
<li>$red : <code>#ff0000</code> ------(👎)</li>
<li>$primary-color : <code>#ff0000</code> ------(👍)</li>
<li>$highlight-color: <code>#ff0000</code> ------(👍)</li>
</ul>
<h3 id="網頁排版流程">網頁排版流程</h3>
<ul>
<li>reset css</li>
<li>clearfix 預先寫好  <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">%clearfix</span><br><span class="line">  &amp;<span class="selector-pseudo">::after</span></span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    clear: both</span><br><span class="line">    display: block</span><br></pre></td></tr></table></figure>
</li>
<li>background 使用 @mixin 節省路徑的寫法<br>
預防還有複合路徑，我把額外的 path 寫在最後面<br>
還有不同的格式，所以就多寫 format，沒有把檔名寫死<br>
根路徑就可以按照想要的圖庫來放  <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$root</span> : <span class="string">&#x27;../img/&#x27;</span></span><br><span class="line">@mixin <span class="built_in">img-url</span>(<span class="variable">$name</span>,<span class="variable">$format</span>,<span class="variable">$path</span>: null)</span><br><span class="line">  <span class="variable">$file</span> : #&#123;<span class="variable">$name</span>+&#x27;.&#x27;+<span class="variable">$format</span>&#125;</span><br><span class="line">  <span class="variable">$fullpath</span> : null</span><br><span class="line">  @if <span class="variable">$path</span></span><br><span class="line">    <span class="variable">$fullpath</span> : #&#123;<span class="variable">$root</span>+<span class="variable">$path</span>+ &#x27;/&#x27;+<span class="variable">$file</span>&#125;</span><br><span class="line">  <span class="keyword">@else</span></span><br><span class="line">    <span class="variable">$fullpath</span> :#&#123;<span class="variable">$root</span>+<span class="variable">$file</span>&#125;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(#&#123;<span class="variable">$fullpath</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li>prefix :  瀏覽器前綴[[#節省寫前綴 prefix]]，用套件或是自己用 @mixin 寫<br>
postcss 具有 autoprefix，或是 compass</li>
</ul>
<p>大部分共用的變數</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$text-color</span> : 主體文字色彩</span><br><span class="line"><span class="variable">$link-color</span> : 連結字顏色</span><br><span class="line"><span class="variable">$link-hover-color</span> : 連結字 hover 顏色</span><br><span class="line"><span class="variable">$line-hiehgt</span> : 字距航高</span><br><span class="line"><span class="variable">$container-width</span> : 區塊寬度</span><br><span class="line"><span class="variable">$font-style</span> : 字體</span><br></pre></td></tr></table></figure>
<p>在切版中把重複性高的獨立出來</p>
<h3 id="整合自己的-Sass-資料夾">整合自己的 Sass 資料夾</h3>
<p><a href="https://github.com/meitung473/Sass-template">我的 sass 資料夾</a><br>
資料夾結構</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">|- src</span></span><br><span class="line">    <span class="string">|- img</span></span><br><span class="line">    <span class="string">|- sass</span></span><br><span class="line">        <span class="string">|- base : css reset、typography</span></span><br><span class="line">        <span class="string">|- component : button、link...</span></span><br><span class="line">        <span class="string">|- layout : 通用版面，header 、 navgation、footer</span></span><br><span class="line">        <span class="string">|- pages : 個別頁</span></span><br><span class="line">        <span class="string">|- utils : variable、mixin、extend 等等</span></span><br><span class="line">        <span class="string">|- vendors : 放 sass-plugin</span></span><br><span class="line">        <span class="string">|- section (目前沒有) :  頁面區塊，hero、cta</span></span><br><span class="line">    - app.sass</span><br><span class="line">    - index.html</span><br></pre></td></tr></table></figure>
<p>每個資料夾都有 all.sass 整合資料夾內的 @import</p>
<ul>
<li>base<br>
裡面已有 meyer 版本的 reset.css</li>
<li>utils/mixin
<ol>
<li>media query breakpoint</li>
<li>img-url background-image 快速匯入<br>
參數 <code>(&lt;檔案名&gt;,&lt;副檔名&gt;,&lt;複合路徑&gt;(optional))</code><br>
裡面的 <code>$root</code> 可以更換圖片根目錄路徑</li>
<li>prefix 手動添加瀏覽器前綴<br>
參數 <code>(&lt;css-property&gt;,&lt;value&gt;,&lt;prefix list&gt;)</code></li>
<li>基礎形狀圓形、三角形<br>
圓形參數 <code>(&lt;size&gt;,&lt;color&gt;)</code><br>
三角形參數 <code>(&lt;size&gt;,&lt;三角形位置&gt;,&lt;color&gt;,&lt;預設 1 是等腰，86.6% 為正三角&gt;)</code></li>
</ol>
</li>
</ul>
<h2 id="總結-18">總結</h2>
<p>Sass 當然還有更多東西可以去研究<br>
在文章裡還包含常用的 sass plugin<br>
compass、susy 等等<br>
考量到這系列文章的年份<br>
發現這兩者已經停止維護<br>
這部分我就沒有去特別著墨了<br>
不過依然讓我學到不少東西</p>
]]></content>
      <categories>
        <category>2022</category>
        <category>03</category>
      </categories>
      <tags>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title>CSSZeroToOneSeries | 04 | 交錯漂浮版</title>
    <url>/2022/03/03/CSSSeriesZeroToOne-04.html</url>
    <content><![CDATA[<h2 id="本篇成果-13">本篇成果</h2>
<p><a href="https://codepen.io/shan473/pen/JjOZEBv">Codepen</a><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4myrS3n9KEVx68j_Eae0KRrAYX2x2pFSw4IpKeLRuSQUsYqqzoIbIJ_TZHOxs96dBkjq9Or4jrv4cbmLYZJHh8XJf5UwXUa8Fst54z9sV0FCDctxAGmKDM3WK1sB4h8QsOqArz8DIpcZX4fpHELmYZC4xd994q-I2LITANufFsVCXWAneTdCRxsl7eG7xqpK_I?width=1024&amp;height=1016&amp;cropmode=none" alt="交錯漂浮版"></p>
<span id="more"></span>
<h2 id="box-sizing-盒子計算方式">box-sizing 盒子計算方式</h2>
<p>box sizing 有兩種屬性</p>
<ul>
<li><code>content-box</code> : 只有內容 (width) 的大小，其他另外算 (padding、border)</li>
<li><code>border-box</code> : 到 border 之前的都計算在內</li>
</ul>
<p>在早期瀏覽器支援度沒那麼高，都會加上前綴 (prefix)<br>
如果擔心使用的瀏覽器是否有支援也可以到 <a href="https://caniuse.com/?search=box-sizing">caniuse</a> 查詢</p>
<h2 id="flex-shirk-壓縮值">flex-shirk : 壓縮值</h2>
<p>父層設定 flex 後<br>
預設內容會進行並排而且壓縮<br>
壓縮值預設是 flex-shirk : 1<br>
所有子項會照數目去壓縮寬度</p>
<p>如果是 0 的話 flex 不會幫你壓內容<br>
而是解開束縛~</p>
<p>在這個排版中我們將兩個子元素 <code>.txt</code> 跟 <code>.pic</code>  width 設定 55%<br>
整體容器的大小照理來說是 110%<br>
但實際上預設最大值只有 100%<br>
在還未設定 flex-shirk 之前，我們可以看到容器實際大小是 600 而不是 660<br>
即使設定兩個子項都設 100% ，flex 還是只會將空間平均分配後縮壓</p>
<p>這時候只要加上 flex-shirk : 0，把壓縮比取消<br>
正確的寬度就會是 660 了</p>
<p>這也是為什麼有人設定完 flex 後，想把剩餘空間平均撐開<br>
填入 width 把原本內容還大的數值<br>
因為 flex 自己就會幫你壓完算完</p>
<h2 id="nth-child-選兒子">nth-child : 選兒子</h2>
<p>跟 nth-of-type 很像，但是 nth-child 只認位置</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 翻譯 : 是第一個，而且 class 是 box 的 */</span></span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;&#125; </span><br><span class="line"><span class="comment">/* 翻譯 : 是第一個，而且在 box 裡 */</span></span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;&#125;  </span><br></pre></td></tr></table></figure>
<p>但如果配上 <code>&gt;</code> ，如果有孫子，並不包含在內，因為 <code>&gt;</code> 是指下一層而已，只包到兒子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grand&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 被套入樣式的只有 grand 裡面第一個 fater，但是 child 不會有 */</span></span><br><span class="line"><span class="selector-class">.grand</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>也可以奇數、偶數</p>
<ul>
<li>奇數 : <code>nth-child(odd)</code></li>
<li>偶數 : <code>nth-child(even)</code></li>
</ul>
]]></content>
      <categories>
        <category>2022</category>
        <category>03</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSSZeroToOneSeries</tag>
      </tags>
  </entry>
  <entry>
    <title>CSSZeroToOneSeries | 03 | 人員介紹卡片</title>
    <url>/2022/03/03/CSSSeriesZeroToOne-03.html</url>
    <content><![CDATA[<h2 id="本篇成果-14">本篇成果</h2>
<p><a href="https://codepen.io/shan473/pen/qBVKqOO">Codepen</a><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mHzg-JW7SyoAHGTdGlUdj_5ZnwCD4xI67k_hSfC3GQoVpUstnuk7UTBR7UmUJpb13ZdYrbWwiYAHfilOlHT7mMJQ7HXqcji-jzR8muC__o_Dw1iYTtrnTdQi6XfOoLIEtZsrFHqsrZq3aNmq8disMaXDMzI_RxGM47SUv3SgTztsiBsVOTkzmRI7CYrfu6ytD?width=1024&amp;height=585&amp;cropmode=none" alt="人員介紹卡片"></p>
<span id="more"></span>
<h2 id="計算區塊尺寸">計算區塊尺寸</h2>
<p>現代在撰寫 CSS 之前，在 reset 你可能會看到</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*,*<span class="selector-pseudo">::after</span>,*<span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>總是會加上一個 <code>box-sizing : border-box</code><br>
讓設計師終於不用再算那些奇奇怪怪的數字<br>
不過在沒有設定之前<br>
到底怎麼算出內容寬度呢 ?</p>
<p>以本篇為例<br>
wrap 總寬度設為 1200px<br>
共有 3 個 item 一個平均設 400px<br>
加上</p>
<ul>
<li>margin 上下左右各 15 px</li>
<li>border 上下左右各 1 px</li>
</ul>
<p>對吧 ! 那我 width 設 400px 準沒錯</p>
<p>結果你打開 devtool 一看 !<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mzmrNWlb-z4xM6ccNPP18s_3klzarPfgQB5BTOPYpOpmJtGrioRBX7Qd5y8xMG1gcZrjoPOwMaXE7NIZSLZAbxRM2xNfah6MTMEOkY6KCfGDaV2WyMtTDMEEv4wHNfgF-9BfapXpyLFlhiC_hzthM7G2lJCfrPn4uKKTrR5z4SriKohs1faMgQ_ukHRedGqO_?width=404&amp;height=660&amp;cropmode=none" alt="368... 什麼鬼，那我還要設寬度嗎 ? "><br>
不過 devtool 也告訴你答案了</p>
<p>如果設超過平均寬度那還好，因為設定了 <code>display : flex</code><br>
瀏覽器會幫你自動平均壓一壓併在同一排<br>
但在 flex 出現之前呢 ?<br>
大家會用 float 來排版，結果最後一個 item 被擠到第二行</p>
<p>實際上在算寬度時 box-model (盒模型) 有兩種方式<br>
預設是 content-box<br>
意思是你的實際內容 (width) 是還要扣掉</p>
<ul>
<li>padding</li>
<li>border</li>
</ul>
<p>但又因為 item 並排又有 margin 的存在<br>
也要一併算在內<br>
就能知道為什麼瀏覽器給我們的寬度是 368<br>
你應該設定的 width</p>
<blockquote>
<p>width  = 400 - (15 * 2)<code>&lt;margin 左右&gt;</code> - (1 * 2)<code>&lt;border 左右&gt;</code></p>
</blockquote>
<p>如果今天設定 box-sizing : border-box ，width 就會是 370<br>
只要扣除 margin 就可以了</p>
<h2 id="製作三角形">製作三角形</h2>
<ul>
<li>有 width 跟 height 的情況下</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: black;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://dsm01pap006files.storage.live.com/y4myQ83gcWFgUdpgYx28trLrkeTeEbnNNerUjEyJiejmEwdCXaGVE8Hec0xCD1_fwAq92se5upOAAzgxpNwDcbKERH78dbQM3p_NVWKRDIgdiSWZ0XekHD6cKfkgm1MVp8SW3uYRu6qLPctjarWRedUKtrIWTB8OHBkk1uVrWJZDPEoFB4W_NUjxJw_kfrCWh11?width=497&amp;height=484&amp;cropmode=none" alt="一般具有長寬的 border"></p>
<p>你可能會想我為什麼不寫 <code>border: 50px solid black</code><br>
我是覺得這樣個別設定可以更方便<br>
當然也可以個別寫方位 <code>border-top</code> 等等的</p>
<ul>
<li>width、height 都等於 0<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4m433-jklFksPiycDy1fvGep6xnsZvv3ps2NNrt4dxZY2AhEySiD_gkuAowFAnbRYjg8UEfdfHvkqo4fe5dXdEx-NEmCFJ06RxrKSJKceEmgUQ1Zfdqxz0mVcswcOGDRFas_Bb-rinjNvhWlINqQ2-fTxO_Xbg8TJFQa8LNA72YsZ7rAbU7uz37y33GtCNM1S8?width=284&amp;height=283&amp;cropmode=none" alt="只有 border"></li>
</ul>
<p>會發現 border 的組成是來自四個等腰三角<br>
出現單個三角只要把其中三邊背景變成透明就可以了</p>
<p>比如說我想要 <strong>向上</strong> 的三角<br>
所以只有底部的 border 保留<br>
<code>border-color : &lt;上&gt; &lt;右&gt; &lt;下&gt; &lt;左&gt;</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: transparent transparent black transparent;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">25px</span> <span class="number">50px</span> <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://dsm01pap006files.storage.live.com/y4mhEdF0YF0fV9DU8nRo63Lueil9A23f78iKvteTNLhrdagTR-P-FEg9JABpPpBf-oJ7HyY8FkAjj2gXaVE1cbl1NiIl3a0-O45t1xzfzOfa-1dn-6WhlHowlP3L80zoOJlzQxpAitnDEtH13ICceEnB4r0sY9uOlPxP3RpjmGjUshc5BxzCwGrpYXQTJ-5FKdw?width=249&amp;height=266&amp;cropmode=none" alt="向上等腰三角形"></p>
<p>雖然左右兩邊是透明的，但不代表他們毫無無關<br>
當我們去調整 width 的左右邊時<br>
發現三角傾斜度不一樣<br>
也可以說 <strong>border 左右邊是來控制傾斜度</strong></p>
<p>在本篇要做兩個到三角<br>
只要把上面的 border 設為透明就 OK 了<br>
左右邊則來控制斜度</p>
<h3 id="正三角形呢">正三角形呢 ?</h3>
<p>對，我上面一直說等腰，那正三角形呢 ?<br>
我們可以確定的是左右兩邊的長度<br>
剩餘的就是底邊 (下) 長</p>
<p>來簡單算數學<br>
假設正三角邊長是 1，那高是</p>
<blockquote>
<p>1^2 - (1/2)^2 開根號 = 根號 3 / 2<br>
根號 3 大概是 1.73… ，除以 2 大約等於 0.866…</p>
</blockquote>
<p>以上面的值來說左右如果設 50<br>
因為左右是 除以 2 的結果<br>
往回推，底長度 <code>50 * 2 * 0.866</code></p>
<p>這邊就可以使用 CSS3 的 <code>calc</code> 來計算<br>
我們只要控制 <code>--width</code> 達成想要的邊長就好</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attr">--width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attr">--tri</span> : <span class="built_in">calc</span>(<span class="built_in">var</span>(--width) * <span class="number">0.866</span>);</span><br><span class="line">  <span class="attr">--side</span> : <span class="built_in">calc</span>(<span class="built_in">var</span>(--width) / <span class="number">2</span>);</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0</span> <span class="built_in">var</span>(--side) <span class="built_in">var</span>(--tri) <span class="built_in">var</span>(--side);</span><br><span class="line">  <span class="attribute">border-color</span>: transparent transparent green transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="補充-三角形的陰影">補充 : 三角形的陰影</h3>
<p>我們知道 width、height 做出的陰影就是同等的大小<br>
要做三角形的陰影不能用單一邊來想</p>
<p>如果直接加上 box-shadow 只會有框邊有陰影<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mTG53FSgXjdPHvOF9D5Dqki3tUPtD_CNtxuMpoF968okr8GNjzzrQN3Tw9LSr-K-EBAoqpsb9RmjyJYoeWSlad8Ak2PQIYG9kAGd4DNeE1qcm7bTbkmqnFNQmz2lfF5LFkBWwVvc7LUOol8lEi8OI2SouBCtNdGKiKkCOD0hS0wjEfAnzpL7ws5jpFxN9-VFn?width=281&amp;height=291&amp;cropmode=none" alt="只有框邊，而不是三角直角陰影"><br>
我們要的是 <strong>直角</strong> 那邊的陰影<br>
所以要有兩邊的 border 形成直角再加陰影</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.tri</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">50px</span> solid black;</span><br><span class="line">  <span class="attribute">border-color</span>:  transparent transparent green green;</span><br><span class="line">  <span class="attribute">transform-origin</span>:<span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform</span>:<span class="built_in">rotate</span>(-<span class="number">45deg</span>);</span><br><span class="line">  <span class="attribute">box-shadow</span>: -<span class="number">3px</span> <span class="number">3px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://dsm01pap006files.storage.live.com/y4mA2Jyaa1HqhHgBom2vW4U42LqOPi2CjxozjxzGJOYstpR76s_Cx5_QWCghJR8bAN3Ua6RYK3LK6lsHOGnMsv9JZ3iB_u8CW4RRpBXgO9hAj6S_ZStsvoVVms31KuLFAbBkI_8KIGN9IKeyeTKTm70222bEwW5LV0pbhJlidC1yHB78ona8fSGWn6lljvyM-ph?width=370&amp;height=192&amp;cropmode=none" alt="正確的三角陰影"></p>
]]></content>
      <categories>
        <category>2022</category>
        <category>03</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSSZeroToOneSeries</tag>
      </tags>
  </entry>
  <entry>
    <title>CSSZeroToOneSeries | 05 | 超通用版面</title>
    <url>/2022/03/03/CSSSeriesZeroToOne-05.html</url>
    <content><![CDATA[<h2 id="本篇成果-15">本篇成果</h2>
<p><a href="https://codepen.io/shan473/pen/yLPqLWg">Codepen</a><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mHj3lx_2ZCP6jUJJdmg3J0yQ1okzs2onLtZoKl8Xl9-SHWo5R76rhJJOxB0CCcCpsr4mjLPVhk5vDB68y-tAOu5tf-ZNbKOE3h4Sre1TfJSvHP0v2J8P8TvUahMIXlTHuDmVXPLF8B_iY-H2YRC15q7MtFqTN40Pi1Q79x-NpaPicKK8MhjlUTMAusYM6_kFp?width=660&amp;height=377&amp;cropmode=none" alt="超通用版面"></p>
<span id="more"></span>
<h2 id="object-fit">object-fit</h2>
<p>讓置換元素 (Replaced element) 的內容如何塞到已知的父層寬度與高度的框</p>
<p>Replaced element 指的是內容呈現不在 CSS 的控制範圍<br>
像以下這些元素</p>
<ol>
<li><code>&lt;img&gt;</code></li>
<li><code>&lt;object&gt;</code></li>
<li><code>&lt;video&gt;</code></li>
<li><code>&lt;textarea&gt;</code> 和 <code>&lt;input&gt;</code> 表單元素。</li>
</ol>
<p>簡單來說還未設定 CSS 寬高之前，是由內容去撐開的</p>
<p>object-fit 有 5 個屬性</p>
<ul>
<li>fill : 填滿，超出會進行拉伸</li>
<li>cover : 照片超出版面，可以讓圖片等比例縮到塞滿框，多餘的裁切。或是照原圖片裁掉不符合框的範圍</li>
<li>contain : 等比例縮放，直到看見整張完整的圖。可能會距離框有距離</li>
<li>none : 不做縮放，直接塞滿框</li>
<li>scale-down : 會是 none 跟 contain 其中一個值，看誰會拿到最小值</li>
</ul>
<p>參考 : <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit">object-fit</a></p>
<h2 id="align-self">align-self</h2>
<p>當父容器為 flex<br>
單一個子元素可以擺脫整體的 align-items 約束<br>
自己排在想要的次軸位置</p>
<p>* align-items 是在父層控制所有子元素的次軸位置，預設是 flex-start</p>
<p>以本篇為例，<code>flex-direction : column</code> 來說次軸是 X 軸<br>
align-self 會控制子元素在 X 軸的排列<br>
我想只讓 more button 往最右邊靠攏只要設定</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.more</span>&#123;</span><br><span class="line">  <span class="attribute">align-self</span>: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="margin-top-auto">margin-top : auto</h2>
<p>子元素會在父層剩餘的 margin 被分配掉</p>
<p>那 <strong>auto</strong> 的值何來 ?<br>
我們必須要告訴瀏覽器有參考值邊界才能算出剩餘的空間</p>
<p>以本篇的按鈕想要往下面對齊<br>
父層使用 <code>display: flex</code> 跟 <code>flex-direction : column</code><br>
子層會被撐開，佔滿空間<br>
這時候子層就可以算出距離邊界的剩餘的空間(也就是子元素內容本身跟父層的邊界)<br>
要全部往下推就要把 top 所有空間都分配掉</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> <span class="selector-class">.txt</span> <span class="selector-class">.btn</span>&#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以如果想往哪邊推，就是把反向的空間給分掉</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin-top</span> : auto ; // 擠到下方</span><br><span class="line"><span class="attribute">margin-bottom</span> : auto ; // 擠到上方</span><br><span class="line"><span class="attribute">margin-left</span> : auto ; // 擠到右方</span><br><span class="line"><span class="attribute">margin-right</span> : auto ; // 擠到左方</span><br></pre></td></tr></table></figure>
<h3 id="常見的-margin-0-auto-置中技巧也是">常見的 margin : 0 auto 置中技巧也是</h3>
<p>把 box 置中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>margin 針對左右邊都分配掉，也就是平均，所以元素才會置中</p>
<ul>
<li>此時的邊界剩餘空間 ?<br>
預設 box 的 display 是 block 占據整行<br>
由於內容只有 100px，剩餘的空間就會是 viewport - box 內容再去分配</li>
</ul>
<h2 id="flex-wrap">flex-wrap</h2>
<p>有兩個值</p>
<ul>
<li>wrap  : 總體寬度超出螢幕寬，會換行</li>
<li>nowrap : flex 預設，打死不換行</li>
</ul>
<p>當複數個元素擠在同一個容器<br>
會發現他們會平均壓縮(預設 flex-shrink : 1)<br>
而且打死不換行<br>
即使你縮到最小，也不會有內容超出容器導致 X 向的捲軸出現<br>
因為 flex 都幫你壓好好的</p>
<p>當然這樣的視覺是 NG 的，內容都擠一塊了<br>
這時候 <code>wrap</code> 就很好用了<br>
當這一行的寬度容不下多的子容器寬度就會往下排</p>
<p>flex 可以說是能屈能伸，你說是不是很棒呢 QQ</p>
]]></content>
      <categories>
        <category>2022</category>
        <category>03</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSSZeroToOneSeries</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - 表達式 &amp; 陳述式</title>
    <url>/2022/03/03/JavaScript-Expression-Statement.html</url>
    <content><![CDATA[<h2 id="表達式-Expressions">表達式 (Expressions)</h2>
<p>執行完程式能直接 <strong>有回傳值</strong>，通常會存成變數，但不一定要存成變數</p>
<ul>
<li>這都是表達式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">3</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> c =&#123;</span><br><span class="line">	<span class="string">&quot;hi&quot;</span> : <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="陳述式-Statements-Declaration">陳述式 (Statements | Declaration)</h2>
<p>沒有回傳值，也不能當作變數的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a===<span class="number">3</span>)&#123;</span><br><span class="line">	<span class="comment">//... dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>a===3</code> : 是表達式</li>
<li><code>if(...)</code> : 陳述式，並沒有回傳值</li>
</ul>
<p>所以不會寫成這樣</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> b = <span class="keyword">if</span>(a===<span class="number">3</span>)&#123;</span><br><span class="line">	<span class="comment">//... dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Function-Expressions-Function-Statements">Function Expressions &amp; Function Statements</h2>
<p>JavaScript 中 Function 是物件的一種<br>
由這個例子可知，Function 在 Object 的原型鍊上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a 是不是 Object 的實作</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>不過如果去查型態 (typeof) function 會是 function</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a) <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="Function-Statements-declaration">Function Statements (declaration)</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mutiply</span>(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mutiply</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> a*b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不會直接回傳任何的值。<br>
該函式就會透過 hoisting 先被儲存在記憶體中，在程式碼出現之前去呼叫，就不會發出錯誤。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title function_">a</span>() <span class="comment">// 執行函式</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 印出函式的內容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Function-Expressions">Function Expressions</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">cross</span>(<span class="number">3</span>,<span class="number">5</span>) </span><br><span class="line"><span class="keyword">const</span> cross = <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> a*b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提前呼叫的話會報錯</p>
<blockquote>
<p>Uncaught ReferenceError: Cannot access ‘cross’ before initialization</p>
</blockquote>
<p>在 let、const 定義了但沒賦值之前是不能叫它的。<br>
如果是 var 宣告則會是 <code>Uncaught TypeError: cross is not a function</code></p>
<p>以 cross 來說，我們先建立了函式，但是沒有命名，這樣的函式叫 <strong>匿名函式（anonymous function 或 function literal）</strong>。</p>
<ol>
<li>為什麼可以不命名 ?<br>
在 function expression 之前已經指定給 cross，這個變數名就用來指稱函式</li>
<li>可以命名嗎 ? <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="keyword">function</span> <span class="title function_">hi</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">greet</span>() <span class="comment">// hello</span></span><br><span class="line"><span class="title function_">hi</span>() <span class="comment">// hi is not defined</span></span><br></pre></td></tr></table></figure>
可以，而且依然可以運行。<br>
在 Huli 大<a href="https://blog.huli.tw/2020/04/18/javascript-function-is-awesome/">這篇文章</a>有提到，在 function expression 中函式給予名稱有些有趣的問題
<ul>
<li>所以叫 greet 還是叫 hi ?<br>
是 hi，在外部呼叫必須用變數名，使用 function 名稱是 <code>is not defined</code></li>
<li>匿名的部份命名有什麼用處 ?
<ol>
<li>想呼叫自己的時候可以使用</li>
<li>stacktrace 會出現這個名字</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li>stacktrace 匿名函式的名稱會出現</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">trace</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure>
<p><img data-src="https://dsm01pap006files.storage.live.com/y4mBgzq2siu2WVu3eDN1OJz6Q8rPxMAKMf84yK2Z4Nw0PN6M8qYYBgOftVQ6BlFQwNEshSk-LjimjWZhNGvTzxLNNibhzJd03yNiG0zmDOJxVi2jjpGG1lqkTvEbr3v8a9GwI0IfOmnF3CwKa__lZB8T2uoXbF8PEQDU6-rLnuAFvLRk1ZIp8_QOjTJEX6AJ6AM?width=370&amp;height=232&amp;cropmode=none" alt="stacktrace"></p>
<h2 id="函式中的函式">函式中的函式</h2>
<p>在函式中放入 function expression 而且是 anonymous function</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//--- 等同</span></span><br><span class="line"><span class="keyword">const</span> anonymousfunction = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">log</span>(anonymousfunction)</span><br></pre></td></tr></table></figure>
<p>會印出 funtion 的結構</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要執行在 log 裡面的 fn 加入 <code>()</code> 就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">	<span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Callback-function">Callback function</h3>
<p>如果要確保程式執行的順序，會使用到 callback function，做法就是把函式傳入另一個函式裡面去呼叫</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hello = <span class="keyword">function</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">	<span class="title function_">callback</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bye = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bye&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hi</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">	<span class="title function_">callback</span>(bye)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">hi</span>(hello)</span><br></pre></td></tr></table></figure>
<p>依序印出 <code>'start'、'hello'、'bye'</code></p>
<h2 id="參考">參考</h2>
<ol>
<li><a href="https://pjchender.blogspot.com/2016/03/javascriptfunction-statements-and.html">[筆記] 進一步談JavaScript中函式的建立─function statements and function expressions</a></li>
<li><a href="https://blog.huli.tw/2020/04/18/javascript-function-is-awesome/">覺得 JavaScript function 很有趣的我是不是很奇怪 - Huli</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>03</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - first class function (一級函式)</title>
    <url>/2022/03/03/JavaScript-First-Class-Function.html</url>
    <content><![CDATA[<h2 id="前言-18">前言</h2>
<p>JavaScript 中的 function 是很神奇的東西<br>
在初學時看到很多名詞<br>
像 callback function(回呼函式)、First-Class Function(一級函式)、High-Order Function(高階函式)<br>
還有 Closure(閉包) 等等的，總是會霧撒撒…<br>
本篇來初步認識 function 中的 First-Class Function 概念</p>
<span id="more"></span>
<h2 id="一級函式">一級函式</h2>
<blockquote>
<p>函式可以被視為其他變數一樣，像是 function 可以指定成變數，也可以做為參數傳入別的 funciton。</p>
</blockquote>
<p>JavaScript 的 function 符合 first class function</p>
<ul>
<li>函式只是物件的一種</li>
<li>function 可以儲存成變數 (function expression) <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> greet =<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>function 可以當作參數傳入別的 function 中，這邊把 function 當作 <strong>值</strong> 來使用。<br>
(這樣的方式會稱這個 function 是 callback function)  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;hello,&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">message,name</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">message</span>()+name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">greet</span>(hello,<span class="string">&#x27;rosa!&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>function 裡面又回傳另一個 function。<br>
只要接收函式作為參數，或是回傳函式作為輸出的函式<br>
就稱作高階函式 ( <strong>Higher-Order Function</strong> )<br>
像是 Array 中的 <code>map</code> function  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">num</span>)=&gt;</span> num * <span class="number">2</span> )</span><br><span class="line"><span class="comment">// 實作</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrayMap</span>(<span class="params">fn,array</span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> length = array.<span class="property">length</span></span><br><span class="line">	<span class="keyword">let</span> newArray = [] </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span> ; i&lt;length ; i++)&#123;</span><br><span class="line">		newArray.<span class="title function_">push</span>(<span class="title function_">fn</span>(array[i]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">arrayMap</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item * <span class="number">2</span> 	</span><br><span class="line">&#125;,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
</li>
<li>function 跟物件一樣有屬性 (property)<br>
下面進行說明</li>
</ul>
<h2 id="函式也是物件的一種">函式也是物件的一種 ?</h2>
<p>範例 :</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;invoke this&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hello</span>() <span class="comment">// 直接執行</span></span><br><span class="line">hello.<span class="property">people</span>=<span class="string">&#x27;rosa&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hello.<span class="property">people</span>) <span class="comment">// output : rosa</span></span><br></pre></td></tr></table></figure>
<ol>
<li>執行 (invoke) 函式，是透過 <code>()</code></li>
<li>可以直接用 <code>.</code> 建立物件中的 key-value</li>
</ol>
<p>證明 function 是一種特殊的物件，也可以當作物件來使用。</p>
<h2 id="補充-函式回傳一個另一個函式">補充 : 函式回傳一個另一個函式</h2>
<p>調用函式與回傳的函式有幾種做法</p>
<ol>
<li>存成變數</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayhi</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello, Rosa!&#x27;</span>)</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myFunc = <span class="title function_">sayhi</span>() <span class="comment">// myFunc 接收的是一個 function</span></span><br><span class="line"><span class="title function_">myFunc</span>() <span class="comment">// 呼叫</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>雙括號直接呼叫</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayhi</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello, Rosa!&#x27;</span>)</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayhi</span>()()</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>IIFE (Immediately Invoked Function Expression): 定義完就回傳的 function</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayhi</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello, Rosa!&#x27;</span>)</span><br><span class="line">	&#125;)() </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayhi</span>()</span><br></pre></td></tr></table></figure>
<p>IIFE 的例子很常在 JQuery 看見</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">$</span>) &#123;</span><br><span class="line">    <span class="comment">//$ = jQuery</span></span><br><span class="line">&#125;)(jQuery)</span><br></pre></td></tr></table></figure>
<h2 id="參考-2">參考</h2>
<ol>
<li><a href="https://pjchender.blogspot.com/2016/03/javascriptfunctionobjects.html">[筆記] JavaScript 中函式就是一種物件 ─ 談談 first class function（一等公民函式） ~ PJCHENder 那些沒告訴你的小細節</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Glossary/First-class_Function">一級函式（First-class Function） - 術語表 | MDN (mozilla.org)</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10224519">JS 原力覺醒 Day19 - 一級函式與高階函式</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>03</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSSZeroToOneSeries | 06 | 網頁頁尾版塊</title>
    <url>/2022/03/03/CSSSeriesZeroToOne-06.html</url>
    <content><![CDATA[<h2 id="本篇成果-16">本篇成果</h2>
<p><a href="https://codepen.io/shan473/pen/oNoMJBQ">Codepen</a><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mtphMUUk0c1yY9dUb53RF0jkrLI5tF-TSjeeSIBE583SwUq1Uk8UZUm-Z011ZK-Or0KbhFHvVqODwJObSn3ACJf7CuFIuu18jaIEzdPeLEqvFFMAesLSLoetnq0FPAtwi7kCTP7ZscwXBBtdaDMV7GQKnv5kTH_3vY6LSOcOkcg1zvlpCEsth5zYrQJ54RM7r?width=660&amp;height=377&amp;cropmode=none" alt="網頁頁尾版塊"></p>
<span id="more"></span>
<h2 id="flex-grow-子元素的空間分配">flex-grow : 子元素的空間分配</h2>
<p><code>flex-grow</code> : 剩餘容器空間分配，運用到 flex-grow : 1，個別分配一樣的，以免內容大小不一導致 container 有大有小。</p>
<blockquote>
<p><code>width : 0</code> 可以把 width 先設定為 0 ，讓 <strong>主軸</strong> 的 width 都交給 grow 分配。</p>
</blockquote>
<h3 id="flex-裡面的-width-100-到底沒有作用">flex 裡面的 width : 100% 到底沒有作用 ?</h3>
<p>有，在還沒設定 flex-grow 之前<br>
子元素的空間是由內容去撐開的<br>
拔掉本篇的 footer-item 中的 flex-grow 並將 width 設為 100%<br>
依然會跟 flex-grow 一樣</p>
<p>在之前的篇章有介紹過 flex-shrink 壓縮值<br>
原因在於 flex-shrink 預設把空間平均壓縮了<br>
這也是為什麼撐開到 100% 也單一個子元素占不滿 container<br>
所以設定 25% (item 總數是 4) 或 100% 也沒差</p>
<p>個人不太建議這樣寫，因為 width 感覺失去意義了</p>
]]></content>
      <categories>
        <category>2022</category>
        <category>03</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSSZeroToOneSeries</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - 參數傳遞 call by value or call by reference &amp; call by sharing</title>
    <url>/2022/03/03/JavaScript-call-by-what.html</url>
    <content><![CDATA[<h2 id="前言-19">前言</h2>
<p>一直以來 JavaScript 的參數傳遞都蠻有爭議性的<br>
可能聽過</p>
<blockquote>
<p>原始型態是 call by value；物件型態是 call by reference</p>
</blockquote>
<p>甚至有人說 JavaScript 只有 <code>call by sharing</code> 或是根本只有 <code>call by value</code><br>
到底是哪種 ? 眾說紛紜，本篇針對這三種名詞進行解釋幫助自己去來理解</p>
<p>如果有誤再麻煩各路大大指點</p>
<span id="more"></span>   
<h2 id="call-by-value-傳值">call by value : 傳值</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line"></span><br><span class="line">a=<span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定義變數 a 並且賦予 5 這個值，假設會被存在記憶體 <code>00x1</code> 這個位址</li>
</ul>
<table>
<thead>
<tr>
<th>變數</th>
<th>記憶體位址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>00x1</td>
<td>5</td>
</tr>
</tbody>
</table>
<ul>
<li>定義變數 b 等於 a ，b 拷貝 a 的值，另外存在新的記憶體位址  <code>00x3</code></li>
</ul>
<table>
<thead>
<tr>
<th>變數</th>
<th>記憶體位址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>00x1</td>
<td>5</td>
</tr>
<tr>
<td>b</td>
<td>00x3</td>
<td>5 (copy from a)</td>
</tr>
</tbody>
</table>
<ul>
<li>當你改變 a 的值，因為 b 指向不同記憶體位置，所以跟 b 沒有關係</li>
</ul>
<table>
<thead>
<tr>
<th>變數</th>
<th>記憶體位址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>00x1</td>
<td>10</td>
</tr>
<tr>
<td>b</td>
<td>00x3</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>即使修改 a 或 b 其中一項，a 、 b 值互不相干擾，稱作 <code>call by value</code><br>
而且 JavaScript 對於 Primitive type 的操作都是 <code>call by value</code><br>
拷貝 「<strong>值</strong>」 但不拷貝 「<strong>址</strong>」</p>
<p>這也為什麼說 Primitive type 是 <strong>immutable</strong> (不可變)<br>
這邊指的不可變 b 雖然等於 a，但你修改 a 並不會去變動到其他的值</p>
<h3 id="Function-中參數的傳遞-by-value">Function 中參數的傳遞 : by value</h3>
<p><a href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/">Huli 大的文章</a> 中也舉例變數 function 做為參數，並在 funciton 中進行新賦值的問題</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">revalue</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">	a = <span class="number">5</span>;</span><br><span class="line">	b = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">revalue</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>把變數 a 跟變數 b 都當作參數傳進 <code>revalue</code> 這個 function，而參數只是複製傳進來的值，並不會影響到在外面的 a 跟 b。</p>
<blockquote>
<p>這邊的參數 a、b 作為傳進來的值的別名 (alias)而已，跟外部定義的 a、b 是無關的</p>
</blockquote>
<h2 id="call-by-reference-傳址">call by reference : 傳址</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1</span><br><span class="line">obj1.<span class="property">a</span> = <span class="number">5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; === &#123;&#125;) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 === obj2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在 object 型態的判斷來看，空物件不會等於空物件，因為記憶體儲存的位址不同<br>
但這裡 <code>obj1 === obj2</code> 是 true 的時候，代表兩個變數是指向同一個地方 ，是一樣的。</p>
<p>接著看怎麼運作的</p>
<ul>
<li>定義變數 obj1 並且賦予 <code>&#123;a : 1&#125;</code> 這個值，記憶體 <code>00x1</code> 這個位址 ，會存有 <code>&#123;a: 1&#125;</code> 這個值。而 obj1 的值則引用 (reference) <code>00x1</code> 位子的值</li>
</ul>
<table>
<thead>
<tr>
<th>變數</th>
<th>記憶體位址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>00x1</td>
<td>{a: 1}</td>
</tr>
<tr>
<td>obj1</td>
<td>00x2</td>
<td>00x1</td>
</tr>
</tbody>
</table>
<ul>
<li>定義變數 obj2 等於 obj1，也就是參照同一個 <strong>位址</strong> 的值</li>
</ul>
<table>
<thead>
<tr>
<th>變數</th>
<th>記憶體位址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>00x1</td>
<td>{a: 1}</td>
</tr>
<tr>
<td>obj1</td>
<td>00x2</td>
<td>00x1</td>
</tr>
<tr>
<td>obj2</td>
<td>00x2</td>
<td>00x1</td>
</tr>
</tbody>
</table>
<ul>
<li>當 <code>obj1.a</code> 改變時，是改動到位在 <code>00x1</code> 記憶體的值 <code>&#123;a : 5&#125;</code>，因為 obj2 也參照這裡的位址的值，在運作上連同 obj2 也被改動到</li>
</ul>
<table>
<thead>
<tr>
<th>變數</th>
<th>記憶體位址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>00x1</td>
<td><code>&#123;a: 5&#125;</code></td>
</tr>
<tr>
<td>obj1</td>
<td>00x2</td>
<td>00x1</td>
</tr>
<tr>
<td>obj2</td>
<td>00x2</td>
<td>00x1</td>
</tr>
</tbody>
</table>
<p>由此可知當改動到 obj1.a 的值 obj2.a 也會改變稱作 call by reference<br>
Object type 通常是 call by reference<br>
拷貝 「<strong>值</strong>」 <strong>也拷貝址</strong></p>
<p>跟 Primitive type 相反的是 Object type 是 <strong>mutable</strong> (可變)<br>
改動 a 的值卻也會變動到 b<br>
在 <a href="https://www.slideshare.net/YiTaiLin/java-script-63031051">Tommy 大簡報第 12 頁有清楚的流程</a> 可以參考</p>
<h3 id="Function-中參數的傳遞-by-reference">Function 中參數的傳遞 : by reference</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">revalue</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">	obj.<span class="property">b</span> = <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">revalue</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1) <span class="comment">// &#123;a: 1,b :5 &#125;</span></span><br></pre></td></tr></table></figure>
<p>在 revalue 函式中我們對參數 obj 進行更新<br>
而外部的 obj1 也會變動到，因為指向的記憶體位址是同一處。</p>
<ul>
<li>obj1 作為引數，帶入 obj 參數時，複製一份 obj1 進去</li>
</ul>
<table>
<thead>
<tr>
<th>變數</th>
<th>記憶體位址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>00x1</td>
<td>{a : 1}</td>
</tr>
<tr>
<td>obj1</td>
<td>00x2</td>
<td>00x1</td>
</tr>
<tr>
<td></td>
<td>00x4</td>
<td>funtion revalue()…</td>
</tr>
<tr>
<td>revalue</td>
<td>00x5</td>
<td>00x4</td>
</tr>
<tr>
<td>參數 <strong>obj</strong></td>
<td>00x2</td>
<td>00x1</td>
</tr>
</tbody>
</table>
<ul>
<li>obj.b = 5 (不是變數重新賦值 !)</li>
</ul>
<table>
<thead>
<tr>
<th>變數</th>
<th>記憶體位址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>00x1</td>
<td><code>&#123;a:1,b:5&#125;</code></td>
</tr>
<tr>
<td>obj1</td>
<td>00x2</td>
<td>00x1</td>
</tr>
<tr>
<td></td>
<td>00x4</td>
<td>funtion revalue()…</td>
</tr>
<tr>
<td>revalue</td>
<td>00x5</td>
<td>00x4</td>
</tr>
<tr>
<td>參數 <strong>obj</strong></td>
<td>00x2</td>
<td>00x1</td>
</tr>
</tbody>
</table>
<h3 id="例外狀況-重新賦值">例外狀況 : 重新賦值</h3>
<p>凡事總有個例外…</p>
<ol>
<li>Object Literals 重新賦值 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1</span><br><span class="line"></span><br><span class="line">obj2 = &#123;a : <span class="number">3</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 === obj2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
按照上面來說，參照同一記憶體位址， obj2 變動應該會連同 obj1 也改變，結果沒有。
<ul>
<li>obj2 = obj1，obj2 複製 obj1</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>變數</th>
<th>記憶體位址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>00x1</td>
<td><code>&#123;a:1,b:5&#125;</code></td>
</tr>
<tr>
<td>obj1</td>
<td>00x2</td>
<td>00x1</td>
</tr>
<tr>
<td>obj2</td>
<td>00x2</td>
<td>00x1</td>
</tr>
</tbody>
</table>
<pre><code>- obj2 新賦值
</code></pre>
<table>
<thead>
<tr>
<th>變數</th>
<th>記憶體位址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>00x1</td>
<td>{a:1}</td>
</tr>
<tr>
<td></td>
<td>00x5</td>
<td><code>&#123;a: 3&#125;</code></td>
</tr>
<tr>
<td>obj1</td>
<td>00x2</td>
<td>00x1</td>
</tr>
<tr>
<td>obj2</td>
<td>00x6</td>
<td>00x5</td>
</tr>
</tbody>
</table>
<pre><code>obj2 在新賦值時，物件創造新的記憶體位址賦予值，obj2 也創造一個新的記憶體位址並且複製物件位址到自己的值  
obj1 跟 obj2 正式分道揚鑣 ~ 成為陌生人  
</code></pre>
<ol start="2">
<li>Function 中參數的傳遞 : Object 重新賦值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">revalue</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">	obj=&#123; a : <span class="number">3</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">revalue</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1) <span class="comment">// &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>
<p>在裡面重新賦值，外部的引數並不會改動到原本的值<br>
跟著跑一遍</p>
<ul>
<li>obj1 作為引數，帶入 obj 參數時，複製一份 obj1 進去</li>
</ul>
<table>
<thead>
<tr>
<th>變數</th>
<th>記憶體位址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>00x1</td>
<td>{a : 1}</td>
</tr>
<tr>
<td>obj1</td>
<td>00x2</td>
<td>00x1</td>
</tr>
<tr>
<td></td>
<td>00x4</td>
<td>funtion revalue()…</td>
</tr>
<tr>
<td>revalue</td>
<td>00x5</td>
<td>00x4</td>
</tr>
<tr>
<td>參數 <strong>obj</strong></td>
<td>00x2</td>
<td><code>00x1</code></td>
</tr>
</tbody>
</table>
<ul>
<li>obj={ a : 3}  重新賦值</li>
</ul>
<table>
<thead>
<tr>
<th>變數</th>
<th>記憶體位址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>00x1</td>
<td>{ a : 1 }</td>
</tr>
<tr>
<td>obj1</td>
<td>00x2</td>
<td>00x1</td>
</tr>
<tr>
<td></td>
<td>00x4</td>
<td>funtion revalue()…</td>
</tr>
<tr>
<td>revalue</td>
<td>00x5</td>
<td>00x4</td>
</tr>
<tr>
<td>參數 <strong>obj</strong></td>
<td><code>00x8</code></td>
<td><code>00x6</code></td>
</tr>
<tr>
<td></td>
<td>00x6</td>
<td>{a : 3}</td>
</tr>
</tbody>
</table>
<ul>
<li>根據 Scope 作用域，函式的變數作用範圍等函式結束後就會釋放記憶體。</li>
</ul>
<table>
<thead>
<tr>
<th>變數</th>
<th>記憶體位址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>00x1</td>
<td>{ a : 1 }</td>
</tr>
<tr>
<td>obj1</td>
<td>00x2</td>
<td>00x1</td>
</tr>
<tr>
<td></td>
<td>00x4</td>
<td>funtion revalue()…</td>
</tr>
</tbody>
</table>
<p>obj1 依然不會變動到。</p>
<p>不過你發現了嗎 ?<br>
Object Type 新賦值的行為是複製值而已，很像 call by value</p>
<h2 id="不是-by-value-也不是-by-renference-而是-by-sharing">不是 by value 也不是 by renference 而是 by sharing</h2>
<p>哦不，我的頭開始痛了<br>
那我前面認識的難道是假的嗎 ?</p>
<p>不，sharing 就像綜合體一樣<br>
按上面所述，我們可以把情況分成三種</p>
<ol>
<li>Primitive type 表現行為是 call by value</li>
<li>Object type 沒有新賦值的情況，而是對內容操作，表現行為像是 call by reference</li>
<li>Object type 重新賦值，表現則是 call by value，會建立一個新的記憶體位置，並且複製其(記憶體位址的)值</li>
</ol>
<p>可知 call by sharing 在不同情況下會就會有不同的表現行為</p>
<p>借一下 Huli 大的圖…<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mnEy3INPdoo5FZIkuPSKskoOVfwI9iapT5pvdWu6c0BSovTa8z0rEaeST_jxZaxA8prHXyxrT_9IWaaoniKLBb6GJz6tdT60tRupMq7E0LMnDVcO97Oc8H1Rk2WzVxmlnTRFYoLOjzbHqdeFe5cLtaWuG_x4SY9Mt6GLI8HYXkVicjUFYT5QsvmVzYogaIAxS?width=949&amp;height=702&amp;cropmode=none" alt="call by sharing"></p>
<p>文章中有提及其實 JavaScript 嚴格意義上是沒有 call by reference 的，因為函式的引數重新賦值並不會修改到外部變數的值。<br>
(C++ 能修改到是跟指標有關)<br>
由於我不是很熟 C 跟 C++… 先不做討論</p>
<p>由上圖可知，JavaScript 可以說</p>
<blockquote>
<p>Primitive 是 Pass by Value，Object 是 Pass by sharing。</p>
</blockquote>
<h2 id="全都是-call-by-value-的觀點">全都是 call by value 的觀點</h2>
<p>那全是 call by value 是怎麼回事 ?<br>
造成爭論的點在於這邊的 value 並未定義說是 <strong>內容的值</strong> 還是 <strong>存放在變數記憶體位址裡的值</strong></p>
<ul>
<li>以 <strong>內容的值</strong> 觀點來看</li>
</ul>
<table>
<thead>
<tr>
<th>變數</th>
<th>記憶體位址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>00x1</td>
<td><strong>5(被複製到 b)</strong></td>
</tr>
<tr>
<td>b</td>
<td>00x3</td>
<td>5</td>
</tr>
</tbody>
</table>
<ul>
<li>以 <strong>記憶體位址裡的值</strong> 觀點來看</li>
</ul>
<table>
<thead>
<tr>
<th>變數</th>
<th>記憶體位址</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><strong>00x1 (被複製)</strong></td>
<td>{a: 1}</td>
</tr>
<tr>
<td>obj1</td>
<td>00x5</td>
<td>00x1</td>
</tr>
<tr>
<td>obj2</td>
<td>00x5</td>
<td>00x1</td>
</tr>
</tbody>
</table>
<p>b 複製 a ， a 也是複製記憶體 <code>(00x1)</code> 位址這個值，所以也可以說是 <strong>call by value</strong><br>
在定義上的不同，導致不同的觀點與結論</p>
<h2 id="參考-3">參考</h2>
<ol>
<li>帶你跑一次 : <a href="https://www.slideshare.net/YiTaiLin/java-script-63031051">簡單介紹JavaScript參數傳遞 (slideshare.net)</a></li>
<li>簡單論述 : <a href="https://ithelp.ithome.com.tw/articles/10191057">重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？</a></li>
<li>從各方面來看 : <a href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/">深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？</a></li>
<li>好懂得位址概念 : <a href="https://ithelp.ithome.com.tw/articles/10209104">你不可不知的 JavaScript 二三事#Day26：程式界的哈姆雷特 —— Pass by value, or Pass by reference？</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>03</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - Event Loop 事件循環 (I)</title>
    <url>/2022/06/06/JavaScript-Event-Loop-01.html</url>
    <content><![CDATA[<h2 id="前言-20">前言</h2>
<p>在 JavaScript 中，非同步的操作是很常見的，舉凡滑鼠事件、發出請求獲取資料…等，反過來問，如果這些操作是 <strong>同步</strong> 的，你可能操作後，畫面就像被卡住了，要等到目前的程式執行完畢才能繼續瀏覽。</p>
<p>Event Loop 的概念如何幫我們了解這件事，具體怎麼做呢 ? 本篇主要是幫助我自己釐清 Event Loop 的概念。</p>
<span id="more"></span>
<h2 id="為什麼會有-Event-Loop">為什麼會有 Event Loop ?</h2>
<p>JS 的語言特性是</p>
<ol>
<li>Single Thread (單線程)</li>
<li>Synchronous (同步)</li>
</ol>
<p>有時候語意上很令人誤解，同步 <strong>並不是同時做很多事</strong>，而是你只能一次做一件事。那為什麼我們可以在 <strong>瀏覽器</strong> 中操作按鈕獲取資料的同時又能做別的事 ?</p>
<p>沒錯，特別指出 <strong>瀏覽器</strong>，因為在不同的執行環境下，才能讓我們執行非同步的操作。(node 也是一種 JavaScript 執行環境，其中也有提供非同步的 API 來操作)</p>
<p>JavaScript 在 Runtime (執行環境) 是同步的，而是瀏覽器提供 Web APIs 讓我們透過 Event Loop 搭配非同步操作，才能&quot;同時&quot;處理很多事。</p>
<h3 id="關於-Event-Loop-的名詞">關於 Event Loop 的名詞</h3>
<h4 id="Stack-堆疊">Stack (堆疊)</h4>
<p>Stack 是資料結構的一種，遵守 LIFO (Last In,First Out)。</p>
<p>JavaScript 中的 Call Stack 會記錄目前執行到程式的部分，因為 JavaScript 是 Single Thread (單線程) ，只會有一個 Call Stack。</p>
<p><strong>那 Call Stack 怎麼運作呢 ?</strong><br>
當執行某個函式，會將目前執行的函式放在 Stack 的最上層，如果函式執行 <code>return</code> 就會從 Stack 最上方抽離。</p>
<p><strong>範例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">	<span class="title function_">a</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">	<span class="title function_">b</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">c</span>();</span><br></pre></td></tr></table></figure>
<p>跟著程式走 :</p>
<ol>
<li>執行 c() ，把 c() 放入 Call Stack 中 1</li>
</ol>
<table>
<thead>
<tr>
<th>order</th>
<th>stack</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>c () <strong>(now)</strong></td>
</tr>
</tbody>
</table>
<ol start="2">
<li>印出 ‘c’，接著執行 b()，把 b() 放入 Call Stack 中</li>
</ol>
<table>
<thead>
<tr>
<th>order</th>
<th>stack</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>b() <strong>(now)</strong></td>
</tr>
<tr>
<td>1</td>
<td>c ()</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>印出 ‘b’，接著執行 a()，把 a() 放入 Call Stack 中</li>
</ol>
<table>
<thead>
<tr>
<th>order</th>
<th>stack</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>a() <strong>(now)</strong></td>
</tr>
<tr>
<td>2</td>
<td>b()</td>
</tr>
<tr>
<td>1</td>
<td>c ()</td>
</tr>
</tbody>
</table>
<ol start="4">
<li>印出 ‘a’，a() 後面沒有程式碼，代表執行完畢，抽離 Stack 中</li>
</ol>
<table>
<thead>
<tr>
<th>order</th>
<th>stack</th>
</tr>
</thead>
<tbody>
<tr>
<td><s>3</s></td>
<td><s>a() ----&gt; 抽離</s></td>
</tr>
<tr>
<td>2</td>
<td>b()</td>
</tr>
<tr>
<td>1</td>
<td>c ()</td>
</tr>
</tbody>
</table>
<ol start="5">
<li>後面跟步驟 4 一樣，依序抽離，直到 c() 執行完畢，後面也沒有程式碼，最後 Call Stack 為空</li>
</ol>
<p>解釋了上面提及的 Stack <strong>Last In,First Out</strong> 的原因。</p>
<h4 id="Task-Queue-任務佇列">Task Queue (任務佇列)</h4>
<p>又稱作 Callback Queue，在 Web APIs 的 function 執行完後，把 callback (接著要執行的 function) 放到 Task Queue 等待。</p>
<p>👉<a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D">參考 Loupe 視覺化工具</a></p>
<p>在這個例子中，有 setTimeout 與 click 事件。當程式執行時 :</p>
<ol>
<li>Button 事件並沒有觸發，callback function 並不會執行，先放置到 Web APIs 等待</li>
<li>第 7 行排進 Call Stack ，印出 ‘Hi !’，執行完畢移出 Call Stack 外</li>
<li>setTimeOut 放置到 Web APIs 等待，並且開始算 5 秒鐘</li>
<li>第 13 行排進 Call Stack ，印出 ‘Welcome to loupe.’，執行完畢移出 Call Stack 外，到這邊靜態的程式碼都執行完畢，Call Stack 變成空的 。(同一時間 setTimeOut 還在跑秒數)</li>
<li>過了大概 5 秒鐘， 把第 9 行 setTimeOut 的 callback <code>timeout()</code> 放到 Callback Queue。</li>
<li><strong>此時 Call Stack 為空的，把 Task Queue 第一順位的 timeout() 搬到 Call Stack 執行</strong> (此時會看見橘色的旋轉鈕轉動，代表 Event Loop)</li>
<li>第 10 行排進 Call Stack ，印出 ‘Click the button’，timeout() 執行完畢，移出 Call Stack 外，Stack 又變成空的。</li>
</ol>
<p><strong>如果這時候按下按鈕呢 ?</strong></p>
<ol>
<li>按下後，onClick 事件執行，排進 Call Stack</li>
<li>執行第 2 行 setTimeout ，把 setTimeout 放置到 Web APIs 等待，並且開始算 2 秒鐘，onClick 事件執行完畢，移出 Call Stack 外，Stack 又變成空的</li>
<li>過了大概 2 秒鐘， 把 setTimeOut 的 callback <code>timer()</code> 放到 Callback Queue。</li>
<li><strong>此時 Call Stack 為空的，把 Task Queue 第一順位的 timer() 搬到 Call Stack 執行</strong></li>
<li>第 3 行排進 Call Stack，印出 ‘You click the button !’，執行完畢，移出 Call Stack 外，Stack 又變成空的。</li>
</ol>
<p>以上是一步步跟著的 Event Loop 的基本運作</p>
<h4 id="Blocking-阻塞">Blocking (阻塞)</h4>
<blockquote>
<p>那如果一直按按鈕呢 ?</p>
</blockquote>
<p>會發現一個個 onClick 事件的 callback 會被排進 Callback Queue 正在排隊等待，setTimeout 同時也在排隊，也要等待 onClick 事件結束，移出 Call Stack 外，透過 Event Loop 檢查 Call Stack 是否為空…(略)，重複一直執行。</p>
<p>這時候畫面就好像靜止了，setTimeout 的 2 秒也不是很精準，這就是發生了 Blocking 。</p>
<p>如果會以為同時印出，要回想 <strong>JavaScript 是同步的</strong> 這句話，執行的結果會是依序出現，不會一下子 “啪!” 全部出來。</p>
<h5 id="阻塞常見的例子-無限滾動載入資料">阻塞常見的例子 : 無限滾動載入資料</h5>
<p>如果直接 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="comment">// Ajax 獲取資料</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>發現每一滑，都會觸發 callback 。就像你一直按按鈕，然後發出請求資料，排進 Web APIs 並且等待資料的 response ，再排進 Callback Queue，這時候會造成 Blocking。為避免一直觸發 scroll 事件，通常會搭配 lodash 的 debounce。</p>
<h3 id="小結-Event-Loop-是…">小結 : Event Loop 是…</h3>
<p>一種機制，讓 JavaScript 可以同時做很多事</p>
<blockquote>
<p>當 Call Stack 為空時，把 Callback Queue 等待的 callback function 放進 Call Stack 來執行</p>
</blockquote>
<h2 id="幾個-Event-Loop-的例子">幾個 Event Loop 的例子</h2>
<p>來自 <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">What the heck is the event loop anyway?</a> 提到的範例</p>
<h3 id="沒那麼精準的-setTimeout-與-setInterval">沒那麼精準的 setTimeout 與 setInterval</h3>
<p>setTimeout 與 setInterval 都是 Web APIs ，會排進 Callback Queue 並且等到 Call Stack 為空的時候才執行。所以不能保證一定精準 x 秒後執行，但至少執行間距的最小秒數是 x 秒。</p>
<p><strong>常見的 0 秒 setTimeout</strong><br>
乍看之下會以為 0 秒是立即執行，其實不然。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>結果是 <code>hi</code> 先印出，再印出 <code>hello</code>。</p>
<p>跟著步驟走 :</p>
<ol>
<li>setTimeout 放入 Web APIs 等待 0 秒後，放入 Task Queue 等待</li>
<li><code>console.log('hi')</code> 排進 Call Stack，並且執行</li>
<li>印出 ‘hi’ ，執行結束，移出 Stack 外</li>
<li>此時的 Call Stack 是空的，而且 Task Queue 的第一位是 setTimeout 的 callback ，排進 Call Stack</li>
<li>執行 <code>console.log('hello')</code></li>
<li>印出 ‘hello’，執行結束，移出 Stack 外</li>
<li>程式碼執行結束</li>
</ol>
<p>這也是為什麼 setTimeout  沒那麼 精準的原因，因為必須等到  Call Stack 為空才會執行，導致中間可能會有誤差。</p>
<h3 id="多個-setTimeout">多個 setTimeout</h3>
<p>遇到 setTimeout 常會問 console.log 的結果是 ?</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>每間隔 1 秒後，依序印出 ‘hi’ (1 秒 ‘hi’，隔 1 秒 ‘hi’…)</li>
<li>在 4 秒後，同時印出 <figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">4 </span>(hi)</span><br></pre></td></tr></table></figure>
</li>
<li>至少間距 1 秒以後，一次印出 4 次的 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>.<br>
.<br>
.<br>
.<br>
.<br>
.<br>
.<br>
結果是<strong>至少間距 1 秒以後，一次印出 4 次的 hi</strong> 。經過 1 秒後即使已經排定到 Callback Queue，但是如果這時候 Call Stack 還不是空的，Queue 就會發生 Blocking 塞車在這裡等待，等到 Stack 空再依序印出 hi。如果 1 秒短到看不見，可以調成更久的時間。</p>
<h3 id="同步與非同步的-callback">同步與非同步的 callback</h3>
<p>我覺得這個例子很有意思，我們知道頻繁的呼叫 callback function 會造成 Blocking 的情形，但是 <strong>Call Stack 塞車或是 Callback Queue 塞車有什麼差別呢 ?</strong></p>
<p>透過這個例子我自己覺得更清楚知道有了 Event Loop 到底幫助在哪。</p>
<p>在這裡的 callback function 有兩種</p>
<ol>
<li>在函式中呼叫另一個函式 (同步的 callback，都在 Call Stack 執行完畢) <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li>像是跟 Web APIs 有關的，例 : click 事件後的 callback function 不會馬上執行，而是等到 Event Loop 後才會。<br>
(非同步的 callback  差別在於，有排隊到 Callback Queue 再到 Call Stack) <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">		&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="同步的-callback-發生了什麼事">同步的 callback 發生了什麼事</h4>
<p>如上面的第一個 callback 範例，我們必須等到 forEach 印完所有元素，才能做其他的事。這段時間造成 Call Stack 的 Blocking，導致畫面不能動作。</p>
<p>一般來說，瀏覽器會在每 16.6 毫秒的時候重新渲染畫面，但這時候 Call Stack 還在處理事情，導致畫面的解析被延遲，在影片中講者有開啟模擬畫面 render 的模擬，render 一直被占據紅線。</p>
<h4 id="改成非同步的-callback-差別在哪">改成非同步的 callback 差別在哪 ?</h4>
<p>上面不斷強調 Event Loop 是 Call Stack 為空時，才會把 Callback Queue 推上 Stack 執行。而在 Call Stack 空的期間，提供瀏覽器執行畫面重新渲染的機會，才不會因為忙碌導致卡住。</p>
<blockquote>
<p>簡單來說 : <strong>畫面渲染的優先度是高於 Callback Queue 的 callback function</strong></p>
</blockquote>
<p>這也是為什麼在影片講者提到不要造成耗時的程式碼放在 Call Stack ，因為 Call Stack 賽車沒辦法重新渲染畫面。</p>
<p>也可以參考這篇 Jack 大的實作範例二，文章也有提到什麼時候會 rendering，助於瞭解整個流程<br>
👉 <a href="https://yu-jack.github.io/2020/02/03/javascript-runtime-event-loop-browser/#%E7%AF%84%E4%BE%8B%E4%BA%8C">Event Loop 運行機制解析 - 瀏覽器篇 - 技術雜記 Technology Notes - Jack Yu | 傑克</a></p>
<h2 id="結語">結語</h2>
<p>目前提到瀏覽器的 Event Loop ，至於 Node 的 Event Loop 我還沒研究，未來會再研究補充。不過還有 mircoTask 與 macroTask 還沒補完 QQ，才能算是了解 Event Loop。</p>
<p>如果有誤麻煩請寄信告訴我，我會非常感謝</p>
<h2 id="參考-4">參考</h2>
<ol>
<li><a href="https://pjchender.blogspot.com/2017/08/javascript-learn-event-loop-stack-queue.html">[筆記] 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式 | PJCHENder 那些沒告訴你的小細節</a></li>
<li>講解 Event Loop 的影片(有中文字幕) : <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">What the heck is the event loop anyway? | Philip Roberts | JSConf EU - YouTube</a></li>
<li>模擬 Event Loop 的網頁 : <a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D">latentflip.com</a></li>
<li><a href="https://yu-jack.github.io/2020/02/03/javascript-runtime-event-loop-browser/#%E7%AF%84%E4%BE%8B%E4%BA%8C">Event Loop 運行機制解析 - 瀏覽器篇 - 技術雜記 Technology Notes - Jack Yu | 傑克</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>06</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - 運算子 ?. 與 ??</title>
    <url>/2022/06/06/JavaScript-null-undefined-operator.html</url>
    <content><![CDATA[<h2 id="前言-21">前言</h2>
<p>對於 undefined 或是 null 的處理，我比較常使用 <code>||</code> (OR) 或是 <code>&amp;&amp;</code> (AND) 的寫法，找資料的時候很常看見 <code>??</code> 以及 <code>?.</code> 的寫法。實在是太好奇了，於是找了資料學習並且記錄下來 。</p>
<span id="more"></span>
<h2 id="Optional-chaining">Optional chaining (?.)</h2>
<p>如果要查找 <strong>Object 的某項是否存在</strong>。我們可能會遍歷整個物件，但不用這麼麻煩，可以使用 <code>obj?.</code> ，如果物件是 null 或是 undefined 就做別的處理，在判斷值存在與否就很好用。</p>
<p>例 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj?.<span class="property">b</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span> + (obj?.<span class="property">b</span> || <span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>那在巢狀的結構中如果不用 <code>?.</code> ，必須先判斷前面的是不是存在</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span> &amp;&amp; obj.<span class="property">a</span>.<span class="property">b</span>) <span class="comment">// obj.a 存在才往下一步</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>?.<span class="property">b</span>) <span class="comment">// 使用 ?.</span></span><br></pre></td></tr></table></figure>
<p>透過 (?.) 的方式 JavaScript 內部會透過隱式 (implicitly) 去確認 obj.a 是不是 null 或是 undefined，而不用顯式 (explicitly) 確認 obj.a 存不存在再去判斷下一個。</p>
<h3 id="為什麼要有">為什麼要有 (?.)</h3>
<p>從一般的判斷來說，我們可以用 <code>||</code>  來決定值存不存在，因而來設定 <strong>預設值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> product =&#123;</span><br><span class="line">	name : <span class="string">&#x27;Rosa&#x27;</span>,</span><br><span class="line">	cost : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> total = product.<span class="property">cost</span> || <span class="number">50</span> <span class="comment">// ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(total)</span><br></pre></td></tr></table></figure>
<p>雖然 <code>||</code> 很好用，但是 <code>||</code> 會強制轉型，也就是 falsy 。數字 0 在判斷中會被轉為 false ，因此在上面的例子，數字 0 也會被判斷成 false 而預設成 50。</p>
<p>可能會想說那判斷 <code>&gt;=0</code> 不就可以了 ?</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> total = product.<span class="property">cost</span> &gt;= <span class="number">0</span> ? product.<span class="property">cost</span> : <span class="number">50</span> </span><br></pre></td></tr></table></figure>
<p>是可以，但會重複寫兩次 <code>product.cost</code>🥴。<br>
BUT !!! 如果有 <strong>負數</strong> 呢 ? 總不能判斷不是 0 吧。<br>
邏輯寫法就更綁手綁腳，但我們實際只確認是不是空值或是為賦值而已。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> total = (product.<span class="property">cost</span> === <span class="literal">null</span> || product.<span class="property">cost</span> === <span class="literal">undefined</span>) ? <span class="number">50</span> : product.<span class="property">cost</span></span><br></pre></td></tr></table></figure>
<p>因此 short-hand 的 <code>?.</code> 誕生，讓我們可以更快判斷。</p>
<blockquote>
<p>IE 並不支援 <code>?.</code> ，如果要使用就是 <strong>依序判斷是否為 null 或是 undefined</strong></p>
</blockquote>
<h3 id="fuction-call-的">fuction call 的 (?.)</h3>
<p>MDN 有提到是如果使用套件的 API，可以使用這種方式，可以確認 function 是否存在再執行，以免發生錯誤。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayhello = &#123;</span><br><span class="line">	<span class="title function_">hello</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayhello.<span class="property">hi</span>?.()) <span class="comment">// undefined ，不會發生錯誤</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayhello?.<span class="title function_">hello</span>()) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p>但是如果 hi 本身並不是 function 就會發生 <code>is not a function</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sayhello.<span class="property">hi</span> = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayhello.<span class="property">hi</span>?.()) <span class="comment">// hi is not a function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayhello?.<span class="title function_">hello</span>()) <span class="comment">// 不會執行，因為上面出現錯誤</span></span><br></pre></td></tr></table></figure>
<p>手動矯正 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sayhello.<span class="property">hi</span> = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> sayhello.<span class="property">hi</span>=== <span class="string">&#x27;function&#x27;</span> ? sayhello.<span class="title function_">hi</span>() : sayhello.<span class="property">hi</span> ) <span class="comment">// &#x27;123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayhello?.<span class="title function_">hello</span>())  <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<h3 id="什麼時候不應該用">什麼時候不應該用 (?.)</h3>
<ol>
<li>沒有被 <strong>宣告</strong> 的變數 : 對變數使用，會發生錯誤，因為 a 並不存在 (is not defined)，並不能這樣判斷。 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a?.<span class="property">b</span>) <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure>
</li>
<li>重新賦值 (left-hand side) : 不能這樣使用 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">2</span>&#125;</span><br><span class="line">obj?.<span class="property">a</span>  = <span class="number">1</span>  <span class="comment">// Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>
</li>
<li>本身是 null <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> prop = a?.[x++]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// 0 並不會增加</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
這邊我有點不太了解，因此我試了空物件，x 遞增是  1 🤔，a 依然是空物件。後來我找到 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">運算子優先序 - JavaScript | MDN (mozilla.org)</a>，簡單來說 <strong>越高階的運算子會按照規則先執行</strong>。<br>
<code>?.</code> 是 18 ,判斷是從左至右。a 已經是 null 了，所以不會執行。但是如果是空物件 <code>&#123;&#125;</code>，?. 會執行，不是 null 也不是 undefined。而<code>[ ]</code> 跟 <code>?.</code> 的層級相同，<code>[x]</code> 存在所以也會執行 ， <code>++</code> 也會執行。(這邊有點不太確定，待補)</li>
</ol>
<p>另一個有關優先序的常見例子是 <code>(function()&#123;var a = b = 5&#125;)()</code>，在非嚴格模式下， global 依序印出 b 跟 a ，b 是 5 ，a 是 is not defined。因為 <code>=</code> 是 right-to-left，也就是 b 在未宣告下賦值，<code>var  a</code> 因作用域的關係，自然在 global 是 not defined。</p>
<blockquote>
<p>MDN 也提到不應該過度使用 (?.)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj?.[<span class="string">&#x27;Rosa&#x27;</span>]?.<span class="property">number</span> ? obj.[<span class="string">&#x27;Rosa&#x27;</span>].<span class="property">number</span> : obj?.[<span class="string">&#x27;Rosa&#x27;</span>]) <span class="comment">// 👎，因為在 obj.[&#x27;Rosa&#x27;] 不存在就可以停止了，不用串串樂來確認</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj?.[<span class="string">&#x27;Rosa&#x27;</span>] ? obj.[<span class="string">&#x27;Rosa&#x27;</span>].<span class="property">number</span> : <span class="literal">undefined</span>) <span class="comment">// V</span></span><br></pre></td></tr></table></figure>
<h2 id="Nullish-coalescing-operator">Nullish coalescing operator (??)</h2>
<p>可用來判斷 <strong>某個值是 null 或是 undefined</strong></p>
<h3 id="為什麼要有-2">為什麼要有 (??)</h3>
<p>跟上面提到 <code>||</code> 的判斷是一樣的，如果是數字 0 會被強制轉型比較成 false，如果只是想檢查 null 或是 undefined，?? 就會比較方便 。</p>
<p><strong>舉例來說</strong></p>
<ol>
<li>先讓 input 有 0 或是有值</li>
<li>手動把 input 的值完全清空， <code>e.target.value</code> 會是 <strong>空字串</strong>，但是我不想讓空字串也通過</li>
</ol>
<p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="ZErwEBe" data-user="shan473" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/shan473/pen/ZErwEBe">
  練習 ?? &amp; ?.</a> by YanShanHong (<a href="https://codepen.io/shan473">@shan473</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
<h3 id="function-call-的">function call 的 (??)</h3>
<p>來自 MDN 的範例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A was called&#x27;</span>); <span class="keyword">return</span> <span class="literal">undefined</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B was called&#x27;</span>); <span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;C was called&#x27;</span>); <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">A</span>() ?? <span class="title function_">C</span>() );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">B</span>() ?? <span class="title function_">C</span>() );</span><br></pre></td></tr></table></figure>
<p>根據 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">運算子優先序</a></p>
<blockquote>
<p><code>??</code> 是 <code>left-hand side</code> ，也就是 <strong>從左邊判斷開始</strong>。</p>
</blockquote>
<p>其結果是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;A was called&quot;</span></span><br><span class="line"><span class="string">&quot;C was called&quot;</span></span><br><span class="line"><span class="string">&quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;B was called&quot;</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>跟著跑一次 :</p>
<ol>
<li>A() 執行，印出 “A was called”</li>
<li>?? 的左邊是 undefined 所以決定執行 C()</li>
<li>C() 執行，印出 “C was called”</li>
<li>?? 左邊是 undefined 所以是 C() 回傳的結果 ‘foo’</li>
<li>B() 執行，印出 “B was called”</li>
<li>?? 的左邊是 false ，不符合 null 或是 undefined，C() 並不會執行</li>
<li>回傳 B() 的結果</li>
</ol>
<h3 id="不要直接用-OR-或-AND-一起使用">不要直接用 OR (||) 或 AND (&amp;&amp;) 一起使用 (??)</h3>
<p>OR 跟 AND 運算子的優先度比 <strong>??</strong> 還低，因此一起使用會發生錯誤，即使前面的結果是 null 或是 undefined</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> || <span class="literal">undefined</span> ?? <span class="string">&quot;foo&quot;</span>) <span class="comment">// 錯誤</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> || <span class="literal">undefined</span> ?? <span class="string">&quot;foo&quot;</span>) <span class="comment">// 錯誤</span></span><br></pre></td></tr></table></figure>
<p>想讓前面先判斷可以用 <code>()</code> grouping 包起來，grouping 的優先度是最高的，所以會先執行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">null</span> || <span class="literal">undefined</span>) ?? <span class="string">&quot;foo&quot;</span>) <span class="comment">// &#x27;foo&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">true</span> || <span class="literal">undefined</span>) ?? <span class="string">&quot;foo&quot;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="Polyfills">Polyfills</h2>
<p>如果瀏覽器不支援 (如 : IE)，可以使用 Polyfills，只要判斷 null 以及 undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = (somevalue !== <span class="literal">null</span> || somevalue !== <span class="literal">undefined</span>) ? somevalue ? <span class="title class_">DefaultValue</span></span><br></pre></td></tr></table></figure>
<h2 id="總結-19">總結</h2>
<ol>
<li><code>?.</code> 是中找尋 Object 類型 (object 、array 、function 等等)的值如果是 null 或是 undefined，結果是右邊的值。亦可用在 function call (<strong>object.method?.()</strong>) 上</li>
<li><code>?.</code> 不管存不存在，不能用來重新賦值</li>
<li><code>??</code> 是判斷任何值如果是 null 或是 undefined，結果是右邊的值</li>
<li><code>??</code> 不要直接跟 OR 或是 AND 一起使用，要用先把 ?? 左邊的括號起來先執行</li>
<li>兩種 IE 不支援 QQ</li>
</ol>
<h2 id="參考-5">參考</h2>
<ol>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">Optional chaining (?.) - JavaScript | MDN</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_Coalescing_Operator">Nullish coalescing operator (??) - JavaScript | MDN</a></li>
<li><a href="https://javascript.info/optional-chaining">Optional chaining ‘?.’ (javascript.info)</a></li>
<li><a href="https://javascript.info/nullish-coalescing-operator">Nullish coalescing operator ‘??’ (javascript.info)</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">運算子優先序 - JavaScript | MDN (mozilla.org)</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>06</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | 初探 CSS Grid</title>
    <url>/2022/04/04/CSS-Grid.html</url>
    <content><![CDATA[<h2 id="前言-22">前言</h2>
<p>眾所皆知 flex 是排版神器，尤其在一維的排版非常好用<br>
那在二維的排版呢 ?<br>
就不得提到 grid，雖然 grid 在舊的瀏覽器支援性沒到很高，現代瀏覽器是幾乎都有支援。(<a href="https://caniuse.com/css-grid">caniuse</a>)</p>
<span id="more"></span>  
<h2 id="grid-container-容器布局">grid-container 容器布局</h2>
<p>要建立網格，起手式先建造一個容器，準備讓子項網格排列</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item1&quot;</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item2&quot;</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item3&quot;</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item4&quot;</span>&gt;</span>item4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item5&quot;</span>&gt;</span>item5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="display-grid">display : grid</h3>
<p>grid 是二維的版面排版，透過 columns 跟 rows 來安排，直接 加上 grid 不會有變化。</p>
<p>display 有關 grid 的有 2 個值，就像 <code>inline-flex</code> 跟 <code>flex</code></p>
<ol>
<li><code>inline-grid</code></li>
<li><code>grid</code> : 2D 布局</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: grid | inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="格線軌道（Grid-Track）">格線軌道（Grid Track）</h3>
<p>在 grid 中有不同的布局方式，來決定網格的架構</p>
<ol>
<li>軌道</li>
<li>fr 分塊，利用百分比算格數，具有彈性</li>
</ol>
<h3 id="明式格線（explicit-grid）">明式格線（explicit grid）</h3>
<p>明式是自定義軌道，有明就會有暗，暗式是 CSS 幫我們建立的線。</p>
<h4 id="grid-template-columns-橫向軌道">grid-template-columns : 橫向軌道</h4>
<p>橫向網格的寬度。<br>
合法的絕對單位 :</p>
<ul>
<li>%</li>
<li>px</li>
<li>em</li>
<li>rem</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">	<span class="attribute">grid-template-columns</span> : <span class="number">100px</span> <span class="number">100px</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>橫向放入三個元素，各別有寬度。</p>
<ul>
<li>
<p><code>fr</code> : 可用空間的分塊（fraction）。全都 <code>fr</code> 的單位就像切分成幾分之幾，但是類似帶有 flex-grow 、flex-shrink 的功能。</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">	<span class="attribute">grid-template-columns</span>: <span class="number">2</span>fr <span class="number">3</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>橫向呈現兩個元素，前者占 2/5，後者 3/5</p>
</li>
<li>
<p><code>auto</code> : 如果是搭配 fr 單位，會是子元素分配剩餘的空間</p>
</li>
</ul>
<p>如果有重複的版面，除了一個個手打，也可以利用 repeat 快速重複</p>
<ul>
<li><code>repeat(&lt;次數&gt;,&lt;單位&gt;)</code>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>:grid;</span><br><span class="line">	<span class="attribute">grid-template-columns</span> : <span class="built_in">repeat</span>(<span class="number">5</span>,<span class="number">1</span>fr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
容器會被橫向切成五塊。</li>
</ul>
<h4 id="gird-template-rows">gird-template-rows</h4>
<p>直排間的大小，跟 columns 很像</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:grid;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span> : <span class="built_in">repeat</span>(<span class="number">5</span>,<span class="number">1</span>fr); </span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">5</span>,<span class="number">1</span>fr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n)&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n+<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>延伸上一個 columns 的例子，這樣就完成 5X5 的網格版面。<br>
做個簡單的就是黑白棋盤格<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mWjsi1VFCz1a4Y4PYgBdGH4nr_koMsXMKau9gYdZw6NHUWT6BZTF5VZzybgEZeTgEWRW7yShbHrosym0pS8SwRMoz8afSelU59UktSX_elpmKmC2GyvE1HQY_PVkefILEXPrnQoaOVZqP-h3mlpRPRv7Ma6NWNF8bWxiFgg0LCDBQ5pAgdUJKSyhR__iTjKM-?width=1024&amp;height=558&amp;cropmode=none" alt="軌道式布局"></p>
<h4 id="grid-template-混合式布局">grid-template : 混合式布局</h4>
<blockquote>
<p>先 row 再 column</p>
</blockquote>
<ul>
<li>grid-template : <code>&lt;rows-template&gt; / &lt;columns-template&gt;</code></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 軌道式 */</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">	<span class="comment">/* ...略 */</span></span><br><span class="line">  <span class="attribute">grid-template</span>: <span class="built_in">repeat</span>(<span class="number">5</span>,<span class="number">1</span>fr) / <span class="built_in">repeat</span>(<span class="number">5</span>,<span class="number">1</span>fr); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了軌道也可以用命名式的，上面的例子可以改成，下面會再提到命名式的寫法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 軌道式 */</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:grid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">grid-template</span>: </span><br><span class="line">    <span class="string">&quot;. . . . .&quot;</span></span><br><span class="line">    <span class="string">&quot;. . . . .&quot;</span></span><br><span class="line">    <span class="string">&quot;. . . . .&quot;</span></span><br><span class="line">    <span class="string">&quot;. . . . .&quot;</span></span><br><span class="line">    <span class="string">&quot;. . . . .&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://dsm01pap006files.storage.live.com/y4munCQNLVYAOI_NYCgXrtU1bv1eLPQS8Nb_33cNyi0-DhiHRAeXzLCZYZi73nysSdYiALn5Ht-_Hoj0uD1VBw3tiLw5HE95LAuvmENJX9hSx2GnjRXwx_yHe8D5LthivgCGVNW_EuGXFJ8I3fJAtqTZVAbSFx8Zxvx_1Av9IqqrTFpH78MQSYy0dVnBEuy4Eeo?width=1024&amp;height=558&amp;cropmode=none" alt="命名式布局"></p>
<h3 id="暗式格線（implicit-grid）">暗式格線（implicit grid）</h3>
<p>瀏覽器將剩餘的空間自行運用產生的<br>
設定剩下沒有指定 template 的 rows</p>
<blockquote>
<p><strong>implicit grid 預設的寬度會根據內容的大小來改變</strong><br>
如果 定格到超出的 track ，CSS 會自動補上 implicit grid</p>
</blockquote>
<h4 id="grid-auto-rows-grid-auto-columns">grid-auto-rows &amp;  grid-auto-columns</h4>
<p>容器預設寬高。</p>
<ul>
<li><code>minmax</code> 可以設定最小和最大值</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">	<span class="attribute">grid-auto-rows</span> : <span class="built_in">minmax</span>(`&lt;min&gt;,&lt;max&gt;`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="網格間距">網格間距</h3>
<h4 id="grid-gap">grid-gap</h4>
<ul>
<li><code>grid-gap-row</code> : 直向元素的間距</li>
<li><code>grid-gap-column</code> : 橫向元素的間距</li>
</ul>
<p>兩個合併設定 grid-gap :  <code>&lt;row&gt; &lt;column&gt;</code><br>
一樣是 <strong>先 row 再 column</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">	<span class="attribute">grid-gap</span> : &lt;row-gap&gt; &lt;column-gap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="另一種布局-命名式">另一種布局 : 命名式</h2>
<h3 id="grid-template-areas-命名式布局">grid-template-areas : 命名式布局</h3>
<p>透過命名的方式給空間<br>
在父層 <code>grid-template-areas</code> 定義版面<br>
子層元素透過 <code>grid-area</code> 設定別名</p>
<p>常見的範例，快速排出 <strong>三欄式布局</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: grid;</span><br><span class="line">	<span class="attribute">grid-template-areas</span> : </span><br><span class="line">	<span class="string">&quot;header header&quot;</span></span><br><span class="line">	<span class="string">&quot;sidebar content&quot;</span></span><br><span class="line">	<span class="string">&quot;footer footer&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="grid-area-定格之命名式定格">grid-area : 定格之命名式定格</h3>
<p>上面有提到軌道式的合併寫法也可以 <code>grid-area</code> 起點 &amp; 終點，而在命名式布局可以對想要的元素命名，再到布局進行排列。</p>
<p>延續上面的三欄式布局，對個別的區塊 <strong>命名</strong><br>
再個別設定區塊大小。  <a href="https://codepen.io/shan473/pen/yLpjwaK">Codepen 三欄式</a></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">200px</span> <span class="number">1</span>fr <span class="number">64px</span>;</span><br><span class="line">	<span class="attribute">grid-template-areas</span> : </span><br><span class="line">	<span class="string">&quot;header header&quot;</span></span><br><span class="line">	<span class="string">&quot;sidebar content&quot;</span></span><br><span class="line">	<span class="string">&quot;footer footer&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.header</span>&#123;</span><br><span class="line">	<span class="attribute">grid-area</span> : header;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span>&#123;</span><br><span class="line">	<span class="attribute">grid-area</span> : sidebar;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fa0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">	<span class="attribute">grid-area</span> : content ; </span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#0fa</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span>&#123;</span><br><span class="line">	<span class="attribute">grid-area</span> : footer; </span><br><span class="line">  <span class="attribute">background-color</span>: violet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>個人覺得這種方式很直覺，做常規版面規劃就可以很快速😃</p>
<h2 id="grid-item-子項定格">grid-item 子項定格</h2>
<h3 id="grid-row-column-start-end-個別設定定格">grid-row/column start &amp; end 個別設定定格</h3>
<p>有兩種方式來讓格子被佔據</p>
<ol>
<li>軌道範圍</li>
<li>佔據格數</li>
</ol>
<h4 id="透過軸線起終點來指定佔據的範圍">透過軸線起終點來指定佔據的範圍</h4>
<ul>
<li><code>grid-column-start</code> :  column 的佔據軌道起點</li>
<li><code>grid-column-end</code> : column 的佔據軌道終點</li>
</ul>
<p>打開 Devtools 按下 grid 的格線視覺工具就可以看見<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mFIFKSjXekpoog3xRQ2ne9NlGlppe2cMmpEyFJah7PMyNkDaFqG3BIrKWtESIgciPHiZw_qqYVFJRFYWO0OHTqvcyjR_0APRrrlZb7mVrKDkTDLsBclQunblwKtk4aoAwiGEk-E8u68pOAqaRSyu6NQ2Cb69euzI-d_02dR7VNk2rk15g-bDZqscdaCPFbDn0?width=1024&amp;height=588&amp;cropmode=none" alt="Devtools grid"></p>
<p>合併寫法</p>
<ul>
<li><code>grid-column</code> : &lt;起點&gt; /  &lt;終點&gt;</li>
</ul>
<p>如果想要 <strong>占據整行</strong>，除了從 <strong>第一行 / 末行</strong> 這樣寫，也可以利用負數來達成。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span>&#123;</span><br><span class="line">	<span class="attribute">grid-column</span> : <span class="number">1</span>/-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="span-數格數">span : 數格數</h4>
<p>預設 grid-column 是 <code>span 1</code>，就是按照 flow 占據一格</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-2</span>&#123;</span><br><span class="line">	<span class="attribute">grid</span>-colum : span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="grid-area-軌道混合式定格">grid-area : 軌道混合式定格</h3>
<p>grid-area : <code>&lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;</code>。</p>
<p>按照老規矩 <strong>先 row 開始再 column</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">	<span class="attribute">grid-area</span> : <span class="number">1</span> / <span class="number">2</span> / <span class="number">3</span> / <span class="number">4</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="order-順序">order 順序</h2>
<p>跟 <code>flex</code> 一樣 grid 是可以改變順序的。</p>
<ul>
<li><code>order : 0</code> 照原本的排序</li>
<li><code>order : -1</code> : order 也可以是負值，屬於往前排。</li>
</ul>
<p>order 的起始點是從 <strong>整體的排列</strong> 後面開始算起。<br>
首先要知道 grid 的排列順序，預設是 row ，也就是從 row 的尾巴開始，如果有兩列，就是從第二列的尾巴開始。</p>
<iframe height="300" style="width: 100%;" scrolling="no" title="Untitled" src="https://codepen.io/shan473/embed/vYpjMZW?default-tab=result&theme-id=dark" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/shan473/pen/vYpjMZW">
  Untitled</a> by YanShanHong (<a href="https://codepen.io/shan473">@shan473</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>
<h2 id="對齊">對齊</h2>
<h3 id="整體垂直與水平對齊">整體垂直與水平對齊</h3>
<p>設定在父層，控制 <strong>整個網格</strong> 的位置</p>
<ul>
<li><code>justify-content</code> : 所有的子項水平位置。</li>
<li><code>align-content</code> :  所有的子項垂直位置</li>
</ul>
<blockquote>
<p>flex-end(start) 這是給 flexbox 用的，gird 寫法是 start 跟 end</p>
</blockquote>
<p>設定在父層，控制 <strong>所有網格中的內容對齊</strong></p>
<ul>
<li><code>justify-items</code> : 預設是 stretch，個別設定會按照子項內容的 <strong>寬</strong> 再去水平對齊。</li>
<li><code>align-items</code> : 預設是 stretch，個別設定會按照子項內容的 <strong>高</strong> 再去垂直對齊。</li>
</ul>
<h3 id="個別設定子項內容對齊">個別設定子項內容對齊</h3>
<p>設定在子層，控制 <strong>個別網格中的內容對齊</strong><br>
子項的內容物想要客製化的對齊，複寫 justify-items &amp; align-items 的控制。</p>
<ul>
<li><code>align-self</code> : 預設是 stretch，使用跟 align-items 差不多。</li>
<li><code>justufy-self</code> :  預設是 stretch，使用跟 justify-items 差不多。</li>
</ul>
<iframe height="300" style="width: 100%;" scrolling="no" title="Untitled" src="https://codepen.io/shan473/embed/PoEevZg?default-tab=result&theme-id=dark" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/shan473/pen/PoEevZg">
  Untitled</a> by YanShanHong (<a href="https://codepen.io/shan473">@shan473</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>
<h2 id="z-index-圖層">z-index 圖層</h2>
<p>以往我們要用到 <code>z-index</code> 都會是在絕對定位的時候，在 grid 中是可以把項目堆疊的，透過 <code>z-index</code> 來前後順序。</p>
<p>預設的圖層順序是 html 結構 <strong>後面的會覆蓋前面的</strong>，可以直接透過 <code>z-index</code> 改變順序。</p>
<p>這個例子兩個有重疊的部分，item-5 寫上後蓋住了 item-1，為了讓 item-1 被看見，圖層寫得比 item-5 高就行了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span>&#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: <span class="number">1</span> / <span class="number">2</span> / <span class="number">1</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-5</span>&#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: <span class="number">1</span> / <span class="number">1</span> / <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="總結-20">總結</h2>
<p>本篇還有很多 grid 的應用還沒研究到，未來再專研 !<br>
很推 <strong>CSS-tricks</strong> 上的文章，很多寫法都很實用</p>
<h2 id="練習">練習</h2>
<ul>
<li>以 <strong><a href="https://zh.wikipedia.org/wiki/%E7%9A%AE%E7%89%B9%C2%B7%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89">皮特·蒙德里安</a></strong> 的《紅、藍、黃的構成》做為練習，說到網格自然就想到這幅畫  XD。<br>
<a href="https://codepen.io/shan473/pen/KKZRmRm">Codepen</a><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4meQohOpsPirn8FgIW6-32dz_PV_9ldr3h7XdfuoLRBgBMVuweq_tSNsV7Osnk8yDBjyZhV4cVT0RuzJnF4Mf5bLcYc5KKVnVXBuu0bOvra6l8WSV33Yu6krcT-r8yl7TlqLB1ir3IPN2crKR6HWWWwN7avpOZB6UabLXjVNMBVnGxMiRl_8PrB3Gs8xKtehAv?width=1022&amp;height=1024&amp;cropmode=none" alt="CSS 版-紅、藍、黃的構成"></li>
<li>額外來自 Frontend Mentor 的練習題，利用 grid 進行排版<br>
<a href="https://meitung473.github.io/testimonials-grid-section-main/">Frontend Mentor | Rosa Hong</a></li>
<li>grid-graden (已破關) : <a href="https://cssgridgarden.com/">Grid Garden - A game for learning CSS grid </a>
<blockquote>
<p>心得 :<br>
遊戲式的 grid 很容易理解，<br>
template 除了正數以外，也可以使用 <strong>負數</strong>。<br>
個人遇到 26 關卡了一下，其他掌握住如何算軌道跟知道格數怎麼應用就沒什麼障礙。對齊的部份，都在另一個 flexbox frog。</p>
</blockquote>
</li>
</ul>
<h2 id="參考-6">參考</h2>
<ul>
<li>快速查表 :  <a href="https://grid.malven.co/">GRID: A simple visual cheatsheet for CSS Grid Layout (malven.co)</a></li>
<li>好筆記 : <a href="https://pjchender.dev/css/css-grid-layout/">[CSS] Grid Layout | PJCHENder 未整理筆記</a></li>
<li>非常詳盡的圖文並茂解說 : <a href="https://css-tricks.com/snippets/css/complete-guide-grid/">A Complete Guide to Grid | CSS-Tricks - CSS-Tricks</a> 。我也很推 flexbox 的教學</li>
</ul>
]]></content>
      <categories>
        <category>2022</category>
        <category>04</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>grid</tag>
      </tags>
  </entry>
  <entry>
    <title>CSSZeroToOneSeries | 07 | 導覽列 &amp; 變化導覽列</title>
    <url>/2022/04/04/CSSSeriesZeroToOne-07.html</url>
    <content><![CDATA[<h2 id="本篇成果-17">本篇成果</h2>
<p><a href="https://codepen.io/shan473/pen/abVaLWx">Codepen</a><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4m9T4H16Ta75kDzYcQq5DvDiixK4mUT7-zgyeMbwFltHZbFafI5uejyNEI2PKXuVsHwbitph6KpHB-W1twOqWHvFYJXV0ZHqpaK31pEbAbsnH7ffzVJrY4jCn-DQT8BuQlWSI7mhiwxpMOte8vgXL82SlBMc9CDVnRs4GQaX5zSfAIPFEVdD6wo429FOHMt4kh?width=1024&amp;height=133&amp;cropmode=none" alt="導覽列"></p>
<p>LOGO 放中央的四種不同寫法導覽列<br>
<a href="https://codepen.io/shan473/pen/NWwLwmZ">Codepen</a><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mxh2kVWQGz5Y5blS98ignQpvNJzpOWFoegrfNdnwioXN37pRMs_UAXWIjV38dGFgg2z4HSQGInRsfJzwzxhUc1-TL4o4jsjhWV_PINth18C_qZ2JEo-KuJm3UAaU8ePorHvVKZABYHV6LJ9mgFTP4YdVPGUP2DmOSCmHehmX01KVzjrVlFs-xp9IVKe_3hKWO?width=660&amp;height=444&amp;cropmode=none" alt="變化導覽列"></p>
<span id="more"></span>
<h3 id="max-width-最大寬度">max-width : 最大寬度</h3>
<p>避免現代螢幕過寬(高解析度螢幕)導致元素被擠在邊邊，如果原本是 width 是填滿的情況，使用 <code>display : flex，justify-content : space-between</code>，元素會被分散在螢幕的邊邊角角。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="input-focus">input : focus</h3>
<p>input 在打字時會有預設的外框線 <strong>(outline)</strong>，可以把框線消失，讓視覺體驗更加。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span>:foucs&#123;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="a-tag-不能-transform-的原因">a tag 不能 transform 的原因</h3>
<p>幫連結加上浮上去的漸變動畫， a 的預設 display 是 <code> inline</code>，會發現直接加上去 a 並不會有變化。</p>
<p>實際上 inline 屬性的元素並不支援，修改 display 屬性就可以了。</p>
<p>參考 :</p>
<ul>
<li><a href="https://stackoverflow.com/questions/14883250/css-transform-doesnt-work-on-inline-elements">CSS transform doesn’t work on inline elements - Stack Overflow</a></li>
</ul>
<blockquote>
<p>根據 CSS 規格書，有提到區塊元素或者 <code>inline-auto</code> 這類才可以 transform。</p>
</blockquote>
<h3 id="border-畫線效果">border 畫線效果</h3>
<p>position 讓我們可以利用 top、bottom、left、right 四邊進行定位，也可以撐開全版面。<br>
也可以利用偽元素的 <code>left</code>、<code>right</code> 來創造線條收縮的效果。</p>
<blockquote>
<p>為什麼用偽元素 ? 這邊的底線只是 <strong>裝飾作用</strong> 不具任何資訊，盡量不要創造新的 tag 來裝</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">right</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="built_in">var</span>(--txtColor); </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transition</span><span class="selector-pseudo">:left</span> .<span class="number">3s</span> ease,<span class="attribute">right</span> .<span class="number">3</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">right</span>:<span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>後來想想這樣的寫法不太好，原因在於 <a href="https://csstriggers.com/top"><code>top</code></a> 這類定位是會 <code>reflow</code> (重排)，效能上比較不好，選擇只有 <code>repaint</code> (重繪) 的 <a href="https://csstriggers.com/transform">transform</a></p>
</blockquote>
<p>改成 transform</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.1em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: center;</span><br><span class="line">  <span class="attribute">transition</span>: transform .<span class="number">3s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(.<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>transition 不要使用 <code>all</code>，針對要件漸變的部分設定就好，以免效能上的浪費。</p>
</blockquote>
<h2 id="導覽列變化手法">導覽列變化手法</h2>
<ol>
<li>把 LOGO 擺中間</li>
<li>flexbox 改變 order</li>
<li>直接改寫 HTML 結構</li>
<li>利用絕對定位</li>
</ol>
<p>個人最喜歡 flexbox 的部份，既不修改結構，又保有彈性修改，哪天想讓 LOGO 到最前面只要修改 <code>order</code> 即可。</p>
]]></content>
      <categories>
        <category>2022</category>
        <category>04</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSSZeroToOneSeries</tag>
      </tags>
  </entry>
  <entry>
    <title>CSSZeroToOneSeries | 08 | 網站麵包屑</title>
    <url>/2022/04/04/CSSSeriesZeroToOne-08.html</url>
    <content><![CDATA[<h2 id="本篇成果-18">本篇成果</h2>
<p><a href="https://codepen.io/shan473/pen/MWOqRoJ">Codepen</a><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4m2Ut7v52DvB4HXKmhJiPfdh0fC0SYoIg5T6XnWySFOIDNRpNgeG6BkVMmRRZ1qoFlUYVdtq9et8hdrrwbuKF_IqtJFFUTFY2ZI0HDP4tw4ma1Jx9JaMbE6WmvD7YYOv32FJlbpmUwIGLUMzWi1CyKgXyGm598Nl1TZPipEnVfdXC5t8p5GdEi7KevsBdw7Zou?width=1024&amp;height=585&amp;cropmode=none" alt="麵包屑"></p>
<span id="more"></span>
<h2 id="before-偽元素">::before 偽元素</h2>
<p><code>::before</code> 或是 <code>:before</code> 寫法都可以<br>
利用 <code>content</code> 內容產生的箭頭，可以隨時替換<br>
箭頭也屬裝飾性，不用再特別寫 html tag</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.breadcrumb</span> <span class="selector-tag">li</span> + <span class="selector-tag">li</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">	<span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>content 覺得圖案太少，也可以利用網頁編碼 UTF-8 的特殊字元來顯示</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.breadcrumb</span> <span class="selector-tag">li</span> + <span class="selector-tag">li</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">&#x27;\003E&#x27;</span>;</span><br><span class="line">	<span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這兩者是一樣的，但前提是要在 html 加入 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code> 設定編碼<br>
參考 : <a href="https://www.toptal.com/designers/htmlarrows/">快速編碼箭頭</a></p>
<h2 id="再深入偽元素">再深入偽元素</h2>
<h3 id="偽元素出現的位置">偽元素出現的位置 ?</h3>
<p>偽元素需要經過瀏覽器的運算跟渲染之後才會出現，所以 <strong>檢視原始碼</strong> 是看不到的</p>
<h3 id="content">content</h3>
<p>偽元素一定要有 <code>content</code> ，不然就不會出現了<br>
其中 content 包含各式各樣的屬性</p>
<ol>
<li>none</li>
<li>normal</li>
<li><code>string</code></li>
<li>url</li>
<li><code>counter</code></li>
<li><code>attr</code></li>
<li>open-quote</li>
<li>close-quote</li>
<li>no-open-quote</li>
<li>no-close-quote</li>
</ol>
<p>這邊舉例常見的幾個樣式</p>
<h3 id="string">string</h3>
<p>一般的文字或是空內容，拿來裝飾元素<br>
像本篇的箭頭就是 string</p>
<h3 id="counter-讓-css-數數">counter : 讓 css 數數</h3>
<p>在父層新建一個 reset 計時器<br>
<code>counter-reset : &lt;計時器名稱&gt; &lt;起始值&gt;</code>，如果沒有寫起始值是從 0 開始</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="attribute">counter-reset</span>: Section <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其實也可以多層</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="attribute">counter-reset</span>: Section <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span>&#123;</span><br><span class="line">  <span class="attribute">counter-reset</span>: P <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">&#x27;Section&#x27;</span> <span class="built_in">counter</span>(Section)<span class="string">&#x27; .&#x27;</span>;</span><br><span class="line">	<span class="attribute">counter-increment</span>: Section <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">&#x27;P&#x27;</span> <span class="built_in">counter</span>(Section)<span class="string">&#x27;-&#x27;</span><span class="built_in">counter</span>(P)<span class="string">&#x27; .&#x27;</span>;</span><br><span class="line">	<span class="attribute">counter-increment</span>: P <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子層的偽元素可以使用 counter 進行計數</p>
<ul>
<li>content : counter(<code>&lt;計數器名稱&gt;</code>)</li>
<li>counter-increment : <code>&lt;計數器名稱&gt; &lt;要增加的數字&gt;</code> 也可以是負數</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="attribute">counter-reset</span>: Title;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;Title &#x27;</span><span class="built_in">counter</span>(Title)<span class="string">&#x27; .&#x27;</span>;</span><br><span class="line">  <span class="attribute">counter-increment</span>: Title <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="attr">attr</h3>
<p>可以拿到 <code>data-</code> 屬性的值，如果跟資料有關的不要放在偽元素，瀏覽器在解析時是讀取不到的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">data-title</span>=<span class="string">&quot;商店&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">data-title</span>=<span class="string">&quot;品項&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">data-title</span>=<span class="string">&quot;貨物&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(data-title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<iframe height="300" style="width: 100%;" scrolling="no" title="css counter" src="https://codepen.io/shan473/embed/podGNON?default-tab=result&theme-id=dark" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/shan473/pen/podGNON">
  css counter</a> by YanShanHong (<a href="https://codepen.io/shan473">@shan473</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>
<h3 id="url-沒作用的圖片">url 沒作用的圖片</h3>
<p>content 中的 <a href="http://csscoke.com/2013/09/22/%E4%BD%BF%E7%94%A8before-%E8%88%87-after%E4%BE%86%E8%A3%BD%E4%BD%9C%E5%8F%AF%E5%88%97%E5%8D%B0%E7%9A%84logo%E5%9C%96%E7%89%87/">url 圖片雖然能被列印出來</a>，但不能調整寬高尺寸，只能利用 scale 來縮放。</p>
<p>根據 <a href="https://segmentfault.com/q/1010000004569689">這篇文</a>，偽元素預設是 inline 的一種，就算調成 block，因為 content 並不是實際計算範圍，block 算的是匿名元素的 <code>width</code> 跟 <code>height</code></p>
<p>真的想放圖片可以使用 background-imge，再透過 background-size 調整大小，但是就不能被影印</p>
<h3 id="注意">注意</h3>
<p>為了 SEO 著想，偽元素出現在裝飾性上就好，資訊類就不建議了</p>
<h2 id="兄弟選擇器-，我的隔壁">兄弟選擇器 (+) ，我的隔壁</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>排擠我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>我有<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>我有<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是防守員<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>排擠我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>我有<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> + <span class="selector-tag">a</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 sass 會寫 <code>&amp; + &amp;</code>，通常是排除第一個，因為第一個的前面並沒有元素</p>
<p>或者寫 <code>:not</code> 把第一個給排除掉</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:first</span>-child)</span><br><span class="line">	<span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="網頁色彩-HSL">網頁色彩 HSL</h2>
<p><code>hsl (色相角度&lt;0~360&gt; , 色彩飽和度 , 色彩的明度 )</code><br>
色彩是 RGB，分別各佔 120 度</p>
<p><a href="http://csscoke.com/2015/01/01/rgb-hsl-hex/"><img data-src="https://dsm01pap006files.storage.live.com/y4mzaFTHqTQKFWQ2sQ_sISqYOCtvikOQA4Dmli4z7vpaNjUQ7Nirr4UbVRGbiS9uCI9vba3kPgs7-_xx4wqwjkXxMs-VnajXcBBhswICqcXV54qi9lLN5lSAO_A-G5MdHISuaULUSfhoHKbgA1KFfLD6bcojrfSyoJJqCwIodr7i0AGpp8ainTKi0Fl7MV7y3XO?width=500&amp;height=424&amp;cropmode=none" alt="HSL 色相環圖片"> 來自《RGB、HSL、Hex 網頁色彩碼，看完這篇全懂了 | CSS可樂》</a></p>
<ul>
<li><code>Hue</code> : 色相</li>
<li><code>Saturation</code> : 飽和度。 預設是 100%，越低越接近灰黑</li>
<li><code>Lightness</code> : 亮度。 預設是 50%。 有點像相機的曝光度，增加白色或黑色的量</li>
</ul>
<p>例 :  綠色  <code>hsl (120,100%,50%)</code></p>
<h2 id="參考-7">參考</h2>
<ol>
<li><a href="https://segmentfault.com/q/1010000004569689">伪类before/after中的图片大小是不是不能设置的? - SegmentFault 思否</a></li>
<li><a href="http://csscoke.com/2013/09/22/%E4%BD%BF%E7%94%A8before-%E8%88%87-after%E4%BE%86%E8%A3%BD%E4%BD%9C%E5%8F%AF%E5%88%97%E5%8D%B0%E7%9A%84logo%E5%9C%96%E7%89%87/">使用::before 與 ::after來製作可列印的logo圖片</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>04</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSSZeroToOneSeries</tag>
      </tags>
  </entry>
  <entry>
    <title>CSSZeroToOneSeries | 09 | 方塊酥版</title>
    <url>/2022/04/04/CSSSeriesZeroToOne-09.html</url>
    <content><![CDATA[<h2 id="本篇成果-19">本篇成果</h2>
<p><a href="https://codepen.io/shan473/pen/wvPYowG?editors=0100">Codepen</a><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mRHJR5nKjd7Mry0fH-Eevw_EuUBALAe_xSDwFAsLc-jhOf9MVukfDscCyR0aOVgn_lXXMo0TTA9P005lZ17bfeeA1u1cH1pUKDVEDHN8e9zgJptSKT1iav8eWY0i6YhYCS8uM0UuTvFQpSWlDK4sLzuIjHGVDA8aLixITKrKveAHX73wjxjTY1VgK64Xx19fM?width=1024&amp;height=585&amp;cropmode=none" alt="方塊酥版"></p>
<span id="more"></span>
<h3 id="float-2">float</h3>
<p>子層設定 float 的時候，會脫離原本的排版序，會導致父層的高度錯誤或抓不到，就要清除浮動 (clearfix)，以免後面的元素不照順序擠上來。</p>
<h4 id="清除浮動-overflow">清除浮動 : overflow</h4>
<blockquote>
<p>父層消除 float</p>
</blockquote>
<p>父層 <code>overflow:hidden</code> ，讓父層可以抓到子層的高度。<br>
overflow 是處理多餘的內容，hidden 隱藏起來</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>左邊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>右邊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我要在下面<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>:hidden;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fa0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">80%</span>;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:right</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="清除浮動-多一個-clearfix-元素">清除浮動 : 多一個 clearfix 元素</h4>
<blockquote>
<p>重點在於子元素，如果下一個想要按照自己的流向排，可以在前面加上 <code>clearfix</code> 斬斷 float 的排版</p>
</blockquote>
<p>在想要正常排版在子元素屁股後面，設定 <code>clear : both</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>float 左邊<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>float 右邊<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clearfix&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>按照老方法往下排<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line"> <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line"> <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">	<span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按下開關可以看有無 float 的效果</p>
<iframe height="300" style="width: 100%;" scrolling="no" title="float clearfix" src="https://codepen.io/shan473/embed/NWwObjj?default-tab=result&theme-id=dark" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/shan473/pen/NWwObjj">
  float clearfix</a> by YanShanHong (<a href="https://codepen.io/shan473">@shan473</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>
<h4 id="清除浮動-父層-after">清除浮動 : 父層 :after</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>左邊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>右邊<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我要在下面<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>:hidden;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fa0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &gt;<span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">	<span class="attribute">content</span> :<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="attribute">display</span>:block;</span><br><span class="line">	<span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>偽元素一定要設定 <code>block</code>，讓寬度撐開</p>
</blockquote>
<h3 id="波浪號選擇器">~ 波浪號選擇器</h3>
<p>波浪號是兄弟選擇器，在同一層的後面兄弟都選起來</p>
<p>常用 <strong>第一個  ~  到底的元素</strong> 都選起來，<a href="../CSSSeriesZeroToOne-08.md">08 篇</a> 的麵包屑除了 <code>(p + p)</code>，波浪號也可以使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>no.1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>no.2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>no.3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>no.4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child ~<span class="selector-tag">p</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一種是想選到同一層的某個東西(們)，除了直接選取外，也可以透過 波浪號</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是 span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是 span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>我是連結<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>我是連結<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是 span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>~<span class="selector-tag">a</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="not-排擠你">:not : 排擠你</h3>
<p>屬於逆向思考，如果要選取除了第一個以外的其他方框，除了用波浪號</p>
<ul>
<li>一般波浪號排擠</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>波浪號式排擠<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>一號走開<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>一號走開<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>一號走開<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>~<span class="selector-tag">p</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>:not</code> : 排擠，麻瓜翻譯機，要選到 <strong>非第一個的 p</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:first</span>-child)&#123;</span><br><span class="line">	<span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="試著用-Grid">試著用 Grid</h2>
<p>同樣的架構，把 float 去除，利用軌道線進行排版。<br>
<a href="https://codepen.io/shan473/pen/ZEvRByL?editors=0100">Codepen</a></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>:grid;</span><br><span class="line">  <span class="attribute">grid-template</span>: <span class="built_in">repeat</span>(<span class="number">3</span>,<span class="number">1</span>fr) / <span class="built_in">repeat</span>(<span class="number">4</span>,<span class="number">1</span>fr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:first</span>-child&#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: <span class="number">1</span> / <span class="number">1</span> / <span class="number">3</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="參考-8">參考</h2>
<ol>
<li><a href="https://medium.com/ui-ux%E7%B7%B4%E5%8A%9F%E5%9D%8A/%E8%A7%A3%E9%99%A4-float-%E5%B1%AC%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95-5e29cc30777d">解除 float 屬性的方法. 使用 float 屬性一定要清除浮動，否則會有版面錯置或失去高度的情況</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>04</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSSZeroToOneSeries</tag>
      </tags>
  </entry>
  <entry>
    <title>CSSZeroToOneSeries  | 10 | 破格式設計</title>
    <url>/2022/04/04/CSSSeriesZeroToOne-10.html</url>
    <content><![CDATA[<h2 id="本篇成果-20">本篇成果</h2>
<p><a href="https://codepen.io/shan473/pen/QWOZgzP">Codepen</a><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mc1SNrsZu-Jd9u35WNRJfQgL79lh5rKUE-T708KZoUgmfj1e0iFbqwtXItGPmNayXFew5OcaISpno8uR1h5a0KOuWpfs9NvwytLMedU4ijzl-h2mJT3AKapQU7kA5rNBSPp_QOV-6viFwczOvlSgU65TDbCQlby6ccQSZ4Rvcith2HND8fQOqhBUHkD3FrJAo?width=1024&amp;height=586&amp;cropmode=none" alt="破格式設計"></p>
<span id="more"></span>
<h3 id="margin-值的數量">margin 值的數量</h3>
<ul>
<li>兩個數值<br>
margin : &lt;上下&gt;  &lt;左右&gt;</li>
<li>四個數值<br>
margin : &lt;上&gt; &lt;右&gt; &lt;下&gt; &lt;左&gt;</li>
<li>三個數值<br>
margin : &lt;上&gt; &lt;左右&gt; &lt;下&gt;</li>
</ul>
<p>比較常用到置中 <code>margin : 0 auto</code>，auto 是把剩餘的空間分配給左右，因此才會置中。<br>
實際上 margin : auto ，雖然是寫全部自動分配，但是 <a href="https://www.zhihu.com/question/21644198">上下並沒有作用</a>。</p>
<p>css 的預設 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode">write-mode (書寫模式)</a> 的方向是 <strong>水平</strong> 的，當我們用 margin-top : auto 或 margin-bottom : auto ，因為高度並無固定值，無法參照，剩餘空間也是 0 。</p>
<h3 id="line-height-單行垂直居中">line-height 單行垂直居中</h3>
<p>如果是文字單行居中容器，可以把 <code>line-height</code> 設定跟容器高一樣</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="border-區塊位置計算-要記得扣掉">border 區塊位置計算 : 要記得扣掉</h3>
<p>實作是 icon 的利用 <code>:before</code> 的 border 做圓框，粗度是 10 px。<br>
<code>top : 0、left : 0</code>，把版面定位到父層起始左上角一樣，此時 border 粗度上下左右都會增長 10px，如果要置中，必須把 border 多出來的在 top、left 扣掉，元素才能擺到中間填滿。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.icon</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">	<span class="attribute">position</span> : absolute;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line">	<span class="attribute">top</span>: -<span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">left</span>: -<span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">width</span> : <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="border-上下左右的呈現方式">border 上下左右的呈現方式</h3>
<p>以半圓框為例，我們知道 border 的切齊點是對角線 (下圖)，變成圓形的話，上下左右並不是剛好從 0 切齊到 90 度<br>
如果想要得到半圓，必須是鄰近兩個 border 再做旋轉 45 度。</p>
<ul>
<li>width、height 為 0 ，單純的 border</li>
</ul>
<p><img data-src="https://dsm01pap006files.storage.live.com/y4mVu7eeg2awMupFoD5T_nq55dVmzodISxqWR8paqvV46NhzCf4-VPLWZ0Xlm_JLUFsOCEGTcqVb6SoH4icdXFX9V3ZLR39nFB5YYYyNr-ENP529_4MNud_lE-ksXUdUOblMf7y8cah3KcaOjNIgJr_9l8o-fXeE4FZotOCa1CSDMl5pHcz4tP-0UtZeuurM5DG?width=496&amp;height=488&amp;cropmode=none" alt="純 border 圓形"></p>
<blockquote>
<p>正確的半圓是相鄰兩邊的 border 組合出來的<br>
像是 <a href="../CSSSeriesZeroToOne-03/#%E8%A3%9C%E5%85%85-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E9%99%B0%E5%BD%B1">03 篇</a>能出現陰影的三角形一樣的概念</p>
</blockquote>
<h3 id="子層物件整體高度超出父層-padding-擠回去">子層物件整體高度超出父層 : padding 擠回去</h3>
<p>因為 icon margin-top 是 -75 px，比原本父層凸出 75 px ，必須在整體的 padding 把多的補回去，把子容器的元素都包含在內。</p>
<h2 id="參考-9">參考</h2>
<ol>
<li><a href="https://www.zhihu.com/question/21644198">为什么「margin:auto」可以让块级元素水平居中？</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>04</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSSZeroToOneSeries</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - Closure 閉包(I) 基礎概念</title>
    <url>/2022/04/04/JavaScript-Closure-I.html</url>
    <content><![CDATA[<h2 id="前言-23">前言</h2>
<p>Closure 是 JavaScript 很重要的基礎<br>
藉由本篇幫助自己釐清 Closure 的概念</p>
<span id="more"></span>
<h2 id="先認識-Scope-Chain">先認識 Scope Chain</h2>
<p><a href="https://blog.rosa.tw/Frontend/JavaScript/JavaScript-Hoisting-II/?highlight=scope#%E4%BD%9C%E7%94%A8%E5%9F%9F-Scope">Scope</a> 是變數生存的範圍，如果在自己層級找不到就會一層一層往外找，直到 Global 為止。</p>
<p>這種行為就稱為「<strong>範圍鏈</strong>」(Scope Chain)。</p>
<blockquote>
<p>範圍鏈是在函式<strong>被定義的當下決定</strong> (lexical scope 來決定)的，不是在被呼叫的時候決定。</p>
</blockquote>
<h3 id="範例">範例</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;global&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> a  = <span class="string">&#x27;change&#x27;</span></span><br><span class="line">	<span class="title function_">test</span>()</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// change</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//global</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">change</span>()</span><br></pre></td></tr></table></figure>
<p>一開始會以為 <code>test()</code> 在 change 裡面呼叫，取得的變數 a 是 change 對不對 ?</p>
<p>NO NO NO,再重複一次 !</p>
<blockquote>
<p>範圍鏈是在函式<strong>被定義的當下決定</strong> 的，不是在被呼叫的時候決定。</p>
</blockquote>
<p><code>test</code> 函式在 Lexical Environments 是 gloabal 的下一層，Scope Chain 是根據 Lexical scope 決定，往上找是 gloabl 那層，所以結果才會是 <code>'global'</code></p>
<h2 id="為什麼要有-Closure">為什麼要有 Closure ?</h2>
<blockquote>
<p>反問 👉 <strong>沒有 Closure 會怎樣 ?</strong></p>
</blockquote>
<p>我們知道 Execution Context 執行環境在執行完 function 後，Stack 會抽掉，有關這個 function 的一切變數也會被回收而且不可再使用。</p>
<ul>
<li>如果要使用 function 裡的變數呢 ? (<code>private variable</code> 的概念)</li>
</ul>
<p>直覺可能會丟到 <code>global</code> 進行宣告，但當專案結構逐漸龐大，久而久之會造成 <strong>全域變數汙染</strong></p>
<p><strong>那閉包的出現解決了…</strong> :</p>
<ul>
<li>自由變數 (free variable)，只有在 function 內部可讀取變數，在外部則無法讀取。</li>
<li>變數暫存，減少重複的複雜計算</li>
</ul>
<h2 id="Closure-的優缺點">Closure 的優缺點</h2>
<ul>
<li>
<p>優點 :</p>
<ol>
<li>避免 <strong>全域變數汙染</strong></li>
<li>提供 <strong>自由變數</strong>，讓該 function 執行完後，變數的作用域不會因 function 結束被回收，而是會繼續存在。</li>
<li>避免重複執行龐大的計算<br>
可以記錄前一次計算的狀態，下一次再呼叫不用重算一次 (cache 的概念)。</li>
<li>在多人協作的時候，有些隱密的資訊不想讓人去修改，可以使用封裝閉包的方式。<br>
別人必須依照固定的寫法來取得資料，且不能修改到內部的資訊。<br>
在開源資料或 API 的方法常使用這樣的方式，以免改動到內部數值。</li>
</ol>
</li>
<li>
<p>缺點 :</p>
<ol>
<li>可能保留到一些不必要的變數或資訊，造成資源多餘消耗。</li>
<li>只能使用涵式提供的方法，因為內部的資訊被隱蔽，在更動上較不彈性。<br>
(但是相反如果不想要被改動會是優點)</li>
</ol>
</li>
</ul>
<h2 id="什麼是閉包">什麼是閉包 ?</h2>
<p>除了自己本身的程式碼外，也可以取得了<strong>內部函式「當時環境」的變數值</strong>，記住了執行當時的環境，這就是「閉包」。</p>
<h2 id="簡單的-Closure-範例">簡單的 Closure 範例</h2>
<ul>
<li>沒有使用閉包</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rate = <span class="number">.75</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">itmePrice</span>(<span class="params">price</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> price &gt;= <span class="number">100</span> ? price*rate : price</span><br><span class="line">&#125;</span><br><span class="line">rate = <span class="number">.1</span> </span><br><span class="line"><span class="keyword">let</span> bag = <span class="title function_">itmePrice</span>(<span class="number">150</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bag)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以透過直接修改數值 (👎)<br>
任何人都可以在外部進行修改</p>
</blockquote>
<ul>
<li>使用閉包</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">itmePrice</span>(<span class="params">price</span>)&#123;</span><br><span class="line">	<span class="comment">// 把 rate 變成私有變數</span></span><br><span class="line">	<span class="keyword">var</span> rate = <span class="number">.75</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> price &gt;= <span class="number">100</span> ? price*rate : price</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bag = <span class="title function_">itmePrice</span>(<span class="number">150</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bag</span>())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只要呼叫需要的東西即可 (👍)<br>
不會被外部修改</p>
</blockquote>
<h2 id="參考-10">參考</h2>
<ol>
<li><a href="https://blog.huli.tw/2018/12/08/javascript-closure/">所有的函式都是閉包：談 JS 中的作用域與 Closure - Huli</a></li>
<li><a href="https://javascript.info/closure#lexical-environment">Variable scope, closure</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10193009">重新認識 JavaScript: Day 19 閉包 Closure</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>04</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - Closure 閉包(II) 常見陷阱題</title>
    <url>/2022/04/04/JavaScript-Closure-II.html</url>
    <content><![CDATA[<h2 id="前言-24">前言</h2>
<p>之前學習閉包沒辦法很容易連結到<br>
尤其 Function 有一堆名詞變異體<br>
總會好奇實際的應用情境</p>
<p>那發生什麼問題才會使用到 Closure 呢?<br>
又怎麼在真正的專案解決問題 ?</p>
<span id="more"></span>
<h2 id="問題-在迴圈中呼叫函式">問題 : 在迴圈中呼叫函式</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">  arr[i] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">arr[<span class="number">0</span>]();</span><br><span class="line">arr[<span class="number">1</span>]();</span><br></pre></td></tr></table></figure>
<p>複習一下 :</p>
<blockquote>
<p><code>var</code> 的切分單位是 <code>function</code></p>
</blockquote>
<p>直覺來說會覺得 <code>i</code> 是會按順序列出<br>
結果是 <code>5 5</code><br>
因為 for 設立的 <code>i</code> 會存在 global 中</p>
<p><strong>試著把運作拆開來</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>當迴圈跑完時， <code>i</code> 是 5，<code>var i  = 5</code><br>
因為 5 不符合迴圈條件跳出<br>
所以不管 <code>arr[?]()</code>，直接印出 <code>i</code> 是 5</p>
<h3 id="解決方法">解決方法</h3>
<h4 id="閉包">閉包</h4>
<p>把 function 獨立出來</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"> arr[i] = <span class="title function_">logN</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//閉包，記住當下的 i</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logN</span>(<span class="params">num</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]() <span class="comment">//0</span></span><br><span class="line">arr[<span class="number">1</span>]() <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<h4 id="IIFE">IIFE</h4>
<p>IIFE(Immediately Invoked Function Expression) 定義完就回傳的 function</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">//拿到當下的 i</span></span><br><span class="line">  arr[i] = (<span class="keyword">function</span> (<span class="params">num</span>)&#123;</span><br><span class="line">	 <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	 <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">	 &#125;</span><br><span class="line">	&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]() <span class="comment">//0</span></span><br><span class="line">arr[<span class="number">1</span>]() <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>把原本有名的函式改為匿名函式，用<code>()</code>包裹 function，尾巴是帶入參數<code>(參數)</code>，沒有的話為空</p>
<h4 id="ES6-的-let">ES6 的 let</h4>
<p>上面出現的原因都是 <code>var</code> 的 scope 問題<br>
ES6 的 let 將作用域限制在 block <code>&#123;&#125;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; arr[i] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">arr[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">arr[<span class="number">1</span>](); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>只要 <code>var -&gt; let</code> ， 就解決問題了，離開之後就不會保留。</p>
</blockquote>
<h2 id="Closure-應用">Closure 應用</h2>
<h3 id="Cache-暫存">Cache 暫存</h3>
<p>計算量大的時候避免重新計算，預先把已算好的值存起來</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">complex</span>(<span class="params">num</span>)&#123;</span><br><span class="line">  <span class="comment">// 複雜計算</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;calculate&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> num*num*num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cache</span>(<span class="params">func</span>)&#123;</span><br><span class="line">  <span class="comment">// 查看是不是有算過</span></span><br><span class="line">  <span class="keyword">var</span> ans =&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="comment">//有的話回傳索引裡的值</span></span><br><span class="line">    <span class="keyword">if</span>(ans[num])&#123;</span><br><span class="line">      <span class="keyword">return</span> ans[num]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 沒有的話才做重新計算</span></span><br><span class="line">    ans[num] = <span class="title function_">func</span>(num)</span><br><span class="line">    <span class="keyword">return</span> ans[num]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cacheComplex = <span class="title function_">cahe</span>(complex)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cacheComplex</span>(<span class="number">20</span>)) <span class="comment">// 第一次計算</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cacheComplex</span>(<span class="number">20</span>)) <span class="comment">// 從 cache 拿到的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cacheComplex</span>(<span class="number">20</span>)) <span class="comment">// 從 cache 拿到的值</span></span><br></pre></td></tr></table></figure>
<p>用 <code>console.time</code> 計時執行的時間<br>
比起直接用 complex 算再重新算<br>
會發現第二次的計算的時間明顯縮短很多</p>
<h3 id="隱匿資訊">隱匿資訊</h3>
<p>想隱匿一些資訊，讓別人不可以直接更改。<br>
把方法以及變數封裝在內部，別人要調用只能呼叫你規定好的方法。</p>
<ul>
<li>以簡易計算機為例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">initNum</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> sum = initNum</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">	 <span class="attr">add</span>:<span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">	    <span class="keyword">return</span> sum +=num</span><br><span class="line">		&#125;,</span><br><span class="line">	 <span class="attr">minus</span>:<span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">	    <span class="keyword">return</span> sum -=num</span><br><span class="line">		&#125;,</span><br><span class="line">	 <span class="attr">mutiply</span>:<span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">		    <span class="keyword">return</span> sum *=num</span><br><span class="line">		&#125;,</span><br><span class="line">	 <span class="attr">divided</span>:<span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">		    <span class="keyword">return</span> sum/=num</span><br><span class="line">		&#125;,</span><br><span class="line">	 <span class="attr">getresult</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		    <span class="keyword">return</span> sum</span><br><span class="line">		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter1 = <span class="title function_">calculate</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> counter2 = <span class="title function_">calculate</span>(<span class="number">10</span>)</span><br><span class="line">counter1.<span class="title function_">add</span>(<span class="number">5</span>)</span><br><span class="line">counter2.<span class="title function_">mutiply</span>(<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter1.<span class="title function_">getresult</span>()) <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter2.<span class="title function_">getresult</span>()) <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>
<p>一個簡單的計算機 (?)🤔<br>
counter1 跟 counter2 並不會影響到彼此<br>
我們只能透過現有的方法來修改 sum 的值</p>
<h2 id="總結-21">總結</h2>
<p>閉包讓我感覺是很神奇的東西<br>
看起來不熟悉，但實際上我們都用到了🤔</p>
<h2 id="參考-11">參考</h2>
<ul>
<li><a href="https://lidemy.com/courses/enrolled/390599"> [JS201] 進階 JavaScript：那些你一直搞不懂的地方 </a></li>
</ul>
]]></content>
      <categories>
        <category>2022</category>
        <category>04</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - 事件機制原理 &amp; 事件代理</title>
    <url>/2022/04/04/JavaScript-EventFlow-EventListener.html</url>
    <content><![CDATA[<h2 id="前言-25">前言</h2>
<p>事件是什麼 ? 為什麼要用事件代理呢 ?<br>
在不了解事件的流程與運作機制，是不是遇過點一下元素<br>
結果跑出兩次以上的結果<br>
透過本篇幫自己釐清事件各種大小事</p>
<span id="more"></span>  
<h2 id="EventFlow-網頁元素接收事件的順序">EventFlow : 網頁元素接收事件的順序</h2>
<p><img data-src="https://dsm01pap006files.storage.live.com/y4m9V74R0Rbxh2VocqOo5K1vnxJNiyqAL1pr2Vw2o2yxenGxG5Uq3iMSm5n1bXDNs7hubkxY7rtnZfQtgz3tSNPDcX22k_WWBKKto5w_fnALPe1MSGDNDjlF11Yr7svwp8O0b8PmsLyMikVMa0Be3EWrsugI0ZsfWzkq9aYgX7R48Jm2YL0dJs6VWHvl3tqxowk?width=1208&amp;height=1160&amp;cropmode=none" alt="EventFlow"></p>
<ul>
<li><code>Capture phase</code> : 捕獲階段指由 <strong>上到下</strong> 傳下去的</li>
<li><code>Target phase</code> : 目標階段，本身被作用的目標才會在這個階段</li>
<li><code>Bubbling phase</code> : 冒泡階段 指由 <strong>下往上</strong> 傳去的</li>
</ul>
<p>透過 <code>e.eventPhase</code> 可以看見事件的階段<br>
當我點下 link</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;link capturing&#x27;</span>,e.<span class="property">eventPhase</span>);</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;link bubbling&#x27;</span>,e.<span class="property">eventPhase</span>);</span><br><span class="line">&#125;)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box capturing&#x27;</span>,e.<span class="property">eventPhase</span>);</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box bubbling&#x27;</span>,e.<span class="property">eventPhase</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">box capturing <span class="number">1</span>  <span class="comment">// CAPTURING_PHASE</span></span><br><span class="line">link capturing <span class="number">2</span> <span class="comment">// AT_TARGET </span></span><br><span class="line">link bubbling <span class="number">2</span> <span class="comment">// AT_TARGET </span></span><br><span class="line">box bubbling <span class="number">3</span> <span class="comment">// BUBBLING_PHASE</span></span><br></pre></td></tr></table></figure>
<p>出現的代碼就是事件的不同階段</p>
<h3 id="事件冒泡-Event-Bubbling">事件冒泡 (Event Bubbling)</h3>
<p>啟動事件的元素往上傳遞到 <strong>根節點</strong> (document)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>TITLE<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>CLICK<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>冒泡傳遞方向 :<br>
CLICK 事件本身元素 👉 body 👉 html 👉 document</p>
<h3 id="事件捕獲-Event-Capturing">事件捕獲 (Event Capturing)</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>TITLE<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>CLICK<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>捕獲傳遞方向 :<br>
document 👉html 👉 body 👉CLICK 事件本身元素</p>
<h3 id="事件是哪種機制">事件是哪種機制 ?</h3>
<p>兩種都會，當我按下按鈕，如果外層元素也有綁定 <strong>事件</strong>，同時也會被觸發</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.outer&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.inner&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>結果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">hi <span class="comment">// 冒泡而觸發</span></span><br></pre></td></tr></table></figure>
<p>點擊 <code>inner</code> 時，同時出現 hello 跟 hi<br>
因為冒泡的關係，outer 也被觸發。</p>
<h3 id="事件的捕獲-冒泡順序">事件的捕獲 &amp; 冒泡順序 ?</h3>
<ul>
<li>對於 <strong>非觸發事件</strong> 本身的元素</li>
</ul>
<blockquote>
<p>先捕獲後冒泡</p>
</blockquote>
<ul>
<li>事件本身<br>
在以往的文章中都是 <strong>按照程式碼執行的順序</strong><br>
當我試著執行後卻發現即使把冒泡放在前面，捕獲放後<br>
一樣都是 <strong>先捕獲再冒泡</strong><br>
仔細一查，才發現原來是 Chorme 89 以後的版本都會先捕獲再冒泡<br>
89 之前的版本就會是看程式碼執行的順序
<blockquote>
<p>出現這樣的狀況是因為 shadow DOM 引起的，詳細原因請參考 <a href="https://juejin.cn/post/6965682915141386254#heading-2">這篇</a></p>
</blockquote>
</li>
</ul>
<p>所以，新版的瀏覽器不管是哪個都是 <strong>先捕獲再冒泡</strong></p>
<h2 id="事件的註冊綁定">事件的註冊綁定</h2>
<ol>
<li><code>on-event</code> : 有 HTML 中 inline on-event；JS on-event 接 function</li>
<li><code>EventListener</code> : addEventListener、removeEventListener…等</li>
</ol>
<h3 id="on-event">on-event</h3>
<ol>
<li>Html <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> </span></span><br><span class="line"><span class="tag"><span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;click&#x27;)&quot;</span>&gt;</span>click </span><br><span class="line">me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
目前很少這樣寫，其一原因是不好維護</li>
<li>非 Html <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>)</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我們最常看見 <code>window.onload</code> 也是事件的 on-event</p>
<h3 id="EventListener">EventListener</h3>
<h4 id="addEventListener">addEventListener</h4>
<p>有三個參數</p>
<ol>
<li>事件名稱</li>
<li>事件處理器 (觸發時執行的 function)</li>
<li>Boolen ，以 「捕獲」 或「冒泡」 機制執行， <code>false</code> (不指定) 為 冒泡</li>
</ol>
<blockquote>
<p>第三個布林值，不是改變事件傳遞的方式，而是在 <strong>哪裡進行監聽</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HI&#x27;</span>); &#125;);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HI&#x27;</span>); &#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 捕獲 </span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HELLO&#x27;</span>); &#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h4 id="removeListener">removeListener</h4>
<p>跟 addEventListener 一樣，如果要解除的話 handler 的 function 必須是同一個實體才行</p>
<blockquote>
<p><strong>為什麼說是同一實體 ?</strong><br>
回想這個例子 <code>&#123;&#125; === &#123;&#125; // false</code><br>
function 也是 Object 的一種<br>
匿名函式沒有指定給變數時，都是屬於不同的記憶體位址</p>
</blockquote>
<p>事件監聽使用匿名函式的寫法，就像潑出去的水，回不來了 🤔</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HI&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件，但是沒用</span></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HI&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>解決此問題，把 handler 的 function <strong>獨立出來</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> clickhandler = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HI&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,clickhandler&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 移除事件，ok!</span></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>,clickhandler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h3 id="on-event-v-s-EventListener">on-event v.s EventListener</h3>
<ul>
<li>
<p><code>EventListener</code> : 可以重複指定多個「處理器」(handler) 給同一個元素的同一個事件</p>
</li>
<li>
<p><code>on-event</code> : 只認一個，後面多寫的會覆蓋前面的事件</p>
</li>
<li>
<p>on-event</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi!&#x27;</span>) <span class="comment">// 不會出現</span></span><br><span class="line">&#125;;</span><br><span class="line">btn.<span class="property">onclick</span>= <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello!&#x27;</span>) <span class="comment">// 會出現 hello</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<ul>
<li>EventListener</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi!&#x27;</span>) <span class="comment">// 出現 hi</span></span><br><span class="line">&#125;&#125;);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello!&#x27;</span>) <span class="comment">// 再出現 hello</span></span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="EventHandler-中的-“event”">EventHandler 中的 “event”</h2>
<p>事件物件會依照 <strong>觸發的事件</strong>(click、change) ，內容會有稍微不同<br>
通常看到 <code>event</code> 寫成 <code>e</code> 、<code>evt</code> 是為了方便，也可以自訂譯名稱<br>
只是大家會選擇有意義的名稱且好記</p>
<p>可以試著在事件觸發印出 <code>e</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">常見的屬性   </span></span><br><span class="line"><span class="string">-   `</span>type<span class="string">` : 表示事件的名稱</span></span><br><span class="line"><span class="string">-   `</span>target<span class="string">` : 表示觸發事件的元素</span></span><br><span class="line"><span class="string">-   `</span>bubbles<span class="string">` : 表示這事件是否是在「冒泡」階段觸發 (`</span><span class="literal">true</span><span class="string">` / `</span><span class="literal">false</span><span class="string">`)</span></span><br><span class="line"><span class="string">-   `</span>pageX<span class="string">` / `</span>pageY<span class="string">` : 表示事件觸發時，滑鼠座標在網頁的相對位置  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 阻擋預設行為 event.preventDefault()</span></span><br><span class="line"><span class="string">&gt;並不會阻止事件向上傳遞 (事件冒泡) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.link&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"></span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box&#x27;</span>) <span class="comment">// 依然會出現</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>on-event</code> 在 eventhandler function 的<strong>最後</strong>加上 <code>return false;</code> 也會有 <code>event.preventDefault()</code> 的效果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.link&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等於 e.preventDefault()</span></span><br><span class="line">link.<span class="property">onclick</span>=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="應用範例一-表單-submit-前的檢查">應用範例一 : 表單 submit 前的檢查</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        帳號</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        密碼</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用者按下 submit 按鈕會送出表單<br>
前端可以先做驗證，確認使用者的輸入是不是符合</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;form&quot;</span>)</span><br><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&#x27;submit&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="comment">//先阻止送出</span></span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;[name=&#x27;username&#x27;]&quot;</span>).<span class="property">value</span></span><br><span class="line">    <span class="keyword">let</span> password = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;[name=&#x27;password&#x27;]&quot;</span>).<span class="property">value</span></span><br><span class="line">    <span class="comment">// 檢查欄位</span></span><br><span class="line">    <span class="keyword">if</span>(!username) <span class="keyword">return</span> <span class="title function_">alert</span>(<span class="string">&#x27;請輸入使用者帳號&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(!password) <span class="keyword">return</span> <span class="title function_">alert</span>(<span class="string">&#x27;請輸入密碼&#x27;</span>)</span><br><span class="line">    <span class="comment">// 都有輸入就送出</span></span><br><span class="line">    form.<span class="title function_">submit</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="應用範例二-避免超連結造成網頁跳轉">應用範例二 : 避免超連結造成網頁跳轉</h4>
<p>按下 <code>a</code> 的時候會找網頁的錨點，如果沒有的話會跳 <code>#</code> 井字號<br>
如果不想要出現井字號呢 ?<br>
有些是對外連結，有些是內連結使用，總不能阻擋每個吧 !</p>
<p>這邊用我使用 <code>class</code> 分開外部連結</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;www.example.com&quot;</span>&gt;</span>我是普通超連結<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>gotoTop<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 選沒有 link class 的 a 標籤</span></span><br><span class="line"><span class="keyword">let</span> actionLink = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;a:not(.link)&#x27;</span>)</span><br><span class="line">actionLink.<span class="title function_">forEach</span>( <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    a.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">        e.<span class="title function_">preventDefault</span>();</span><br><span class="line">        <span class="comment">// 判斷各個 actionLink 要做的事</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>這樣就可以分出哪些是外部連結，哪些是內網頁連結，而且不會出現 <code>#</code> 井字號 😃</p>
<h3 id="阻擋事件冒泡傳遞-event-stopPropagation">阻擋事件冒泡傳遞 event.stopPropagation()</h3>
<blockquote>
<p>阻止的動作，加在冒泡發生的元素上</p>
</blockquote>
<p>如果不要讓 box 出現，加在想停止冒泡的地方 <code>event.stopPropagation()</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.link&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這裡會發生冒泡，要阻止上傳</span></span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box&#x27;</span>) <span class="comment">// 不會出現</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>你可以試著註解 <code>e.stopPropagation();</code> 會發現當你按下 link<br>
因為 link 冒泡機制導致 box 的事件也觸發而印出 <code>'box'</code></p>
<h4 id="阻止任何的傳遞-event-stopImmediatePropagation">阻止任何的傳遞 event.stopImmediatePropagation()</h4>
<p>如果同一個元素有掛兩個 <code>addEventListener</code><br>
點擊時兩個都會在 <code>Target phase</code><br>
A 跟 B 事件一樣會觸發<br>
在 A 加入 <code>stopImmediatePropagation()</code> 會把 B 停掉</p>
<p>以上面的例子來說，link 掛兩個事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A 事件</span></span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i am A&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// B 事件</span></span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i am B&#x27;</span>) <span class="comment">//不會出現，在 A target pharse 阻止 B 冒泡階段發生</span></span><br><span class="line">&#125;)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box&#x27;</span>) <span class="comment">// 不會出現，因為阻止了冒泡</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="應用範例-label-input">應用範例 : label &amp; input</h4>
<p>label 跟 input 的組合需要多一個 id<br>
為了不浪費 id，我們常常會用 label 把 input 包起來。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>/&gt;</span></span><br><span class="line">	開關</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>label</code> 綁上監聽事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> labelone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line"></span><br><span class="line">labelone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>神奇的是，hi 會出現兩次<br>
checkbox 也會接收到 click 事件，改變了狀態<br>
發生冒泡到 label 元素，再次觸發 label 的事件</p>
<p><strong>重點複習</strong></p>
<blockquote>
<p><strong>阻止的動作，加在冒泡發生的元素上</strong></p>
</blockquote>
<p>冒泡發生的是 <strong>input</strong> ，所以 <code>stopPropagation</code> 是要加在 input 而非 label</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> labelone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> inputone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"></span><br><span class="line">labelone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">inputone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="事件-“本身”-指的是-target-v-s-currentTarget-this">事件 “本身” 指的是 ? target v.s currentTarget (this)</h3>
<p>我們知道在 function 當中是可以使用 <code>this</code><br>
那這邊的 <code>this</code> 是指什麼呢 ?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> labelone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line"></span><br><span class="line">labelone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tagName</span>) <span class="comment">// LABEL</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>this</code> 代表的會是「觸發事件的<strong>目標</strong>」元素<br>
也就是 <code>event.currentTarget</code> 而不是 <code>e.target</code>。</p>
</blockquote>
<p>那 <code>e.target</code> 指的是 ?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> labelone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line">labelone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">tagName</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tagName</span>, <span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> inputone= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">inputone.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">tagName</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tagName</span>, <span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>點擊 label</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;LABEL&quot;</span> <span class="number">1</span> <span class="comment">// e.target</span></span><br><span class="line"><span class="string">&quot;LABEL&quot;</span> <span class="number">1</span> <span class="comment">// this</span></span><br><span class="line"><span class="string">&quot;INPUT&quot;</span> <span class="number">2</span> <span class="comment">// e.target</span></span><br><span class="line"><span class="string">&quot;INPUT&quot;</span> <span class="number">2</span> <span class="comment">// this</span></span><br><span class="line"><span class="string">&quot;INPUT&quot;</span> <span class="number">1</span> <span class="comment">// checkbox 冒泡上來的而觸發 labelone，e.target</span></span><br><span class="line"><span class="string">&quot;LABEL&quot;</span> <span class="number">1</span> <span class="comment">// checkbox 冒泡上來的而觸發 labelone， this</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>e.target</code> 其實是「觸發事件的元素」</p>
</blockquote>
<p>如果不考慮事件傳遞的情況下，<code>this</code> 實質上就等同於 <code>e.target</code> 了。</p>
<h2 id="事件指派-Event-Delegation">事件指派 (Event Delegation)</h2>
<p>用 JavaScript 新增的元素並不會綁到事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.list&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> items = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.list-item&#x27;</span>);</span><br><span class="line"><span class="comment">// 一個個手動加入</span></span><br><span class="line">items.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">	item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">textContent</span>);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newItem = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;LI&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> txt = <span class="variable language_">document</span>.<span class="title function_">creatTextNode</span>(<span class="string">&#x27;new&#x27;</span>);</span><br><span class="line">newIten.<span class="title function_">appendChild</span>(txt)</span><br><span class="line">list.<span class="title function_">appendChild</span>(newItem)</span><br></pre></td></tr></table></figure>
<p><code>newItem</code> 不會有 click 事件<br>
為避免每次新增要重新綁定事件，又要移除監聽，造成 memory leak 的嚴重問題<br>
<strong>事件指派</strong> 是比較好的做法。</p>
<p><strong>事件代理人</strong> 透過判斷 <strong>目標節點</strong>，再執行動作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.list&#x27;</span>);</span><br><span class="line"><span class="comment">// list 直接看底下的子元素</span></span><br><span class="line">list.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(e.<span class="property">target</span>.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>()===<span class="string">&#x27;li&#x27;</span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">textContent</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newItem = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;LI&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> txt = <span class="variable language_">document</span>.<span class="title function_">creatTextNode</span>(<span class="string">&#x27;new&#x27;</span>);</span><br><span class="line"></span><br><span class="line">newIten.<span class="title function_">appendChild</span>(txt)</span><br><span class="line">list.<span class="title function_">appendChild</span>(newItem)</span><br></pre></td></tr></table></figure>
<p>搭拉 ! <code>newItem</code> 就有點擊的效果</p>
<h2 id="總結-22">總結</h2>
<p>事件是 JavaScript 的基本，當我們了解機制的運作<br>
遇到奇怪的觸發多次時，記得想起事件的流程</p>
<blockquote>
<p>先捕獲再冒泡</p>
</blockquote>
<p>還有相關的</p>
<ul>
<li>阻止預設行為 <code>preventDefault</code></li>
<li>阻擋冒泡行為 <code>stopPropagtion</code></li>
</ul>
<h2 id="參考-12">參考</h2>
<ol>
<li><a href="https://ithelp.ithome.com.tw/articles/10191970">重新認識 JavaScript: Day 14 事件機制的原理</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10192015">重新認識 JavaScript: Day 15 隱藏在 “事件” 之中的秘密</a></li>
<li><a href="https://blog.techbridge.cc/2017/07/15/javascript-event-propagation/">DOM 的事件傳遞機制：捕獲與冒泡</a></li>
<li><a href="https://juejin.cn/post/6965682915141386254#heading-2">Chrome 89 更新事件触发顺序，导致99%的文章都错了（包括MDN）</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>04</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - class 物件導向 (I) 初探 OOP</title>
    <url>/2022/04/04/JavaScript-Object-oriented-programming-01.html</url>
    <content><![CDATA[<h2 id="前言-26">前言</h2>
<p>JavaScript 是物件導向的語言<br>
但跟其他的物件導向語言使用 class 有點不同</p>
<p>恩 ? Javascript 不是也用 class 嗎 ?<br>
不，<code>class</code> 是語法糖，到 ES6 才問世<br>
真正的 JavaScript 是使用 prototype 來達成物件導向</p>
<p>本系列將從現代開發用的 <code>class</code> 來了解<br>
再到認識真的原汁原味 <code>prototype</code> 的作法</p>
<span id="more"></span>
<h2 id="class-的物件導向">class 的物件導向</h2>
<p><code>Object-oriented programming</code> 簡稱 OOP<br>
物件導向的優點在於更 <strong>直覺</strong>，更模組化</p>
<p>ES6 是使用 class<br>
ES5 以前並沒有 class，而是使用 <code>prototype</code> (原型) 的方式。<br>
<code>class</code> 像是藍圖，而 <code>new</code> 則是把藍圖裡的東西實例出來</p>
<blockquote>
<p>類別型的物件都是<strong>大寫開頭</strong>，這是常用的寫法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定義貓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">	<span class="comment">// 每隻貓有名字</span></span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 每隻貓打招呼會喵喵叫</span></span><br><span class="line">	<span class="title function_">hello</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says meow`</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建立一隻叫 lily 的貓，把它存在 lily 這個變數</span></span><br><span class="line"><span class="keyword">let</span> lily = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;lily&#x27;</span>)</span><br><span class="line">lily.<span class="title function_">hello</span>() <span class="comment">// lily says meow</span></span><br><span class="line"><span class="keyword">let</span> bob = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line">bob.<span class="title function_">hello</span>() <span class="comment">// bob says meow</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>class</code> : 物件的藍圖<br>
裡面的涵式不需要寫 <code>function</code> 的字，可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions#description">function shorthand</a></li>
<li><code>new</code> : 把藍圖實做出來，放到自訂義變數中，之後這個變數也擁有藍圖包含的功能。<br>
用 <code>.</code> (dot) 連接，像 <code>object</code> 來呼叫。</li>
<li><code>new XXX(建構子參數)</code> : 建構子是 class 內部的涵式，可以加入參數，類似初始化。<br>
對應 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//這是建構子</span></span><br><span class="line"><span class="title function_">construtor</span>(<span class="params"><span class="variable language_">arguments</span></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">arguments</span> = <span class="variable language_">arguments</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>constructor</code> : 可以看做基本資料(設定檔)，<code>this.name = name</code><br>
把 new 帶入的引數作為內部建構子參數使用。</p>
</blockquote>
</li>
<li><code>this</code> : 分成 class 內部的 <code>this</code> 與外部的 <code>this</code>。這邊著重內部的 this。<br>
<code>this</code> 是對應被實體出來的主體。<br>
lily 被指向叫做 lily 的貓<br>
反之 bob 也是，並不是指同一個物件<br>
但是內部方法是共用同一個 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lily.<span class="property">hello</span> === <span class="title class_">Bob</span>.<span class="property">hello</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>對於已經建立的物件再修改內部建構的值非常不建議</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lily.<span class="property">name</span> = <span class="string">&quot;rosa&quot;</span> (👎)  </span><br></pre></td></tr></table></figure>
<p>雖然可以修改掉內部的 <code>this.name</code> 的值<br>
一般來說在建立實體時都會設定好，較少再直接透過個別更改</p>
<h2 id="沒有-class-的物件導向">沒有 class 的物件導向</h2>
<p>在 ES5 並沒有 class 的做法<br>
如果沒有使用 prototype 的寫法<br>
我們可以透過 function 來建構</p>
<blockquote>
<p>function 也是物件，所以可以透過 <code>.</code> 拿到屬性或方法</p>
</blockquote>
<ul>
<li>改寫上面的 Cat class</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name</span>) &#123;</span><br><span class="line"><span class="comment">// 用 _ (dash) 通常指被封裝在函式內的變數，類似私有變數，一般不會直接修改</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">	  <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">_name</span>,</span><br><span class="line">    <span class="attr">hello</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says meow`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Lily</span> = <span class="title class_">Cat</span>(<span class="string">&quot;Lily&quot;</span>);</span><br><span class="line"><span class="title class_">Lily</span>.<span class="title function_">hello</span>();</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Bob</span> = <span class="title class_">Cat</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"><span class="title class_">Bob</span>.<span class="title function_">hello</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lily</span>.<span class="property">hello</span> === <span class="title class_">Bob</span>.<span class="property">hello</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>讓物件能呼叫方法用 <code>function</code> 回傳 function 的方式<br>
但是這個方法 <strong>非常消耗記憶體</strong><br>
每一個產生的 function 都是不同的 function</p>
<h2 id="對比圖">對比圖</h2>
<p><img data-src="https://dsm01pap006files.storage.live.com/y4mPsTnRBXXRDKUTn4h4YIRTBAE1Q3K4imjKAv-NaRLxF9KjYvNc3TJj5u-GvDWoZUpm_TBcByzdTcbSFqiAJtRNy43xJRnNoug9RKxYtHqxvCm-JrazXLtBM82gThGBaH8-SjTQbaFr0zZr4tGF2CuwLIl0u7I3soTI3iJ8usyN9oWE1SV6GyXIBp3snhf2Ply?width=1024&amp;height=325&amp;cropmode=none" alt="右 : ES5 ，左 : ES6"></p>
<p>右邊因為每一個實體都是重新創建一個新物件方法，明明要呼叫的指向實體是同一個而已。<br>
改善這部分會使用到 <code>prototype</code>，讓建構的物件都有共同的方法與屬性</p>
<ul>
<li>有無使用 prototype 的寫法</li>
</ul>
<p><img data-src="https://dsm01pap006files.storage.live.com/y4meCfDywgqAcUJCJFA07OVsJ4OvfDl-Qu_nPbSoDEocZ_v0aTe19CwejVfn_H2ZHF8PR5mb1xI4pjAwUuAQLb-NdFX5VB-_AmcjbZbIrfTn8wy1Cf5im0Lr8--yFtVkM8wsSdEd-N4TO9cPP64dTTXfH0td0OWI8XuyKow6jmPGLxam61-1dH2JWOpXzMFCDg3?width=1024&amp;height=308&amp;cropmode=none" alt="左 : function 直接回傳物件，右 : 透過 prototype"></p>
<p>最大的差別在於產生的物件 <strong>是不是共用同一個方法</strong><br>
右邊的透過 prototype 方法是都指向同一個</p>
<p>建立物件時右邊是使用了 <code>new</code>，幫將物件的原型綁在建構函式上</p>
<h2 id="new-藍圖的實作">new : 藍圖的實作</h2>
<p>new 到底做了什麼是呢 ?</p>
<ul>
<li>new 不 new ?</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同於 class 的 construtor</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">name</span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">buy</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`you buy a new <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> toyota = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;toyota&#x27;</span>)</span><br><span class="line">toyota.<span class="title function_">buy</span>()</span><br><span class="line"><span class="keyword">let</span> honda = <span class="title class_">Car</span>(<span class="string">&#x27;honda&#x27;</span>) <span class="comment">// 錯誤</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>沒 new 會出現 <code>Class constructor Car cannot be invoked without 'new'</code><br>
代表沒有初始化。</p>
<h3 id="複習一下-call">複習一下 call</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hello</span>() <span class="comment">//這邊印出的 this 是全域物件  </span></span><br><span class="line">hello.<span class="title function_">call</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">//123，this 變成傳進去的東西</span></span><br></pre></td></tr></table></figure>
<p><code>.call</code> 是呼叫函式的另一種方法<br>
透過這樣的方式可以將 this 綁在傳入的物件上</p>
<h3 id="手動造一個-new">手動造一個 new</h3>
<p>知道 call 跟 this 的關係，就能了解 <code>constructor</code> 的初始化。</p>
<ul>
<li>目標 : 不用 new 做一樣的功能</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> toyota = <span class="title function_">newCar</span>(<span class="string">&#x27;toyota&#x27;</span>)</span><br><span class="line">toyota.<span class="title function_">buy</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>用 newCar</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">name</span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">buy</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`you buy a new <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">newCar</span>(<span class="params">name</span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> obj =&#123;&#125;</span><br><span class="line">	<span class="title class_">Car</span>.<span class="title function_">call</span>(obj,name)</span><br><span class="line">	obj.<span class="property">__proto__</span> = <span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">	<span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new 其實做了 :</p>
<ol>
<li>建立一個 obj</li>
<li><code>.call(obj,name)</code>，呼叫建構子。把 obj 當作 <code>this</code>，name 作為參數，完成 <code>constructor</code> 的初始化。
<blockquote>
<p>沒有這一項無法指向實體，<code>this</code> 綁定問題</p>
</blockquote>
</li>
<li>用 <code>__proto__</code> 導向至 prototype，跟原型進行搭橋，才能使用到該原型方法。</li>
<li><code>return obj</code> ，實例 (instance) 出來的東西。</li>
</ol>
<h2 id="結語-2">結語</h2>
<p>現代開發大多還是使用 class<br>
但並非代表 JavaScript 就是用 class(類別) 來建立<br>
背後依然是 function 與指定 prototype 的實作</p>
<p>想更了解 JavaScript 認識 prototype 是不可少的<br>
同時我也查了為什麼 JavaScript 作者使用 prototype 的設計<br>
而不是用類別 ，是出於什麼考量?</p>
<p>在<a href="https://stackoverflow.com/questions/8433459/what-s-the-purpose-of-prototype">這篇</a> 找到的的解釋是 class-based 是要 <strong>重頭設計物件</strong>，而 prototype-based 可以透過現有已建立的物件再建立，總得來說效能上更快。</p>
<h2 id="參考-13">參考</h2>
<ul>
<li><a href="https://lidemy.com/courses/enrolled/390599">JS201 進階 JavaScript：那些你一直搞不懂的地方</a></li>
</ul>
]]></content>
      <categories>
        <category>2022</category>
        <category>04</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - Prototype 物件導向 (III) 原型 &amp; 原型鏈</title>
    <url>/2022/04/04/JavaScript-Object-oriented-programming-03.html</url>
    <content><![CDATA[<h2 id="前言-27">前言</h2>
<p>JavaScript 的核心就在原型 !<br>
原型使得物件都能使用在原型鏈上的屬性及方法<br>
本身物件也可以再擴充<br>
透過本篇了解原型的使用方法</p>
<span id="more"></span>
<h2 id="什麼是-prototype">什麼是 prototype ?</h2>
<p><img data-src="https://dsm01pap006files.storage.live.com/y4mZUP0lakeV0ZyTOBA3FOhGoj0nLq4_-h6RClQix2hTtsj-YL9kg-RwmOfya_emwZ1jekhk9jIrt-JrTQQfyiPEwOfYlVWWxlFZHdaAgkONuvg-kxkJgmo67BaKWfhEePd-7sT21E5ITCGSdla3HTIiK8NillkQBfzy2mTCrs5ZtISAl-h5eV-JiE6ySo075Ow?width=946&amp;height=563&amp;cropmode=none" alt="prototype"><br>
參考圖 : <a href="https://ithelp.ithome.com.tw/articles/10194356">重新認識 JavaScript: Day 25 原型與繼承</a></p>
<p>從 01 篇知道 prototype 可以讓不同的物件共享原型的同一個方法或屬性<br>
prototype 就像是從 function 產生的集裝箱<br>
讓 function 建立出來的物件都可以拿到同樣的東西</p>
<blockquote>
<p><strong>函式也是物件</strong>，所以可以透過 prototype 來擴充每一個透過這個函式所建構的物件</p>
</blockquote>
<p>好像難以連結，不過我們時時刻刻都在使用 prototype 的概念<br>
有想過為什麼基本型別的值 (number、string、bool) 可以 <strong>像 object 一樣呼較方法獲取到屬性</strong>呢 ?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="property">length</span> );</span><br></pre></td></tr></table></figure>
<p>沒錯，就是透過 prototype 原型提供的方法來繼承<br>
在 JavaScript 呼叫方法或屬性之前，會透過基本型別包裹器 (Primitive Wrapper)<br>
被轉型為該類別的「物件」，由對應的物件提供的方法是透過原型鏈 (prototype chain)<br>
讓我們可以對基本型別的值呼叫方法</p>
<ul>
<li>類似這樣</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// str.length 模擬過程</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// 變成物件</span></span><br><span class="line">str.<span class="property">length</span> <span class="comment">// 拿到屬性</span></span><br><span class="line">str = <span class="literal">null</span> <span class="comment">// 銷毀</span></span><br><span class="line">str = <span class="string">&#x27;Hello&#x27;</span> <span class="comment">// 恢復成基本型別</span></span><br></pre></td></tr></table></figure>
<h2 id="prototype-怎麼來">prototype 怎麼來 ?</h2>
<p><strong>函式建立時會自動產生 prototype 屬性</strong>。<br>
產生的物件並&quot;不&quot;代表物件的 prototype 屬性就是這個函式的原型物件<br>
而是透過 <code>new</code> 出來的物件會有 <code>[[Prototype]]</code> 的隱藏屬性<br>
是指 <strong>建構式</strong> 的 prototype</p>
<blockquote>
<p><code>constructor.prototype</code></p>
</blockquote>
<p>上面的敘述很令人混亂對吧 ?<br>
先舉個例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">getName</span> =<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rosa = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Rosa&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="title function_">getName</span>()) <span class="comment">// Rosa</span></span><br></pre></td></tr></table></figure>
<p><code>rosa</code> 是從 Person 建構出來的物件</p>
<blockquote>
<p>所以 rosa 的原型是 Person</p>
</blockquote>
<p>回到第一句話<br>
<strong>函式建立時會自動產生 prototype 屬性</strong></p>
<p>對著 <code>Person</code> 函式取 prototype ，確實是有的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// Person 本身</span></span><br></pre></td></tr></table></figure>
<p>prototype 讓 rosa 可以直接拿到 <code>Person</code> 裡面的方法 (getName)</p>
<p>那第二句是什麼意思 ?<br>
試著讓 <code>rosa</code> 呼叫 <code>toString()</code>，但是 Person 並沒有這個方法呀 ?!<br>
我們說過 rosa 的原型是 Person</p>
<blockquote>
<p>但 <strong>不</strong> 代表建構出來的物件 (rosa) 的 prototype 屬性就是這個函式 (Person) 的原型物件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">lgo</span>(rosa.<span class="title function_">toString</span>()) <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure>
<p>rosa 這裡取來的屬性或方法是來自 <code>Object.prototype</code> 傳下來的</p>
<p>接著第三句 <strong>建構式</strong> 的 prototype 是什麼意思 ?<br>
試著對 <code>rosa</code> 取 prototype<br>
新手一開始會以為 <code>rosa</code> 的 prototype 是等於 <code>Person</code> 的 prototype<br>
特別要搞清楚這裡的 prototype 是指什麼(我一開始也搞混了)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>回到第一句，回想 <code>.prototype</code> 是誰產生的 ?<br>
對，是 <strong>函式</strong><br>
那 rosa 物件是透過建構式的方式而來<br>
prototype 是隱藏屬性，沒辦法透過建構出來的物件直接取得</p>
<p><img data-src="https://dsm01pap006files.storage.live.com/y4mL7f71rE-gVfp4ze955AsP5mGlQNR1PYAJH4jUShpBHgc6U4Wq0pK2oYpDCsmDsGL0r2AxpMx3WXujkLUwZtgTEX_C1HPGIei28YZq0VvVXXwaTb7DT7K2RM-5ywv0SCz41iHsWPYdEp4lRb2YP19GWxtllx_EEBLXmJXO65f5jsuWSyQcLed8gq4Xo3YG0e3?width=692&amp;height=620&amp;cropmode=none" alt="藏在 contructor"></p>
<h2 id="取得物件的-prototype">取得物件的 prototype</h2>
<p>既然不能直接透過 <code>rosa.prototype</code> 取得原型<br>
如果我們要知道 rosa 是繼承誰的 prototype 可以透過三種的方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(rosa)) <span class="comment">// 現在比較好的拿到的方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// 從建構式拿到 [[Prototype]] 的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="property">__proto__</span>) <span class="comment">// 原本各家瀏覽器實作，後來 ES6 保留的方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(rosa)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === rosa.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === rosa.<span class="property">__proto__</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="原型鏈-Prototype-Chain">原型鏈 Prototype Chain</h2>
<p>原型可以讓本來 <strong>沒有某屬性的物件去存取其他物件的屬性</strong></p>
<h3 id="proto-溝通的原則">__proto__ : 溝通的原則</h3>
<p>如果本身物件沒有屬性或方法使用，可以透過原型鍊 (prototype chain) 來取得<br>
那是怎麼傳的呢 ?</p>
<p>原本 JavaScript 沒有提供標準方法直接存取物件的 <code>[[Prototype]]</code>。<br>
<code>__proto__</code> 是瀏覽器實作的的，並非 EMCAScript 的標準，不是所有的環境都有這個值。</p>
<blockquote>
<p>ES5 以後的是使用 <code>Object.getPrototypeOf()</code><br>
ES6 為了向下兼容，<code>__proto__</code> 也是承認的，但環境的不同支援度不同，還是用 <code>getPrototypeOf</code><br>
<code>__proto__</code> 是 <code>[[Prototype]]</code> 底下的屬性，屬於 setter/getter</p>
</blockquote>
<p><code>__proto__</code> 這個特殊屬性或者是 <code>Object.getPrototypeOf()</code> 都是取得某個物件的原型物件 <code>[[Prototype]]</code> 的方式。</p>
<p>官方比較建議使用 <code>Object.getPrototypeOf()</code>，因為 <code>__proto__</code> 比較耗效能</p>
<p>除了拿到物件原型的 prototype，<br>
還可以透過 <code>.__proto__</code> 看原型們如何溝通</p>
<p><strong>範例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name</span>)&#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says meow`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lily = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;lily&#x27;</span>)</span><br><span class="line">lily.<span class="title function_">hello</span>()</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Bob</span> = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="title class_">Bob</span>.<span class="title function_">hello</span>()</span><br></pre></td></tr></table></figure>
<h3 id="模擬溝通">模擬溝通</h3>
<p>想執行 <code>lily.hello()</code><br>
會依照這樣的順序尋找</p>
<ol>
<li>找 lily 本身是不是有 hello function ?<br>
👉 沒有，往上一層找</li>
<li>找 <code>lily.__proto__</code> 是不是有 hello ?<br>
👉 沒有的話，再往上一層找<br>
知道 <strong>lily._<em>proto_</em> = Cat.prototype</strong></li>
<li>找 <code>lily.__proto__.__proto__</code> 是不是有 hello ?<br>
=&gt; <code>lily.__proto__.__proto__ = Cat.prototype.__proto__</code>。<br>
=&gt; <code>lily.__proto__.__proto__  = Object.prototype</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>往上找像是用鏈結的方式，所以才稱 prototype chain<br>
我們找到 Object.prototype 就停止了</p>
<blockquote>
<p>那 <code>Object.prototype.__proto__</code> 呢?</p>
</blockquote>
<h3 id="最頂層的原型物件-Object-prototype">最頂層的原型物件: Object.prototype</h3>
<p>往上找 <code>__proto__</code>，什麼時候才會停止 ?<br>
會發現 <code>Object.prototype.__proto__</code> 等於 <code>null</code>，代表 Object 是最頂層了。</p>
<p>在 JavaScript 幾乎所有的物件 (環境宿主物件除外)會順著原型鍊找到最頂層<br>
<code>Object.prototype</code> 才停止，因為 <code>Object.prototype</code> 是 JavaScript 所有物件的起源。</p>
<p>在 <code>Object.prototype</code> 提供的所有方法，在 JavaScript 的所有物件的可以呼叫它。</p>
<ul>
<li><code>Object.prototype.hasOwnProperty()</code> : 是否為自己的屬性或方法</li>
<li><code>Object.prototype.toString()</code> : 轉型成字串</li>
<li><code>Object.prototype.valueOf()</code> : 取得 <strong>基本型別</strong> 的值</li>
</ul>
<p>幾乎所有的值可以使用的。<br>
即便建立物件時，沒有定義這些方法，但基於原型鏈的繼承，我們還是可以呼叫這些方法。</p>
<h2 id="instanceof-是否在物件的原型鏈上">instanceof : 是否在物件的原型鏈上</h2>
<p>instanceof 除了檢查 <code>constructor.prototype</code> 是不是在物件的原型鏈上<br>
也能檢查 <strong>複合式物件的基本型別</strong></p>
<ul>
<li>檢查基本型別</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">100</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num) <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num <span class="keyword">instanceof</span> <span class="title class_">Number</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">valueOf</span>()) <span class="comment">// 100，基本型別的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num.<span class="title function_">valueOf</span>()) <span class="comment">//&#x27;number&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>valueOf()</code> 可以拿到基本型別的值</p>
<ul>
<li>檢查是不是在原型鏈上，同理使用 <code>class</code> 的結構也可以檢查</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> rosa = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa <span class="keyword">instanceof</span> <span class="title class_">User</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="物件本身-v-s-原型鏈-出現同名屬性物件">物件本身 v.s 原型鏈 : 出現同名屬性物件 ?</h2>
<p>物件實體與原型具有相同的屬性或方法</p>
<blockquote>
<p><strong>優先存取自己的屬性或方法</strong>，如果沒有才會再順著原型鏈向上尋找。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Yo!&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hi!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="title function_">sayHello</span>()) <span class="comment">// Yo!</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 原型的方法擴充</span></span><br><span class="line"><span class="string">class 級別的擁有 extend 往下擴充  </span></span><br><span class="line"><span class="string">實例出實體後，會尋找存在的原型，並且一層層往上找。</span></span><br><span class="line"><span class="string">如果要替原型定義其他的方法可以這樣寫    </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">// 原始</span></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says meow`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定在最上層，讓往下的都可以使用</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> =<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says meow`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Object 是最頂層，其實在這邊定義也可以。<br>
如果不是同一類型都需要使用，這種方法也可以導致奇怪的問題發生</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">push</span>(<span class="string">&#x27;lol&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> arr= []</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">0</span>]) <span class="comment">// &#x27;lol&#x27;</span></span><br></pre></td></tr></table></figure>
<p>每一個 array 產生時已經被加上 <code>'lol'</code><br>
使用上合法，但不是一個好操作</p>
<p>以上如果有誤，歡迎指教 QQ</p>
<h2 id="參考-14">參考</h2>
<ol>
<li><a href="https://ithelp.ithome.com.tw/articles/10194356">重新認識 JavaScript: Day 25 原型與繼承</a></li>
<li><a href="https://lidemy.com/courses/enrolled/390599">JS201 進階 JavaScript：那些你一直搞不懂的地方</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>04</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - class 物件導向 (II) 繼承</title>
    <url>/2022/04/04/JavaScript-Object-oriented-programming-02.html</url>
    <content><![CDATA[<h2 id="前言-28">前言</h2>
<p>上一篇我們提到 class 像是幫我們製作藍圖<br>
有車子基本構造的藍圖<br>
是不是能透過藍圖能做出其他車種的藍圖呢 ?</p>
<p>可以，就是繼承 !</p>
<span id="more"></span>
<h2 id="extends">extends</h2>
<p>要讓子物件擁有父物件的內容可以透過 <code>extends</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">newClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">OldClass</span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>範例 :</strong><br>
Dog 繼承 Animal</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> makes a noise.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">	<span class="title function_">sit</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> sits.`</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Mitzie&#x27;</span>);</span><br><span class="line">d.<span class="title function_">speak</span>();<span class="comment">// &#x27;Mitzie barks.&#x27;</span></span><br><span class="line">d.<span class="title function_">sit</span>(); <span class="comment">// &#x27;Mitzie sits.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Dog 繼承 Animal 的方法了，因此在 Dog 呼叫 speak 是可以的。</p>
<p>extends 背後會幫我們連接物件的 prototype<br>
使我們可以取得父物件的方法或屬性。</p>
<blockquote>
<p>JavaScript 使用 prototyped-based 不能讓物件一次繼承兩種<br>
但有一個方法叫 <code>mixin</code> 利用拷貝的概念達到目的</p>
</blockquote>
<p>因為我還不會，先擱著 QQ，待補<br>
參考 :</p>
<ul>
<li><a href="https://zh.javascript.info/mixins">Mixin 模式</a></li>
</ul>
<h2 id="super">super()</h2>
<p>如果要在一開始就 <strong>呼叫父層的方法</strong>，必須加入<code>super()</code>，代表在繼承的子層初始化時，將舊數值蓋過去，要傳進的參數也要帶入。</p>
<blockquote>
<p>簡單來說，<code>super</code> 就是上一層的 <code>constructor</code></p>
</blockquote>
<ul>
<li>沒有 <code>super()</code> 的情況下，想在新物件生成時呼叫原型方法的 <code>speak()</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> makes a noise.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="title function_">speak</span>() <span class="comment">// 建構時在這裡呼叫原型的方法  </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">sit</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> sits.`</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Mitzie&#x27;</span>);</span><br><span class="line">d.<span class="title function_">speak</span>(); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>就會跑出</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Must call <span class="keyword">super</span> constructor <span class="keyword">in</span> derived <span class="keyword">class</span> <span class="symbol">before</span> <span class="symbol">accessing</span> &#x27;<span class="symbol">this</span>&#x27; <span class="symbol">or</span> <span class="symbol">returning</span> <span class="symbol">from</span> <span class="symbol">derived</span> <span class="symbol">constructor</span></span><br></pre></td></tr></table></figure>
<p>會提示你要記得加入 super，不然 <code>this</code> 使用時會出現問題</p>
<ul>
<li>加上 super 以及要初始化的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> makes a noise.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">		<span class="variable language_">super</span>(name)</span><br><span class="line">		<span class="variable language_">this</span>.<span class="title function_">speak</span>() <span class="comment">// 建構時在這裡呼叫原型的方法  </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">sit</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> sits.`</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Mitzie&#x27;</span>);</span><br><span class="line">d.<span class="title function_">speak</span>(); <span class="comment">// &#x27;Mitzie makes a noise.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果 super 裡面沒有傳入 <code>name</code><br>
<code>this</code> 是 Dog 本身，但是不具有 <code>name</code> 這個值，就會是 <code>undefined</code></p>
<h2 id="應用-3">應用</h2>
<p>繼承可以用在有 <strong>共同屬性</strong> 的時候，想再加一些附加功能，透過繼承不用完全重寫。</p>
<h2 id="參考-15">參考</h2>
<ul>
<li><a href="https://lidemy.com/courses/enrolled/390599">JS201 進階 JavaScript：那些你一直搞不懂的地方</a></li>
</ul>
]]></content>
      <categories>
        <category>2022</category>
        <category>04</category>
      </categories>
      <tags>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - Prototype 物件導向 (IV) 原型的繼承</title>
    <url>/2022/04/04/JavaScript-Object-oriented-programming-04.html</url>
    <content><![CDATA[<h2 id="前言-29">前言</h2>
<p>上一篇知道原型與原型鏈的內容<br>
如果我們要讓東西繼承，除了透過 new 建立物件直接幫我們繼承之外<br>
還有 <code>Object.setPrototypeOf</code> 以及 <code>Object.create()</code></p>
<span id="more"></span>  
<h2 id="原型如何繼承">原型如何繼承 ?</h2>
<ol>
<li><code>Object.setPrototypeOf(&lt;繼承者&gt;,&lt;被繼承者&gt;)</code> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person1, person2);</span><br></pre></td></tr></table></figure>
</li>
<li><code>Object.create(proto,屬性物件)</code> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person 物件</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Default_Name&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hi, I&#x27;m &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透過 Object.create() 將 Person 作為原型物件來建立一個新的物件</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>);</span><br><span class="line"><span class="comment">// 沒有 this.name</span></span><br><span class="line">p.<span class="title function_">sayHello</span>();   <span class="comment">// &quot;Hi, I&#x27;m Default_Name&quot;</span></span><br><span class="line"></span><br><span class="line">p.<span class="property">name</span> = <span class="string">&#x27;Rosa&#x27;</span>;</span><br><span class="line">p.<span class="title function_">sayHello</span>();   <span class="comment">// &quot;Hi, I&#x27;m Rosa&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Object-setPrototypeOf">Object.setPrototypeOf()</h2>
<p>上一篇我們提到 <code>[[Prototype]]</code> 是隱藏屬性<br>
ES5 之前是使用 <code>__proto__</code>，ES6 新增 <code>getPrototypeOf()</code> 與 <code>setPrototypeOf()</code> 讓我們可以直接改變物件的 prototype</p>
<h3 id="in-某屬性是否可以透過這個物件存取">in  : 某屬性是否可以透過這個物件存取</h3>
<p>我們知道物件的屬性或方法不一定是本身物件的<br>
而是來自原型鏈往上找到的<br>
如此一來，建構物件就能使用原型鏈上的屬性<br>
那怎麼確定能存取到呢 ?<br>
沒錯，就是透過 <code>in</code> !</p>
<blockquote>
<p>屬性名稱必須是「字串」</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">	a : <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 =&#123;</span><br><span class="line">	b : <span class="number">2</span> ,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;a&quot;</span> <span class="keyword">in</span> person1) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;b&quot;</span> <span class="keyword">in</span> person1) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如果要讓 person1 也能讀取到 b 就必須改變其原型<br>
可以透過 <code>Object.setPrototypeOf()</code> 直接改變<br>
不過建議非必要不要直接改變物件的 prototype</p>
<h3 id="Object-setPrototypeOf-2">Object.setPrototypeOf()</h3>
<p><code>Object.setPrototypeOf(&lt;繼承者&gt;,&lt;被繼承者原型&gt;)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person1,person2)</span><br></pre></td></tr></table></figure>
<p>JavaScript 的原型物件是物件內部屬性，<strong>無法直接存取</strong> (通常標示為 <code>[[Prototype]]</code>)，但是可以透過 setPrototypeOf 指定物件之間的原型關係</p>
<blockquote>
<p>原型繼承的規則裡，<strong>同一個物件無法指定兩種原型物件</strong>。</p>
</blockquote>
<p>試著去存取「不存在」的屬性時，那麼 JavaScript 就會往它的 <code>[[Prototype]]</code> 原型物件去尋找 (prototype chain)</p>
<p>讓 <code>person1</code> 同時有 b 也有 c 屬性</p>
<blockquote>
<p>讓 b 去繼承 c，a 再繼承 b，就能同時擁有 b 與 c</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">	a : <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 =&#123;</span><br><span class="line">	b : <span class="number">2</span> ,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person3 = &#123;</span><br><span class="line">	c : <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person2,person3)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person1,person2)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">c</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c&quot;</span> <span class="keyword">in</span> person1) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="hasOwnProperty-是否為物件本身的方法或屬性">hasOwnProperty() 是否為物件本身的方法或屬性</h3>
<p>有些屬性與方法是來自 prototype 繼承的<br>
要確定是不是屬於自己本身用 <code>hasOwnProperty</code><br>
<code>objself.hasOwnProperty(&lt;property&gt;)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">	a : <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 =&#123;</span><br><span class="line">	b : <span class="number">2</span> ,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person1,person2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">b</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 屬性 b 並非建立於 person1 物件中，而是透過繼承的方式取得的 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;b&#x27;</span>)) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h2 id="Object-create">Object.create()</h2>
<p>新建物件後的 <code>[[Prototype]]</code> 就會是我們所指定的那個原型物件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> rosa = <span class="title class_">Object</span>.<span class="title function_">creat</span>(<span class="title class_">Person</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rosa.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// constructor 的 prototype</span></span><br></pre></td></tr></table></figure>
<p>也可以是 <code>null</code>，這樣就會變成非常一般的物件 (“Very plain” objects)<br>
不帶有任何 prototype 甚至是 <code>Object.prototype</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">toString</span>()) <span class="comment">//Error</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// false</span></span><br><span class="line">conosle.<span class="title function_">log</span>(obj) <span class="comment">//非常空的物件</span></span><br><span class="line">obj.<span class="property">a</span> = <span class="number">2</span> <span class="comment">// 還是可以給予屬性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123;a:2&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) <span class="comment">// [&#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>但並不代表 Object 有關的方法都不能呼叫<br>
而是要看方法是否在 prototype 裡<br>
像是 Object.keys 依然可以使用</p>
<h3 id="造一個-Object-create">造一個 Object.create()</h3>
<p><code>Object.create()</code> 簡單實作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">create</span> = <span class="keyword">function</span> (<span class="params">proto</span>)&#123;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">	F.<span class="property"><span class="keyword">prototype</span></span> = proto;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>透過一個封裝過的建構式建構出來的物件，並把 <code>prototype</code> 指向作為參數的 <code>proto</code>。</p>
<h2 id="Object-create-v-s-new">Object.create() v.s new ?</h2>
<p>兩個都是建立物件，哪裡不一樣 ?</p>
<blockquote>
<p><code>new</code> operator 跟 <code>Object.create</code> 的差別在於會不會執行 constructor</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 建立的時候，也印出 hi</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>) <span class="comment">// 指是建立了而已</span></span><br></pre></td></tr></table></figure>
<h2 id="參考-16">參考</h2>
<ol>
<li><a href="https://zh.javascript.info/prototype-methods#very-plain">原型方法，没有 <strong>proto</strong> 的对象</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10194356">重新認識 JavaScript: Day 25 原型與繼承</a></li>
<li><a href="https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/javascript-new-operator-implementation-8c0d15f2b899">new operator — JavaScript | 為了瞭解原理，那就來實作一個 new 吧！</a></li>
<li><a href="https://blog.csdn.net/blueblueskyhua/article/details/73135938">你不知道的javascript之Object.create 和new区别</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>04</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - this (I) 基礎概念</title>
    <url>/2022/04/04/JavaScript-this-I.html</url>
    <content><![CDATA[<h2 id="前言-30">前言</h2>
<p>在學習 JavaScript 時很多課程會建議不要急著先用 <code>this</code><br>
因為 this 會跑出讓新手無法預期的結果<br>
在某些情況下使用 this 反而更棘手<br>
藉由本次來初步了解這個奇妙的 <strong>this</strong>!</p>
<span id="more"></span>
<h2 id="什麼是-this">什麼是 this ?</h2>
<ul>
<li>關鍵字</li>
<li>function 執行時，自動生成的內部物件</li>
<li>隨 function 執行場合不同，this 指向的值也會不同</li>
<li>大多數情況，this 代表的就是呼叫 function 的物件 (Owner Object of the function)。</li>
</ul>
<p>總得來說 :</p>
<blockquote>
<p>this 會因 <strong>執行的環境與上下文</strong> (context) 的不同，而有不同的結果<br>
翻譯機 : <strong>跟 function 在哪裡呼叫有關</strong></p>
</blockquote>
<p>空說 this 有點難以了解，this 其實在哪裡都可以使用(非嚴格模式下)<br>
JavaScript 並沒有特別限制 this 綁定在哪，所以 this 是會變來變去的<br>
正因如此才顯得有點麻煩</p>
<h2 id="不同情況下的-this">不同情況下的 this</h2>
<h3 id="物件導向的-this">物件導向的 this</h3>
<p>this 就是 <code>instance</code> 本身，被 <strong>實例</strong> 出來的那個。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">getValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> toyota = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;toyota&#x27;</span>)</span><br><span class="line">toyota.<span class="title function_">getValue</span>()</span><br></pre></td></tr></table></figure>
<p>這個例子就是 <code>toyota</code> 物件本身</p>
<h3 id="物件導向之外的-this">物件導向之外的 this</h3>
<p>脫離 <code>class</code> 後，可以再細分成</p>
<ol>
<li>一般 function 中的 this</li>
<li>DOM 事件中的 this</li>
<li><code>object</code> 的 this</li>
<li>arrow function 的 this <strong>(特別)</strong> ⭐</li>
</ol>
<blockquote>
<p>殺手鐧 : 可以用 <code>.call()</code> 來知道 this 的意義</p>
</blockquote>
<p><code>.call()</code> 是執行 function 另一種方式<br>
<code>.call(context,args[0],args[1])</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">p1,p2</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,p1,p2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// undefined 1 2</span></span><br><span class="line">test.<span class="title function_">call</span>(<span class="literal">undefined</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// undefined 1 2</span></span><br></pre></td></tr></table></figure>
<p>這兩個是一樣的，會發現原來一般呼叫 function 會少了 this<br>
而這個 this 就是看執行的環境與上下文 (context) 而來的</p>
<p><strong>物件中的 function 呢 ?</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">p1,p2</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,p1,p2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	func : test</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">func</span>.<span class="title function_">call</span>(obj)</span><br></pre></td></tr></table></figure>
<p>根據上面說的</p>
<blockquote>
<p><code>this</code> 代表的就是呼叫 function 的物件</p>
</blockquote>
<p>物件呼叫，呼叫的 method 前面是 obj<br>
所以 call 裡面的 this 位置是 <code>obj</code></p>
<h4 id="一般-function-中的-this">一般 function 中的 this</h4>
<p>根據環境不同，結果不同<br>
但是都是 global 的物件<br>
在 <strong>非嚴格模式</strong> 下</p>
<ul>
<li>node.js : <code>this = global</code><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mBY1X7hZFvUS0mwa7p25amxq2Q5tXcp0SRBAKj7cJNx_37JCdjvCWa0cMAjfVWWbH4a8_YsBV0qOgYrNgcg6zJ5FhgIGuLqLlMT8euJQKJx8Dr9WTfy2FGVzvqh4ES1YzVoXlfdOCNR8Q_ndRIiDSyucw5IxbNHFsKeU5KRB71oZ9e096hhsMhYq6JT-FlHeR?width=1022&amp;height=617&amp;cropmode=none" alt="global 物件"></li>
<li>瀏覽器 : <code>this = window</code><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mkwi-WphtCQHHgZoUP5u8Q0AkSyEZZcX6U6ErkFF5AKuF0z1us2zGqqo2w-Ir8auT0FL7AbZxjEfLh3Y4wyVYyLU38xVibSCWD1r70lghQMdlCieK35uGdQSgT5HKX5iStqZw2ekAtQWqgxktoKIFmMjFBf-L3h8PkZ505ii9ON4qS1jF7nRxrEJz42_hQ7AL?width=662&amp;height=300&amp;cropmode=none" alt="window 是瀏覽器的全域物件"></li>
</ul>
<blockquote>
<p><strong>嚴格模式</strong> 下的 this 指向全域物件是 <code>undefined</code><br>
因為 this 沒有綁定誰，所以會是 <code>undefined</code>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>() <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 轉成 call</span></span><br><span class="line">test.<span class="title function_">call</span>() <span class="comment">// undefined ,沒有帶入東西，嚴格模式下是 undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="DOM-事件中的-this">DOM 事件中的 this</h4>
<p>對應到事件觸發的 <strong>元素</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>)</span><br><span class="line">.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以 click 為例， <code>this</code> 會導向被按到的 <strong>元素</strong> 本身</p>
<p>但是在事件裡 <strong>呼叫其他 function</strong> 時就要特別注意了<br>
由於內部的 function 沒有綁定物件， this 會是全域物件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">	<span class="comment">// ajax 的 this 是 window 全域物件</span></span><br><span class="line">	$.<span class="title function_">ajax</span>(<span class="string">&#x27;url&#x27;</span>,<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">textContent</span>,res) </span><br><span class="line">	&#125;)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>可以透過其他變數將 <code>this</code> 先存起來，直接在內部呼叫的函式替換。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">	<span class="comment">// 把這邊的 this 存起來，指向的是元素本身</span></span><br><span class="line">	<span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">	<span class="comment">// ajax 的 this 是 window</span></span><br><span class="line">	$.<span class="title function_">ajax</span>(<span class="string">&#x27;url&#x27;</span>,<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">		<span class="comment">// 把 元素本身的 this 帶進來</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(that.<span class="property">textContent</span>,res) </span><br><span class="line">	&#125;)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>下一篇會提到如何用函式的方式綁定 this</p>
<ul>
<li>轉成 <code>.call</code><br>
<code>el</code> 是 document 子結點取得的，這邊也可以看做一個物件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,handler,<span class="literal">false</span>)</span><br><span class="line">el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;type&#x27;</span>,handler.<span class="title function_">call</span>(el),<span class="literal">false</span>) <span class="comment">// 放入的是 元素 本身</span></span><br></pre></td></tr></table></figure>
<h4 id="object-的-this">object 的 this</h4>
<p>指 obj 本身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">	test : <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>) <span class="comment">// 1</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// obj</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">test</span>()</span><br><span class="line"><span class="comment">// 轉成 call</span></span><br><span class="line">obj.<span class="property">test</span>.<span class="title function_">call</span>(obj)</span><br></pre></td></tr></table></figure>
<h4 id="arrow-function-的-this">arrow function 的 this</h4>
<blockquote>
<p>arrow function 沒有自己的 this<br>
而是用外部的 this</p>
</blockquote>
<p>箭頭函式之所以在 this 表現奇怪<br>
跟其他狀況的 this 不同的是 <strong>不是哪裡被呼叫有關</strong><br>
而是 <strong>在哪定義</strong> 有關<br>
如果前面已定義了，就會用那個值<br>
來看看例子</p>
<ul>
<li>一般 function</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hello</span>&#123;</span><br><span class="line"> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"> 	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line"> 	<span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> 		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line"> 	&#125;,<span class="number">2000</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">hello</span>()</span><br><span class="line">a.<span class="title function_">test</span>()</span><br></pre></td></tr></table></figure>
<p>很明顯的 <code>new</code> 建構出來的物件<br>
前面有提到是 <strong>實例</strong> 本身<br>
但是裡面呼叫 function 的  this 呢 ?<br>
是指 <strong>全域物件</strong><br>
setTimeout 並沒有透過其他物件呼叫<br>
就像在外部呼叫 <code>setTimeout</code></p>
<p>既然是 hello 這個物件的東西<br>
我們希望 <code>this</code> 指向的是 hello 本身建構出來的物件<br>
<code>arrow function</code> 就派上用場了</p>
<ul>
<li>用 <code>arrow function</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hello</span>&#123;</span><br><span class="line"> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"> 	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// hello&#123;&#125;</span></span><br><span class="line"> 	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"> 	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// hello&#123;&#125;</span></span><br><span class="line"> 	&#125;,<span class="number">2000</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">hello</span>()</span><br><span class="line">a.<span class="title function_">test</span>()</span><br></pre></td></tr></table></figure>
<p>arrow function 本身沒有 this<br>
而是根據定義在哪，this 就是那個值<br>
通常也是指箭頭函是外部的 this</p>
<h2 id="this-與前後文本-context-的綁定基本原則">this 與前後文本 (context) 的綁定基本原則</h2>
<p>this 綁定原則大概可以分四大種</p>
<ul>
<li><strong>預設綁定</strong> (Default Binding)</li>
<li><strong>隱含式綁定</strong> (Implicit Binding)</li>
<li><strong>顯式綁定</strong> (Explicit Binding)</li>
<li>「<strong>new」關鍵字綁定</strong></li>
</ul>
<h3 id="預設綁定">預設綁定</h3>
<p>宣告在 global scope 的變數，跟全域物件屬性是相同的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 直接讀</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 透過全域物件底下的屬性讀取</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>因為預設綁定，當 function 被呼叫的當下如果沒有值或是在 <code>func.call(null)</code> 或 <code>func.call(undefined)</code> 此類的情況下，此時裡面的 <code>this</code> 會<strong>自動指定至全域物件</strong>。</p>
<p>如果是嚴格模式， this 綁定全域物件是 <code>undefined</code></p>
<h3 id="隱含式綁定">隱含式綁定</h3>
<p>function 被宣告的地方是在 global scope 中，只要它 <strong>成為某個物件的參考屬性</strong> (reference property)，在那個 function 被呼叫的當下，該 function 即被那個物件所包含。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a  = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">a</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: func <span class="comment">// 引用 global 的 function</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>();  <span class="comment">// 2 , this是 obj 本身</span></span><br><span class="line"><span class="keyword">var</span> func2 = obj.<span class="property">foo</span>;</span><br><span class="line"><span class="title function_">func2</span>();    <span class="comment">// undefined ， 這邊的 func 是 global 的，this 是 window，a 是找不到的</span></span><br></pre></td></tr></table></figure>
<p>決定 this 的關鍵不在於它屬於哪個物件，而是</p>
<blockquote>
<p>在於 function「呼叫的時機點」</p>
</blockquote>
<p>透過物件呼叫某個方法 (method) 的時候，此時 this 就是那個物件 (owner object)。</p>
<h3 id="顯式綁定">顯式綁定</h3>
<ol>
<li><code>.bind()</code></li>
<li><code>.call()</code></li>
<li><code>.apply()</code></li>
</ol>
<p>這類直接指定 this 的 function 都可被歸類至顯式綁定的類型。</p>
<h3 id="new-關鍵字綁定">new 關鍵字綁定</h3>
<p>當一個 <code>function</code> 前面帶有 <code>new</code> 被呼叫時，會發生：</p>
<ul>
<li>會產生一個新的物件 (物件被建構出來)</li>
<li>這個新建構的物件會被設為那個 function 的 <code>this</code> 綁定目標，也就是 <code>this</code> 會指向新建構的物件。</li>
<li>除非這個 function 指定回傳 (return) 了他自己的替代物件，否則這個透過 <code>new</code> 產生的物件會被自動回傳。</li>
</ul>
<p>關於 <code>new</code>，參考 : <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new#description">MDN 對 new 的說明</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title function_">foo</span>( <span class="number">123</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj.<span class="property">a</span> );      <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<h2 id="this-的應用-Cascade-組合技">this 的應用 : Cascade 組合技</h2>
<p>Cascade 也有人稱作 <strong>「Fluent Interface」</strong><br>
可以讓 method 串串樂</p>
<p>JavaScript 允許函式 <code>return undefined</code><br>
那改成 <code>return this</code> 呢 ?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> calNum = <span class="keyword">function</span>(<span class="params">num</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">num</span> = num;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">newNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> += newNum;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sub</span> = <span class="keyword">function</span>(<span class="params">newNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> -= newNum;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">multi</span> = <span class="keyword">function</span>(<span class="params">newNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> *= newNum;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">division</span> = <span class="keyword">function</span>(<span class="params">newNum</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">num</span> /= newNum;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 透過 new 建立實體，this 是 calNum本身</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">calNum</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 分開呼叫</span></span><br><span class="line">a.<span class="title function_">add</span>(<span class="number">50</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a.<span class="property">num</span> ); <span class="comment">// 150</span></span><br><span class="line">a.<span class="title function_">sub</span>(<span class="number">100</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a.<span class="property">num</span> ); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p>當回傳 this 時，指的是物件本身，可以往後串在一起，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.<span class="title function_">add</span>(<span class="number">50</span>).<span class="title function_">sub</span>(<span class="number">100</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a.<span class="property">num</span> ); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p>JQuery 中的也是用 method chain (方法鏈) 這樣的方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;div&#x27;</span>).<span class="title function_">addClass</span>(<span class="string">&#x27;is-active&#x27;</span>)</span><br><span class="line">        .<span class="title function_">removeClass</span>(<span class="string">&#x27;is-hide&#x27;</span>)</span><br><span class="line">        .<span class="title function_">text</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>或者 <code>Array</code> 的內建函式<br>
是可以串聯不同的方法<br>
而且回傳的都是 <strong>同類型</strong> 的陣列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">el</span> =&gt;</span> e*<span class="number">2</span>)</span><br><span class="line">	   .<span class="title function_">filter</span>(<span class="function"><span class="params">el</span> =&gt;</span> el &gt;= <span class="number">4</span>) <span class="comment">// [4,6]</span></span><br></pre></td></tr></table></figure>
<h2 id="總結-23">總結</h2>
<p>除了轉成 <code>.call()</code> 來判斷 this<br>
對於 this 也可以朝幾種方向來判斷</p>
<ol>
<li>function 的呼叫，是透過 <code>new</code> 進行的嗎？<br>
如果是，那 this 就是被建構出來的物件。</li>
<li>function 是以 .call() 或 .apply() 的方式呼叫的嗎？ 或是 function 透過 .bind() 指定？<br>
如果是，那 this 就是被指定的物件。</li>
<li>function 被呼叫時，是否存在於某個物件？<br>
如果是，那 this 就是那個物件。</li>
<li>如果沒有滿足以上條件，此 function 裡的 this 就一定是全域物件<br>
在嚴格模式下則是 undefined。</li>
</ol>
<h2 id="參考-17">參考</h2>
<ol>
<li><a href="https://blog.huli.tw/2019/02/23/javascript-what-is-this/">淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂 - Huli</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23804247">this 的值到底是什么？一次说清楚</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10193193">重新認識 JavaScript: Day 20 What’s “THIS” in JavaScript (鐵人精華版)</a></li>
<li><a href="https://zh.javascript.info/object-methods">对象方法，“this”</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>04</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - this (II) call、appaly、bind</title>
    <url>/2022/04/04/JavaScript-this-II.html</url>
    <content><![CDATA[<h2 id="前言-31">前言</h2>
<p>除了透過執行環境與上下文來綁定之外<br>
this 是可以改變的<br>
改變 this 有三種方式</p>
<span id="more"></span>
<h2 id="call-apply">call &amp; apply</h2>
<p>上一篇有簡略提過 <code>.call()</code><br>
等同於 function 直接執行<br>
而且是有帶 <code>this</code><br>
第一個參數是指定 <code>this</code>，後面及是 <code>arguments</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 這樣是一樣的</span></span><br><span class="line"><span class="title function_">test</span>() === test.<span class="title function_">call</span>()</span><br><span class="line"><span class="title function_">test</span>() === test.<span class="title function_">apply</span>()</span><br></pre></td></tr></table></figure>
<p>這兩個執行是差不多的<br>
差在後面的參數類型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> test =&#123;</span><br><span class="line">	a : <span class="number">1</span>,</span><br><span class="line">	<span class="title function_">log</span>(<span class="params">num</span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>,num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">test.<span class="title function_">log</span>(<span class="number">5</span>) <span class="comment">// 1 , 5</span></span><br><span class="line"><span class="comment">// 改變 this </span></span><br><span class="line">test.<span class="property">log</span>.<span class="title function_">apply</span>(obj,[<span class="number">5</span>]) <span class="comment">// 5 , 5</span></span><br><span class="line">test.<span class="property">log</span>.<span class="title function_">call</span>(obj,<span class="number">5</span>) <span class="comment">// 5 , 5</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>call</code> : 後面都用逗號隔開<br>
<code>.call(thisValue,args[0],args[1])</code></li>
<li><code>apply</code> : 前面為 this，後面參數為類陣列。<br>
<code>.apply(thisValue,[args[0],args[1]])</code></li>
</ul>
<h3 id="call-跟-apply-為什麼同時存在">call 跟 apply 為什麼同時存在 ?</h3>
<p>例子是來自 <a href="https://blog.huli.tw/2020/04/18/javascript-function-is-awesome/">覺得 JavaScript function 很有趣的我是不是很奇怪</a><br>
這篇也探討很有趣的 JS 問題</p>
<ul>
<li>Math.max 的參數可以吃隨意數值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>如果我們要從陣列中找出最大值呢 ?<br>
直接呼叫會導致錯誤<br>
可以運用 apply 的參數是 <strong>陣列</strong> 的方式帶入<br>
或者用 ES6 展開</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>,arr)) <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(...arr)) <span class="comment">// 6 , 展開 </span></span><br></pre></td></tr></table></figure>
<p>總是會有不同的情境可以使用</p>
<h2 id="bind">bind</h2>
<p>把 this 的值先綁死，不管後面怎麼 call<br>
都不會變動。</p>
<blockquote>
<p>bind 回傳的是一個 <strong>function</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	<span class="attr">a</span>:<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">	<span class="attr">test</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = obj.<span class="property">test</span>.<span class="title function_">bind</span>(o) <span class="comment">// function</span></span><br><span class="line"><span class="title function_">b</span>() <span class="comment">// 10</span></span><br><span class="line">b.<span class="title function_">call</span>(obj) <span class="comment">// 依舊是 10</span></span><br></pre></td></tr></table></figure>
<p>非嚴格模式底下，無論是用 call、apply 還是 bind<br>
傳進去的如果是 primitive 都會被轉成 <strong>object</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">hello.<span class="title function_">call</span>(<span class="number">123</span>) <span class="comment">// [Number: 123]</span></span><br><span class="line"><span class="keyword">const</span> myHello = hello.<span class="title function_">bind</span>(<span class="string">&#x27;my&#x27;</span>)</span><br><span class="line"><span class="title function_">myHello</span>() <span class="comment">// [String: &#x27;my&#x27;]</span></span><br></pre></td></tr></table></figure>
<h2 id="箭頭函式-v-s-bind">箭頭函式 v.s bind</h2>
<p>初學時會認為 arrow funciton 有指向自己，綁定的意味<br>
但兩者有很大的區別</p>
<ul>
<li><code>.bind(this)</code> : 呼叫之前就先綁定，讓被呼叫的都有固定的 <code>this</code>。</li>
<li>arrow function this : 箭頭函式沒有建立任何的 this，簡單來說是根本沒有自己的 this。<br>
在箭頭函式使用 this，會像變數一樣，往外部尋找。</li>
</ul>
<h2 id="參考-18">參考</h2>
<ol>
<li><a href="https://blog.huli.tw/2019/02/23/javascript-what-is-this/">淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂 - Huli</a></li>
<li><a href="https://blog.huli.tw/2020/04/18/javascript-function-is-awesome/">覺得 JavaScript function 很有趣的我是不是很奇怪</a></li>
<li><a href="https://zh.javascript.info/arrow-functions">深入理解箭头函数</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>04</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>紀錄 | Frontend Mentor 挑戰題 - Time tracking dashboard</title>
    <url>/2022/04/04/Practice-to-Master-01.html</url>
    <content><![CDATA[<h2 id="前言-32">前言</h2>
<p>這是在 <a href="https://www.frontendmentor.io/solutions/responsive-reactjs-styledcomponent-BkFnvCvr9">frontend mentor 的挑戰題</a><br>
使用 React + styled-components</p>
<ul>
<li><a href="https://meitung473.github.io/time-tracking-dashboard-main/">網頁</a></li>
<li><a href="https://github.com/meitung473/time-tracking-dashboard-main">github repo</a></li>
</ul>
<p><img data-src="https://dsm01pap006files.storage.live.com/y4m9LQmpdiru45ZO2sTWfVBoSuRS1cfQoRCmHTFQxc-7aQWX0hkbq0r2q3tefJlGHA3SeXfA_G4CV5PHZIagjALPplvZ3s9MO6tpWyEEYyL2J7ep3EbhiNczfUybFUlxBTjvVQybnsXtFwrgoLmqEFJBftLbJvhzcipVkL-hdLjY23wEqHVpwrW0vNREUMTmt-y?width=1024&amp;height=585&amp;cropmode=none" alt="完成圖"></p>
<span id="more"></span>
<h2 id="專案建置">專案建置</h2>
<ol>
<li><strong>create-react-app</strong> : 一鍵建立好環境</li>
<li><strong>eslint</strong> : 加上 <code>Protype</code> 來檢查類型</li>
</ol>
<h2 id="我的流程">我的流程</h2>
<ol>
<li>Design - 照著參考圖刻出 figma 版型及元件</li>
<li>JS - 完成 filter 的功能，拿出想要的資料</li>
<li>JS - 照 figma 切出 component 架構</li>
<li>CSS - mobile 刻板</li>
<li>CSS - RWD</li>
<li>上傳至 frontend mentor + 撰寫 Readme</li>
</ol>
<h2 id="額外練習-figma-切版">額外練習 figma : 切版</h2>
<p>一邊練習切版以及 figma 的使用<br>
本次學習 &amp; 練習</p>
<ul>
<li>元件 <code>component</code> :</li>
<li>變體 <strong>variants</strong> : 用程式概念想有點像 obj  <code>key-value</code> pair，可透過先建立好的類似類型，再替換選項。<br>
常用的例子 : 有無圖案，實心空心，方向。<br>
figma 是 <code>[property,value]</code> 來替換。
<blockquote>
<p>obj 的 key 不能重複， <strong>figma 的 property 也是不能重複</strong>。<br>
如果不在同一個 frame 裡的元件不能結為變體</p>
</blockquote>
</li>
<li><strong>auto layout</strong> : 有點像 css 的 flex</li>
<li><strong>asset</strong> : 將重複的物件作做成元件，放到元件庫</li>
<li>巢狀結構 : 用 <code>/</code> 斜線來代表類似的元件群組</li>
</ul>
<p>最後切出來的元件<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mZHL-B7h3iluUZzub-BxoLDbrZc2Wp43yRJd2NVsXDW2zIV5XhtSM4KNshxjCkPBfsHoSgqnK2Kdxg1pBBWw0T5RjD-TTXkiNZn69EENIX9dqbxu3K51pbNjKeNhyHJ1bpXSDwFX9c_cUoC8vv_UUaPUbmLmE9C2qcbYmNRl93CPWgVuKOBRb8U8crh2FSTTU?width=656&amp;height=1024&amp;cropmode=none" alt="Asset"></p>
<p>菜鳥設計稿 🥴，照著圖片檔慢慢切出來<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mwTdZBRAfGvMzTnynXGFrQ4yShvVgoGM-PJdXLOnF-3zi3OCyKeWiW1TYFmpurDs8l3lReNkOzMNTIDjoFCNdWNQbukzoR0iXkfmz9edOCJrqOrnH-aS2aT-17DZPd3W4cOL2lLovbNjta_rMsjlzeAgNDWQf458D4AxkOyiGYVlSHwfLTq1slPvuG8YDTHV4?width=1024&amp;height=800&amp;cropmode=none" alt="設計稿"><br>
上半部都是變體的設定</p>
<h3 id="變體設定">變體設定</h3>
<p>變體部分是透過 nested 的方式，從元件最小的部分到整塊卡片都是可以切換</p>
<ol>
<li>卡片種類，我把每一種都先做樣板，可以直接替換卡片。<br>
發現用處不大 XD，因為卡片都只有一張…，替換順序倒是蠻有幫助的。</li>
<li>滑鼠移入 <code>:hover</code> active &amp; inactive。<br>
我直接做在 setting component 上</li>
<li>Profile 底下的時間節點切換，把 daily 、 weekly 等等的跟 setting 一樣分成 active 跟 inactive。</li>
<li>電腦版型  &amp; 手機版型 卡片，用處也不大。當時是想說如果多一種版型可以思考…</li>
<li>背景的 icon 切換，這是在做個別卡片原件快速切換用的而已</li>
</ol>
<p>在把上述的合併起來，在面板可以自由切換 😃<br>
接下來就是進到寫程式的環節🥰</p>
<h2 id="React-部分">React 部分</h2>
<p>練習題較少用到使用到 React Hooks<br>
大部分還是 CSS 居多<br>
只有使用 <code>useState</code>、<code>useMemo</code> 而已</p>
<h3 id="svg-當作-component-匯入">svg 當作 component 匯入</h3>
<p><a href="https://create-react-app.dev/docs/adding-images-fonts-and-files/">官方</a> 要引入圖片有兩種方式</p>
<ol>
<li>當作 component 匯入 (svg)</li>
<li>直接匯入圖檔來源</li>
</ol>
<p>圖檔是 svg ，這邊我採用 component 的方式，主要是想改變 hover 時的填色</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 當作元件匯入</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">ReactComponent</span> <span class="keyword">as</span> <span class="title class_">Play</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./images/icon-play.svg&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			&#123;/*作為元件使用*/&#125;</span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">Play</span>/&gt;</span>		</span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>關於第二點，使用 <code>src</code> 引入圖檔<br>
因為 deploy 之後 <code>index.html</code> 的路徑無法對上，有的人會建議把圖檔放在 <code>public</code> 上，在透過相對路徑引入。<br>
或者讓 webpack 幫我們透過 JavaScript module (file loader)來處理，不過要注意的是，路徑的起始點是 <code>./</code>，所以後續在 deploy 時要設定 <code>homepage</code> 來矯正路徑</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 這邊是相對路徑字串</span></span><br><span class="line"><span class="keyword">import</span> play <span class="keyword">from</span> <span class="string">&#x27;./images/icon-play.svg&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			&#123;/*作為路徑使用*/&#125;</span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;play&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;Play icon&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="從外部匯入的-Element-轉成正確的-React-component">從外部匯入的 Element 轉成正確的 React component</h3>
<p>這邊我需要找到對應的樣式跟 icon 圖，起初我是回傳 <code>[Icon[type], theme.primary[type]]</code><br>
預想中是在 component 中要拿到 <code>&lt;Play/&gt;</code> 這樣的 svg as component<br>
轉出來的是 component <code>&#123;Play&#125;</code> 這樣可以，看起來好像一般的值，我想改成 tag 的形式，加上 <code>&lt;&gt;</code> 反而變成  <code>React Element</code> 。<br>
從<a href="https://github.com/facebook/react/issues/13445#issuecomment-414389398">官方的 issues 這篇</a> 有提到，是因為 <strong>格式錯誤</strong><br>
加上 tag 的方法實際上變成這樣 <code>&lt;&lt;Play/&gt;/&gt;</code>，可以用 function 先把元件輸出再使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// svg as component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Icon</span> = &#123;</span><br><span class="line">    <span class="title class_">Exercise</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Exercise</span> /&gt;</span></span>,</span><br><span class="line">    <span class="title class_">Play</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Play</span> /&gt;</span></span>,</span><br><span class="line">		...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 拿到該圖檔跟顏色</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">type2Style</span>(<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type.<span class="title function_">includes</span>(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">        type = type.<span class="title function_">replace</span>(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// React Element -&gt; Component，把 React Component </span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">BgIcon</span> = (<span class="params"></span>) =&gt; <span class="title class_">Icon</span>[type];</span><br><span class="line">    <span class="keyword">return</span> [<span class="title class_">BgIcon</span>, theme.<span class="property">primary</span>[type]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="資料轉化">資料轉化</h3>
<p>這部分是想要熟悉如何去使用 Object &amp; Array 的 function<br>
把自己想要的資料召喚出來，目前已知的是按鈕切換取得資料，<code>useState</code> 在 set 的時候做 re-render 讓我們可以看到資料改變後畫面也改變。</p>
<ul>
<li>Click Event</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="comment">// 1. 觀察 timeframe 改變時設定的值</span></span><br><span class="line">    <span class="keyword">const</span> [timeframe, setTimeframe] = <span class="title function_">useState</span>(<span class="function">() =&gt;</span></span><br><span class="line">        <span class="title class_">Type2Data</span>(timetype.<span class="property">daily</span>, data)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 2. 點擊後改變 type</span></span><br><span class="line">    <span class="keyword">const</span> [type, setType] = <span class="title function_">useState</span>(timetype.<span class="property">daily</span>);</span><br><span class="line">    <span class="comment">// 3. 傳入 type 值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">clickhandler</span> = (<span class="params">type</span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">setTimeframe</span>(<span class="function">() =&gt;</span> <span class="title class_">Type2Data</span>(type, data));</span><br><span class="line">        <span class="title function_">setType</span>(<span class="function">() =&gt;</span> type);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeProvider</span> <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">TimerLayout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		            &#123;/* 4. 把 handler 當作 props 傳給元件的 button */&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">ProfileCard</span> <span class="attr">clickhandler</span>=<span class="string">&#123;clickhandler&#125;</span> <span class="attr">type</span>=<span class="string">&#123;type&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;timeframe.map((&#123; last, title, prev, current &#125;, i) =&gt; (</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">TimeframeCard</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">key</span>=<span class="string">&#123;i&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">data</span>=<span class="string">&#123;&#123;</span> <span class="attr">last</span>, <span class="attr">title</span>, <span class="attr">prev</span>, <span class="attr">current</span> &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    /&gt;</span></span></span><br><span class="line"><span class="language-xml">                ))&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">TimerLayout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ThemeProvider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>轉換資料的 function</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Type2Data</span>(<span class="params">type, data</span>) &#123;</span><br><span class="line">		<span class="comment">// 初始值是陣列</span></span><br><span class="line">    <span class="keyword">return</span> data.<span class="title function_">reduce</span>(<span class="function">(<span class="params">p, n</span>) =&gt;</span> &#123;</span><br><span class="line">		    <span class="comment">// 1. 把官方給的 data.json 解構</span></span><br><span class="line">        <span class="keyword">const</span> &#123; title, timeframes &#125; = n;</span><br><span class="line">        <span class="comment">// 2. 畫面上需要轉換 timeframe 的文字</span></span><br><span class="line">        <span class="keyword">let</span> type2text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> timetype.<span class="property">daily</span>:</span><br><span class="line">                type2text = <span class="string">&quot;day&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> timetype.<span class="property">weekly</span>:</span><br><span class="line">                type2text = <span class="string">&quot;week&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> timetype.<span class="property">monthly</span>:</span><br><span class="line">                type2text = <span class="string">&quot;month&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 把符合的 timeframe 資料抓出來，後續要透過 map 把資料印出來</span></span><br><span class="line">        p.<span class="title function_">push</span>(&#123;</span><br><span class="line">            <span class="attr">last</span>: type2text,</span><br><span class="line">            title,</span><br><span class="line">            <span class="attr">prev</span>: timeframes[type].<span class="property">previous</span>,</span><br><span class="line">            <span class="attr">current</span>: timeframes[type].<span class="property">current</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搭拉 ! 當我按下按鈕，state 改變進行 re-render<br>
<img data-src="https://i.imgur.com/P9Aj0ae.gif" alt="切換 timeframe"></p>
<h3 id="useMemo-把資料記起來">useMemo : 把資料記起來</h3>
<p>由於我的圖片以及顏色是透過計算而來，而不是寫死的， 每次 state 改變時也會 re-render ，導致每次都重新計算一次😓。<br>
但是 <strong>樣式內容是不變</strong> 的，所以用 <code>useMemo</code> 包起來，紀錄樣式資料</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TimeframeCard</span>(<span class="params">&#123; data &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; last, title, current, prev &#125; = data;</span><br><span class="line">    <span class="comment">// 避免 re-render 又跑一次</span></span><br><span class="line">    <span class="keyword">const</span> [<span class="title class_">BgIcon</span>, <span class="title class_">BgColor</span>] = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">type2Style</span>(title), [title]);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">TimeframeCardContainer</span> <span class="attr">bgcolor</span>=<span class="string">&#123;BgColor&#125;</span> <span class="attr">br</span>=<span class="string">&#123;br&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">BgIcon</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">FrameBody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">FrameHeader</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">FrameHeaderTitle</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">FrameHeaderTitle</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Setting</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">FrameHeader</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">FrameContent</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">CurrentText</span>&gt;</span>&#123;current&#125;hrs<span class="tag">&lt;/<span class="name">CurrentText</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">PrevText</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        Last &#123;last&#125; - &#123;prev&#125;hrs</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">PrevText</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">FrameContent</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">FrameBody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">TimeframeCardContainer</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>後來寫文時，我覺得這邊寫的不是很好，既然是固定的，我為什麼要透過計算來取得樣式呢🥴<br>
回想當初在寫，多想到如果改成客製化卡片，樣式內容就會改變，以目前的練習題並沒有這個需求😅<br>
也許可以作為之後的 :Todo</p>
<h3 id="Deploy-部屬網站">Deploy : 部屬網站</h3>
<p><code>package.json</code> 需要設定 homepage 將路徑重新設定，否則輸出的 build 裡面的 index.html 引入的東西會找不到。<br>
<a href="https://create-react-app.dev/docs/deployment/#building-for-relative-paths">Deployment 官方教學</a></p>
<ul>
<li>package.json</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;my-app&quot;</span>,</span><br><span class="line">  <span class="comment">// 我發布在網頁上的路徑</span></span><br><span class="line">+ <span class="string">&quot;homepage&quot;</span>: <span class="string">&quot;https://meitung473.github.io/time-tracking-dashboard-main/&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSS部分">CSS部分</h2>
<p>包含 styled-component 以及一些 CSS 遇到的問題</p>
<h3 id="normalize-css">normalize.css</h3>
<p>我記得在 create-react-app 使用 normalize 在 <code>index.css</code> 加上 :</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import-normalize</span></span><br></pre></td></tr></table></figure>
<p>結果 IDE 提示格式錯誤以外，感覺好像都沒作用<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4muj1fnDJhMGuehE88QmzA1uezUw5o7ocb8_KQf52VuXLdBQFYupbRyS3943vlDwAYqGq1KtqHfS80RjlFnRRYsuOvLIUb1Nd-Rog1ThCib7FhPDbyqo_bYip_65arJPHfXKV5Q4g4iJGC1JO8kls0kAU8JQXlHFxFogThYvQFB2GRkhdoUH31i7XUKHkXADaH?width=1024&amp;height=115&amp;cropmode=none" alt="IDE 提示格式錯誤"><br>
我是按照官方的 <a href="https://create-react-app.dev/docs/adding-css-reset/#browser-support">教學</a><br>
打開 devtool 反而是多了 <code>where:</code> 的樣式，所以並不是沒有<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mzXONRr23Eb4GiE7hLxjSlL9TuG5SxD6Xhhcl5xYKY__SAR-WM9kUhCeYYOZQpf1O6AFdFl27BwQM1_6LlbadtlQvNV1T-VtH7aIhhR0MP35pOqAxyfMIjPgTVbN0UhbGShKwyy-LxhksBAcP-GSYnocw-tj-k3YF6zbeelM3Tn2MOfTm-p5cIGAwkqtW9xUl?width=1024&amp;height=147&amp;cropmode=none" alt="where:"></p>
<p>我查到 <a href="https://stackoverflow.com/questions/56532121/normalize-css-does-not-fully-add-reset-to-react-app">這篇</a> 解釋為什麼 normalize.css 其實有不同份，如果在另外安裝 <a href="https://github.com/necolas/normalize.css">normalize.css</a> ，引入為什麼作用是因為 <strong>根本沒有指向到這版</strong>。</p>
<p>目前的 React 是使用 <code>@csstool/normalize</code> 而不是 <code>necolas/normalize</code> 版的<br>
關於這兩份的差別，<a href="https://github.com/csstools/normalize.css/issues/3">共同作者解釋</a> 是移除一些固定格式的設定像是 (<code>body&#123;margin:0&#125;</code>) ，以及兼顧瀏覽器的兼容性問題。 🤔</p>
<p>另外我也查了一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:where">:where</a> 偽元素，為什麼 normalize 會使用這個。<br>
以往在寫 CSS 必須注意權重的問題，而 <code>:where</code> 的權重是 0 ，不管設定的 CSS 權重後來的值都可以覆蓋過去， 相較 <code>:is()</code> 來的更適合設定預設值。<br>
目前幾乎所有的瀏覽器都有支援，IE 因為今年六月要被淘汰了，就沒差了吧 🥴</p>
<h3 id="styled-components-media-query">styled-components @media query</h3>
<p>在之前學習是寫成個別一行，再一個個 import 到需要改動的元件裡面做修改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> breakpoint_md = <span class="string">&quot;@media screen and (min-width: 768px)&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>不過都 CSS-in-JS 了，不如把它變得更加程式化一點。<br>
我在寫 styled-component 時只把他想成 <strong>會產出一大串的文字</strong>，想要做到 sass 的 @mixin 功能，改成寫 function 回傳想要的字串。<br>
所以這次的目標是 :</p>
<blockquote>
<p>object 透過 key 拿到 <code>@media</code> 的字串，例 <a href="http://breakpoint.md">breakpoint.md</a> 對應 min-width : 768px</p>
</blockquote>
<p>參考 : <a href="https://dev.to/cagatayunal/how-to-use-css-media-query-breakpoint-in-styled-components-9of">How to use CSS Media Query Breakpoint in Styled-Components</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先寫好對應的尺寸</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sizes = &#123;</span><br><span class="line">    <span class="attr">xxl</span>: <span class="number">1440</span>,</span><br><span class="line">    <span class="attr">xl</span>: <span class="number">996</span>,</span><br><span class="line">    <span class="attr">md</span>: <span class="number">768</span>,</span><br><span class="line">    <span class="attr">sm</span>: <span class="number">576</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @media 固定的格式，從手機往上寫 &#123;size&#125; 拿來做替換</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;@media screen and (min-width: &#123;size&#125;px)&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> br = <span class="title class_">Object</span>.<span class="title function_">keys</span>(sizes).<span class="title function_">reduce</span>(<span class="function">(<span class="params">p, n</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">/* 轉換過後的 sizes : [&#x27;xxl&#x27;,&#x27;xl&#x27;,...]</span></span><br><span class="line"><span class="comment">		我們只要</span></span><br><span class="line"><span class="comment">			&#123;</span></span><br><span class="line"><span class="comment">				n1 : sizes[n1]</span></span><br><span class="line"><span class="comment">				n2 : sizes[n2]</span></span><br><span class="line"><span class="comment">				...</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 用取代的方式</span></span><br><span class="line">    p[n] = prefix.<span class="title function_">replace</span>(<span class="string">&quot;&#123;size&#125;&quot;</span>, sizes[n]);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>不想這麼麻煩也可以直接透過 template 帶值<br>
<code>@media screen and (min-width: $&#123;sizes[n]&#125;px)</code><br>
在 styled-component 內我們就可以直接使用</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; br &#125; <span class="keyword">from</span> <span class="string">&quot;../../Device&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FrameBody</span> = <span class="title function_">styled</span>(<span class="title class_">InfoCard</span>)<span class="string">`</span></span><br><span class="line"><span class="string">		&#123;/* 直接寫 */&#125;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;br.md&#125;</span> &#123;</span></span><br><span class="line"><span class="string">        padding: 1em 1.2em;</span></span><br><span class="line"><span class="string">        cursor: pointer;</span></span><br><span class="line"><span class="string">        transition: filter 0.3s ease-out;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>
<p>這樣做 RWD 就可以比較簡單了🥰</p>
<h2 id="結語-3">結語</h2>
<p>每次練習都會覺得自己又更進步一些<br>
重新思考自己的製作流程<br>
最後覺得 CSS 的部份有點雜，可以抽出相同的樣式再重構<br>
後續有時間再修改</p>
<h2 id="參考資料">參考資料</h2>
<ol>
<li><a href="https://dev.to/cagatayunal/how-to-use-css-media-query-breakpoint-in-styled-components-9of">How to use CSS Media Query Breakpoint in Styled-Components</a></li>
<li><a href="https://airbnb.io/javascript/react/#class-vs-reactcreateclass-vs-stateless">Airbnb JavaScript Style Guide</a></li>
<li><a href="https://github.com/facebook/react/issues/13445">expected a string (for built-in components) or a class/function</a></li>
<li><a href="https://create-react-app.dev/">Create React App</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>04</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>styled-components</tag>
      </tags>
  </entry>
  <entry>
    <title>心得 | Foresea畢業專題(I) ─《綜合資源分享》</title>
    <url>/2021/05/05/Foresea-bookreport-I.html</url>
    <content><![CDATA[<p><code>[此篇為舊文，從Notion搬運過來，撰寫日期為05/18/21]</code></p>
<h2 id="大學簡陋的句點">大學簡陋的句點</h2>
<p>你曾想過自己大學最後會帶走什麼嗎?<br>
現在我還在想答案似乎遲了點，但在疫情草草結束我的大學生涯的最後…</p>
<span id="more"></span>  
<p>| <strong>我想發揮自己的價值</strong>。</p>
<p>對。<br>
除了分享也是種紀錄，如果有幫助到任何人大概是件好事<br>
目前預計寫幾篇製作畢業專題相關的，包含 資源分享、程式學習、心得歷程。</p>
<hr>
<h2 id="想法萌生">想法萌生</h2>
<p>人生八九不如意，因此我選擇十分努力<br>
我並不是一個特別厲害的人。單純熱愛分享而已。<br>
憶起一位學長在我大三系學會會長任期結束時，提出可否組成技術互助會什麼的<br>
協助系上同學整體學習與資源的傳承<br>
當時我無法提供一個完善的機制來運作這件事…<br>
目前我只能以文章類型來提供(我有思考另一種方式，但技術不夠)<br>
做這件事我相信我不是第一位，也希望不是最後一位。<br>
(偷偷搬運 :  <strong><a href="https://www.youtube.com/channel/UCbZ34gnooSIHXAZUW1_wvgQ">程式大師</a></strong>、<strong><a href="https://www.notion.so/fd0b3d043fcb4bbc86d542424e4b6040">動態大師</a></strong>  <strong>)</strong> 還有更多我不知道的。<br>
這些資源與建議請作為參考，非絕對</p>
<hr>
<h2 id="專題簡單介紹">專題簡單介紹</h2>
<p>以專題為例，還是來簡單介紹一下🥳<br>
Foresea 是我的畢業專題，組成為四人，我負責遊戲程式的部分<br>
內容是關於認識六個海洋議題的遊戲與網站，有興趣的話可以點下方觀看<br>
<strong>專題網站:</strong><br>
<a href="https://byforesea.github.io/foresea/">Foresea｜預見海洋最糟的情況，你會怎麼做？</a><br>
<strong>本系專題介紹:</strong><br>
<a href="https://dedm66019206.github.io/dedm110expo/about/Foresea.html">Foresea | 嘉義大學數位系110級畢業展覽</a><br>
以下這些資源，已取得我們團隊同意，就一併開放</p>
<p><strong>重要聲明 :</strong></p>
<ol>
<li>Package中的美術素材不可複製、修改或應用於別處。</li>
<li>不可拿Foresea 主程式修改後，做為自己的作品(僅提供學習觀摩用)</li>
<li>任何資源請抱持學習與愛惜之心。若發現不當使用，將撤銷所有文章</li>
</ol>
<hr>
<h2 id="資源分享正篇">資源分享正篇</h2>
<h3 id="一、音樂-音效-資源">一、音樂 / 音效 資源</h3>
<table>
<thead>
<tr>
<th>用途</th>
<th>網站</th>
</tr>
</thead>
<tbody>
<tr>
<td>音效</td>
<td><a href="https://taira-komori.jpn.org/freesoundtw.html">小森平音效</a></td>
</tr>
<tr>
<td>音效</td>
<td><a href="https://on-jin.com/kiyaku.php">音人</a></td>
</tr>
<tr>
<td>音效</td>
<td><a href="https://gamesounds.xyz/">Xyz</a></td>
</tr>
<tr>
<td>BGM</td>
<td><a href="https://www.tam-music.com/se000_category/natural">TAM</a></td>
</tr>
<tr>
<td>BGM</td>
<td><a href="http://amachamusic.chagasi.com/index.html">甘茶の音楽工房</a></td>
</tr>
<tr>
<td>BGM</td>
<td><a href="http://conte-de-fees.com/">conte-de-fees</a></td>
</tr>
<tr>
<td>Both</td>
<td>Youtube 音效庫</td>
</tr>
</tbody>
</table>
<p>也可以找找 Unity 商店有些人免費提供的音樂包<br>
⚠ 遵守CC，有些須註明標記，請自行斟酌</p>
<hr>
<h3 id="二、程式包-Package">二、程式包 (Package)</h3>
<p>Unity 建置環境 :<br>
<strong>2019.4.9.f1</strong> (請用以上的版本)  2D 平台<br>
<strong>注意事項 :</strong></p>
<ol>
<li>如果有一堆黃色驚嘆號，是正常的</li>
<li>按開始無反應，可能是 <code>Tag</code> 或是<code>layer</code> 設定跑掉，導致程式找不到。請自行創建 layer 與 tag 替換上。</li>
</ol>
<p>🤙可以詢問我， Email :  <a href="mailto:yanshanhong23@gmail.com">yanshanhong23@gmail.com</a></p>
<blockquote>
<p>📄 <strong><a href="https://1drv.ms/u/s!AtRw0OR0iI_KjYJrOgYRJWs_90BckQ">Download</a></strong></p>
</blockquote>
<p><strong>密碼提示</strong> (英文校系名大寫+系上主要的電腦教室的代號)<br>
下載後請開新Project ，到Assest 匯入package。</p>
<hr>
<h3 id="三、我常用軟體推薦">三、我常用軟體推薦</h3>
<p>(如果你還沒找到合適的軟體可以試試)</p>
<ol>
<li>
<p><strong>Mind-Map</strong><br>
幾乎每一堂課都會使用到的好工具，對於想法上的整體很有幫助<br>
常見的 <a href="https://coggle.it/">coggle</a>、 <a href="https://miro.com/mind-map/">miro</a></p>
<ul>
<li><strong>coggle</strong></li>
</ul>
<ol>
<li>多人共同編輯與檢閱</li>
<li>缺點的話大概是操作有點反人類<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mmjL6nXvoTD5vue0HhyP6fa4l_DJEeQ7bsG0goiqQ55KBHTn55tbB_9KK3sirJnSeTFwD3zqKzt_oGtD4owZZ5LfL0NEb28QeJeJwR8UR1LKu_WFL4l4TyXG3J9ThrHj2xiwu_1cDLp1nqvPozMXGybnVOofMfR4nfaUxUyGbjEHBjN61nsIt3D8_VK_3TZuz?width=2728&amp;height=1519&amp;cropmode=none" alt="coggle.png" title="RUNOOB"></li>
</ol>
<hr>
</li>
<li>
<p><strong>流程圖</strong> : <u><a href="https://www.diagrams.net/">Diagram</a></u></p>
<ul>
<li><strong>Diagram</strong>
<ol>
<li>可與google雲端整合，也可共編</li>
<li>釐清程式邏輯順序或架構好用(我覺得啦)</li>
<li>缺點是我後期很少使用，因為我變懶了…，但在一開始確實幫助不少<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mYgX9RMMGIobacfZ38FjqtbUkMn9FsRTycTrfWIpisvTwtivy2XZggSR3EjE9ujoc_RHDIRN_cg3z-63Md0F4xsgpWjLtdwxCs7yr3q1TI6o16I9bV2VSKw5rF-p0OwkNuZ0ueesuG8WclWX0AzWnzM3iqv8USR-gqdjPPou-WYuMJOvjdn7ep0ISlzDhWAEJ?width=2705&amp;height=1517&amp;cropmode=none" alt="draw.io"></li>
</ol>
</li>
</ul>
<hr>
</li>
<li>
<p><strong>Excel</strong><br>
條列整理文件或交付事項</p>
<ul>
<li><strong>Google Excel</strong><br>
以&quot;加入音效到遊戲&quot;這件事為例<br>
與幫忙的組員寫清楚規則，檔案規範、用途等等，加速彼此的效率。<br>
<font color=#FF0000> <code>這個見仁見智^^ </code></font><br>
<img data-src="https://chi01pap001files.storage.live.com/y4m-zTcPiKrGUr0_8QqtNeDnkW407YWkCp-iOrL9nwJcFBr2LhD1xfgYNSdhXM9n-SdcXuhpIqVWUQpjChuXTfwa-j2gY1P39AkeAtTO6uls83zOFIxgY6hvPg2QLnFJ7sstNtPJYAsygOp5oKLMMLSxMX9QN7BorimhbOT_wF80MMwwVuGo9JqIqug0V585h8m?width=2711&amp;height=1507&amp;cropmode=none" alt="googleExcel.png"></li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li>
<p><a href="https://trello.com/zh-Hant"><strong>Trello</strong></a><br>
清單管理，除了一般瑣碎的事，寫程式checklist非常好用<br>
一定要配開發時使用，當有問題不能當下解決紀錄就不會忘記了<br>
每一個LIST都還能再細寫更多東西，也能團隊共同管理使用。<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mnqXqhpGYU0GU7j_M-eNzyAz7SLC6gSLfvcU4Np2J8Ca_bJ3Gf8ChjSXOwviwoJaJsgSGsJZM7y0CSCsYDunoUVWfGWwFdt7x61T45BYcF2fvXBwhHpI3KZNip13ae5xHZlVYKDGA2qm71gNcDy-6uzKg53g42_prkJTHdOvDeZjaPJ5oo50iqSt6E239NEZm?width=2732&amp;height=1751&amp;cropmode=none" alt="Trello.png"></p>
<hr>
</li>
<li>
<p><a href="https://www.notion.so/product?fredir=1"><strong>Notion</strong></a><br>
我們團隊有拿來管理使用，但效果不佳，大概是新軟體不太適應。<br>
但這個功能很多，我通常會拿來寫學習筆記之類的紀錄<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mQsK7Du13b6XsXKXFwW-8NI-gXSCyzmrmtzkxBu791sAWQs5domiCmdDBw2-Sw5TCMqirK85llxH9o2AjMKAV4qgPc1Qo2EbnbyTtqUwus4y0vvBXTRolGYuKXUtM8i9V3o9_XAUMSTWVCJBYI0ZDfP1YSmWAk6MIwNM1kIQXSL0wsWGiGI45zux-1q3JhLfC?width=2720&amp;height=1738&amp;cropmode=none" alt="Notion.png"></p>
<hr>
</li>
<li>
<p><strong>Teams</strong><br>
你懂得，大家不見得窩在一起做，這時候需要及時討論的工具<br>
大家都熟的很就不貼了，可以使用裡面的whiteboard<br>
每個人都可以進行即時的畫面討論，在白板上畫圖溝通<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mTNZnfCLxG2SeK8w3pqa3Ks0J5BfNAr7c-0V7eb09ujKkShZi9UZ1JipLBlSxuWfJaf7HYW9LEqV4PXyXh1NN_9YzsfWF-wnWQ0-iBY0rnON-z2kw54UQ5GQcXf37p5VpuQoVeMpyplY_UkuQpXLYgDuof_LEObmcNXi3kIBnxM-PkQus94PjrkivLfOYkcFE?width=2413&amp;height=1526&amp;cropmode=none" alt="Teams.png"></p>
<hr>
<p>如果你覺得不好用也可以統一整合使用Google 的產品</p>
<ul>
<li>
<p><strong><a href="https://jamboard.google.com/u/0/">Google Jamboard</a></strong><br>
以前曾在修APP課堂時，因為真的都太難了😥，我創來課後作業討論<br>
很推便利貼，老師們最愛的那一味。<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mJWII5EapwwyxJb5NL2PWExyGzoxTbLR09J1m-rw7WvuEkjHTRbHF6p9qMFfBEdXZ-2MojI1fq9jnPm4SvLWQFmYrSNeWLImZLKpVsftIs2ltZIC7ZcmocbqKDHAjGnppV36rW81tR5R5VsfE5qoSH7SV7qTNiJMAeBceb1J6urCXdMbI0LGcNuUTz1_IcvdR?width=2736&amp;height=1510&amp;cropmode=none" alt="google Jamboard.png"></p>
<hr>
</li>
</ul>
</li>
<li>
<p><strong>Visual Studio Code</strong><br>
寫code的好朋友👯‍♀️，Extension 裝一裝非常好用。<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mWWAZ2a5ZYDZM9BDrvvBYx04ee8joAsfFALh9AtPl3pu_YICmUIbEeBY95KivST82H8__ZQVSpwH53Qu7PV02VOGvpmmZ5baW4hR8p2XGV4jyHxW2m3JMcprETT-aGDTq0M8jMaqMWv9RGhxx9rKILB1ZdxOrpP0blH1_f81PNs28FLwW28fB88PoE8HHjmQJ?width=2736&amp;height=1762&amp;cropmode=none" alt="vscode.png"></p>
<p><strong>Extension必裝</strong><br>
如果你是負責 <code>**網頁**</code> :  Live Sever(網站更動即時瀏覽) ，也可參考<u><a href="https://hackmd.io/@TSweb/Bkyx5zY94"><strong>這篇</strong></a></u><br>
如果你是負責<code>**Unity**</code> : 請參考<u><a href="https://medium.com/@walkerwalker427/unity-%E7%94%A8vscode%E9%96%8B%E7%99%BCunity3d-491a87a8b880">這篇</a></u><br>
(大概step5就差不多了)</p>
</li>
</ol>
<blockquote>
<p>我說那個Unity 會叫你裝的 Visual Studios呢?</p>
</blockquote>
<p>VScode小巧方便、開啟快速，我用過後就回不去了，但我個人建議以習慣的就好。</p>
<hr>
<h2 id="結語-4">結語</h2>
<blockquote>
<p><strong>工欲善其事，必先利其器。</strong></p>
</blockquote>
<p>你我都懂，結合應用才是考驗的開始。<br>
以上這些是我用過還不錯的資源與工具<br>
如果你本身有愛用的，就用舊愛就好，以免要適應一段時間。<br>
謝謝你閱讀完，希望能幫助每一個點開的人。<br>
我並不是一個特別厲害的人。單純熱愛分享而已。</p>
]]></content>
      <categories>
        <category>2021</category>
        <category>05</category>
      </categories>
      <tags>
        <tag>畢業專題</tag>
      </tags>
  </entry>
  <entry>
    <title>紀錄 | HEXO 一起來做部落格(I)</title>
    <url>/2021/07/07/Hexo-BuildBloger-I.html</url>
    <content><![CDATA[<h2 id="前言-33">前言</h2>
<p>每次在學習新的概念，都會忘記零碎的步驟<br>
想說還是來架個網頁來記錄好了</p>
<p>雖然我自己有在Notion 紀錄前端、動畫以及Unity等等的學習文<br>
但很常忘記更新，很多都東西做完文章卻寫到一半<br>
不得不說寫文章還蠻…累人的，很常想寫成「大家覺得很棒的文」</p>
<p>這樣不行!寫文章成了有點痛苦的事，寫的時間也加倍，就變教材了<br>
於是辦了一個專頁「經營」，像跟大家紀錄分享心得這樣<br>
當然，滑FB我可是不會錯過的，經營也會讓大家像在監督一樣，就決定做了!</p>
<p>另外也是受到 <a href="https://hulitw.medium.com/blog-e7a23a74ae2b"><strong>Huli 大大的文章</strong></a>啟發，才下定決心認真做</p>
<blockquote>
<p>對阿，寫文章即使是廢文也沒關係，我的文章又沒有多少人會看，自己看得懂就好</p>
</blockquote>
<p>在那之前有想過用 Blogspot 、Notion、HackMD…等等的<br>
但想想自己想成為一個 Junior Web Developer<br>
就還是想自己打指令來架XD</p>
<p>很常看技術文的時候<br>
一直看到同個版面的主題，一度讓我以為是X角學院的架網站作業<br>
結果是Hexo，查一查才知道這東西有多好用<br>
啊~沒錯就是那個 NEXT 主題，很好看，我也很想架一個<br>
說來就來吧!</p>
<h2 id="環境建置">環境建置</h2>
<p>我是使用 <code>Window 10 + Visual Studio Code</code> 來建置哦!<br>
簡單來說是 使用 <code>git + Hexo</code> 來架架構<br>
最後使用 <code>github pages</code> 來做網站發布的地方</p>
<blockquote>
<p><a href="https://hexo.io/zh-tw/">官方 Hexo 安裝文件</a></p>
</blockquote>
<ol>
<li>需要下載 node.js 因為Hexo 是基於Node.js 的網誌框架<br>
版本選LTS 長期維護的版本就可以了，除非有要用到很新的功能
<ul>
<li><a href="https://nodejs.org/en/">Node.js</a></li>
</ul>
</li>
<li>下載git，拿來做專案上的版本控制，至於git嘛…還在學
<ul>
<li><a href="https://git-scm.com/downloads">Downloads</a></li>
</ul>
</li>
</ol>
<p>原本我先創建好資料夾在Visual Studio開始步驟<br>
確認npm、node 版本</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm <span class="literal">-v</span></span><br><span class="line">node <span class="literal">-v</span></span><br></pre></td></tr></table></figure>
<ul>
<li>v 是<code>version</code></li>
</ul>
<p>官方有說建議使用 Node.js 10.0 及以上版本</p>
<blockquote>
<p>安裝Hexo</p>
</blockquote>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">npm install hexo-<span class="keyword">cli</span> -g</span><br></pre></td></tr></table></figure>
<p>挖咧，第一個安裝就遇到問題<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mCxHVbujSFcMehB-U5KPzs--xmlmuYVVZe2pMyTZSft1rncg9MkzMxxEosNX3BuTX2KnWZ9fs3KOT_aS8Gv8d92vR79PvIFdkSQIq8LBBvUSFulofH9OmU8rtEPfEenW5qP1eVPwXf3ij67XR3qSEkl85Kn-iTyrBbx1vCJrrxlcvGY9P-nEUuOQjzGriSrSA?width=660&amp;height=139&amp;cropmode=none" alt=""><br>
爬了一小時的文也無解阿…<br>
網路上都說 WARN 是沒關係的<br>
參考<a href="https://github.com/hexojs/hexo/issues?q=npm+WARN+optional+SKIPPING+OPTIONAL+DEPENDENCY%3A+fsevents%40%7E2.3.2">官方issue</a>這邊的三篇文還是無解<br>
像是 <code>fsevents</code> 是 Mac使用上要注意的點，Window可以忽略<br>
到這步是已經完成安裝了才對，像是輸入 <code>hexo -v</code> 應該能看到hexo的版本<br>
但當我查詢 Hexo 的版本來確定是否安裝了<br>
結果還是悲劇QQ</p>
<p>於是我決定重新安裝node.js，按照巴哈這篇的指示去做<br>
<a href="https://home.gamer.com.tw/creationDetail.php?sn=4849277">【教學】10分鐘內從安裝Hexo到佈署至GitHub Pages - 巴哈姆特</a><br>
唉呦!蠻成功的哦 ! 不過過程還是有一些奇怪的錯誤QQ<br>
以下是我的紀錄</p>
<h2 id="安裝">安裝</h2>
<p>安裝完環境後在想要建立檔案夾的地方案右鍵<br>
按 Git Bash here ，要開始長專案的地方了<br>
接著會打開cmd</p>
<p><img data-src="https://chi01pap001files.storage.live.com/y4mIK9wCuNQwZ0zJMHkou9hRVyXWh28JoKBA-1bZ6FcLDaKkUPDeGBpyQdYuH7VsvRi8nhD8WVovBSyTOKR2vGocFQviA6ShMudM1SNTyUeWmn4tvzaCQrqA_9XZkZU6RyLDkXxW-xtFuoacHlZydEqGzsdwsosj-3VDki_KfPysUZuSuBYT5f7KiXGRzy4LccO?width=380&amp;height=477&amp;cropmode=none" alt=""></p>
<ol>
<li>輸入 <code>npm install hexo-cli -g</code> 安裝hexo</li>
<li><code>hexo init **自訂義資料夾名稱**</code> hexo建置的設定</li>
<li><code>cd **資料夾名稱**</code> 移到剛剛指定的資料夾，記得cd前是在資料夾外部，要設定的東西要移到裡面哦!</li>
<li><code>npm install</code> npm檔案建立</li>
<li><code>hexo g</code> 建立網頁，這是 <code>hexo generate</code> 的縮寫，大致來說就是收集/重構</li>
</ol>
<p><img data-src="https://chi01pap001files.storage.live.com/y4m7NCCI1fphAc3k5NKaTmP41Iby0YB-h5Cbn-SwSnTImTZZTJAXyCTjmzq_CzVAaFfJLche0TAe2N1b2iDmjbLYdY5oNFGpThho_rkUOhEv6klUo9MtSGnbbFRuvSN4SM8lCcFRK8VgKkLtWDq5ZRCsl80U_tA2pgHfnSP2rcbFDcrqLekv2DOaaWDWdWX_IxP?width=256&amp;height=143&amp;cropmode=none" alt=""><br>
有一個大大的NEXT 可以忽略，因為我已經偷去安裝NEXT主題XD<br>
一開始沒有是正常的哦!</p>
<ol start="6">
<li><code>hexo s</code> 建立伺服器，這是  <code>hexo server</code> 的縮寫，會開啟本機伺服器來測試哦!</li>
</ol>
<p><img data-src="https://chi01pap001files.storage.live.com/y4mycn74k2IMLb1w2uZqoidTS7ipFDmgX_9nGZ-2GL_7L8jfiX0em-cxLBDOu8YCbDrJVCfYn8Xjk6tHvjv8RV8QM09oQx1kStTjZaxi8lcVmolKGkM-pIN5TcDc3g1oNKLsFuH282XlaWq2rx7xlnBL7Esif-E6eXPZOmDoFXzRslmIlhzdmFzNUJtN_jjV2po?width=256&amp;height=126&amp;cropmode=none" alt=""></p>
<p>之後它會寫出 <a href="http://localhost:4000">localhost:4000</a><br>
在網址中輸入<code>localhost:4000</code>就可以看到原始設定好的網站<br>
哈哈我設定的太多看不出來原本的，之後還會設定相關的布局。<br>
最簡單的長出網站就完成了<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mCBYZSy_5x5ydLOC4xpxPk09WVHkKiY1buv_Qa5pOl3SoFu0g_9VBg6nQ3gc-q53DUu1dE6sSWMz71miCQZX1u0W7M-YoSTICiWD4HEkJvAEcdPq37uv-XwmdrZQz059IYZgPocbyyWRz_JEDLe_qHI9_WcB2M6HDAAZXsOot7S1trnAuWdche5gN_C9DNs5n?width=660&amp;height=425&amp;cropmode=none" alt=""><br>
最後是要發布在github pages 上，這等下一篇在來說明吧!</p>
<h2 id="遇到技術排解ing">遇到技術排解ing</h2>
<p>中途還是有遇到一些問題，雖然在 git 的cmd裡沒問題<br>
但在Visual Studio 中的 powershell 輸入指令卻不能用😵<br>
明明安裝hexo成功了卻不能在VS編輯使用指令…</p>
<p><img data-src="https://chi01pap001files.storage.live.com/y4mtLrJFmWIviARn_idGlEGScnJlDZW4X9uIenTO3iDKoj9MRUcB73XwcF8mDojM8sQ6Pa-FltKSD9VC7mQM__GWt1acgomR4armP7ink0UX67mCelMg4t79T8z2KRrcyjEneSwGENJ6w87c7CuV5wOkip17Ou_4MLn7XElvmHtpdva7bN1_08VbsMA0WOTrzBV?width=660&amp;height=115&amp;cropmode=none" alt=""></p>
<p>原因是Window 因安全性的問題，而開啟的一個機制<br>
又稱「限制原則」，要打開的話就需要開啟權限來設定</p>
<p>這邊的解決方法 : <code>Set-ExecutionPolicy</code> 更細節的設定資訊可以看參考資料</p>
<p><img data-src="https://chi01pap001files.storage.live.com/y4m0d30xMqYQ4AGiWx9HRjiCsP3xrKm11lqIZVUC5RgItMt77XCL6eldhygSUot7xrbCC0vLc6cMvQU2qtW2FKUHQ8eFajj_Hg3goYS5BUVrJE1R1v9d-UDbCRV-OZobhz5LNUdA83Yz918yvHotQf4gJgOnZalgXgxfxUEaoigtBMoUOErj92GWozOti0UpPS7?width=1024&amp;height=439&amp;cropmode=none" alt=""></p>
<p>啊…結果權限不夠QQ，因此要用**「系統管理員」**執行哦!<br>
不過紅字第三行有提到，請執行<code>Set-ExecutionPolicy -Scope CurrentUser</code></p>
<blockquote>
<p>我的理解是<br>
如果妳現在登入的使用者是系統管理員的話可以直接使用<br>
基本上我的電腦就是了，不需要再特定開</p>
</blockquote>
<p><img data-src="https://chi01pap001files.storage.live.com/y4mmJ2BZ3aT_LKsge3e5oES5mrHnK_IBEo2o6a7w7lfGGBwmgHWev35sXk7fMuSqvgnQO5F72YihlbeMVTIAuCEX6z6IjCMSO44FW1OGofu2i5wvRPKzNW6eDnVdAYolnEzxtX6I0o-ikpECKfS2LthdXvFg_R5DU6AnzP1GRztpausnBPEegbI6BGqWDhrdc4I?width=660&amp;height=93&amp;cropmode=none" alt=""></p>
<p>如果再不行就到 <code>開始 &gt; 搜尋 &gt; powershell</code><br>
對著應用程式按右鍵使用系統管理員執行</p>
<p><img data-src="https://chi01pap001files.storage.live.com/y4m-q_Dw7jek9H56ojCPVFlInrzSXG4PNNYgYeHS67nnvUAXn7ehSdBeI0eJmY-ZqlxtVTKkKqWKbGbfyTHJ4yvs-D8r5MJzLeEVsqbIkjYIJXh4AcS6inKRaJR5KOWa1ujEtUOMkLXN2MiQ4CTjVUgE3M3Y3pMMny-qgKkLWm62_Fu3YG_ju2QGOGSOdE9gbJO?width=256&amp;height=103&amp;cropmode=none" alt=""></p>
<p>它會請求輸入值，輸入 <strong><code>RemoteSigned</code></strong><br>
意思是</p>
<blockquote>
<p>同意本機撰寫的腳本檔案，不需要簽署就可以執行<br>
npm install 遠端下載的其它東西經過可信任的發行者簽署後才可以執行。</p>
</blockquote>
<ul>
<li><a href="https://hsiangfeng.github.io/other/20200510/1067127387/">Window安全性 解決的辦法參考資料</a></li>
</ul>
<p>燈愣!<br>
沒想到成功了，可以在VS裡盡情的打了<br>
我想我開啟的方式可能有些錯誤啦…<br>
繞了不少路，這次就當教訓吧</p>
<p>明天就架完成吧!<br>
這篇寫得有點急有點亂，會在進行統整在新的部落格中哦!</p>
]]></content>
      <categories>
        <category>2021</category>
        <category>07</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | 初級入門必學的 CommandLine</title>
    <url>/2021/07/07/LearnAboutCommandLine.html</url>
    <content><![CDATA[<h2 id="前言-34">前言</h2>
<p>人跟人會用語言符碼來溝通<br>
而人要跟電腦溝通，我們會想到</p>
<blockquote>
<p>阿不就用滑鼠?</p>
</blockquote>
<span id="more"></span>  
<p>是阿，現在我們能用滑鼠按左、右鍵<br>
在畫面上操作電腦的動作<br>
都多虧了<code>GUI</code>（圖形操作介面）<br>
降低電腦的使用門檻<br>
讓我們享受電腦帶來得便利</p>
<h2 id="還沒有GUI的時候"><strong>還沒有GUI的時候</strong></h2>
<p>早期沒有GUI的時代，都是使用鍵盤輸入指令來控制<br>
也就是使用「文字指令介面」 <code>Commamd Line Interface</code>簡稱 <code>CLI</code>。<br>
當然這大大提高了使用電腦的門檻<br>
光是指令種類就讓人頭昏眼花<br>
更別提如果像爸媽有點年紀的人想查個資料<br>
還要向查字典一樣<br>
之後每一次執行還要同樣的查字典動作<br>
論誰都會覺得麻煩<br>
接著爸媽不會想弄，只會叫你出來處理<br>
<s>於是你就立志成為工程師了</s></p>
<h2 id="為什麼Command-Line-Interface-依然存在"><strong>為什麼Command Line Interface 依然存在?</strong></h2>
<p>常常在想工程師一定要會CLI嗎? 或許這是個蠢問題。<br>
但我喜歡探究這些問題，對於菜鳥來說理解根源才能信服XD</p>
<h3 id="GUI與CLI差在哪">GUI與CLI差在哪?</h3>
<blockquote>
<p>嚐過GUI難道不香嗎?</p>
</blockquote>
<p>香阿，但是GUI操作你想想看有多少個動作?</p>
<ul>
<li>
<p>以<code>複製</code>A東西到同目錄為例</p>
<ol>
<li>滑鼠移動到指定複製物件</li>
<li>按下右鍵</li>
<li>點選拷貝(copy)</li>
<li>滑鼠移到空白處按下右鍵</li>
<li>點選貼上(paste)</li>
<li>幫複製物件取新名稱</li>
</ol>
</li>
<li>
<p>那CLI操作呢?</p>
<ol>
<li>開啟命令提示字元</li>
<li>鍵盤輸入<code>cp A物件 命名複製物件新名稱</code></li>
<li>done.</li>
</ol>
</li>
</ul>
<p>可能中間安插個去到目錄 cd 一下。</p>
<blockquote>
<p>幾行字，就是這麼簡單</p>
</blockquote>
<p><img data-src="https://truth.bahamut.com.tw/s01/202106/80efcf5f0815fc0b7a2efdacac66b7c1.JPG" alt=""></p>
<p>這邊不討論ctrl C ctrl V 大法</p>
<p>除此之外，光是G<code>(Graphic)</code><br>
圖片帶來的效能消耗讓早期的電腦吃了不少虧<br>
好在現在電腦的效能水平都遠遠足夠<br>
才能讓我們看見把<strong>指令步驟具象化的過程</strong></p>
<p>當然我想GUI與CLI是相輔相成的狀態<br>
誰不想複雜的東西簡單化呢?尤其變成圖片</p>
<h3 id="回到CLI為何還是存在"><strong>回到CLI為何還是存在</strong></h3>
<p>套用老師們最喜歡的一句話 <code>快、狠、準</code><br>
<s>刪除到檔案也<code>快狠準</code>QQ</s><br>
從剛剛的複製例子可以得知<br>
對於效能與呈現，無疑是比較快的<br>
甚至是有些指令只能透過CLI來執行<br>
現在的CLI也是越來越進步<br>
東西好用，當然還存在阿!</p>
<h3 id="對於我來說"><strong>對於我來說</strong></h3>
<p>對我來說，GUI與CLI可以說是像到外國與在地的感覺</p>
<ul>
<li>
<p><strong>GUI</strong><br>
人生地不熟，靠Body language筆劃，或是拿圖片問是最友善的(這邊以你不會當地語言為主)。</p>
</li>
<li>
<p><strong>CLI</strong><br>
你懂我懂的語言，直接講最快。</p>
</li>
</ul>
<p>這也不難解釋，為什麼程式基礎必修要會CLI<br>
溝通，最講求效率:D…</p>
<h2 id="常用的CLI指令"><strong>常用的CLI指令</strong></h2>
<p>阿這好像才是這篇最主要的XD<br>
以前上過Linux的課堂<br>
順便複習與搞懂其他不懂的詞</p>
<h3 id="基礎四招">基礎四招</h3>
<table>
<thead>
<tr>
<th>常用指令</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td>pwd</td>
<td>告訴你現在在哪裡?</td>
</tr>
<tr>
<td>ls</td>
<td>印出現在所在地的所有檔案</td>
</tr>
<tr>
<td>cd</td>
<td>移動到指定的地方</td>
</tr>
<tr>
<td><a href="#mv">mv</a></td>
<td>移動到指定地或是修改指定的檔案名稱</td>
</tr>
</tbody>
</table>
<ul>
<li>註: pwd 在window cmd沒有，用cd 有同效果。</li>
</ul>
<h3 id="快速招式">快速招式</h3>
<blockquote>
<p>個人記到<code>資料夾新增、刪除與複製</code>，感覺就蠻夠用的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>好用指令</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#touch">touch</a></td>
<td>修改檔案時間或是<code>建立新檔案</code></td>
</tr>
<tr>
<td><a href="#rm">rm</a></td>
<td>刪除檔案</td>
</tr>
<tr>
<td>rmdir</td>
<td>刪除指定資料夾</td>
</tr>
<tr>
<td>mkdir</td>
<td>建立資料夾</td>
</tr>
<tr>
<td>cp</td>
<td>複製檔案</td>
</tr>
<tr>
<td>cat</td>
<td>直接讀取檔案內容</td>
</tr>
<tr>
<td><a href="#grep">grep</a></td>
<td>抓取檔案內容中的關鍵字</td>
</tr>
<tr>
<td><a href="#wget">wget</a></td>
<td>下載檔案，後面接檔案的url</td>
</tr>
<tr>
<td>clean</td>
<td>清空目前的指令畫面</td>
</tr>
<tr>
<td>curl</td>
<td>送出 request (ex:api)</td>
</tr>
</tbody>
</table>
<ul>
<li>註: grep、cat、curl 在window cmd沒有效果。</li>
<li>weget、touch 在cmd 與 powershell都沒有效果。</li>
</ul>
<h3 id="參數">參數</h3>
<blockquote>
<p>前面都會加一個小槓槓「-」，兩個的話就和在一起寫<br>
例如 -al -rf</p>
</blockquote>
<table>
<thead>
<tr>
<th>常見指令參數</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td><code>all</code>的意思，包含開頭為<code>.</code>的檔案</td>
</tr>
<tr>
<td>-l</td>
<td><code>list</code>。詳列所有東西，包含權限、屬性、時間</td>
</tr>
<tr>
<td>-f</td>
<td><code>force</code>。 強制執行 <s>(不要亂使用這個參數)</s></td>
</tr>
<tr>
<td>-r</td>
<td>這個資料夾以下的檔案一起包</td>
</tr>
</tbody>
</table>
<h3 id="其他">其他</h3>
<p>因為不知道叫什麼…</p>
<table>
<thead>
<tr>
<th>其他</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#pipe%E7%B5%84%E5%90%88%E6%8A%80">| (pipe)</a></td>
<td>組合技(將輸出給後面的輸入)</td>
</tr>
<tr>
<td><a href="#redirection%E9%87%8D%E6%96%B0%E5%B0%8E%E5%90%91">&gt; (redirection)</a></td>
<td>重新導向，會將檔案內容覆蓋過去</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>跟 &quot; &gt; &quot;概念依樣，但不覆寫，而是加入</td>
</tr>
<tr>
<td>…</td>
<td>代表上一層的位置</td>
</tr>
<tr>
<td>~</td>
<td>使用者的根目錄</td>
</tr>
</tbody>
</table>
<h3 id="快速舉例">快速舉例</h3>
<h4 id="mv">mv</h4>
<ol>
<li>
<p>移動 mv [<strong>檔案</strong>] [<strong>新名稱</strong>]</p>
   <figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">mv `123.txt` `456.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>檔案名稱變 <code>456.txt</code></p>
</blockquote>
</li>
<li>
<p>更名 mv [<strong>檔案</strong>] [<strong>目的地</strong>]</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv `123.txt` `.\Myblog`  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>123.txt 就會在 <code>Myblog</code> 資料夾底下<br>
目的有分成 <strong>絕對路徑</strong> 與 <strong>相對路徑</strong></p>
</blockquote>
</li>
</ol>
<h4 id="touch">touch</h4>
<ol>
<li>
<p>修改時間<br>
EX : folder1 \ 123.txt<br>
上次檔案編輯時間 :  07/27/21 13:00<br>
現在時間 : 14:03</p>
   <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">touch</span> <span class="number">123</span>.txt  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>檔案寫入的編輯時間會變成 <code>07/27/21 14:03</code></p>
</blockquote>
</li>
<li>
<p>建立新檔案<br>
EX: folder1\123.txt</p>
   <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">touch</span> <span class="number">456</span>.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>當找不到該層符合的檔案名，就會建立新檔案<br>
因此在 folder1 輸入<code>ls</code>底下會有<br>
<code>123.txt 與 456.txt</code> 兩個檔案</p>
</blockquote>
</li>
</ol>
<h4 id="rm">rm</h4>
<ol>
<li>刪除檔案<br>
EX: 我想刪除 123.txt。   <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rm</span> <span class="number">123</span>.txt</span><br></pre></td></tr></table></figure>
</li>
<li>刪除資料夾<br>
EX: 我想刪除 blog 資料夾，裡面還有很多檔案<br>
結果<code>rmdir blog</code> 發現行不通，因為<code>資料夾裡面不是空的</code>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -r blog</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>利用<code>-r</code>來選取包含blog資料夾以下的所有子目錄<br>
進行刪除</p>
</blockquote>
<h4 id="grep">grep</h4>
<ul>
<li>尋找關鍵字 grep [<strong>關鍵字</strong>] [<strong>檔案</strong>]<br>
EX: 檔案 <code>123.txt</code> 裡面有 hello world 這行字<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">grep o <span class="number">123</span>.txt  <span class="regexp">//</span> 我想尋找o</span><br></pre></td></tr></table></figure>
<blockquote>
<p>執行後印出 : hell<code>o</code> w<code>o</code>rld  ，這兩個o被highlight起來</p>
</blockquote>
</li>
</ul>
<h4 id="wget">wget</h4>
<ul>
<li>wget [<strong>url</strong>]<br>
EX: 我想下載東西<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget http:<span class="regexp">//</span>www.google.com</span><br></pre></td></tr></table></figure>
<blockquote>
<p>圖片或是原始碼都可以取得</p>
</blockquote>
</li>
</ul>
<h4 id="pipe組合技">pipe組合技</h4>
<ul>
<li>組合技應用<br>
EX: 把blog資料夾裡檔名含有<code>o</code>的檔案印出來<br>
資料夾 blog 含有 hello.txt、hi.txt、row.txt<br>
透過 | 可以將兩者合併成一行<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">ls <span class="regexp">/blog/</span> | <span class="keyword">grep</span> o  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>印出 兩個檔案 ，<code>hello.txt row.txt</code><br>
組合技可以玩串燒，愛串多少串多少~~(?)~~</p>
</blockquote>
</li>
</ul>
<h4 id="redirection重新導向">redirection重新導向</h4>
<ol>
<li>覆蓋寫入<br>
EX : 123.txt 檔案裡有 <code>hello</code>文字，改成bye<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">echo byebye &gt; <span class="number">123</span><span class="selector-class">.txt</span></span><br><span class="line">cat <span class="number">123</span><span class="selector-class">.txt</span> <span class="comment">// 查看一下印出 </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>123.txt 裡面的文字是 <code>byebye</code></p>
</blockquote>
</li>
<li>增加寫入<br>
EX : 123.txt 檔案裡有 <code>hello</code>文字，加入bye <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">echo byebye &gt;&gt; <span class="number">123</span><span class="selector-class">.txt</span></span><br><span class="line">cat <span class="number">123</span><span class="selector-class">.txt</span> <span class="comment">// 查看一下印出 </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>123.txt 裡面的文字是 <code>hello byebye</code></p>
</blockquote>
</li>
</ol>
<h2 id="結語-5">結語</h2>
<p>Linux 跟 Window 內建的指令有點不太一樣<br>
先知道指令的用法我覺得是件好事<br>
前期底子打的越深，銜接上較無痛。<br>
GOGO ! 往更深的坑前進</p>
<p>如果我有寫錯的地方歡迎在下面留言指教<br>
新手多多包涵</p>
]]></content>
      <categories>
        <category>2021</category>
        <category>07</category>
      </categories>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>紀錄 | HEXO 一起來做部落格(III)</title>
    <url>/2021/07/07/Hexo-BuildBloger-III.html</url>
    <content><![CDATA[<h2 id="前言-35">前言</h2>
<p>呼!建置的差不多了<br>
原本要總結研究 Hexo 三天的成果<br>
寫成比較順暢的建構過程<br>
結果一弄又更新好多東西…<br>
一樣先來補齊概念吧!<br>
月底再來一個大總結&gt;&lt;</p>
<hr>
<h2 id="資料結構">資料結構</h2>
<pre><code>+Blogger 
|- .github
|- .vscode
|- .node_modules  
|- .scaffolds
    |- draft.md
    |- page.md
    |- post.md
|- .source
    |- _drafts
    |- _posts
    |- 其他頁面(略)
|- .themes
    |- next
        |- (略)
        |- languages
        |- layout
        |- (略)
|- _config.next.yml
|- _config.yml
|- package.json
+  

</code></pre>
<p>這邊我僅有挑我有用到的幾個</p>
<blockquote>
<p>最外層</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>資料夾名稱</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>.node_modules</td>
<td>npm原始設定(不常用)</td>
</tr>
<tr>
<td>.scaffolds</td>
<td>文章狀態模板 (可以修訂統一模板)</td>
</tr>
<tr>
<td>.public</td>
<td>發布自動後生成的資料夾 (不用動)</td>
</tr>
<tr>
<td>.source</td>
<td>部落格編輯(文字都在這編輯)</td>
</tr>
<tr>
<td>.themes</td>
<td>編輯主題樣式(相關 css )</td>
</tr>
<tr>
<td>._config.next.yml</td>
<td>next 安裝設定檔，多是插件</td>
</tr>
<tr>
<td>._config.yml</td>
<td>hexo 安裝設定檔</td>
</tr>
<tr>
<td>.package.json</td>
<td>專案的設定檔，會寫安裝什麼東西(基本上不用動)</td>
</tr>
</tbody>
</table>
<blockquote>
<blockquote>
<p>. scaffolds</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th><strong>資料夾名稱</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>_drafts</td>
<td>草稿模板</td>
</tr>
<tr>
<td>page .md</td>
<td>頁面模板</td>
</tr>
<tr>
<td>post .md</td>
<td>文章模板</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>指令快速記!</p>
<pre><code class="language-cmd">hexo new draft 文章名稱  //建立一篇草稿  
hexo new post 文章名稱  //建立一篇新文章  
hexo new page 頁面名稱 //建立一篇新頁面，同時source 會建立新的資料夾  
hexo publish 版面 檔案名稱 // 發布(草稿)  
</code></pre>
</li>
</ul>
<blockquote>
<blockquote>
<p>. source</p>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th><strong>資料夾名稱</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>_drafts</td>
<td>草稿會在這</td>
</tr>
<tr>
<td>_posts</td>
<td>發布的貼文都會在這</td>
</tr>
<tr>
<td>其他頁面資料夾</td>
<td>像是About、tags、categroies…</td>
</tr>
</tbody>
</table>
<p>因為一開始沒有About等等的基礎頁面，自己要新增</p>
<pre><code class="language-cmd">  hexo new page About  
  hexo new page tags 
  hexo new page categroies 
</code></pre>
<p>然後新頁面新增 <code>type</code> 來做頁面記號<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mUs5S3stfFRMyDXC2wenjxmYnUyrrWZLN195KoJDuBNbjDIUXcIHbvzGlPGiUiyTgjwNaoLwYAM6i881mLxbBrFsfqBSUm0CSwtIWpIcZ8psQgmom42pugcn98p5OsSHq8t7JU1GKO7NotQ-nqR1teCP-h9lS_J3AZkoZWgJ-o7187LBZXhCtg7x2BWH8ou9t?width=865&amp;height=303&amp;cropmode=none" alt="categroies_type"><br>
這頁是分類，跟設定檔的地方對應哦! 頁面 - 路徑<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mSHJlXGuxGrOywWFqkyu391Exl7Z_yJrwNUwZTN56tV5LPXobIEudNoPFKamiALfWJe9NbCEJmdI2PLekXQ5b67LgUGmQurJ8LEta7IHg3crrFvX8YfLeVZ-zTllPrB9b88o6RngYO2tbAoyjmtBFF1Fq5YxN-BnGO1Q-4DaX4Lt8H4X_apXvACFiKuR515oO?width=715&amp;height=1510&amp;cropmode=none" alt="路徑"></p>
<blockquote>
<blockquote>
<p>. themes - .next (依照主題去分資料夾)</p>
</blockquote>
</blockquote>
<p>如果 theme 沒有跑出 next 的資料夾，可以用git 的方式 clone 一下<br>
<u><a href="https://github.com/theme-next/hexo-theme-next">官方教學 底加</a></u></p>
<pre><code class="language-cmd">    git clone https://github.com/theme-next/hexo-theme-next themes/next  
</code></pre>
<p>之後我就GG了，因為 NEXT 主題更新蠻快的，導致一些語法或函式沒統一更新到，最近的是8.0版<br>
網路上layout檔是 <code>.swig</code> ，我的是<code>.njk</code><br>
我問號了起來，不過還好語法上差不了多少<br>
但在 <code>hexo g</code> 會報錯，主要是<code>load</code>的函式要更新用法</p>
<p>會顯示 <code>yml.safeload</code> 用法過時，必須改成 <code>yml.load</code><br>
最快速的方法就是</p>
<pre><code class="language-js">1. 專案的搜尋欄打 safeload  
2. 找到 `vendors.js` 
3. 尋找 `yml.safeload`
4. const dependencies = yaml.safeLoad(vendorsFile); //這行改成下面這個
5. const dependencies = yaml.load(vendorsFile);
</code></pre>
<p>這樣就能重構，在 <code>hexo s</code> 一下看看是不是有跑出頁面<br>
當然嫌麻煩還可以裝指定版本<br>
<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/INSTALLATION.md">官方教學</a></p>
<table>
<thead>
<tr>
<th><strong>資料夾名稱</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>languages</td>
<td>語言對應字</td>
</tr>
<tr>
<td>layout</td>
<td>調整看到的版面 基底</td>
</tr>
<tr>
<td>source</td>
<td>一些css js image 設定在這(跟外層的source不一樣)</td>
</tr>
</tbody>
</table>
<ul>
<li>theme 中的 source 主要掌管 next 主題的樣式而已</li>
<li>外層的 source 是 hexo 架構的編輯地方<br>
兩者有差哦!</li>
</ul>
<h3 id="語言設定">語言設定</h3>
<p>languages 預設原本是 <code>en</code>，從 <code>_config_yml</code> 就可以更改語系<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mGt3P_ahV1z8j1pRbpVUp8wSl6nBkqs_kpfNhZB32cMMkamaJhe70pZkqoosmLUiVaElphRPcWkvde5dQfOYASoAYIJbirgBTXzcpY8xkx7ARrrtFFRjvMQarZpJv2ANNm-XSosQEGoq0d6s9n9kv55XqPeEOrHtWGChQkJAL-o4AMO-xc_Z-p5a2MWic6Gow?width=1223&amp;height=410&amp;cropmode=none" alt="lang-setting"></p>
<p>當然網頁可以寫成多國語，待研究XDD，可以的話想寫成英文<br>
有些翻譯過來的文字可能不太喜歡，或是想 自訂義<br>
就可以到 theme 字料夾中的 languages 找 zh-TW<br>
把想要的文字替代上去哦!<br>
<img data-src="https://chi01pap001files.storage.live.com/y4ma1tCvNxVMoUCdcaPYcIjlNvLRelGj3E1tbBnrI3EAXwnLvIoNp4JrjYMC7GYuWjeVhYRVFf6f0sNhPWNlDqWsTsGS8HvaqjBDyLj49cWpdfBJ9Bl0GiCJOfmCwBAxlbVdIawagjcA9XlFdu2B43oKb_6ZveVwqdQsVsKjjtjd9zUQRkYqJIBu7AIpFGaQKnd?width=1004&amp;height=1512&amp;cropmode=none" alt="lang-word"></p>
<h3 id="版面設定">版面設定</h3>
<p>layout 有很多頁面設定，包含第三方外掛都可以設定外觀等等的<br>
當然也有 css或js 可以設定，在 source 資料夾裡，基本的換色、背景圖片都可以自訂。</p>
<hr>
<h2 id="調整樣式-外觀">調整樣式&amp;外觀</h2>
<p>next 的 <code>config.yml</code> 可以開啟 comment 的功能<br>
因為我裝了disqus留言版，結果發現 next 主題在tags、categroies等等頁面都是套 post 的板<br>
也就是 post 每一則下方有留言區是正常的<br>
但誰會在<code>標籤</code>跟<code>分類</code>或是<code>關於我</code> 底下讓人留言啦!</p>
<p>就要修改 <code>theme &gt; next &gt; layout &gt; _layout.njk</code><br>
其實可以發現 page 的版面 都用同一個 layout<br>
所以在 <code>new page</code> 或<code>new post</code> 下方都會有comment(如果妳有打開的話)</p>
<p>打開 <code>_layout.njk</code>，找到下面這行</p>
<pre><code>  &#123;% include '_partials/comments.njk' %&#125;
</code></pre>
<p>來把它加上if-else條件，判斷哪一頁加入comment<br>
改成 :</p>
<pre><code class="language-js">&#123;% set page_type = page.type === 'tags' or page.type === 'categories' %&#125;
&lt;div style=&quot;&#123;%if page_type %&#125; visibility:hidden; height:0px;&#123;% endif %&#125;&quot;&gt;
&#123;% include '_partials/comments.njk' %&#125;  
</code></pre>
<p>原本我是看這篇<a href="https://hsiangfeng.github.io/hexo/20190516/2710757554/">文章教學</a><br>
結果不行，因為版本問題，layout檔再也不是<code>.swig</code><br>
還好語法上還能通，只有平常在寫得 <code>||</code> 要改成 <code>or</code></p>
<hr>
<h2 id="好用的寫文插件">好用的寫文插件</h2>
<p>上一篇有提到 hexo 有的後台頁面<br>
哦~我的天，markdown 雖然能馬上看見效果<br>
但實際版面跟輸出後的差異蠻多的<br>
後來我還是在 VS 上做編輯了<br>
當然是來安裝個插件XD</p>
<ol>
<li>VS 的插件商店搜尋 <code>Markdown Preview Enhanced</code></li>
<li>安裝</li>
<li>新增一個 post 看看 <code>hexo new post a123</code></li>
<li>開啟檔案對著它按右鍵，選 <code>Reopen Editor with ...</code><br>
<img data-src="https://chi01pap001files.storage.live.com/y4m5e44Li2JyNG7g5TuAltJILiqeBueOK15DFGll5OZ4uHTS58Bu68ngUQGhBM_987DVWt6su774wdyt-a-BiUKqHX0W9AC1ohAq2SoRQRPnZBSqs-T4-xq8aQCr4Zc48fQWmdmhOYZJ_t9SIJbtk8GUHPxwB5cqSpBiWpbVmYtnbZp2Epk5FhS_pFPi9yikSaA?width=2736&amp;height=1824&amp;cropmode=none" alt="圖示"></li>
<li>上面會跳出選擇器，選<code>markdown preview</code></li>
<li>在點這個開啟內分頁<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mD3vUlN6kw2OxydnmAU1ZhFwb8pUd-ya_RTwIDBiggyqM-HXup_763uqZsG3yDfqWMcjYw2GStohPK4f88s0gSmDTD8yK5vvJVV2gO2cat_AzjyjpL_m4XutuM6hXy4AmQq1cjGdYQZkGEDo161pc8Ir8UZhMMlx4ZSdMyNLyRmRp98rCHT1QNNQIXq9-Y2S1?width=1423&amp;height=401&amp;cropmode=none" alt="內分頁"></li>
<li>在開一次原檔案在分頁中，就可以準備來編輯囉!</li>
</ol>
<p>燈愣! 就變這樣，邊寫可以邊看到效果 :happy:<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mRvRQYFuUfq-zmPn2p99ZdGCFN6dBqQaGcm4gMBtYN-O6M9Oz01zGE_OL_KFQ3aG14pD7aiNcIAFH4JOi61XP8uoGLyxx5Jo0Ux7VLu8umfff5TIp1v-P7lriTZcDEOGO39yKM195CeZwH6ApqOLjfWRZ2zskQSp8ZOUZRT6qM5k6DS_UOMGa8hze41xI1iKh?width=2600&amp;height=1615&amp;cropmode=none" alt="寫文好幫手"></p>
<h2 id="結語-6">結語</h2>
<p>網站建置的差不多了<br>
短時間應該沒有要再美化<br>
要多努力寫文章<br>
markdown 還在學習中…</p>
<p>經過三日連發<br>
這類實作文章應該就沒有每天產了<br>
改成2-3天發布一篇<br>
不然感覺每天都再搭特快車<br>
再抓一下什麼樣的寫法才好吸收</p>
<p>最近有看到一種寫文章的方式<br>
是時候來增強寫作技巧  XD</p>
]]></content>
      <categories>
        <category>2021</category>
        <category>07</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>紀錄 | Unity ─ UI Navigation 尋找不見的按鈕</title>
    <url>/2021/07/07/Navgation.html</url>
    <content><![CDATA[<p><img data-src="https://i.imgur.com/Vz6RmrN.png" alt=""></p>
<span id="more"></span>
<h2 id="前言-36">前言</h2>
<p>最近在做Unity + Fungus 小遊戲<br>
發現 Fungus 裡的 Menu 選項不斷的亂跳<br>
一直找不到問題，還找去原始碼…<br>
想說是不是 Fungus 腳本有衝突<br>
才知道自己連 Unity 的介面功能沒有到很熟<br>
紀錄一下:D</p>
<h2 id="控制-Fungus-Menu-選項">控制 Fungus Menu 選項</h2>
<p>Fungus 內建的Menu 可以新增很多個選項<br>
並且有不同的分支可以讓對話更加多元<br>
在控制時可以使用滑鼠與鍵盤上下左右鍵操作<br>
能使用鍵盤控制是來自UI物件上的Navigation(導航)<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mYWPYxomKMTvK8NkXSc7wGnefboAs8DPi3XzwVpZlIO3b-Rndt8PKkmqQuDSmVqQnyv6XgAlkRyy2Tiasz_D_rZlIFtDQtyjAwOr31k2Ye_2_2tN8zBbZcSpagvbipBpnPJqTEe_lUHlsti2r_hIdylS477eT9LurYr1TNFzZi2KUjf0JaPHb7Kx0Tfap5j1z?width=660&amp;height=477&amp;cropmode=none" alt=""></p>
<p>更往前想一點<br>
那腳本是如何跟物件來互動的呢?<br>
UI 能進行互動是來自 Unity 的 Event System<br>
很常時候會看到腳本最上層掛這一個</p>
<ul>
<li><code>using UnityEngine.EventSystem</code></li>
</ul>
<p>使我們可以在腳本中控制UI物件的事件<br>
可以偵測<code>誰被按了?</code>、<code>誰被選擇了?</code> 等等的。</p>
<h2 id="Event-System">Event System</h2>
<p>一開始新增Canvas 或 UI 物件時<br>
Unity 會幫我們自動生成 Event System 這個物件<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mKFqurQ2X7h0jJ3Frd1kPO8ipgXgBIIrqYrRtGiNY4C1piCm1NuKKjM9AO3Nqagj6DyNOs6GXStvOutfie-uffMZUMLR4sDoJwm6q3zlfz6vEnl3N1xhZKZe8dvH-Fib6_OG9Qi1OBKnIYbGVpmIIZV5P8YyjuQRw0gVeTucDuK2rV5AV6EOYeUHRjTagVWbr?width=256&amp;height=166&amp;cropmode=none" alt=""></p>
<p>仔細看一下有兩個腳本附在上面<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mST6rqopQUEi6t6yz5eNJ6zUrND4Ljt8vOQMFh1c984h-H30bdnD4CLygkpxsGyfEOF1XORmpkFiplC5dVAk41QD3LsU7qGOsXDTdEDu65Ao_zDfCBb2QBIZoWzLProM1iVsYgR6ber8xbKpLo4wXY9oZg6JRTbUGa9J5cW3tJajUOJi7Bef-3ZGLu7IVozQa?width=468&amp;height=660&amp;cropmode=none" alt=""><br>
分別是 <code>Event system</code> 與 <code>Standalone Input Moudle</code></p>
<table>
<thead>
<tr>
<th>腳本名稱</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Event system</td>
<td>處理UI物件狀態，像是button 中的滑入、滑出、點擊、拖曳等等</td>
</tr>
<tr>
<td>Standalone Input Moudle</td>
<td>像是鍵盤或搖桿的輸入控制</td>
</tr>
</tbody>
</table>
<p>這次先專注於 Event system 腳本上<br>
以下的三個設定</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td>First Selected</td>
<td>預設被選定的UI物件</td>
</tr>
<tr>
<td>Send Navigation Event</td>
<td>是否開啟UI導航功能</td>
</tr>
<tr>
<td>Drag Threshold</td>
<td>拖曳事件靈敏度</td>
</tr>
</tbody>
</table>
<p>在我的專案中，遊戲操作皆來自鍵盤<br>
因此需要使用到UI導航功能</p>
<h2 id="遇到的問題">遇到的問題</h2>
<p>只有三個選項，卻會超出選項格外<br>
<img data-src="https://i.imgur.com/v0hC0wV.gif" alt=""><br>
甚至按不回來，由動圖可知選項超出後<br>
不知道選到了誰</p>
<h3 id="問題解決">問題解決</h3>
<p>提到 Navigation，一般設定為 <code>auto</code><br>
也就是按上下左右鍵會分別對應按鈕的位置<br>
如果有多個按鈕都是設<code>auto</code>就會發生我這樣的事情<br>
除了auto外，也有其他的方式</p>
<ul>
<li>none 不被導航影響</li>
<li>Horizontal</li>
<li>Vertical</li>
<li>Explicit 則是可以指定選擇跳選的對象</li>
</ul>
<p><img data-src="https://i.imgur.com/Lubtgid.png" alt=""></p>
<h4 id="注意-2"><strong>注意</strong></h4>
<p>當然如果其他的Button是Deactivate狀態下，是不被影響的<br>
物件停用狀態腳本自然也不會被執行<br>
不過物件<code>Set Active</code>開開關關會使效能產生一個臨時高峰<br>
會突然LAG一下，因此我是使用<code>Canvas Group</code>的alpha值控制按鈕的出現，但實際上功能還是運行的狀態<br>
所以還是吃的到Navigation事件</p>
<h4 id="我選到了誰"><strong>我選到了誰?</strong></h4>
<p>這時候可以打開<code>Visualize</code>來看這些UI物件是怎麼連結的<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mOdcNws2PW6q_sxLe5GYT3fa1Ty342iMadi9U1sHLMtA2Z1VHwPBP_iIFDhBznNzBEHBVHgsVFQSC2ut_euANWxu-otOVWFt1wlbQN1KoBFtmd2ORx930-8vW8JeH_81zE-5WLmpi2Jg8LVIFxOoDeL33Yp0UXJNk5tEW5UgX6dLcIlBbK8tMQCPUI9MYwe2U?width=660&amp;height=421&amp;cropmode=none" alt=""><br>
我先把alpha值打開，看一下按鈕位置<br>
搭啦!凌亂的連連看 (注意黃色線)<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mxQaNp1uNlJFSzfiusdX7iG1ZaWaLCiKJ2l6WiLBBRVB_NEzB9pVX1nOvW-XeEqGIgScY1Dn54xIeBJTO84UeBaIfXDErzZ-QzjS22pFpLWwEfQQaHj-bhxCGpsDBH4obPA87l31JCD7-V4QR3A0GnuchQQBIvy3XwN5QOXSQxjYy8eTeTA8O5OwBHQVLBHAu?width=660&amp;height=372&amp;cropmode=none" alt=""><br>
知道原因後，斷開連結就行了，把其他無關緊要的按鈕都選擇<code>none</code>就好了。</p>
<blockquote>
<p>如果不選擇none的效果就可以知道navigation怎麼運作</p>
</blockquote>
<p><img data-src="https://i.imgur.com/8IRNaIr.gif" alt=""></p>
<blockquote>
<p>選擇none的效果後</p>
</blockquote>
<p><img data-src="https://i.imgur.com/D5mGljJ.gif" alt=""></p>
<p>看看這連連看都鎖在中間了(很糊!沒辦法Unity就這麼糊)<br>
<img data-src="https://i.imgur.com/CQwmNFb.png" alt=""></p>
<h2 id="延伸思考">延伸思考</h2>
<p>當然不只Fungus的Menu可以使用<br>
可以搭配出更多的UI複合式選單<br>
尤其是使用搖桿的玩家<br>
在操作上可以更加靈活</p>
<h2 id="結語-7">結語</h2>
<p>總之這種情形還真得要多多注意<br>
當時找這個問題找了一個小時多<br>
沒想到就這麼小問題QQ</p>
]]></content>
      <categories>
        <category>2021</category>
        <category>07</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Event System</tag>
      </tags>
  </entry>
  <entry>
    <title>紀錄 | HEXO 一起來做部落格(II)</title>
    <url>/2021/07/07/Hexo-BuildBloger-II.html</url>
    <content><![CDATA[<h2 id="前言-37">前言</h2>
<p>昨日已經將網站安裝起來了<br>
今天要基礎設定，以及發佈至github上<br>
使用很多人用的 NEXT 主題，NEXT 也有很多好用的插件<br>
像是留言區、人流計數、打賞之類的都有<br>
客製化自己的部落格更方便了<br>
讓我想起小時候玩無名小站的快樂…</p>
<h2 id="複習">複習</h2>
<p>昨天最常使用的2個指令，今天再加一個</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">hexo clean =&gt; 簡寫 hexo cl <span class="regexp">//</span>清除建構檔  </span><br><span class="line">hexo g  <span class="regexp">//</span>重新建構  </span><br><span class="line">hexo s  <span class="regexp">//</span>發布伺服器(本端)  </span><br></pre></td></tr></table></figure>
<p>有時候會有囤積的檔案，clean一下之後再重新建構<br>
明天再來細補資料夾的結構與檔案設定的部份<br>
來做一個統整復習</p>
<h2 id="換上NEXT主題">換上NEXT主題</h2>
<blockquote>
<p><a href="https://github.com/theme-next/hexo-theme-next">官方指引</a></p>
</blockquote>
<p>不過我一樣是看那位<a href="https://home.gamer.com.tw/artwork.php?sn=5138471">巴哈L大大的文章</a>，真的幫助我很多☺️</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-<span class="keyword">next</span>  </span><br></pre></td></tr></table></figure>
<p>直接在終端機輸入安裝指令<br>
之後在左側的資料夾找到<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mZoV2zYTezJ7XnQzQftdPHv7G283xYtZn29Jm7MZ5BcCvcgEz5ET80-IILT_wrv5cE-TDME573cM8j3IQndYptgcFKJboIPsDViORzMo-554RRyfmKuwmWNFLSCifx1yqRbRS_1vGsOCjc52mDfyHSBXfKC2qOJOSP-_382CTz8EjWdyen19M2UAwGLqGcNis?width=290&amp;height=602&amp;cropmode=none" alt=""><br>
<code>_config.yml</code>  ⇒ 網頁設定檔，設定一些插件開關阿，網頁名稱、網址等等的<br>
NEXT安裝完後會生出 <code>_config.next.yml</code> ⇒ 是 NEXT主題中的設定，這個先不設定了。<br>
首先要把網頁設定檔的一些東西設定好，善用 <code>ctrl + F</code> 直接尋找</p>
<p><img data-src="https://chi01pap001files.storage.live.com/y4mg5VYrXhn9SKuFB7O410M0VrdE80dSyg12iiXxEjvdvFV36VXtMsNIyS90lEwOEjoEwGU8AvLctdsyh42QKc7m_VT5DBKUkjUwZAVZzXPWkqjbUjvOIrtXtZmk8w-NQb--hMM-_jkdmrzXBFZ8f8xG2ofs35BdVqZQ36OjvduhjK3UXSuWqfopS2MDFKov9NB?width=660&amp;height=418&amp;cropmode=none" alt=""></p>
<table>
<thead>
<tr>
<th>名稱</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td>網頁的網址。先去 github 建立好一個空的網頁，複製網址貼上</td>
</tr>
<tr>
<td>root</td>
<td>網頁的根目錄，這邊寫專案名就好， /***/ 是相對路徑的寫法哦</td>
</tr>
<tr>
<td>theme</td>
<td>網站套用的主題。這邊安裝的是NEXT填寫上 next</td>
</tr>
<tr>
<td>deloy</td>
<td>發布設定。這邊先填寫 <code>type: git</code> 。 repo 等等到github 上複製即可</td>
</tr>
</tbody>
</table>
<p><img data-src="https://chi01pap001files.storage.live.com/y4m31ODFxu3XGBixiLchDX0zi4lqY1toUWP2_3Bvbe2iqrsvUY5k035-7vUuTxYOsecl-msD3YU6BjrtEXYrR4vfzVsO0GR7w5HPZuS816bAUuUJ3b8LOyZro_eBsQX7EzvEvwyCle5dAdlWgxV2Ynrlk2WOPIyQan6qaNM5hF8XhMsowebpXBVIsiPg6QkwICt?width=256&amp;height=68&amp;cropmode=none" alt=""></p>
<blockquote>
<p>記得 冒號 : 後面要空一格(space)，設定值才算有哦</p>
</blockquote>
<p>裝完 Next 也改完設定了，再一次執行指令</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo cl</span></span><br><span class="line"><span class="attribute">hexo g</span></span><br><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure>
<p>會在終端機上看到大大的NEXT<br>
開啟本機伺服器後，看到主頁面沒問題就OK囉<br>
發現tags categroies 等等頁面都not found是正常的<br>
因為還沒新增頁面</p>
<h2 id="發布至github-pages">發布至github pages</h2>
<p>關於上傳有兩個方式<br>
分別用 https 或 SSH 形式，兩者都可以<br>
都是git的上傳方式<br>
根據<a href="https://wcc723.github.io/git/2018/02/12/github-ssh-https/"><strong>卡斯柏大大</strong></a>寫的，github 官方推薦https方式但也有提供SSH</p>
<blockquote>
<p><strong>https</strong> ⇒ 是不用金鑰，上傳時第一次會要求登入<br>
<strong>SSH</strong> ⇒ 需要金鑰，不用再登入帳號認證</p>
</blockquote>
<p>懶人如我，當然選SSH XDD<br>
以下這邊會以 SSH 部署方式進行<br>
先安裝 hexo - git 的發布工具<br>
如果有慣用的可以到hexo Plugin 找一下</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<p>恩…   <code>- -save</code>  是什麼碗糕呢<br>
查了一下大概是 發佈&amp;開發狀態的區別<br>
不過就先照官方的做吧! 之後在總結補上概念<br>
<code>deploy</code> 中文是部署，就是發布的意思啦!<br>
接著回到上面 <code>_config.yml</code> 檔進行設定</p>
<p><img data-src="https://chi01pap001files.storage.live.com/y4mAgiLoI6WV74o0adjBGFlRZU-8LOLmfwTqA6WE10zJOcOQWQcjFuUUTtl_jsAoAXrQUu08ZmDPU8g7l7hgaAT1DOVYYDjxiWeS2hftDZXLinaOqNrU4zsLPPdPZn3nBsD5Crg07WHCYbskme0mhi0CQD_sWE-ZjVSFhPULnsB8ZurJzRRoMCsXMHt_GFO52eL?width=256&amp;height=68&amp;cropmode=none" alt=""></p>
<p>剛剛我們在 <code>deploy</code> 這邊寫打好type了<br>
為了接上自己的 github repository<br>
我們到要成為blog的專案底下找到 code 這個綠綠的，按一下<br>
裡面會有 https 跟 SSH 的git 上傳地址 ， 複製SSH 的那串到 repo 貼上</p>
<p><img data-src="https://chi01pap001files.storage.live.com/y4mtrlRgLYfAcRsAhseYDa7VThDuZI0wLDMnhFqvZ7xSbTkFjpstkcIn1SQWWs-ZgIQXy9_w2VNi0KMgNLoJdt9Uvcsq2JAyt-klGyB5qA_HHhyUCu1RJqsELKcVABJd1Rh-QcOSMEcfBXzOdw1pN1zkgWoeBD68rwLUwpTZoiXDjH5eFa_V-Rx4InL5hdAIyA2?width=660&amp;height=487&amp;cropmode=none" alt=""></p>
<p>再來我們要透過 終端機用git連接上去囉!<br>
設定好登入口</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">git config <span class="attr">--global</span> user<span class="selector-class">.name</span> <span class="string">&quot;你的帳號名&quot;</span>  <span class="comment">//像我的就是 meitung473  </span></span><br><span class="line">git config <span class="attr">--global</span> user<span class="selector-class">.email</span> <span class="string">&quot;你註冊的信箱(你的帳號)&quot;</span></span><br></pre></td></tr></table></figure>
<p>因為透過SSH的方式，需要金鑰，所以來建立一個新的金鑰</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">&quot;你註冊的信箱(你的帳號)&quot;</span></span><br></pre></td></tr></table></figure>
<p>…你說這又是啥碗糕，SSH 之前略懂略懂而已，所以我又查了一下<br>
<code>ssh-keygen</code> ⇒ 產生金鑰， 後面的 rsa 是加密金鑰的演算，至於這些不是我的拿手就不多說了<br>
好奇的話可以看 <a href="https://docs.microsoft.com/zh-tw/azure/virtual-machines/linux/create-ssh-keys-detailed">MS 官方說明</a> ，像是 為什麼有 -t 與 -C 的用途是為何</p>
<p>總之非對稱加密會有兩把鑰匙，一把公鑰一把私鑰<br>
接著把公鑰的部分提出來，塞給自己的github，上傳的時候透過  「鑰&lt;-&gt;鑰」溝通(you know~)</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">cat ~<span class="regexp">/.ssh/i</span>d_rsa.pub</span><br></pre></td></tr></table></figure>
<p><code>cat</code> ⇒ 是印出檔案內容指令，我們要提取剛剛產生的SSH 公鑰的部分<br>
<code>~./ssh/id....</code>這邊是公鑰的檔案路徑<br>
你會發現輸入指令後有一大串的東西出現<br>
開頭 <code>ssh-rsa AAAAB.... 你的電子信箱</code> 結尾，把它複製起來<br>
接著到 github &gt; Setting，找到 <code>SSH keys and GPG keys</code> 的設定頁面，建立新的SSH key<br>
複製的文字貼到key上，title取自己方便的就好</p>
<center> 
<p><img data-src="https://chi01pap001files.storage.live.com/y4mtrlRgLYfAcRsAhseYDa7VThDuZI0wLDMnhFqvZ7xSbTkFjpstkcIn1SQWWs-ZgIQXy9_w2VNi0KMgNLoJdt9Uvcsq2JAyt-klGyB5qA_HHhyUCu1RJqsELKcVABJd1Rh-QcOSMEcfBXzOdw1pN1zkgWoeBD68rwLUwpTZoiXDjH5eFa_V-Rx4InL5hdAIyA2?width=256&amp;height=189&amp;cropmode=none" alt="step01"></p>
<p><img data-src="https://chi01pap001files.storage.live.com/y4m8_6cDZHW1v4JSUJsrUu1p9bMSzDmISLkPucVi6NDP88dCk5LwTSNVligcXEMl81_wAl0zvVnA_WXHJdKvEIccFUNyticly15iG3l2HSc4Wob7_MFbIQaPdxt1KrDyLUosjUouzN0940St1O3nLFi2qH_LUIFad_H5L0VmBpQQJZegkAIR9m0Z8NpnoCC4dbg?width=256&amp;height=140&amp;cropmode=none" alt="step02"></p>
</center>
<p>恩?你說這樣就好了嗎，NONO雖然都打好了<br>
但我們還沒用「(公)鑰(私)鑰」連結<br>
接著輸入指令，連結到 github 做認證，當在終端機部署上去就會上傳到你的github了</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ssh</span> -T git<span class="variable">@github</span>.com</span><br></pre></td></tr></table></figure>
<p>出現 <code>Hi,你剛剛帳號名! …</code> 就代表成功囉!<br>
最後一步了!再次打上指令</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">hexo g  </span><br><span class="line">hexo d  <span class="regexp">//</span>部署 deploy 的縮寫</span><br></pre></td></tr></table></figure>
<p>燈愣!等一會兒就會發現發布的網頁出現新的主題哦!<br>
長得不太一樣是因為NEXT 有4種不同版型</p>
<p>如果發現好像沒有動靜，檢查一下 <code>branch</code> 是不是設定正確哦<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mUwaX8yxoT5torp_6oiPYLOI5bjcEE0IJ89NRpRpuhwB6uUaD7dWVgENZka-pJtH4jWV_QrTpJhDe5styDA24xN6fvf0_nWbzeWRzgFWsz9U--NP80ITmFjg4HyStxEjbMOPPco1sLRZPDNmy9Z4TLRgNYcRlBSgGYnzNgDACmLTzLz2Kq859eMQbkhbKT1mq?width=256&amp;height=76&amp;cropmode=none" alt=""><br>
<img data-src="https://chi01pap001files.storage.live.com/y4mK9VlB_cWLjYZ-RMixf0tnkWDOEsySIboe-UtyXoGkSN38L2iUgW4cfm4ru33sO850_G6xbqnE1fQ1VmFeIuJWc4NZKcOWcI0x6NW6by4-rCVi8btKN5Hqt54R23dSlNk5hhOVUEIsc6nYJF2ihz-1AMnxct_WzyxqXEAopufB_acOFW8a5OIrzMyH9MmjSKO?width=256&amp;height=120&amp;cropmode=none" alt=""></p>
<h2 id="追加-利用Hexo後臺來快速新增頁面或文章">[追加]利用Hexo後臺來快速新增頁面或文章</h2>
<p>今天查一查發現有後台可以安裝<br>
挖屋~~~~簡直是一大福音<br>
輸入指令安裝</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-admin</span> <span class="literal">--save</span>  </span><br></pre></td></tr></table></figure>
<p>重新重構與開啟伺服器 <code>hexo g</code> ⇒ <code>hexo s</code><br>
打開<code>localhost:4000</code> 後面輸入 admin 進入管理後台，就會看到這樣的頁面</p>
<p><img data-src="https://chi01pap001files.storage.live.com/y4m6t5lwQPLeYwvheAsHrOEHdnJDvfl0c0F_h5yuFzqA519FHGGLzP7wzctJ4tWl-gKQVjsmRL_fTPQZfF-lkmpGSk1ElGcFRl91NAVboiaUtF8aJ_5SBTB7FcXnFt0aLhgJsASoM9qihet4CBavi-X-4oSRL7ygPu1IBOAk1-G-b0e78pNOTA5C_avI3hXqGtM?width=660&amp;height=406&amp;cropmode=none" alt=""></p>
<p>哦耶，這邊就可以更整潔的去組織文章與頁面囉!<br>
也會同步更新到 VS 編輯器裡的檔案<br>
是不是很讚呢!<br>
明天慢慢把東西搬過去吧!</p>
<h2 id="結語-8">結語</h2>
<p>到部署步驟的總結，要會的指令大概四招吧</p>
<pre><code class="language-powershell">hexo cl     //建構檔案清理
hexo g      //檔案重構
hexo s      //本機在進行修改的時候開的伺服器，如果要發布就不用打了
hexo d      //發布到指定地方，要先建置好部署步驟哦
</code></pre>
<p>安裝下來，發現自己要去學習的東西更多了</p>
<ul>
<li>npm的基礎指令</li>
<li>git 指令</li>
<li>markdown 語法</li>
</ul>
<p>雖然還有很多想要的插件還沒安上…<br>
就一步步來吧:D…</p>
<hr>
<blockquote>
<p>參考資料 :</p>
<ol>
<li><a href="https://home.gamer.com.tw/artwork.php?sn=5138471">Hexo 簡易調教指南（一）：軟體安裝及網站建構 - lewopa47894的創作 - 巴哈姆特</a></li>
<li><a href="https://wcc723.github.io/git/2018/02/12/github-ssh-https/">[Github 中的 ssh、https 路徑有什麼差異？ - 如何設定 Github SSH 金鑰]</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10227181">[SSH 金鑰：免密碼登入遠端主機、傳遞檔案]</a></li>
<li><a href="https://ed521.github.io/2019/08/hexo-admin/">[教學]我的第一篇 Hexo 文章：使用 hexo-admin 後台管理工具</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>2021</category>
        <category>07</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | CSS 選擇器</title>
    <url>/2021/08/08/CSS-Selector.html</url>
    <content><![CDATA[<h2 id="前言-38">前言</h2>
<p>複習常見用法與了解選擇器權重的問題</p>
<span id="more"></span>  
<h2 id="條件使用">條件使用</h2>
<p>舉 class 的例子<br>
選擇器還有 <code>Universal(*) 、pseudo-classes(偽類別)、id、tag(標籤)</code>等等的選擇器<br>
除了 <strong>id</strong> 外基本都以此類推。</p>
<h3 id="範例-2">範例</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 省略 Html 架構--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;A&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 範例 4 開始 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;B&quot;</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;B&quot;</span>&gt;</span> 2 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;C&quot;</span>&gt;</span> 3 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;C&quot;</span>&gt;</span> 4 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;A item&quot;</span>&gt;</span>item<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;A&quot;</span>&gt;</span>P<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>來套上CSS</p>
<ol>
<li>同時符合條件才套用</li>
</ol>
<ul>
<li><code>.A.item</code> : 連續的，並無空格
<blockquote>
<p>是 A 又有 item 的才會被選，其他 A 不套用</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>父層以下的所有叫 OO <strong>都</strong>  套用</li>
</ol>
<ul>
<li><code>.wrapper .A</code> : 中間空一格
<blockquote>
<p>這邊通通有 class <code>A</code> 的都會被套用</p>
</blockquote>
</li>
</ul>
<ol start="3">
<li>父層的下一層要叫 OO 才套用</li>
</ol>
<ul>
<li><code>.wrapper&gt;.A</code> : 下一層的 A 都會套用
<blockquote>
<p>box 裡面的 A 是屬於 下下層，因此不套用</p>
</blockquote>
</li>
</ul>
<ol start="4">
<li>同一層的旁邊叫 OO 的才套用</li>
</ol>
<ul>
<li><code>.B+.C</code> : 兩個都同一層
<blockquote>
<p>只有 B-2 旁邊的 <code>C-3</code> 會套用</p>
</blockquote>
</li>
</ul>
<ol start="5">
<li>同一層的右邊只要叫 OO 的都套用</li>
</ol>
<ul>
<li><code>.B~.C</code> : 兩個都同一層
<blockquote>
<p>B-2 旁邊的 <code>C-3</code> 與 <code>C-4</code> 皆會套用</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><a href="https://codepen.io/shan473/pen/BaRMyrz">練習</a></p>
</blockquote>
<h4 id="快速複習">快速複習</h4>
<table>
<thead>
<tr>
<th style="text-align:center">符號</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&gt;</td>
<td>下一層</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td>同一層的旁邊一個</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td>同一層的旁邊所有的</td>
</tr>
</tbody>
</table>
<h2 id="常用的選擇器">常用的選擇器</h2>
<ul>
<li>pseudo-classes (偽類別)<br>
以 <code>:</code> 表示
<ul>
<li>
<p>關於動作的 (Dynamic)<br>
像是 <code>:hover</code>、<code>:active</code> … 等等</p>
<p>以往在開發時可能都要實際操作再看效果<br>
在 Dev tool 中可以手動直接控制<br>
瀏覽器顯示 style 有個 <code>:hov</code><br>
<img data-src="https://chi01pap001files.storage.live.com/y4mXniSc9YQknILFFtKip8TAQ82En47NCTww_UljZH2WPpwqvQD9hnkcwXYNUQu4BrLI_6xTabbid29wewJsyt3Kj522mgEJaTDHjoN0PzHXFUSvUP8ZTj3OBzQEs91uitM5P80iFV083PpDcTt6BzOsT4yaDtMYgcVgBNAKvX0bnj3LL0-BoayHXrZxslbKj8r?width=660&amp;height=236&amp;cropmode=none" alt=""></p>
</li>
<li>
<p>選擇器<br>
<code>:nth-child(n)</code> : 選擇子層的第 n 個<br>
<code>:first-child</code>  :  指第一個<br>
<code>:first-child</code>  :  指最後一個</p>
<p>快速一點</p>
<ol>
<li><code>:nth-child(odd)</code> : 只選奇數位</li>
<li><code>:nth-child(even)</code> : 只選偶數位</li>
<li><code>:nth-child(an+b)</code> : 等差選</li>
</ol>
<blockquote>
<p>nth-child 是從後面解讀<br>
例 : .wrapper .A:nth-child(3)<br>
XX層的第 n 個元素是 OO 再動作</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>參考資料<br>
<a href="https://developer.mozilla.org/zh-TW/docs/Web/CSS/Pseudo-classes">虛擬類別 - CSS | MDN (mozilla.org)</a></p>
</blockquote>
<ul>
<li>pseudo-elements (偽元素)<br>
以 <code>::</code> 表示<br>
最常用的是 <code>::before</code> 跟 <code>::after</code><br>
使用上可以用 <strong>共同想加入的東西</strong><br>
例如 金錢符號  <iframe height="300" style="width: 100%;" scrolling="no" title="" src="https://codepen.io/shan473/embed/OJmdPvN?default-tab=result&theme-id=dark" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
See the Pen <a href="https://codepen.io/shan473/pen/OJmdPvN">
</a> by YanShanHong (<a href="https://codepen.io/shan473">@shan473</a>)
on <a href="https://codepen.io">CodePen</a>.
</li>
</ul>
</iframe>  
<pre><code>這樣只要改 ::before 的內容就可以統一修改      
</code></pre>
<blockquote>
<p>content 一定要有，沒有內容也可以空的</p>
</blockquote>
<p>*<code>content : attr( class or tag )</code><br>
可以抓到 html 的資料</p>
<blockquote>
<p>參考資料<br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content">content - CSS（层叠样式表） | MDN (mozilla.org)</a></p>
</blockquote>
<h2 id="選擇器權重">選擇器權重</h2>
<p>常常會因為套用很多 CSS 而眼花撩亂<br>
誰被套用了 ? 誰套了又沒效果了 ?<br>
透過權重就能清楚知道</p>
<ul>
<li>把握基本原則
<blockquote>
<p><strong>id &gt; class &gt; tag</strong><br>
越詳細越先套用<br>
重複寫到一樣的，以後面的為重</p>
</blockquote>
</li>
</ul>
<p>網路上會以 <code>100 : 10 : 1</code>  來說明比重<br>
但我更喜歡 Huli 大講的 <code>0,0,0</code> 越前面的越重<br>
誰佔的比較前面就吃那個樣式</p>
<p>假如都使用 class 那第二個就是看 <code>數量</code><br>
數字並不會十進位</p>
<p>有神人測試過 256 個 class 可以超過 id<br>
不過應該不會有人會寫到這麼多 class …<br>
應該是測試極限用而已</p>
<blockquote>
<p>參考資料<br>
<a href="https://juejin.cn/post/6844903608199151630">你对CSS权重真的足够了解吗？ (juejin.cn)</a></p>
</blockquote>
<h3 id="進階原則">進階原則</h3>
<p>也就是 <code>!important</code> 與 <code>inline style</code></p>
<ol>
<li>inline style : 寫在 html 同一行元素裡的 style</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;background:red;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>!important</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class</span>&#123;</span><br><span class="line">	<span class="attribute">background</span>:red <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>綜合排一下</p>
<blockquote>
<p>!important &gt; inline style &gt; id &gt; class &gt; tag</p>
</blockquote>
<p>看成 <code>0 , 0 , 0 , 0 , 0</code><br>
越後面樣式越容易被覆蓋</p>
<p>因此套上 <code>!important</code> 是奧義<br>
並不會很常使用<br>
不然其他寫的都沒意義了</p>
<p>最常使用的是 class 而非 id</p>
<h2 id="結語-9">結語</h2>
<p>以前使用 CSS 重點在其他設定<br>
老是一直層層疊上去<br>
透過整理可以更清楚知道選擇器的權重<br>
與選擇器正確的使用</p>
]]></content>
      <categories>
        <category>2021</category>
        <category>8</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | HTML 基本語法</title>
    <url>/2021/08/08/HTML-Tags.html</url>
    <content><![CDATA[<h3 id="前言-39">前言</h3>
<p>這邊紀錄常用標籤與標籤用處<br>
標籤基本都成雙成對<br>
本篇主要複習跟稍微解析實際網頁的應用部分</p>
<span id="more"></span>
<h3 id="基本">基本</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- !DOCTYPE HTML :告訴瀏覽器這是標準的 html 格式--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- head : 網頁資本資訊--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		(1) title : 網站標題</span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>網站標題<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		(2) charset : 編碼</span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf8&quot;</span>/&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--body : 主要呈現的地方--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		(1) div : 分組，會換行 </span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">		(2) span : 分組，不會換行</span><br><span class="line">		<span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> </span><br><span class="line">		(3) img : 圖片 </span><br><span class="line">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;放source&quot;</span> </span></span><br><span class="line"><span class="tag">			 <span class="attr">title</span>=<span class="string">&quot;滑鼠 Hover 顯示文字&quot;</span></span></span><br><span class="line"><span class="tag">			 <span class="attr">alt</span>=<span class="string">&quot;圖片跑不出來的替代文字&quot;</span>/&gt;</span></span><br><span class="line">		(4) 清單  </span><br><span class="line">		<span class="tag">&lt;<span class="name">ul</span>&gt;</span> : 沒有排序的清單，只會出現 dot</span><br><span class="line">		<span class="tag">&lt;<span class="name">ol</span>&gt;</span> : 有排序的清單 (order)，會顯示數字</span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span> : 項目</span><br><span class="line">		</span><br><span class="line">		(5) pre : 保留完整格式 </span><br><span class="line">		<span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">		說明 : 在 html 空多少格都會只有呈現一格</span><br><span class="line">		加入 <span class="tag">&lt;<span class="name">pre</span>&gt;</span> 後，html長相都會被「照實呈現」</span><br><span class="line">		</span><br><span class="line">		(6) br : 換行 </span><br><span class="line">		<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">		(7) 表格</span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">			(7-1) 表格標題 (header)</span><br><span class="line">			<span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">			說明 : 可以放在首列，標題字會變粗體</span><br><span class="line">			-----</span><br><span class="line">			(7-2) 列(row)</span><br><span class="line">			<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">				(7-3) 子項</span><br><span class="line">				<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		(8) 錨點 </span><br><span class="line">		(8-1) 連外部網絡</span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">herf</span>=<span class="string">&quot;連結網址&quot;</span> </span></span><br><span class="line"><span class="tag">		   <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">新分頁開啟</span></span></span><br><span class="line"><span class="tag">		   				   <span class="attr">不加的話預設是直接打開</span></span></span><br><span class="line"><span class="tag">		&gt;</span></span><br><span class="line">		(8-2) 連內部段落</span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">herf</span>=<span class="string">&quot;#段落ID&quot;</span>&gt;</span></span><br><span class="line">		說明 : 使用 id 來進行連結</span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;!DOCTYPE HTML&gt;</code> 通常可加可不加<br>
不加偶爾會出 Bug ，所以還是加一下。</li>
</ul>
<h3 id="實用型">實用型</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. iframe  : 嵌入網站。</span><br><span class="line">說明:通常會看到嵌入 yt 影片、網頁內容等等。</span><br><span class="line">實際上很多網站會擋，以防資訊被偷竊。</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;來源網址&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2. form : 表單</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">	2-1. input : 輸入 </span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> =<span class="string">&quot;輸入類型&quot;</span> </span></span><br><span class="line"><span class="tag">		   <span class="attr">vaule</span>=<span class="string">&quot;被輸入的值可以先預設&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">	type 常見有 : </span><br><span class="line">           text、password、email、radio、</span><br><span class="line">           checkbox、date</span><br><span class="line">	有作用的按鈕 :</span><br><span class="line">	    submit (送出)</span><br><span class="line">	注意 : submit 類型的 vaule 是指按鈕文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>input 更多類型往這邊<br>
<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTML/Element/input">超文本標記語言 | MDN (mozilla.org)</a></p>
</blockquote>
<p>範例</p>
<ul>
<li><strong>radio</strong> 單選</li>
</ul>
<iframe height="300" style="width: 100%;" scrolling="no" title="" src="https://codepen.io/shan473/embed/bGWOrWB?default-tab=html%2Cresult&theme-id=dark" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/shan473/pen/bGWOrWB">
  </a> by YanShanHong (<a href="https://codepen.io/shan473">@shan473</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>
<ol>
<li><code>type</code>  : 設定種類</li>
<li><code>name</code> :  把選項群組。<br>
使用單選時，要確定哪個是同一種單選<br>
如果沒有 <strong>name</strong> 就沒用哦</li>
<li><code>label</code> : 可以把內容也變的跟同個 id 有一樣的效果。<br>
如果沒有 label 可以發現 <strong>使用者體驗較差</strong><br>
每次點擊必須精準落在圈圈內<br>
加上之後，讓 label 裡的字串點擊也可以勾選<br>
以便來 <strong>提升使用者的體驗</strong></li>
</ol>
<blockquote>
<p>關於 vaule 的範例<br>
<a href="https://matthung0807.blogspot.com/2019/08/html-input-value.html">菜鳥工程師 肉豬: HTML value屬性</a></p>
</blockquote>
<h3 id="語意化標籤">語意化標籤</h3>
<p>英文 <em>Semantic Elements</em></p>
<p>綜觀所有東西確實可以使用 <code>div</code> 來包裹<br>
但在閱讀上其實不太方便<br>
尤其網頁在爬蟲時，要讓機器方便閱讀<br>
因此才有語意化標籤來輔助<br>
如果是人，在閱讀上也來的更清楚快速</p>
<blockquote>
<p>更多的可以參照 W3 說明<br>
(<a href="https://www.w3schools.com/html/html5_semantic_elements.asp">HTML Semantic Elements (w3schools.com)</a>)</p>
</blockquote>
<p>提到給機器看，很大一部分跟 SEO (search engine optimization) 也有關連<br>
比起看 <code>div</code> 猜意思，不如直接跟他說這是什麼區塊</p>
<p>這邊舉幾個是常見的</p>
<ol>
<li><code>&lt;main&gt;</code> : 放主要內容的</li>
<li><code>&lt;nav&gt;</code> : 導覽列</li>
<li><code>&lt;footer&gt;</code> : 網頁底部資訊</li>
<li><code>&lt;section&gt;</code> : 區塊資訊</li>
</ol>
<p>總之，功能跟 <code>div</code> 包裹沒差別，差在更容易識別。</p>
<h3 id="跳脫標籤">跳脫標籤</h3>
<p>有些特殊字元並沒辦法在 html 中呈現<br>
當你打 想顯示 &lt;div&gt; ，怎麼打就是看不見<br>
例如 <code>div</code> 前面跟後面的 <code>&lt; &gt;</code> 這個標籤<br>
替代符號可以用以下幾個</p>
<table>
<thead>
<tr>
<th>符號</th>
<th>替代使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>&amp;amp;</td>
</tr>
<tr>
<td>&lt;</td>
<td>&amp;lt;</td>
</tr>
<tr>
<td>&gt;</td>
<td>&amp;gt;</td>
</tr>
</tbody>
</table>
<p>範例 : *markdown 語法也會吃 html</p>
 <pre>			&lt;div&gt;</pre>
<p>實際上長這樣 <strong>&amp;lt;div&amp;gt;</strong></p>
<h3 id="SEO-相關東西">SEO 相關東西</h3>
<p>這邊我覺得蠻有趣的，所以也記錄一下</p>
<p>搜尋一打，為什麼有些網站名列前茅?<br>
SEO 要做得好，其實跟 meta tag 脫不了關係<br>
因為這部份真的很 <strong>深深深深</strong><br>
有些公司是有一個專門團隊在管理這部分的<br>
僅列出稍微知道的一部分</p>
<h4 id="SEO是給機器看的">SEO是給機器看的</h4>
<p>也就是為什麼有語意化標籤的產生<br>
除了內容標籤之外<br>
又必須在網頁設定告訴機器哪些事?</p>
<p>常見的有這幾個<br>
以 <a href="https://www.walkerland.com.tw/article/view/186797">這個網站</a> 為例<br>
按出 devtool 打開 head 就可以看見<br>
記得 head 裡面的東西是 <strong>網頁的資本資訊</strong><br>
<img data-src="https://chi01pap001files.storage.live.com/y4mJy12jCWqUv8I3m2vELwKn21a1DPZjMIadHGCUzAOxa4X6RW-HfYkEBrWU1KomtH6K40CNew2xpfnfk64KV51Gek1qn-XTbvyr7E65IcIgyyGjosLV9kyNCsyyjQk-1NUgZanO06xoRqbydtD3pRl7nrxCyJC0QUm5UeTudmF47vINqUkYQWoAnzv0wybtQRM?width=660&amp;height=462&amp;cropmode=none" alt=""></p>
<p>這邊都是指在搜尋引擎相關的資訊</p>
<ol>
<li><code>keywords</code> : 關鍵字</li>
<li><code>description</code>  : 網頁敘述。這蠻重要的，寫得好容易被排的前面</li>
<li><code>title</code> : 網頁的標題。搏人眼球的標題容易點進來</li>
<li><code>property</code> : 屬性。這邊通常會給 <code>社群媒體</code> 相關設定用</li>
</ol>
<h5 id="property"><strong>property</strong></h5>
<ol>
<li><code>og</code> : Open Graph protocol。最常用的是 FB 。<br>
裡面可以設定在 FB 分享時出現的 <code>圖片、標題、敘述</code><br>
詳細可以到 偵錯工具看<br>
子屬性分別有對應的功能</li>
</ol>
<blockquote>
<p><a href="https://developers.facebook.com/tools/debug/?locale=zh_TW">分享偵錯工具 - Facebook for Developers</a></p>
</blockquote>
<ol start="2">
<li><code>app_id</code> : 有些網站具有 app ，會挑出訊息告訴使用者可以下載來獲得更加體驗之類的。</li>
</ol>
<h5 id="JSON-LD"><strong>JSON-LD</strong></h5>
<p>這個是給 google 引擎看的<br>
是在搜尋後呈現的東西<br>
一樣同個網站，Umm不太好找<br>
主要有找到這個標籤<br>
<img data-src="https://chi01pap001files.storage.live.com/y4myYnkBblETyqypt00tVvRJJCVVClV3ueNCz4wZmj6vFMd_cwhAPAFQJLmtm8-TsF-CxnhijUI_n6HF80TxRos9HOO3yWE1n96TzqWQbECYmjCGlLlXiIFfSZJe8FERdC9C8NrXgp9NLSxp8tY1B_3oEaNLMJPQ_I7YEbuNWcJMF1Px7RyrLfK5IpGyQsN-I2E?width=660&amp;height=146&amp;cropmode=none" alt=""></p>
<blockquote>
<p>詳細參考這篇文章有提到各式種類呈現<br>
<a href="https://z3388638.medium.com/%E4%BD%BF%E7%94%A8-json-ld-%E8%99%95%E7%90%86-seo-%E4%B8%A6%E8%AE%93-google-%E9%87%9D%E5%B0%8D%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%B6%B2%E7%AB%99%E5%81%9A%E7%8D%A8%E7%89%B9%E7%9A%84%E6%90%9C%E5%B0%8B%E7%B5%90%E6%9E%9C%E5%91%88%E7%8F%BE-9c74783c017a">使用 JSON-LD 處理 SEO，並讓 Google 針對不同形式網站做獨特的搜尋結果呈現 | by YY | Medium</a></p>
</blockquote>
<p>google 的開發者頁面就有提到這部分</p>
<blockquote>
<p><a href="https://developers.google.com/search/docs/advanced/structured-data/intro-structured-data?hl=zh-tw">瞭解結構化資料的運作方式 | Google 搜尋中心  |  Google Developers</a></p>
</blockquote>
<p>關於 JSON-LD</p>
<blockquote>
<p><a href="https://json-ld.org/">JSON-LD - JSON for Linking Data</a></p>
</blockquote>
<h5 id="robot-txt"><strong>robot.txt</strong></h5>
<p>這個檔案是給爬蟲看的<br>
裡面也明確規範告訴爬蟲<br>
哪些不要看、哪些給你看</p>
<blockquote>
<p>參考資料<br>
<a href="https://zh.wikipedia.org/wiki/Robots.txt">robots.txt - 維基百科，自由的百科全書 (wikipedia.org)</a></p>
</blockquote>
<h5 id="sitemap-xml"><strong>sitemap.xml</strong></h5>
<p>也就是網站地圖<br>
更快速幫助機器讀懂網站架構<br>
通常也會規範在 robot.txt 裡</p>
<blockquote>
<p>參考資料<br>
<a href="https://ranking.works/%E6%8A%80%E8%A1%93SEO/sitemap">【Sitemap SEO教學篇】Sitemap是什麼？一次掌握Sitemap網站地圖製作與提交流程！ | Ranking SEO</a></p>
</blockquote>
<h3 id="結語-10">結語</h3>
<p>主要是紀錄 html 的架構說明<br>
SEO 的部分只是蜻蜓點水<br>
以後有興趣再往深處寫</p>
]]></content>
      <categories>
        <category>2021</category>
        <category>8</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - 資料型態(I)</title>
    <url>/2021/08/08/JavaScript-DataType.html</url>
    <content><![CDATA[<h2 id="前言-40">前言</h2>
<p>這篇 Primaitvie vaule (原始值) 以及 Object 之間差別的說明</p>
<span id="more"></span>
<h3 id="Primitive-vaule">Primitive vaule</h3>
<p>常見的有六種，另外兩種 symbol 跟 BigInt 先不做討論</p>
<ol>
<li>boolean</li>
<li>string</li>
<li>number</li>
<li>null</li>
<li>undefined</li>
<li>object ( function 函式 、array 陣列 … )</li>
</ol>
<p>在 <strong>null</strong> 與  <strong>undefined</strong> 的定義有點微妙<br>
暫不討論</p>
<h3 id="Object">Object</h3>
<p>像是 Object 或 Array 這類的會被歸類在 object</p>
<blockquote>
<p>注意 :  主要是記憶體跟純賦值不同<br>
function 算是被視為一種 Object 只是被呼叫而已</p>
</blockquote>
<h3 id="typeof-2">typeof</h3>
<p>查詢數值型態</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a) <span class="comment">// string</span></span><br></pre></td></tr></table></figure>
<p>其他的類別以此類推</p>
<blockquote>
<p>詳細的型態說明<br>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#examples">typeof - JavaScript | MDN (mozilla.org)</a></p>
</blockquote>
<h3 id="可變與不可變-Immutable">可變與不可變 (Immutable)</h3>
<h4 id="不可變">不可變</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="number">2.</span> a = <span class="string">&#x27;yo&#x27;</span></span><br><span class="line"><span class="number">3.</span> a.<span class="title function_">toUpperCase</span>()</span><br></pre></td></tr></table></figure>
<p>(2) <code>a  = yo</code> 這是被賦值，並非完全被覆蓋掉<br>
在  <strong><code>hello </code></strong> 已建立了一個記憶體位置儲存值<br>
而 <strong><code>yo</code></strong> 只是重新賦值<br>
且又新建立一個新的記憶體位置存放值</p>
<p>(3) 的部分是沒有任何效果的，是不會變動到 a<br>
也不會改變a的值<br>
要麼寫成 <code>a = a.toUpperCase()</code></p>
<blockquote>
<p>這邊講的不可變是 <strong><code>操作值所回傳的結果</code></strong><br>
a.toUpperCase() 回傳回來的並沒有被改變<br>
而在 a = a.toUpperCase() 才做改變</p>
</blockquote>
<p>因此 CDN 這邊說明 Primaitive vaule 是不可變的</p>
<h4 id="可變">可變</h4>
<p>舉 object 來看 mutable</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">var</span> obj = &#123; <span class="attr">a</span>:<span class="number">1</span> &#125;</span><br><span class="line"><span class="number">2.</span> <span class="keyword">var</span> obj2 = obj </span><br><span class="line"><span class="number">3.</span> obj2.<span class="property">a</span> = <span class="number">2</span></span><br><span class="line"><span class="number">4.</span> obj.<span class="property">a</span> = <span class="number">0</span></span><br><span class="line"><span class="number">5.</span> obj2.<span class="property">b</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>必須先知道 Object 是儲存記憶體的位置<br>
並非只有單純的值</p>
<ol>
<li>(1)新建立一個 obj 實際是建立了一個記憶體<br>
例如是 <code>0x01</code></li>
<li>(2) 新物件 obj2 =  obj<br>
obj 跟 obj2 是指向同一個記憶體位置</li>
<li>(3) obj2 改變 a 的值， <strong><code>obj 的 a 也會一同被改變</code></strong><br>
也就是 <code>obj2 = &#123;a : 2&#125; ,obj = &#123;a : 2&#125;</code>
<blockquote>
<p>改變的是同一個記憶體位置<br>
obj2 的 記憶體位置也是 <code>0x01</code><br>
兩者指向的是同一個，因此改變其中一個就會通通改變</p>
</blockquote>
</li>
</ol>
<ul>
<li>列出跟 Primative vaule 差別</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="comment">//請問 b = ?</span></span><br></pre></td></tr></table></figure>
<p>答案 <strong><code>b = 1 ,a = 2</code></strong><br>
這邊我們可以知道這邊指的是賦值<br>
並非指向同一個記憶體</p>
<ol start="4">
<li>因此到 (4) 再看一次 <code>obj = &#123;a : 0&#125; ,obj = &#123;a : 0&#125;</code></li>
<li>(5)  obj2 多新增一個 b ，但 obj 並不會新增<br>
這邊 obj 已經是另一個新的記憶體 <code>0x02</code><br>
代表兩者已經不一樣了<br>
<code>obj = &#123;a : 0&#125; ,obj = &#123;a : 0 ,b : 2&#125;</code></li>
</ol>
<p>關於 <strong>淺拷貝與深拷貝</strong> 參考可以看這篇</p>
<blockquote>
<p><a href="https://blog.huli.tw/2018/06/23/javascript-call-by-value-or-reference/">深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？ - Huli</a></p>
</blockquote>
<h2 id="結語-11">結語</h2>
<p>之前在使用物件時<br>
常常不知道為什麼會突然改到原物件<br>
我以為的拷貝結果不是拷貝 :O<br>
接觸更深後才知道<br>
要複製可以使用展開的方式<br>
像這樣</p>
<pre><code class="language-javascript">  var obj = &#123;
    a:1,
    b:2
  &#125;
  var obj2 = &#123;...obj&#125;
</code></pre>
<p>再改動 obj2 值就不會影響 obj 了</p>
<p>基礎篇章都只是記錄小東西<br>
更新的不快<br>
繼續學習 ! GOGO</p>
<hr>
<blockquote>
<p>參考資料<br>
<a href="https://derek.coderbridge.io/2020/09/29/javascript-%E6%A0%B8%E5%BF%83-%E8%AE%8A%E6%95%B8%E8%88%87%E4%BB%96%E7%9A%84%E7%94%A2%E5%9C%B0/">JavaScript 核心 - 變數與他們的產地 (coderbridge.io)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>2021</category>
        <category>8</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript 邏輯運算子</title>
    <url>/2021/08/08/JavaScript-Logic.html</url>
    <content><![CDATA[<h2 id="前言-41">前言</h2>
<p>在寫網頁的經歷<br>
有很大一部分是關於 <strong><code>「設計面」</code></strong><br>
程式面的部份都像蘸醬油一樣<br>
打算把基礎的概念弄得清楚</p>
<span id="more"></span>
<p>未來打算規劃 30 Days Javascript Challenages<br>
提升自己對解決問題的敏感度 XD<br>
在這之前先補齊一些常識吧 QQ</p>
<h2 id="邏輯運算"><strong>邏輯運算</strong></h2>
<p>在二元邏輯裡面知道布林值有 <code>true</code> 和 <code>false</code><br>
JS 什麼情況下是 <code>true</code>？ 什麼是 <code>false</code> ？<br>
其實 JS 對於這兩個各自又對某些值有不同的定義</p>
<p>在一般的程式語言中，不是回傳 true 就是 fasle<br>
但在 JS 裡數字、字串也可以做邏輯運算<br>
後面會說明</p>
<p>先來看一下運算子有哪三個：</p>
<h3 id="運算子"><strong>運算子</strong></h3>
<p>運算子有三種</p>
<table>
<thead>
<tr>
<th>邏輯</th>
<th style="text-align:center">長相</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AND</td>
<td style="text-align:center">&amp;&amp;</td>
<td>兩個為 <code>真</code> 就是 <code>真</code>；其一為 <code>假</code> 就是 <code>假</code></td>
</tr>
<tr>
<td>OR</td>
<td style="text-align:center">||</td>
<td>其一為 <code>真</code> 就是 <code>真</code>，反之 <code>假</code> 也是</td>
</tr>
<tr>
<td>NOT</td>
<td style="text-align:center">!</td>
<td><code>真</code> 為 <code>假</code> ； <code>假</code> 為 <code>真</code></td>
</tr>
</tbody>
</table>
<p>* <strong>NOT</strong> 簡單來說就是把得出的值給相反過來。</p>
<p>總之基本上有四種狀況</p>
<ul>
<li>true , true</li>
<li>true , false</li>
<li>false , true</li>
<li>false , false</li>
</ul>
<p>應該還行吧～</p>
<h3 id="短路求值">短路求值</h3>
<p>上面有提及關於數字與字串也可以做邏輯運算<br>
來看看官方的例子</p>
<ol>
<li>
<p>&amp;&amp;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 =  <span class="literal">true</span> &amp;&amp; <span class="literal">true</span>;   <span class="comment">// t &amp;&amp; t 回傳 true</span></span><br><span class="line"><span class="keyword">var</span> a2 =  <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>;  <span class="comment">// t &amp;&amp; f 回傳 false</span></span><br><span class="line"><span class="keyword">var</span> a3 = <span class="literal">false</span> &amp;&amp; <span class="literal">true</span>;   <span class="comment">// f &amp;&amp; t 回傳 false</span></span><br><span class="line"><span class="keyword">var</span> a4 = <span class="literal">false</span> &amp;&amp; (<span class="number">3</span> == <span class="number">4</span>); <span class="comment">// f &amp;&amp; f 回傳 false</span></span><br><span class="line"><span class="keyword">var</span> a5 = <span class="string">&quot;Cat&quot;</span> &amp;&amp; <span class="string">&quot;Dog&quot;</span>; <span class="comment">// t &amp;&amp; t 回傳 Dog</span></span><br><span class="line"><span class="keyword">var</span> a6 = <span class="literal">false</span> &amp;&amp; <span class="string">&quot;Cat&quot;</span>; <span class="comment">// f &amp;&amp; t 回傳 false</span></span><br><span class="line"><span class="keyword">var</span> a7 = <span class="string">&quot;Cat&quot;</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// t &amp;&amp; f 回傳 false</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>a1 兩者為 <code>真</code> 就是真 <code>真</code></li>
<li>a2、a3 其一為 <code>假</code> ，就是 <code>假</code></li>
<li>a4 兩者為 <code>假</code> ， 就是 <code>假</code></li>
<li>a5 為什麼會回傳 <strong><code>Dog</code></strong> 呢　？  而不是 <code>Cat</code></li>
<li>a6 為什麼會回傳 <strong><code>false</code></strong> 呢　？ 而不是 <code>Cat</code></li>
<li>a7 為什麼會回傳 <strong><code>false</code></strong> 呢　？ 而不是 <code>Cat</code></li>
</ul>
<p>官方到底在 <strong>りしれ供さ小</strong><br>
甚至看到 <code>||</code> 的例子又更懵了</p>
<ol start="2">
<li>||</li>
</ol>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o5 = <span class="string">&#x27;Cat&#x27;</span> || <span class="string">&#x27;Dog&#x27;</span>;  <span class="comment">// t || t 回傳 Cat</span></span><br><span class="line"><span class="keyword">var</span> o6 = <span class="literal">false</span> || <span class="string">&#x27;Cat&#x27;</span>;  <span class="comment">// f || t 回傳 Cat</span></span><br><span class="line"><span class="keyword">var</span> o7 = <span class="string">&#x27;Cat&#x27;</span> || <span class="literal">false</span>;  <span class="comment">// t || f 回傳 Cat  </span></span><br></pre></td></tr></table></figure>
<ul>
<li>o5 為什麼會回傳 <strong><code>Cat</code></strong> 呢　？  而不是 <code>Dog</code></li>
<li>o6 為什麼會回傳 <strong><code>Cat</code></strong> 呢　？ 而不是 <code>false</code></li>
<li>o7 為什麼會回傳 <strong><code>Cat</code></strong> 呢　？ 而不是 <code>false</code></li>
</ul>
<p>6 跟 7 看起來一樣，判斷上又不一樣</p>
<h4 id="什麼是短路求值">什麼是短路求值?</h4>
<p>把兩者分開來看</p>
<ol>
<li>
<h5 id=""><strong>&amp;&amp;</strong></h5>
<p>如果遇到假，整個就是假的了<br>
那個 <code>假</code> 就是產出的值</p>
<p>都為真的情況下，最後一個的值才會是產出</p>
<blockquote>
<p>簡單來說就是 <strong><code>真的就過關斬將</code></strong><br>
遇到假的就停止</p>
</blockquote>
<p>總結來說<br>
遇到第一個 <code>假</code> ，就短路了<br>
後面就不用判斷了</p>
</li>
<li>
<h5 id="-2"><strong>||</strong></h5>
<p>那麼 <code>||</code> 就是相反了<br>
遇到真，整個亦為真<br>
那個真，就是產出的值</p>
<p>反之，全都假，最後一個值才會是產出</p>
<blockquote>
<p>遇真就停止<br>
全假就假到底</p>
</blockquote>
<p>簡單來說，遇到第一個 <code>真</code> ，就短路了</p>
</li>
</ol>
<p><strong>這有什麼好處呢？</strong><br>
短路求值的好處就在 <strong><code>不用整個都去判斷完才有果</code></strong><br>
遇到短路就得值，就 Out<br>
比較不會占用效能</p>
<p>其實這也不用背啦<br>
只要知道哪些東西會被判斷為假才叫假</p>
<h4 id="真真假假是又是怎麼判斷">真真假假是又是怎麼判斷</h4>
<blockquote>
<p>哪些是 <strong><code>false</code></strong> ?</p>
</blockquote>
<p>以下是 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">官方文件</a> 說的<br>
常見的是這幾個</p>
<ol>
<li><code>0</code></li>
<li><code>&quot;&quot;</code>、<code>''</code> 空字串</li>
<li><code>null</code></li>
<li><code>NaN</code> (not a number)，這個很…微妙，改天做一篇</li>
<li><code>undefined</code> (未定義)</li>
</ol>
<p>其餘的就是 <code>真</code> 了。</p>
<p>所以來看看這些例子</p>
<ol>
<li>0 <code>||</code> 3 =&gt; 3</li>
<li>3 <code>&amp;&amp;</code> 0 =&gt; 0</li>
</ol>
<ul>
<li>
<p><strong><code>||</code></strong> :</p>
<blockquote>
<p>是真。求真，遇到 3 是真，得值</p>
</blockquote>
</li>
<li>
<p><strong><code>&amp;&amp;</code></strong></p>
<blockquote>
<p>是假。求假，遇到 0 是假，得值</p>
</blockquote>
</li>
</ul>
<p>如果是一場串的，也是一樣的</p>
<p>當然還有 <strong><code>ToBoolean</code></strong> 的問題<br>
這邊先不討論<br>
<code>布林值</code> 跟 <code>布林物件</code> 是不一樣的</p>
<h2 id="位元運算">位元運算</h2>
<p>邏輯運算子是兩個符號湊在一起<br>
像 <code>&amp;&amp;</code> 、 <code>||</code><br>
看的是整體，而位元看的是個體</p>
<p>位元，會想到 2 進位<br>
也就是 <code>1001</code> 這類的<br>
那邏輯上哪裡不同 ?</p>
<h3 id="何謂整體與個體？">何謂整體與個體？</h3>
<h4 id="個體-位元運算">個體 <strong>(位元運算)</strong></h4>
<p>舉例運算 <strong><code>10 &amp; 15</code></strong><br>
先把兩者都變成2進位<br>
不足的話往前補零</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">         <span class="number">1010</span></span><br><span class="line"><span class="variable constant_">AND</span>      <span class="number">1111</span></span><br><span class="line">輸出     <span class="number">1010</span></span><br></pre></td></tr></table></figure>
<p>位元 <code>1010</code> 換十進位值是 <code>10</code><br>
所以 <code>10 &amp; 15 = 10</code></p>
<h4 id="整體-邏輯運算">整體 <strong>(邏輯運算)</strong></h4>
<p>一樣舉例 <code>10 &amp;&amp; 15</code><br>
兩者為真，最後為值<br>
所以 <code>10 &amp;&amp; 15 = 15</code>。</p>
<p>在 JS 輸入 <code>&amp;&amp;</code> 以及 <code>&amp;</code> 兩者會不一樣的</p>
<h3 id="位元運算符號">位元運算符號</h3>
<table>
<thead>
<tr>
<th style="text-align:center">符號</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp; (AND)</td>
<td>和邏輯運算一樣</td>
</tr>
<tr>
<td style="text-align:center">| (OR)</td>
<td>和邏輯運算一樣</td>
</tr>
<tr>
<td style="text-align:center">^ (XOR)</td>
<td>都一樣回傳 <code>0</code>，反之傳 <code>1</code></td>
</tr>
<tr>
<td style="text-align:center">~ (NOT)</td>
<td>把 <code>1</code> 變 <code>0</code>，反之 <code>0</code> 變 <code>1</code></td>
</tr>
</tbody>
</table>
<p>舉例 :</p>
<ol>
<li><code>10 &amp; 15 = 10</code></li>
<li><code>10 | 15 = 15</code></li>
<li><code>10 ^ 15 = 5</code></li>
<li><code>~ 10 = -11</code></li>
</ol>
<ul>
<li>前面空的位數都需要補零，在 NOT 才不會算錯</li>
</ul>
<blockquote>
<p>參考資料<br>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators">bitwise_operators</a></p>
</blockquote>
<h3 id="這能做什麼？">這能做什麼？</h3>
<p>從 <code>&amp;</code> 來看</p>
<ul>
<li><code>A &amp; 1</code> 尾數是 <strong><code>0</code></strong>  就是偶數</li>
<li><code>A &amp; 1</code> 尾數是 <strong><code>1</code></strong>  就是奇數</li>
</ul>
<p>這樣可以來判斷該數是 <code>偶數</code> 或 <code>基數</code><br>
不然以往我們要判斷時都要透過 <code>2 的餘數是不是 0</code><br>
也就是 <code>A % 2</code> 來判斷。</p>
<ol>
<li>來個實例，例如 5</li>
</ol>
  <figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">  101</span></span><br><span class="line"><span class="section">&amp;   1</span></span><br><span class="line"><span class="section">-----</span></span><br><span class="line"><span class="code">  001</span></span><br></pre></td></tr></table></figure>
<p>可以發現這個值的尾數是 1 ， 5 是奇數。</p>
<p>大概是這樣 XD</p>
<ol start="2">
<li>來個實例，例如 10</li>
</ol>
  <figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">  1010</span></span><br><span class="line"><span class="section">&amp;    1</span></span><br><span class="line"><span class="section">------</span></span><br><span class="line"><span class="code">  0000</span></span><br></pre></td></tr></table></figure>
<p>可以發現這個值的尾數是 0 ， 10 是偶數。</p>
<h2 id="位元進位">位元進位</h2>
<table>
<thead>
<tr>
<th style="text-align:center">符號</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&gt;&gt;</td>
<td>往右二進位</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td>往左二進位</td>
</tr>
</tbody>
</table>
<p>舉例 :</p>
<ul>
<li>10 &lt;&lt; 2 = 40</li>
<li>10 &gt;&gt; 2 = 2</li>
</ul>
<p>* 記得要先換成二進位。</p>
<h3 id="這能做什麼？-2">這能做什麼？</h3>
<ul>
<li><code>&lt;&lt; 1</code> 可以想成 <strong>乘以 2</strong></li>
<li><code>&gt;&gt; 1</code> 可以想成 <strong>除以 2</strong></li>
</ul>
<p>位元運算一般效能比較快</p>
<h2 id="結語-12">結語</h2>
<p>運算子其實有很多<br>
有用到再查好了<br>
我才知道原來有位元進位這東西<br>
不過實際的用途沒什麼概念</p>
]]></content>
      <categories>
        <category>2021</category>
        <category>8</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>紀錄 | UnityWebGL 輸出問題</title>
    <url>/2021/08/08/UnityWebGL-Output-Promblem.html</url>
    <content><![CDATA[<h2 id="前言-42">前言</h2>
<p>很不容易終於把案子的遊戲做出來了<br>
輸出 WebGL ，遇上不少問題</p>
<span id="more"></span>
<p>在與對方對接時都是使用 Github Pages 來呈現<br>
運行的很順利</p>
<p>沒想到遇到對方外包的網頁公司 <code>伺服器</code> 就不行了 QQ<br>
因為我也是第一次碰到這問題<br>
網頁不是我的專長，這下我也不知道怎麼辦</p>
<p>這篇稍微紀錄一下問題跟解決方式</p>
<blockquote>
<p>主要是 <code>MIME type</code> 的問題</p>
</blockquote>
<h2 id="遇到問題">遇到問題</h2>
<p><img data-src="https://chi01pap001files.storage.live.com/y4m8Z81Ua_QFAxCDEHu3CXVZNDlALhmbNSwT1XhMY0TSA9BscdtnomNnmQX5RP5WzdtaqXy5zYX0EiR8PJZJo03_Hk1LATCyDhLQ2vJkpbP4baeuDQB14elPoHRI061wVNDT9sZenz_5g-hWYGapBGfsv4Z60gWmUUXM_2oPLIcg1Bsij5JfL7Z5PpgMspsQO4F?width=660&amp;height=180&amp;cropmode=none" alt=""></p>
<p>console 顯示的是這兩個問題</p>
<ol>
<li>
<p>Invoking error handler due to<br>
<strong><code>Uncaught SyntaxError: Unexpected token '&lt;'</code></strong></p>
</li>
<li>
<p><strong><code>UnityModule is not defined</code></strong><br>
at UnityLoader.loadCode.Module (UnityLoader.js:4)<br>
at HTMLScriptElement.i.onload (UnityLoader.js:4)</p>
</li>
</ol>
<blockquote>
<p><strong>Uncaught SyntaxError: Unexpected token ‘&lt;’</strong><br>
根據 <a href="https://wcc723.github.io/development/2020/09/16/chrome-js-alert/">JavaScript 開發中常見錯誤解決辦法</a><br>
是指 <code>結構錯誤</code> 或者 <code>類型錯誤</code><br>
我想應該下面 not defined 問題造成的</p>
</blockquote>
<blockquote>
<p><strong>UnityModule is not defined</strong><br>
可以知道 unity 相關檔案好像沒被定義到<br>
導致 Unity 內容無法被呈現出來<br>
所以語法上關於 Unity 是會報錯的</p>
</blockquote>
<h2 id="剖析問題"><strong>剖析問題</strong></h2>
<p>這是目前有看到的<a href="https://answers.unity.com/questions/1397472/webgl-build-when-uploaded-gives-me-this-error-unca.html">解決方針</a><br>
針對 Undefined 的問題</p>
<h3 id="為何沒被定義"><strong>為何沒被定義</strong></h3>
<p>仔細拜讀一下文章提及的 <strong>MIME TYPE</strong><br>
關於伺服器端沒有包含這類的 <code>媒體類別</code><br>
也就是在後端中傳送出來認不得這個媒體是什麼<br>
所以才會出現 <code>UnityModule is not defined</code><br>
檔案中 <strong><code>.unityweb</code></strong> 是無法被讀取內容</p>
<blockquote>
<p>Github Pages 可以好好運行的原因<br>
<a href="https://docs.github.com/en/enterprise-server@2.22/pages/getting-started-with-github-pages/about-github-pages#mime-types-on-github-pages">官方有說 Pages 在這部分有支援 750 種</a><br>
因此普遍在開發上才不會特別有問題<br>
真的是太甘心了 QQ</p>
</blockquote>
<h3 id="何謂-MIME-TYPE-媒體類別">何謂 MIME TYPE (媒體類別)</h3>
<p>常見的就是 <code>text/css</code> 或 <code>text/plain</code></p>
<p>根據 <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MDN 說明</a><br>
基本形式是長這個樣子  <code>type/subtype</code><br>
也可以加參數<br>
<code>type/subtype;parameter=value</code><br>
EX : <code>text/plain;charset=UTF-8</code></p>
<p>很熟悉吧<br>
就是常常在 head 裡面寫的 <code>link</code> 或 <code>script</code> 格式<br>
有些特殊的媒體檔案一樣也可以透過這樣的方式加入</p>
<h4 id="有哪些媒體類型">有哪些媒體類型?</h4>
<p>這邊我還不是很清楚<br>
但好像有分很多種樣式<br>
總之有分 <code>標準</code> 與 <code>非標準</code><br>
非標準前面會有 <code>x-</code> 開頭<br>
區分的是 IANA 是否經過認證而定</p>
<blockquote>
<p><a href="https://www.freeformatter.com/mime-types-list.html">很詳細的網站</a></p>
</blockquote>
<p>透過搜尋就可以找到 <code>.unityweb</code><br>
接著就想辦法安插進去</p>
<h2 id="解決問題">解決問題</h2>
<p>根據 <a href="https://answers.unity.com/questions/1397472/webgl-build-when-uploaded-gives-me-this-error-unca.html">解決方針</a></p>
<ol>
<li>開啟一個新 txt 檔</li>
<li>把檔案另存成 <strong><code>web.config</code></strong></li>
<li>用 IDE 打開，貼上下面那串</li>
<li>讓 <code>index.html</code> 更新一次</li>
</ol>
<p>簡單來說，要讓專案初始化的時候知道 <code>.unityweb</code> 是誰就好了</p>
<blockquote>
<p>得解 : 新增關於 Unity 的 <strong>MIME TYPE</strong></p>
</blockquote>
<pre><code class="language-XML"> &lt;configuration&gt;
      &lt;system.webServer&gt;
         &lt;staticContent&gt;
            &lt;mimeMap fileExtension=&quot;.unityweb&quot; mimeType =&quot;TYPE/SUBTYPE&quot; /&gt;
         &lt;/staticContent&gt;
      &lt;/system.webServer&gt; 
   &lt;/configuration&gt;
</code></pre>
<h3 id="了解其運作">了解其運作</h3>
<h4 id="什麼是-web-config-檔？"><strong>什麼是 <code>web.config</code> 檔？</strong></h4>
<p>我以為是自訂義檔名，結果這個檔很特別哦 !</p>
<p>根據 <a href="https://docs.microsoft.com/zh-tw/aspnet/core/host-and-deploy/iis/web-config?view=aspnetcore-5.0">MS 官方開發說明</a></p>
<ul>
<li>是 IIS 所讀取的檔案， <code>web.config</code> 以及用來設定以 iis 託管之應用程式的 <a href="http://ASP.NET">ASP.NET</a> Core 模組 。</li>
</ul>
<p>這個檔案在建置 <a href="http://ASP.NET">ASP.NET</a> 的時候就會建置了<br>
而且是每一層都會有<br>
如果 <code>子層</code> 沒有，就會吃 <code>父層</code> 的<br>
再沒有就 <code>祖父層</code> …</p>
<p>很好，跨謀 :D …<br>
查了一下別人怎麼解釋</p>
<p><code>web.config</code> 是對網站的設定檔，包含很多像是</p>
<ul>
<li>設定 <code>application</code> 中的各種 settings (裝置)</li>
<li><code>settings</code> 包含如何呈現網頁</li>
<li>如何 <code>compile</code> 網頁程式</li>
<li><code>session state</code> 的管理</li>
<li><code>security</code> 的控管、…等等。</li>
</ul>
<p>我的理解是網頁一打開幫你設定端口、讀取型態之類<br>
<code>congfig</code> 就是對整體專案在初始化時的設定。</p>
<p>在 <code>html檔</code> 最前面其實就有設定這些東西<br>
我也不太清楚</p>
<blockquote>
<p>直接來看，如何設定一個 MIME TYPE</p>
</blockquote>
<ul>
<li>
<p><strong><code>mimeMap</code></strong> <a href="https://docs.microsoft.com/zh-tw/iis/configuration/system.webServer/staticcontent/mimemap">MS 官方文件</a></p>
<pre><code class="language-html">&lt;mimeMap fileExtension=&quot;.unityweb&quot; mimeType =&quot;TYPE/SUBTYPE&quot; /&gt;
</code></pre>
<ul>
<li><code>fileExtension</code> 寫檔案類型</li>
<li><code>mimeType</code> 這邊好像是因為 <code>.unityweb</code> 是標準寫法<br>
只要套個形式就可以吃到值<br>
應該可以寫 <code>application/vnd.unity</code></li>
</ul>
<blockquote>
<p>* 為什麼說應該，因為我無法測試，伺服器是客戶的<br>
我並不知道結果與過程</p>
</blockquote>
</li>
</ul>
<h4 id="關於-system-webServer">關於 <strong>&lt;system.webServer&gt;</strong></h4>
<p><a href="https://www.cnblogs.com/xcsn/p/6939628.html">Web.config设置system.webServer</a><br>
這篇提到一般在 web 上是不用特定去設定的<br>
有時候會遇到一些需要複雜的情況需要去特別設定</p>
<blockquote>
<p>需要修改 <code>system.webServer</code> 節的三個常見配置任務：</p>
<ol>
<li>添加默認檔，以便在請求 URL 未包含特定的檔時，提供該默認檔。</li>
<li>註冊託管代碼模組。</li>
<li>添加自訂回應標頭。</li>
</ol>
</blockquote>
<p>本次的問題看起來比較偏  <s>1</s>。</p>
<p>本篇下面還有提到文件要加入 <strong><code>remove</code></strong><br>
避免檔案 <strong><code>已存在</code></strong> 的情況下導致錯誤訊息<br>
變這樣</p>
<pre><code class="language-XML">&lt;remove fileExtension=&quot;.unityweb&quot; /&gt;  
  &lt;mimeMap fileExtension=&quot;.unityweb&quot; mimeType =&quot;TYPE/SUBTYPE&quot; /&gt;
</code></pre>
<h2 id="補充">補充</h2>
<p>放在不同的伺服器好像有不同的寫法<br>
看到 <code>Azure</code> 跟 <code>Aapche Server</code> 好像有點不太一樣<br>
可能之後才能理解 QQ</p>
<blockquote>
<p>參考<br>
<a href="https://forum.unity.com/threads/solved-unity-2020-webgl-doesnt-work-uncaught-syntaxerror-invalid-or-unexpected-token.872581/">[SOLVED] Unity 2020 WebGL Doesn’t work Uncaught SyntaxError: Invalid or unexpected token</a></p>
</blockquote>
<p>一方面好像跟 Unity 輸出時的檔案壓縮方式有關<br>
官方在解說關於 <a href="http://docs.unity3d.com/2019.3/Documentation/Manual/webgl-deploying.html">輸出的部分</a> 非常詳細<br>
也包含這次 IIS 組態的問題</p>
<h2 id="結論">結論</h2>
<p>今天算急件<br>
所以有不少細節忽略過去<br>
要再找時間吸收一下了 QQ<br>
怕下一個專案也有同問題<br>
極速的做個紀錄</p>
<p>將 config 弄好後，沒多久對方說 「沒問題了~」<br>
我也看不到結果，對方說沒問題就 OK 了吧</p>
<p>就在懵懵懂懂之間解決掉，我心想</p>
<center>
<p><strong>「奇怪的知識又增加了」</strong></p>
<p><img data-src="https://chi01pap001files.storage.live.com/y4myqjbK3Roj7WjrEv-CzkHhAcpNzI46qzCFneGbIYW8EydJa7kmtireeyC3ojmny-WWeh3T9f71khS4CDv15xeGvn7aZbKcq_-hznr8KZbFlmDi433AFKO4jB4hHeD1r27bKNSEtsqXyh9Tn9m4WYkkMxLN0EGWallC22EW4DCRK4RwRt6H9Fl1QKTBfWg1Zxp?width=584&amp;height=421&amp;cropmode=none" alt=""></p>
</center>  
<blockquote>
<p>參考資料 :</p>
</blockquote>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5">維基百科_Http表頭</a></li>
<li><a href="http://docs.unity3d.com/2019.3/Documentation/Manual/webgl-deploying.html">WebGL: Deploying compressed builds</a></li>
<li><a href="https://blog.xuite.net/ghel0915/nblog/21685755">ASP.NET不可或缺的組態檔→Web.config</a></li>
<li><a href="https://answers.unity.com/questions/1397472/webgl-build-when-uploaded-gives-me-this-error-unca.html">WebGL build error :Uncaught SyntaxError: Unexpected token &lt; || UnityLoader.js is not a function (SOLVED)</a></li>
<li><a href="https://www.cnblogs.com/xcsn/p/6939628.html">Web.config设置system.webServer</a></li>
<li><a href="https://stackoverflow.com/questions/3828352/what-is-a-mime-type">很不錯的解釋文_What is a MIME type?</a></li>
</ol>
]]></content>
      <categories>
        <category>2021</category>
        <category>8</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | CSS 預處理器 Sass 介紹&amp;安裝</title>
    <url>/2021/11/11/CSS-Sass-01.html</url>
    <content><![CDATA[<h2 id="前言-43">前言</h2>
<p>CSS 寫到一個程度後<br>
有點難以去維修<br>
大量的大括號以及分號<br>
使得架構越來越龐大<br>
在我苦惱 CSS 跟我一樣肥的時候<br>
剛好認識了 <strong>CSS 預處理器</strong></p>
<span id="more"></span>
<p>簡單來說的話就是可以 <strong>用程式的方式</strong> 來寫 CSS<br>
於是來紀錄關於學習 Sass 的事<br>
根據 <a href="https://lidemy.com/p/fe201">[FE201] 前端中階：那些前端會用到的工具們</a> 學習的雜記</p>
<hr>
<h2 id="CSS-預處理器">CSS 預處理器</h2>
<p>學習新工具時了解工具的誕生<br>
更能知道使用時機</p>
<h3 id="預處理器的誕生">預處理器的誕生</h3>
<p>現在網站的樣式越來越華麗<br>
CSS 越寫越龐大<br>
甚至會有重複寫的情形<br>
導致在 debug 上變得不易<br>
於是出現各種 CSS 預處理器<br>
像是 <code>Sass</code> 、 <code>LESS</code> 、 <code>Stylus</code></p>
<p>是使用程式的邏輯在寫樣式<br>
簡單來說更快速<br>
畢竟沒人想要重複罰寫吧 QQ<br>
當然不同的預處理器各有自己的優點<br>
但如果學會一套<br>
基本上都可以無痛跳轉別的<br>
只差在一些符號上的差異</p>
<h3 id="預處理器的處理方式">預處理器的處理方式</h3>
<p>我們知道瀏覽器只看得懂三個東西</p>
<ol>
<li>HTML</li>
<li>CSS</li>
<li>Javascript</li>
</ol>
<p>蛤！你說這樣我寫 Sass 有什麼用嗎？</p>
<p>NO NO , 所以寫完 <code>Sass</code> 後<br>
還要經過 Compiler ( 編譯器 ) 成 CSS 檔<br>
瀏覽器才知道這個樣式長圓的還扁的<br>
大概是這樣子<br>
<img data-src="https://i.imgur.com/E9vfSTE.png" alt="CSS 變身過程"></p>
<h3 id="小結-2">小結</h3>
<blockquote>
<p>預處理器提供程式化的方法來寫 CSS<br>
使 CSS 更有結構的來管理</p>
</blockquote>
<h2 id="Sass-、-Scss-傻傻搞不清楚">Sass 、 Scss 傻傻搞不清楚</h2>
<p><a href="https://sass-lang.com/">Sass</a> 是蠻多人在用的一款 CSS 預處理器<br>
但在講 Sass 之前<br>
可能還聽過 Scss<br>
而且通常會一起講<br>
所以 Scss 跟 Sass 是什麼關係？</p>
<h3 id="Sass-v-s-Scss">Sass v.s Scss</h3>
<p>在 <a href="https://sass-lang.com/guide">官方的文件</a> 中<br>
可以看到 Sass 跟 Scss 是差不多的<br>
<code>Sass</code> 比 <code>Scss</code> 少了 <strong>大括號</strong> 跟 <strong>分號</strong><br>
相容性上 Scss 可以無痛跨 CSS<br>
檔名 <code>.scss</code> 改成 <code>.css</code> 沒什麼太大問題<br>
因為結構相同<br>
Sass 直接轉換成 css 就打妹了</p>
<p>讓我想起大學時期學網頁為什麼不先學 Sass<br>
而是用 Scss 的原因了<br>
不然初學者的成就感就會被磨光光 XD</p>
<h2 id="Sass-基本指令">Sass 基本指令</h2>
<h3 id="安裝-Sass">安裝 Sass</h3>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> sass </span><br><span class="line">sass <span class="literal">--version</span> // 查看版本是否有安裝成功</span><br></pre></td></tr></table></figure>
<p>看到版本之後就對了！<br>
在使用 Sass 的 cli 就好</p>
<h3 id="把-Sass-檔轉換成-CSS-檔">把 Sass 檔轉換成 CSS 檔</h3>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sass [<span class="type">input</span>].sass [<span class="type">output</span>].css</span><br></pre></td></tr></table></figure>
<ul>
<li><code>input.sass</code> 是指要轉換的 sass 檔</li>
<li><code>output.css</code> 是轉換出來的 css 檔</li>
</ul>
<blockquote>
<p>也可以加上 <code>--watch</code> 隨時監聽檔案變化</p>
</blockquote>
<p>Like this ！</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sass <span class="literal">--watch</span> [<span class="type">input</span>].sass [<span class="type">output</span>].css</span><br></pre></td></tr></table></figure>
<p>按下 save 後 ，檔案會自動轉換<br>
<img data-src="https://i.imgur.com/Yc6zMa4.png" alt="有點像自動儲存再轉換"></p>
<h3 id="最小化-minify-檔案">最小化 (minify) 檔案</h3>
<p>最小化是讓檔案的體積更小<br>
會將不必要的空白刪除<br>
只留下精華 :D</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sass <span class="literal">--style</span> compressed [<span class="type">input</span>].sass [<span class="type">output</span>].css</span><br></pre></td></tr></table></figure>
<p>會發現檔案都被壓縮成一排</p>
<h3 id="小結-3">小結</h3>
<p>指令複習一遍</p>
<ol>
<li><code>npm install -g sass</code> : 安裝</li>
<li><code>sass --watch [input].sass [output].css</code> : 轉換</li>
<li><code>sass --style compressed [input].sass [output].css</code> : 壓縮</li>
</ol>
<p>sass 跟 scss 一樣<br>
所以以此類推把 sass 的部分換成 scss 就可以了</p>
<h2 id="Sass-做了什麼">Sass 做了什麼 ?</h2>
<p>我們知道預處理器的作用<br>
會發現把 <code>.sass</code> 轉換成 <code>.css</code> 時<br>
還會出現一個叫 <code>.map</code> 的檔案<br>
就是 source map</p>
<h3 id="什麼是-source-map-？">什麼是 source map ？</h3>
<p><code>source map</code> 就是儲存了原始碼與編譯後程式碼 <strong>對應關係之檔案</strong><br>
一般 devtool 會用來除錯用</p>
<blockquote>
<p>Wait！ Wait！ What？</p>
</blockquote>
<p>阿不是說瀏覽器只能看得懂一般的 CSS？<br>
那你有想過萬一你是 <code>sass</code> 樣式想改<br>
不會是要一行行回推到 CSS 吧！</p>
<p>所以這時候就得靠 <code>source map</code><br>
簡單來說需要透過 map 去引導檔案 sass 的行數<br>
在 devtool 上就可以除錯<br>
哇嗚這我還真不知道…<br>
那我想如果其他 library 也是出現map<br>
也是為了導向原始的編輯檔去<br>
蠻聰明的</p>
<p>另一個小知識就是 :</p>
<blockquote>
<p>source map 不會影響網站載入速度與一般使用者的體驗</p>
</blockquote>
<p>不過這部分因為暫時不會涉及到很深<br>
所以我沒有研究<br>
有興趣的人可以到下面這篇文章</p>
<ul>
<li>關於 <code>sourceMap</code> 的文章 :<br>
<a href="https://blog.techbridge.cc/2021/03/28/how-source-map-works/#post-comment-wrapper">Source map 運作原理 (techbridge.cc)</a></li>
</ul>
<h2 id="總結-24">總結</h2>
<p>sass 的優點還有實戰使用還沒提及<br>
將在下一篇文章說明<br>
目前正在嘗試每個小作品都使用 sass<br>
讓自己的熟練度更加提升<br>
GOGO！</p>
]]></content>
      <categories>
        <category>2021</category>
        <category>11</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | CSS 預處理器 Sass 結構化&amp;模組化</title>
    <url>/2021/11/11/CSS-Sass-02.html</url>
    <content><![CDATA[<h2 id="前言-44">前言</h2>
<p>上篇了解 CSS 預處理器的運作<br>
跟 Sass 的安裝<br>
接下來要認識 Sass 的使用了！<br>
一樣根據 <a href="https://lidemy.com/p/fe201">[FE201] 前端中階：那些前端會用到的工具們</a><br>
這堂課的隨堂筆記<br>
若有誤請指教</p>
<p>接下來會提到幾個常用的功能</p>
<h2 id="結構化">結構化</h2>
<p>想一下如果每次都要抓色票<br>
都要複製 6 碼<br>
是一件蠻麻煩的事<br>
呈上篇介紹&amp;安裝所講的<br>
預處理器是套用程式的概念來寫樣式<br>
在程式邏輯中如果重複出現的東西<br>
最好想辦法簡單化<br>
因此結構化地處理可以使的維修更快速<br>
就必須講到兩個東西</p>
<ol>
<li>自訂義變數</li>
<li>巢狀結構</li>
</ol>
<h3 id="變數-variable">變數 ( variable )</h3>
<blockquote>
<p><code>$variable</code> : <code>css value</code></p>
</blockquote>
<p>用 <code>$</code> 符號來表示定義變數<br>
當然別跟 <code>JQuery</code> 的 <code>$</code> 搞混了<br>
兩個沒什麼關係</p>
<p>在 Sass 中可以自訂義多組變數<br>
使用上 :</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$color-primary</span>: <span class="number">#eee</span></span><br><span class="line"><span class="variable">$h1</span>: <span class="number">1.6rem</span></span><br></pre></td></tr></table></figure>
<p>不過最近的 CSS 已經可以自訂義變數了<br>
只是是用 <code>var</code> 也就是全域變數</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">  <span class="attr">--text-color</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--text-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有興趣可以讀一下 MDN 的文件<br>
目前我還沒有研究這部分 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties">Using CSS custom properties</a><br>
但不代表可以完全替代 Sass<br>
泛用 <code>var</code> 全域變數其實是不太方便的</p>
<h3 id="巢狀-nesting">巢狀 ( nesting )</h3>
<p><code>HTML</code> 也是一層層像洋蔥皮<br>
<code>Sass</code> 也可以堆疊<br>
整體來說沒有 CSS 那麼囉嗦</p>
<ul>
<li>
<p>以往 css 寫要這樣</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu__listgroup</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu__listgroup</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Sass</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu</span></span><br><span class="line">  <span class="attribute">color</span>: red</span><br><span class="line">  &amp;.listgroup</span><br><span class="line">    background-color:blue</span><br><span class="line">  &amp;.listgroup:hover</span><br><span class="line">    color:white</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&amp;</code> 是指 上一層的本身元素<br>
這樣可以不用重複撰寫</li>
<li>如果是寫<code>:hover</code>、<code>::before</code> 這些也可以<br>
例 : <code>&amp;:hover</code> <code>&amp;::before</code></li>
</ul>
</li>
</ul>
<p>噹噹！這樣不用重複罰寫多棒 QQ</p>
<h3 id="小結-4">小結</h3>
<ol>
<li>自訂義變數用 <code>$</code></li>
<li>重複提起自己用 <code>&amp;</code></li>
</ol>
<h2 id="模組化">模組化</h2>
<p>就像 javascript 一樣可以 <code>import</code></p>
<h3 id="import-use">@import  &amp; @use</h3>
<p>這兩者都是可以引入</p>
<ul>
<li>@import<br>
引入其他檔案的 sass</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// style.sass</span></span><br><span class="line"><span class="keyword">@import</span> __variables(.sass)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>__variables</code> 是變數檔案命名習慣<br>
<code>__mixins</code> 以此類推<br>
這樣可以直接使用裡面的內容</p>
</blockquote>
<ul>
<li>@use<br>
跟 import 很像，但可以另外訂 namespace</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// style.sass</span></span><br><span class="line"><span class="keyword">@use</span> __variables(.sass) as variable</span><br></pre></td></tr></table></figure>
<p>引用就像 object 一樣<br>
例 : <code>variable.color</code></p>
<h3 id="extend">@extend</h3>
<p>利用 <code>%</code> 百分比符號來表示 <strong>模板</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">%btn</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">50px</span></span><br><span class="line">	height:<span class="number">50px</span></span><br><span class="line">	background:$btn-color</span><br></pre></td></tr></table></figure>
<ul>
<li>使用的時候用 <code>@extend</code></li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">	<span class="keyword">@extend</span> %btn</span><br></pre></td></tr></table></figure>
<h3 id="mixin">@mixin  &amp; +</h3>
<p>把想要的元件內容包裝起來<br>
可以 <strong>帶變數</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 不帶變數</span><br><span class="line"><span class="keyword">@mixin</span> hover-btn</span><br><span class="line">	&amp;:<span class="attribute">hover</span></span><br><span class="line">		transition : .<span class="number">3s</span></span><br><span class="line">	</span><br><span class="line">// 帶變數 ($<span class="attribute">Value</span>:default value)</span><br><span class="line">@mixin btntemp ($<span class="attribute">bg-color</span>:grey)</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">50px</span></span><br><span class="line">	<span class="attribute">height</span>:<span class="number">50px</span></span><br><span class="line">	<span class="attribute">background</span>:$bg-color</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<ul>
<li>使用的時候</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">	btn</span><br><span class="line">	+hover-btn</span><br><span class="line">	+<span class="built_in">btntemp</span>(red) <span class="comment">//如果沒有填的話就是預設 grey</span></span><br></pre></td></tr></table></figure>
<h3 id="function-return">@function &amp; @return</h3>
<p>可以寫一個函式回傳值</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@function</span> btn-size($size)</span><br><span class="line">	@return $size * .<span class="number">1rem</span></span><br><span class="line">	</span><br><span class="line">.btn</span><br><span class="line">	<span class="attribute">font-size</span>: btn-size(<span class="number">2</span>)  </span><br><span class="line">// 結果就是 <span class="number">0.2rem</span></span><br></pre></td></tr></table></figure>
<h3 id="小結-5">小結</h3>
<ol>
<li><code>@import</code>、<code>@use</code> 都是拿來引入的，<code>@use</code> 可以自訂義名稱</li>
<li><code>%</code> 是寫模板用的。<code>@extend</code> 是在 className 裡引入模板用。</li>
<li><code>@mixin</code> 可以加入參數，但不會回傳<br>
使用時用 <code>@include</code>  或 <code>+</code></li>
<li><code>@function</code> 可以加入參數，使用 <code>@return</code> 回傳</li>
</ol>
<h2 id="個別差別">個別差別</h2>
<p>有些功能會讓人混淆<br>
有一些小小差別<br>
不過用的 OK 其實都行</p>
<h3 id="import-v-s-use">@import v.s @use</h3>
<table>
<thead>
<tr>
<th></th>
<th>@import</th>
<th>@use</th>
</tr>
</thead>
<tbody>
<tr>
<td>差別</td>
<td>純引入位址</td>
<td>引入可以加 namespace</td>
</tr>
</tbody>
</table>
<p><code>@use</code> 比較客製化<br>
在命名上比較不會混亂</p>
<h3 id="extend-v-s-mixin-2">@extend v.s @mixin</h3>
<p>兩者都可以模組化需要的東西</p>
<table>
<thead>
<tr>
<th></th>
<th>@extend</th>
<th>@mixin</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用用處</td>
<td>純模板</td>
<td>可以帶參數微調的模板</td>
</tr>
<tr>
<td>用法</td>
<td>固定的部件(按鈕的外觀形狀)</td>
<td>附加的屬性(按鈕客製顏色)</td>
</tr>
<tr>
<td>產出差別</td>
<td>同樣的東西以逗號隔開</td>
<td>個別獨立出來</td>
</tr>
</tbody>
</table>
<ul>
<li>可以這樣用</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">%btn</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">50px</span></span><br><span class="line">	width: <span class="number">50px</span></span><br><span class="line">	padding : <span class="number">5px</span></span><br><span class="line"></span><br><span class="line">@mixin <span class="built_in">btn_color</span>($color:<span class="number">#eee</span>)</span><br><span class="line">		background-color:$color  </span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span></span><br><span class="line">	<span class="keyword">@extend</span> %btn</span><br><span class="line">	&amp;:nth-child(odd)</span><br><span class="line">		+btn_<span class="attribute">color</span>(red)</span><br><span class="line">	&amp;:nth-child(even)</span><br><span class="line">		+btn_<span class="attribute">color</span>(blue)		</span><br></pre></td></tr></table></figure>
<p>範例 : 產出的差別<br>
<img data-src="https://i.imgur.com/ndmDRQY.png" alt="針對不同的按鈕"></p>
<ol>
<li><code>@extend</code> : 產生同樣模板的東西會以逗號隔開<br>
<img data-src="https://i.imgur.com/RMcBMOl.png" alt="extend產出"></li>
<li><code>@mixin</code> 則是會個別獨立，重新複製貼上<br>
<img data-src="https://i.imgur.com/tkgByt1.png" alt="mixin產出"></li>
</ol>
<p>以效能上來說<br>
重複性值的屬性 <code>@extend</code> 比較好<br>
因為用字數較少<br>
容量自然就小一點</p>
<h3 id="mixin-v-s-function">@mixin v.s @function</h3>
<table>
<thead>
<tr>
<th></th>
<th>@mixin</th>
<th>@function</th>
</tr>
</thead>
<tbody>
<tr>
<td>常使用</td>
<td>多項同個元件</td>
<td>單個屬性回傳值</td>
</tr>
<tr>
<td>用法</td>
<td>一塊跨頁的部件</td>
<td>一些特定狀況時回傳，通常會在 mixin 裡面</td>
</tr>
</tbody>
</table>
<p>因為我比較少用到 <code>@function</code> 的用法<br>
不過可以拿 boostrap 的檔案來看<br>
<img data-src="https://i.imgur.com/6bnQPlz.png" alt="boostrap 圓角"><br>
boostrap 也是使用 sass<br>
針對條件來寫判斷以及迴圈更快產生樣式<br>
簡單來說</p>
<blockquote>
<p>boostrap 已經幫你寫好一堆 css</p>
</blockquote>
<p>以常見的 <code>h1~h6</code> <code>mt-1~-4(margin-top)</code><br>
當然不會一個個寫<br>
而是利用 Sass 的 <code>loop</code> 以及 <code>mixin</code> 寫響應<br>
來產生一系列的功能<br>
有興趣的可以下載 boostrap 官方文件看看<br>
也能更知道實際這些功能的應用何在</p>
<h2 id="結語-13">結語</h2>
<p>知道基本的功能在撰寫 CSS 時<br>
可以更加簡潔！<br>
Sass 還有 <code>loop</code> 以及 <code>if-else</code> 判斷式<br>
<code>loop</code> 在動畫上的搭配就可以更加靈活<br>
我覺得可能要多看一些例子才知道怎麼應用在專案上 QQ<br>
雖然官方寫得算清楚<br>
但我看倒像是綠豆糕 QQ</p>
<hr>
<p>參考資料 :<br>
<a href="https://sass-lang.com/documentation">Sass Documentation</a></p>
]]></content>
      <categories>
        <category>2021</category>
        <category>11</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - fetch 獲取遠端資料</title>
    <url>/2022/06/JavaScript/JavaScript-fetch.html</url>
    <content><![CDATA[<h2 id="前言-45">前言</h2>
<p>想要獲取遠端的資料可以使用 AJAX ，在 ES6 之前大多會使用 JQuery 的 <code>$.ajax</code>  或者原生的 XHR，而在 HTML5 則提供 fetch 使用，更多時候會使用 axios 套件。<br>
本篇記錄 fetch 的使用方式與常見的使用誤區。</p>
<span id="more"></span>
<h2 id="fetch">fetch</h2>
<p>fetch 是 HTML5 原生獲取遠端的方式，其操作也十分簡單</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url)</span><br><span class="line"><span class="title function_">fetch</span>(url,&#123;obj&#125;) <span class="comment">// 第二個參數為 options</span></span><br></pre></td></tr></table></figure>
<p>沒有 options 的物件，只有網址的話是 <code>GET</code>。<br>
fetch 回傳的是一個 Promise 物件，Promise 簡單來說是 <strong>處理非同步操作的特殊物件</strong>，有關於 Promise 之後會再補充。</p>
<h3 id="then-catch">then &amp; catch</h3>
<p>如果要拿到回傳的 response ，可以透過 <code>then</code>。要接 .then 前面的物件必要類型為 Promise，而 <code>fetch()</code> 回傳的就是一個 Promise 物件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> endPoint = <span class="string">&#x27;https://restcountries.com/v3.1/name/Taiwan&#x27;</span></span><br><span class="line"><span class="title function_">fetch</span>(endPoint).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>是 <code>fetch().then</code> 而不是 <strong>fetch.then</strong>，是 fetch 這個函式裡面回傳 Promise</p>
</blockquote>
<p>then 接收的參數是 Promise 中 resolve 或是 reject 的函式運行的結果，通常是 resolve，如果是 reject 則會用 <code>.catch</code> 來作錯誤處理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(endPoint).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>會被丟進 catch 處理的 err 並不是像 XHR status 404 或 500 這類的，而是可能網路連線錯誤或者網址有誤導致不能發出 request 。</p>
<h3 id="HTTP-狀態碼處理-Response-status-Response-ok">HTTP 狀態碼處理 Response.status &amp;  Response.ok</h3>
<p>只要是 HTTP 狀態碼 400 以上的我們通常會在 XHR 做錯誤處理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">err</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>但是 fetch 不管狀態碼多少，只要有正確的發出請求後回傳的 response 都會進入 resolve ，如果要處理像 onerror 的錯誤可以透過 .then 中 response 的 status 或 ok。</p>
<ul>
<li>response.status : 回傳結果的 HTTP code</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(endPoint).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>) <span class="comment">// 200 代表成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>response.ok : 回傳 boolean ，如果 HTTP code 在 200~299 就回傳 true</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(endPoint).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(response.<span class="property">ok</span>)&#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">		&#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Response-text-json">Response.text() &amp; .json()</h3>
<p>可以將 response 解析成想要的形式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(endPoint).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> response.<span class="title function_">text</span>()</span><br><span class="line">	<span class="comment">// return response.json() 兩者擇一</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>.text()</code> : 直接印出文字</li>
<li><code>.json()</code> : 自動幫我們解析 json 格式的資料</li>
</ul>
<p>其他種類的格式 :</p>
<ul>
<li><code>.blob()</code>：把資料轉成Blob物件</li>
<li><code>.formData()</code>：把資料轉成FormData物件</li>
<li><code>.arrayBuffer()</code>：把資料轉成二進制數組</li>
</ul>
<blockquote>
<p>這些方法 <strong>只能擇一</strong>，一但被解析過就不能重複再使用其他的函式解析了。</p>
</blockquote>
<h2 id="POST">POST</h2>
<p>POST 也很簡單，跟 <code>$.ajax()</code> 的操作很像</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二個參數可以攜帶 header 、body 或 Http 等資訊</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;<span class="attr">name</span>:<span class="string">&#x27;Rosa&#x27;</span>&#125;</span><br><span class="line"><span class="title function_">fetch</span>(endPoint,&#123;</span><br><span class="line">	<span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data),</span><br><span class="line">  <span class="attr">headers</span>: <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>fetch 的 options 還有包含其他常見的 HTTP 處理，<br>
在 body 中如果我們要上傳的格式是 JSON 檔，記得要將內容轉換成 JSON 格式。</p>
<blockquote>
<p><strong>GET 與 HEAD 是沒有 body 的</strong></p>
</blockquote>
<h2 id="fetch-的-Headers">fetch 的 Headers</h2>
<p>以往在 XHR 要加上 Header</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">XMLHttpRequest</span>.<span class="title function_">setRequestHeader</span>(header, value);</span><br></pre></td></tr></table></figure>
<p>在 fetch 要加上 Header，可以直接加，或者 new 出一個 Header 容器來放置所需的內容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接使用 headers</span></span><br><span class="line"><span class="title function_">fetch</span>(url,&#123;</span><br><span class="line">	<span class="attr">headers</span>:&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//透過實例出一個 Headers</span></span><br><span class="line"><span class="title function_">fetch</span>(url,&#123;</span><br><span class="line">	<span class="attr">headers</span>: <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Content-Type">Content Type</h3>
<p>表單 或是 JSON 格式資料</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JSON</span></span><br><span class="line">&#x27;Content-Type&#x27;<span class="punctuation">:</span> &#x27;application/json&#x27;</span><br><span class="line"><span class="comment">// 表單</span></span><br><span class="line">&#x27;Content-Type&#x27;<span class="punctuation">:</span> &#x27;application/x-www-form-urlencoded&#x27; </span><br></pre></td></tr></table></figure>
<h3 id="credentials">credentials</h3>
<p>預設上不會自動帶上或接收任何 cookies，如果網站依賴 session 會導致請求回傳未經認證，想把 cookies 一起帶上，要加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url,&#123;</span><br><span class="line">	<span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="對-mode-的誤解">對 mode 的誤解</h2>
<p>發送 request 可能會遇到 CORS 的限制，fetch 中mode 提供 <code>'no-cors'</code> 的方法，乍看之下會以為能突破 CORS 限制，既不會跳出錯誤 (不會跳到 .catch)，也能發出 request ，但 <strong>response 的 status 是 0 ，body 是空的</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url,&#123;</span><br><span class="line">	<span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">	<span class="attr">headers</span>: <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line">		<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">	&#125;),</span><br><span class="line">	<span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;Rosa&#x27;</span>&#125;),</span><br><span class="line">	mode : <span class="string">&#x27;no-cors&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="title function_">json</span>())</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>麻瓜翻譯機 :<br>
不會回傳錯誤，也不會突破 CORS 的限制<br>
避免發生錯誤，硬要丟出一個 request ，還你一個安心 response，裡面包含沒東西的 body 以及 status 為 0 。</p>
</blockquote>
<p>CORS 的限制是後端要解決，前端無法直接實現掛跨 CORS。</p>
<h2 id="為什麼-XMLHttpRequest-還是存在">為什麼 XMLHttpRequest 還是存在 ?</h2>
<p>我們都知道 XHR 寫起來有點囉嗦，在 fetch 問世之後，除了支援舊的瀏覽器會使用到 XHR，現代開發大多還是使用 fetch，但是 XMLHttpRequest 並沒有被廢棄，因為 fetch 還是有些功能是無法做到的。</p>
<p>**fetch 做不到 : **</p>
<ol>
<li>上傳進度追蹤，fetch 必須搭配其他的 API 才能做到，</li>
<li>錯誤的回應處理<br>
fetch 不管 HTTP 404 還是 500 ，也還是會 resolve，代表 <strong>你確實有送出 request</strong>，<code>.catch</code> 會抓到的錯誤只會是 <strong>網路錯誤或其他會中斷 request 的情況</strong>。對於錯誤的處理不是那麼直覺。</li>
<li>中斷  (absort) fetch<br>
目前沒有直接中斷 fetch (Promise) 的方法，不像 XHR 提供 <code>.absort()</code>，但是 WebAPIs 有提供 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/AbortController#browser_compatibility">AbortController</a> 可以讓 fetch 做到中斷，目前為實驗性(?)<br>
<a href="https://mdn.github.io/dom-examples/abort-api/">MDN 提供的範例</a>，讓你突然不想看影片的時候，停止發出 request。</li>
<li>逾時處理 (timeout)<br>
XHR 逾期的時候可以暫停發出請求，第三點也提到 fetch 因為沒有中斷的功能，無法做到。</li>
</ol>
<h2 id="補充-幾種發-request-的方法">補充 : 幾種發 request 的方法</h2>
<p>以下都會使用 GET 為例</p>
<ol>
<li>XHR <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(url)</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">response</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(response.<span class="property">state</span>&gt;=<span class="number">200</span> &amp;&amp; response.<span class="property">state</span> &lt;=<span class="number">400</span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure>
</li>
<li>JQuery <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">	method : <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">	url : url</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">done</span>(<span class="keyword">function</span>(<span class="params">response</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">fail</span>(<span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li>fetch <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li>axios <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(url)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line"> &#125;)</span><br><span class="line"> .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="結語-14">結語</h2>
<p>在我學習 JavaScript 這段期間，講到遠端取資料，很多教學並不會提到 fetch 或是 XMLHttpRequest，反而是叫你直接使用 axios，畢竟重新造輪子是很麻煩的 🥴，不過 fetch 無疑的是會越來越完善，不論是用何者工具或手法必有一定誕生的理由，了解原理後開發都可以更得心應手。</p>
<p>我蠻喜歡<a href="https://www.ithome.com.tw/voice/121435">良葛格 下的這番結論</a></p>
<blockquote>
<p>舊東西誕生在舊的時代，適時地解決了當時的問題，而後從中累積了不少的使用經驗，因而誕生了新的技術、概念或規範，急著預言舊東西將會逝去，並不會讓開發者看起來更為耀眼，只會讓開發者看不清楚新東西的本質罷了。</p>
</blockquote>
<h2 id="參考-19">參考</h2>
<ol>
<li>從 fetch 解決什麼問題來看 : <a href="https://www.ithome.com.tw/voice/121435">從XHR到Fetch | iThome</a></li>
<li>Huli 大的 fetch 系列影片
<ul>
<li><a href="https://youtu.be/_8cLWMAQe3A">Fetch 與 Promise 補充系列（一）：初探 Fetch</a></li>
<li><a href="https://youtu.be/Ovv9tPhiW_0">Fetch 與 Promise 補充系列（二）：fetch 的 POST 與錯誤處理</a></li>
<li><a href="https://youtu.be/5A9ogWY7J7w">Fetch 與 Promise 補充系列（三）：fetch 的使用注意事項</a></li>
</ul>
</li>
<li>XHR v.s fetch，單純只是好奇查詢 XD <a href="https://blog.openreplay.com/ajax-battle-xmlhttprequest-vs-the-fetch-api">Ajax Battle: XMLHttpRequest vs the Fetch API </a></li>
<li><a href="https://zh.javascript.info/fetch">Fetch</a></li>
<li>很推的詳細文字版學習 : <a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/ajax_fetch.html">AJAX與Fetch API · 從ES6開始的JavaScript學習生活 (gitbooks.io)</a></li>
</ol>
]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>fetch</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>紀錄 | 串接 Twitch API 實戰</title>
    <url>/2021/12/JavaScript/JavaScript_API_twitch.html</url>
    <content><![CDATA[<h2 id="概要">概要</h2>
<p>紀錄串接 API 的過程以及想法<br>
事不宜遲，直接上手吧 !</p>
<h2 id="實作">實作</h2>
<h3 id="事前預備">事前預備</h3>
<ol>
<li>創建帳號進入 twitch dev<br>
<a href="https://dev.twitch.tv/">Home | Twitch Developers</a></li>
<li>建立 app<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mh-F93GYryYifP-KaHhsLHMLdlRFmH8aH0JC7-ViFhkXZ5hSaibFN5NpsXMprq0qqLd3X4czumdP1D_dKDvbv0iFjtMYWWZl9eMO0DiXLs5wRAU5e7hJUIx6Xnmc0p5DIOWbB31h37gq-deaq9Dx8edWnlXXdJhLmSyCq-x6YqkUiWEg2sngSnn3iCMw3gj5r?width=660&amp;height=379&amp;cropmode=none" alt=""><br>
填上 app 名稱以及 app 應用地方</li>
</ol>
<ul>
<li><code>OAuth</code> 開發階段可設為本機<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mt-abtC6iaRNJOcL06xmknc_DuRdRzrfQP2uyGOYGjVMCT5wTWo3kaaohr9CSO-oX8ttudhoCYPVByDWhMDc8dHS_PZD4hYBs2CD7OH4V0y5oVSc5oSNMdiSsLbkZQEoNIcc-GR-LNEFZvcA_5KGnrrt-CIBYGsk5X5RbIou1jXLAeUUlSx6rXFsnr5ifXMBd?width=660&amp;height=637&amp;cropmode=none" alt=""><br>
設定完按儲存</li>
</ul>
<h3 id="認證">認證</h3>
<p>API 文件 : <a href="https://dev.twitch.tv/docs/api">Twitch API | Twitch Developers</a><br>
Step 1 已經做完了所以直接跳 Step 2</p>
<ol>
<li>
<p>透過 twitch cli 認證 app</p>
<ul>
<li>下載 cli 之前，先看自己的電腦系統<br>
因為我是 window 所以用 <a href="https://scoop.sh/">Scoop</a></li>
</ul>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">iwr</span> <span class="literal">-useb</span> get.scoop.sh | <span class="built_in">iex</span></span><br></pre></td></tr></table></figure>
<p>再透過 Scoop 下載 twitch cli<br>
→  <a href="https://github.com/twitchdev/twitch-cli#scoop">官方操作</a></p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scoop bucket add twitch https://github.com/twitchdev/scoop-bucket.git</span><br><span class="line">scoop install twitch-cli</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>再來拿取 <strong>app-token</strong> 認證<br>
以防自己 cli 沒裝成功<br>
可以用 <strong>twitch version</strong> 來確認一下  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">twitch token</span><br></pre></td></tr></table></figure>
如果是第一次拿取 token<br>
會要求 <code>client-id</code> 跟 <code>client-secret</code><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mG2G8j3XoHH9PQKBsVEt5iN7jDGaTfj4edFSEWc_5e3SGLo-eeXErIS_YuC8KAMtJp7d6sJa_kWfn6pTP08n5BnHC60oUFk2DC1V87ozkdR9uI-Fr60OnFBfgXIfJPZpm9D75EyIIz1L8aikwhZ0GT_AMWASyBv5q819n69I53hmp9ekGl3L2C4g0VyIckD4S?width=660&amp;height=121&amp;cropmode=none" alt=""><br>
來源是這裡<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mdi7Nh5dMfPQ5xzSVtxSdnByfMY4LZWnKeCPaCfw-h2GWDXkXiq5bviTNls30NA8ACNG0Zq1NDiNEmeP9hwTLueF-GZtj13QR0eLFHiovrg6mXTjaapiuXFN9OGw0kcqywuRIlUr1UrgveD-uJYIryaNqV83W3toFb157Hko6Hhry98S5ucLULH5XcA2gOpkV?width=660&amp;height=657&amp;cropmode=none" alt=""><br>
輸入進去就會獲得一組 token<br>
先複製起來，待會會用到 !</li>
</ul>
<blockquote>
<p>twitch token 出現錯誤怎辦 ?<br>
<code>responded with an error while generating token</code><br>
<strong>莫驚莫慌莫害怕</strong><br>
透過 <code>twitch configure</code><br>
刷新設定再索取一次<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4m5G8UcXoxPKOlkwNHqQT_XMLTpCR-o0mZ-MukKd3rYsfZIlReY4a4r0spvs413G12ssJf-JcSZLBdDxs1m4WL5m9K6uIhj6Tyf1-iLOSi1QcHl25_27HYeUav6X_yU0uWUx9Rmbp6jGFUTIcpb5PhCNHQBMn1gRvHWabo9pZsm5XqZ80ufADj_rexSeDSxtjh?width=660&amp;height=145&amp;cropmode=none" alt=""></p>
</blockquote>
<p>官方有提到認證時效性的問題<br>
過 60 天會失效<br>
過期之後再重新設定一次 ~</p>
<h3 id="拿資料">拿資料</h3>
<p>使用資料前先有辦法<strong>拿到資料</strong><br>
所以必須了解 twitch api 的規則<br>
→ <a href="https://dev.twitch.tv/docs/api/guide">Guide | Twitch Developers</a><br>
→ <a href="https://dev.twitch.tv/docs/api/reference#get-streams">Reference | Twitch Developers</a></p>
<p>規則 :</p>
<ol>
<li>要加入請求 2 個標頭
<ul>
<li><strong>client-id</strong></li>
<li><strong>Authorization</strong></li>
</ul>
</li>
<li>傳參數用 <code>&amp;</code> 串<br>
像這樣<br>
<code>&amp;login=twitch&amp;login=twitchgaming</code></li>
</ol>
<p>接著來串目前正在串流的遊戲 LOL<br>
動手之前先想好如何架構</p>
<h4 id="個人想法與流程">個人想法與流程</h4>
<p>透過 game_name 來知道 game_id<br>
再找 streams</p>
<ol>
<li>拿到 Game id (data1)</li>
<li>拿到 <a href="http://data1.id">data1.id</a><br>
找正在串流資料符合的遊戲之 data2</li>
<li>data2 中要用到的
<ul>
<li>user_id</li>
<li>live_titile</li>
<li>thumbnail_img_url</li>
</ul>
</li>
<li>拿到 符合 data2.user_id 的 data3</li>
<li>data3 中
<ul>
<li>找 data3_user_id 和 data2_user_id 一樣的
<ul>
<li>data3_user_name</li>
<li>data3_user_profile_img_url</li>
</ul>
</li>
</ul>
</li>
<li>把資料展現在畫面<br>
data中的 3-2,3-3，5-1-1,5-1-2<br>
最後出現在畫面上</li>
</ol>
<h3 id="javascript-實際操作">javascript 實際操作</h3>
<p>官方文件有範例知道取的資料格式<br>
→ <a href="https://dev.twitch.tv/docs/api/reference#get-streams">Reference-streams | Twitch Developers</a></p>
<p>使用 HTTP method 的 <code>GET</code> 來取得我們想要的資料</p>
<p>看一下 reference 可以查到什麼<br>
query string 的參數有 <code>game</code><br>
要的遊戲名稱是 <code>League of Legends</code><br>
網址會轉成 <code>League%20of%20Legends</code></p>
<p>因此在找的時候 api 的 url 是<br>
<code>https://api.twitch.tv/helix/streams?game=League%20of%20Legends</code></p>
<p>直接輸入在網址會沒有回應<br>
是因為 CORS 的問題<br>
要加上 <code>標頭</code><br>
並且透過 ajax 來存取</p>
<h4 id="前置設定">前置設定</h4>
<p>把 id 跟 Authorization 設定成變數<br>
jquery 的 ajax 為<code>$.ajax(&quot;網址&quot;,設定)</code><br>
把設定內容寫在一起</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clientID = <span class="string">&quot;i9vpv94xpthipcxeo902aunlhw9940&quot;</span></span><br><span class="line"><span class="keyword">const</span> token = <span class="string">&quot;Bearer 1wcbnczsqjzp3675p5dngbxq19hh5d&quot;</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;https://api.twitch.tv/helix/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">XhrSetting</span> = &#123;</span><br><span class="line"> <span class="attr">method</span>:<span class="string">&quot;GET&quot;</span>,</span><br><span class="line"> <span class="attr">beforeSend</span>: <span class="keyword">function</span>(<span class="params">xhr</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> 	xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Client-ID&#x27;</span>, clientID);</span><br><span class="line">	xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Authorization&#x27;</span>, token);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>setRequestHeader</code> : 用來設定 HTTP 的表頭請求，<code>XMLHttpRequest</code> 物件中的方法。</li>
</ul>
<p>參考 :<br>
<a href="https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest/setRequestHeader">XMLHttpRequest.setRequestHeader() - Web APIs | MDN (mozilla.org)</a></p>
<h4 id="函式-2">函式</h4>
<p>根據上面的架構先存取遊戲 id<br>
以下都是使用 jquery</p>
<ul>
<li>GetGames</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">GetGames</span>(<span class="params">gamename,callback</span>)&#123;</span><br><span class="line"> 	$.<span class="title function_">ajax</span>(url+<span class="string">&quot;games/?name=&quot;</span>+gamename,<span class="title class_">XhrSetting</span>)</span><br><span class="line"> 	.<span class="title function_">done</span>(<span class="keyword">function</span>(<span class="params">response</span>)&#123;</span><br><span class="line"> 	<span class="title function_">callback</span>(response.<span class="property">data</span>[<span class="number">0</span>].<span class="property">id</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>為什麼用 callback function ?<br>
callback function 是可以把 B 函式<br>
作為 A 函式的參數</p>
<p>這樣可以拿 GetGame 拿到的 response裡的 id 再去拿下一個資料</p>
</blockquote>
<p>再來就是取得串流資料</p>
<ul>
<li>GetStreams</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">GetStreams</span>(<span class="params">data</span>)&#123;</span><br><span class="line"> $.<span class="title function_">ajax</span>(url+<span class="string">`streams/?game_id=<span class="subst">$&#123;data&#125;</span>&amp;first=<span class="subst">$&#123;limit&#125;</span>&amp;<span class="subst">$&#123;language&#125;</span>`</span>,<span class="title class_">XhrSetting</span>)</span><br><span class="line"> .<span class="title function_">done</span>(<span class="keyword">function</span>(<span class="params">streams</span>)&#123;</span><br><span class="line">	 <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 	拿 userId 取頭貼</span></span><br><span class="line"><span class="comment">		以及顯示在 html </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>GetUser : 串流的 userId 再去得個別資訊</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">GetUser</span>(<span class="params">data,callback</span>)&#123;</span><br><span class="line"> $.<span class="title function_">ajax</span>(url+<span class="string">&quot;users?id=&quot;</span>+data,<span class="title class_">XhrSetting</span>)</span><br><span class="line"> .<span class="title function_">done</span>(<span class="keyword">function</span>(<span class="params">response</span>)&#123;</span><br><span class="line"> <span class="title function_">callback</span>(response);</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>這裡的 response 是要顯示在 html 資訊的<br>
所以這邊的函式是 <code>渲染畫面</code></p>
</blockquote>
<ul>
<li>GetColumn : 顯示</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">GetColumn</span>(<span class="params">stream,data</span>)&#123;</span><br><span class="line"> <span class="keyword">const</span> userProfileImg = data.<span class="property">data</span>[<span class="number">0</span>].<span class="property">profile_image_url</span>;</span><br><span class="line"> <span class="keyword">const</span> stremsThumbnail = stream.<span class="property">thumbnail_url</span>.<span class="title function_">replace</span>(<span class="string">&quot;-&#123;width&#125;x&#123;height&#125;&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string"> &lt;div class=&quot;card&quot;&gt;</span></span><br><span class="line"><span class="string">	 &lt;div class=&quot;card_video&quot;&gt;</span></span><br><span class="line"><span class="string">	 &lt;img src=&quot;<span class="subst">$&#123;stremsThumbnail&#125;</span>&quot; alt=&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">	 &lt;/div&gt;</span></span><br><span class="line"><span class="string">	 &lt;div class=&quot;card_profile&quot;&gt;</span></span><br><span class="line"><span class="string">		 &lt;div class=&quot;card_profile_img&quot;&gt;</span></span><br><span class="line"><span class="string">		 &lt;img src=&quot;<span class="subst">$&#123;userProfileImg&#125;</span>&quot; alt=&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">		 &lt;/div&gt;</span></span><br><span class="line"><span class="string">		 &lt;div class=&quot;card_profile_content&quot;&gt;</span></span><br><span class="line"><span class="string">			 &lt;div class=&quot;card_profile_content_title&quot;&gt;<span class="subst">$&#123;stream.title&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">			 &lt;div class=&quot;card_profile_content_name&quot;&gt;<span class="subst">$&#123;stream.user_name&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">		 &lt;/div&gt;</span></span><br><span class="line"><span class="string">	 &lt;/div&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string"> `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用<code>‵‵</code> 包裹字串是 ES6 的語法<br>
可以塞多行文字，其帶入值用 <code>$&#123;value&#125;</code></li>
</ul>
<p>接著合補完 <code>GetGames</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">GetStreams</span>(<span class="params">data</span>)&#123;</span><br><span class="line"></span><br><span class="line"> $.<span class="title function_">ajax</span>(url+<span class="string">`streams/?game_id=<span class="subst">$&#123;data&#125;</span>&amp;first=<span class="subst">$&#123;limit&#125;</span>&amp;<span class="subst">$&#123;language&#125;</span>`</span>,<span class="title class_">XhrSetting</span>)</span><br><span class="line"> .<span class="title function_">done</span>(<span class="keyword">function</span>(<span class="params">streams</span>)&#123;</span><br><span class="line">	 streams.<span class="property">data</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">stream</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="title class_">GetUser</span>(stream.<span class="property">user_id</span>,<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">			 <span class="keyword">if</span>(data.<span class="property">data</span>[<span class="number">0</span>].<span class="property">id</span> === stream.<span class="property">user_id</span>)</span><br><span class="line">				 $(<span class="string">&#x27;.row&#x27;</span>).<span class="title function_">append</span>( <span class="title class_">GetColumn</span>(stream,data))</span><br><span class="line">		 &#125;)</span><br><span class="line">	 &#125;);</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最後在補上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> limit = <span class="number">20</span> <span class="comment">// 資料數量</span></span><br><span class="line"><span class="keyword">const</span> language = <span class="string">&quot;&amp;language=zh&quot;</span> <span class="comment">//語言系</span></span><br><span class="line"><span class="keyword">const</span> gameName = <span class="string">&quot;League%20of%20Legends&quot;</span></span><br><span class="line"><span class="title class_">GetGames</span>(gameName,<span class="title class_">GetStreams</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>結果 :<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mzBThzpbO12L6GrjUQzYhQb-bPJf086nDiPhzZnbGQHRhXmro10FMYN4kHIfrwUCxHuwNb8L7ZqW8_1xhj5Uw7k7KLJG7TqHWnrginQRlFeMxpjarZfQgYkzfEqjEKHdyz7oYhvsftONoZ4e-e9sYzZL-E7-E02dOG6GfGV-HBOCrvsfYGTTIRlW6I-Xo9Wdx?width=1024&amp;height=593&amp;cropmode=none" alt=""></li>
</ul>
<h2 id="結語-15">結語</h2>
<p>透過實戰一次串接<br>
就比較知道 API 內容在做什麼<br>
從中也認識 RESTful API 的意義<br>
還有 HTTP Method、StatusCode</p>
<p>實作時覺得結構上可以再更精簡<br>
有些重複性的東西盡可能省略</p>
]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | React - Context API</title>
    <url>/2022/07/React/ContextAPI.html</url>
    <content><![CDATA[<blockquote>
<p>文章來自 :</p>
<ol>
<li><a href="https://www.taniarascia.com/using-context-api-in-react/">Using Context API in React (Hooks and Classes) | Tania Rascia</a></li>
<li><a href="https://reactjs.org/docs/context.html#gatsby-focus-wrapper">Context – React</a></li>
</ol>
</blockquote>
<h2 id="摘要-4">摘要</h2>
<p>主要以 Class Component 為主</p>
<ol>
<li>使用 Context 的時機</li>
<li>如何使用 class Component 的 ContextAPI</li>
<li>Context 缺點</li>
</ol>
<span id="more"></span>
<h2 id="什麼時候用-Context">什麼時候用 Context ?</h2>
<p>在 React 中，當這個值想要共享的範圍很廣，擴及多個 Component ，意味著變成 <strong>global</strong> ，可以使用 Context 來避免 props 傳遞至太深的地方 (又稱 <code>props drilling</code>)。</p>
<p>常見使用 Context 範例 :</p>
<ul>
<li>使用者登入的狀態、資料 : 元件操作之權限</li>
<li>網頁主題 (theme) : 不同元件需要更換顏色</li>
<li>偏好語言 : 文字資料切換</li>
</ul>
<h2 id="或許不用-Context">或許不用 Context</h2>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最上層接收 props 後往下傳</span></span><br><span class="line">&lt;<span class="title class_">Page</span> user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中間幫忙傳遞而已</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">PageLayout</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">avatarSize</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavigationBar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">avatarSize</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 內部終於拿到 props</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&#123;user.permalink&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Avatar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">size</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><code>user</code> 跟  <code>avatarSize</code> 不斷地被重複提到。<br>
如果只是避免傳遞 props 到每一層，你應該做的是 <strong>提出來並重構<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></strong> (component composition)，而不是使用 Context 。</p>
<h2 id="Context-createContext">Context.createContext</h2>
<p>建立 Context，主要是建立 <code>Provider</code> 與 <code>Consumer</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(defaultValue);</span><br></pre></td></tr></table></figure>
<p>defaultValue 可以設定預設值，例如對於 <strong>主題</strong> 來說，可以先預設 <code>theme.dark</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> theme = &#123;</span><br><span class="line">   <span class="attr">light</span>: &#123;</span><br><span class="line">      background : <span class="string">&#x27;#fff&#x27;</span>;</span><br><span class="line">      text : <span class="string">&#x27;#000&#x27;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">dark</span>:&#123;</span><br><span class="line">      background : <span class="string">&#x27;#000&#x27;</span>;</span><br><span class="line">      text : <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(theme.<span class="property">dark</span>);</span><br></pre></td></tr></table></figure>
<p>並且 <strong>defaultValue 是給沒有被 Provider 包住 Component</strong>，對 Consumer 並沒有影響。</p>
<blockquote>
<p>Note: passing <strong>undefined</strong> as a Provider value does not cause consuming components to use defaultValue.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
</blockquote>
<p>如果把 Provider 的 value 設成 <code>undefined</code>，也不會是 defaultValue</p>
<p>👉試著實作 <a href="https://codepen.io/shan473/pen/XWEjrQy">React Context Provider value as undefined</a>。</p>
<h3 id="default-Value-的用意">default Value 的用意</h3>
<p>那我就好奇了，defalut value 的用意在哪裡 ?<br>
我找到這篇</p>
<blockquote>
<p>This is helpful for testing components in isolation without wrapping them, or testing it with different values from the Provider.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>
</blockquote>
<p>default value  是不在 Provider 裡面的 component，如果試圖用 Context 會拿到 createContext defalutValue 的值。</p>
<p>👉試著實作 <a href="https://codepen.io/shan473/pen/LYdRYZV?editors=0010">React Context - out of Provider component get Context</a></p>
<p>好處是提高測試性，可以獨立測試 component。</p>
<h2 id="Context-Provider">Context.Provider</h2>
<p>Context 翻譯是上下文，上有 Provider 下有 Consumer。<br>
Provider 可以將提供 value 給 Consumer 使用 :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Primative type</span></span><br><span class="line">&lt;<span class="title class_">Context</span>.<span class="property">Provider</span> value=&#123;<span class="string">&#x27;hello world&#x27;</span>&#125;&gt;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&lt;/<span class="title class_">Context</span>.<span class="property">Provider</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object type : 注意物件型別的問題</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;[1,2,3]&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   //...</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>每一個 Consumer 都會監聽 Provider value 的變化。<br>
一個 Provider 底下可以有很多個 Consumer，也可以被底下的其他的 Provider 覆寫。</p>
<h3 id="render-的問題">render 的問題</h3>
<blockquote>
<p>當 Provider 的 value 改變時，所有的 Consumer (包含使用 contextType 與 useContext) 都會被強迫 re-render。</p>
</blockquote>
<p>變化是傳遞到所有 Consumer 元件，這種更新是不受 shouldComponentUpdate 控制，即使父層沒有變化，還是會被迫更新，</p>
<p>決定 value 改變的比較方式是 <code>Object.is</code>。</p>
<blockquote>
<p>[!NOTE] <strong><a href="http://Object.is">Object.is</a></strong> v.s === &amp; ==</p>
<ul>
<li><strong>==</strong> 會強制轉型，undefined、null 等等會被強制轉為 falsy</li>
<li><strong>===</strong> 比 == 多比較型別，但與 <a href="http://Object.is">Object.is</a> 不同的是</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>比較相同</th>
<th style="text-align:center">Number.NaN &amp; NaN</th>
<th style="text-align:center">+0 &amp; -0</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://Object.is">Object.is</a></td>
<td style="text-align:center">true</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td>===</td>
<td style="text-align:center">false</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td>==</td>
<td style="text-align:center">false</td>
<td style="text-align:center">true</td>
</tr>
</tbody>
</table>
<p>如果 value 是 Object type 會讓底下的子孫代 component 強迫 re-render，簡單來說 <code>&#123;&#125; !== &#123;&#125;</code> 或是 <code>[] !== []</code>。</p>
<h3 id="value-是-Object-Type-的問題">value 是 Object Type 的問題</h3>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Context</span>.<span class="property">Provider</span> value=&#123;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;&gt;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&lt;/<span class="title class_">Context</span>.<span class="property">Provider</span>&gt;</span><br></pre></td></tr></table></figure>
<p>value 如果是物件型別，每次 render 都會重新建立，如果是頻繁變動的 context ，可以把控制權交給 React 的 state，<strong>提升 state 到 parent component</strong>。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">value</span>: &#123;<span class="attr">something</span>: <span class="string">&#x27;something&#x27;</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Toolbar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Consumer">Consumer</h2>
<p>Consumer 使用的 context 是在樹狀中最鄰近 Provider 的 value。<br>
class Component 建立 Consumer 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 種方式，並且用於不同情境</p>
<ol>
<li><code>&lt;Context.Consumer&gt;</code> :
<ul>
<li>僅有 <code>render()</code> 可以使用</li>
<li>可以同時使用多個 Context</li>
<li>優化 Context ，拆分成好幾個 Consumer</li>
</ul>
</li>
<li><code>contextType</code> :
<ul>
<li>所有生命週期內可以使用，並使用 <code>this.context</code> 取得值</li>
<li>只能應用一個 context</li>
</ul>
</li>
</ol>
<p>在 Hooks 中只要用到 <code>useContext</code> 就可以拿到 context value。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Class-contextType">Class.contextType</h3>
<p><strong>在生命週期內使用 context</strong>，可以在 class 內部加上 static 的 contextType，或是在外部加。<br>
使用時可以直接用 <code>this.context</code> 取得 value 的值。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyContext</span> <span class="keyword">from</span> <span class="string">&#x27;./MyContext&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在外部指定</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">contextType</span> = <span class="title class_">MyContext</span>;</span><br></pre></td></tr></table></figure>
<p>也可以使用 class 中的 <code>static</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">   <span class="keyword">static</span> contextType = <span class="title class_">MyContext</span></span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Context-Consumer">Context.Consumer</h3>
<p>有別於 <code>this.context</code> 的方式，<code>Context.Consumer</code> 是透過 <strong>props</strong> 取的 context 的值，就像 functional component 一樣，使用 props 並 return React Node。<br>
這種方式是 Render Props<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> 的技巧，等同把 React Element 當作 props 來傳遞。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>(</span><br><span class="line">         <span class="language-xml"><span class="tag">&lt;<span class="name">MyContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           &#123; props =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                 return (</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                       &#123;props.value&#125;</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                 )</span></span><br><span class="line"><span class="language-xml">              &#125;   </span></span><br><span class="line"><span class="language-xml">           &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">MyContext.Consumer</span>&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Context-displayName">Context.displayName</h2>
<p>替 context 取別名，在 React 的開發工具之下，會使用 displayName 的值來顯示這個 context。<br>
我比較常看見在 UI 函式庫看到這樣的用法，例如 : <a href="https://github.com/react-bootstrap/react-bootstrap/blob/master/src/AccordionContext.ts">React-Boostrap - Accordion</a></p>
<p>範例 :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> context = <span class="title class_">React</span>.<span class="property">createContext</span>&lt;<span class="title class_">AccordionContextValue</span>&gt;(&#123;&#125;);</span><br><span class="line">context.<span class="property">displayName</span> = <span class="string">&#x27;AccordionContext&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context;</span><br></pre></td></tr></table></figure>
<p>如果在同一個 Component 有多個 Provider ，在 DevTools 只會出現 <code>Context.Provider</code><br>
<img data-src="https://i.imgur.com/TCVpxYH.png" alt="#small"><br>
重複的 Context.Provider 造成 Debug 困難，這時候可以使用 displayName 將不同 context 分開。</p>
<h2 id="Multiple-Context">Multiple Context</h2>
<p>最好不要把所有用到的值都塞進同一個 Context，這就會導致非相關的 component 強制更新，優化的方式就是拆成好幾個 Provider 與 Consumer ，將明確的界線劃分出來。</p>
<p>範例 :  theme 跟 user 分開成不同的 context</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Content</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;theme =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">UserContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;user =&gt; (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ProfilePage</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          )&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">UserContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Context-的優缺點">Context 的優缺點</h2>
<ul>
<li>優點
<ol>
<li>改善 props drilling 的問題，跳過 intermediate component ，把值直接給想要的 component。</li>
<li>在小型的 APP 中，可以快速解決 global 的問題，不用用到 React-Redux</li>
</ol>
</li>
<li>缺點
<ol>
<li>效能上的問題，只要 value 中的值更新，其底下所有套上 Consumer 的元件也會被強迫更新</li>
<li>當 APP 擴展共享值越多時，使用 Context 會造成效能上的問題。</li>
<li>不適合用 <strong>頻繁</strong> 改變的值</li>
<li>耦合性高，不好做測試</li>
</ol>
</li>
</ul>
<h2 id="如何改善-Context-的效能問題">如何改善 Context 的效能問題</h2>
<p>Dan 大提供 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span>  種優化 Context 的方式<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>，主要以 Hooks 為主。</p>
<ol>
<li>分開不同的 Context，跟上面 [[#Multiple Context | 多個 Context]] 是一樣的意思，只有用到 theme 就拆成 themeContext，不要跟其他 Context 包在一起。<strong>分開 Context 這是最好的方式</strong></li>
<li><code>memo</code> 作為 component 的 props 觀察需要<strong>需要變化的 value</strong>。<br>
Button 主要是接收 Context 的容器，將 theme 給分離出來。</li>
</ol>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> appContextValue = <span class="title function_">useContext</span>(<span class="title class_">AppContext</span>);</span><br><span class="line">   <span class="comment">// 把 theme 從 Context 提取出來</span></span><br><span class="line">   <span class="keyword">let</span> theme = appContextValue.<span class="property">theme</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ThemedButton</span> <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 當 theme 沒有改變的時候，就不會 re-render</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemedButton</span> = <span class="title function_">memo</span>(<span class="function">(<span class="params">&#123; theme &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 剩下的邏輯</span></span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ExpensiveTree</span> <span class="attr">className</span>=<span class="string">&#123;theme&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>useMemo</code> : 如果全部塞在同一個地方，這裡的 <code>useMemo</code> 記住 React Element，並監聽 theme 是不是有改變。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> appContextValue = <span class="title function_">useContext</span>(<span class="title class_">AppContext</span>);</span><br><span class="line">  <span class="keyword">let</span> theme = appContextValue.<span class="property">theme</span>; <span class="comment">// Your &quot;selector&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// The rest of your rendering logic</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ExpensiveTree</span> <span class="attr">className</span>=<span class="string">&#123;theme&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;, [theme])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>memo</code> 與 <code>useMemo</code> 都是額外交給 React 處理，因此效能上不一定保證能優化，是需要去權衡的 (React 將優化流程的方式稱作 <strong>bailout</strong>)。</p>
<h2 id="總結-25">總結</h2>
<ul>
<li>建立 Context 使用 <code>createContext()</code></li>
<li>Context 提供 <code>Provider</code> 與 <code>Consumer</code>，Provider 的 <code>value</code> props 就是傳遞下去的值；接住值使用 Consumer 。</li>
<li>如果 value 是 Object type ，最好提到 Component 之外建立，或者只用 state 。</li>
<li>不相干的 Context 最好分開來，避免造成效能上不必要的 render</li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://reactjs.org/docs/composition-vs-inheritance.html#containment">Composition vs Inheritance – React</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://reactjs.org/docs/context.html#reactcreatecontext">Context -  default Value – React</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">default 的用意 :  <a href="https://stackoverflow.com/questions/49949099/react-createcontext-point-of-defaultvalue">javascript - React.createContext point of defaultValue? - Stack Overflow</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">把 React Element 當作 props 傳遞<a href="https://reactjs.org/docs/render-props.html">Render Props – React</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">Context 預防 re-render : <a href="https://github.com/facebook/react/issues/15156#issuecomment-474590693">Preventing rerenders with React.memo and useContext hook. · Issue #15156 · facebook/react · GitHub</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>Front-end</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | JavaScript - 宣告提升(II) - 跟著 JavaScript 引擎發動</title>
    <url>/2022/01/01/JavaScript-Hoisting-II.html</url>
    <content><![CDATA[<h2 id="前言-46">前言</h2>
<p>從上一篇 <a href="https://meitung473.github.io/RosaBlog/Frontend/JavaScript/JavaScript-Hoisting/">筆記 | JavaScript - 宣告提升(I) - 我以為的以為</a><br>
知道有三種東西會做宣告提升<br>
但是不太清楚如何運作<br>
為了瞭解如何宣告提升之前<br>
要問自己為什麼 <strong>需要</strong> 宣告提升？<br>
如果沒有宣告提升，JavaScript 不能做到那些事？</p>
<h2 id="如果沒有宣告提升-Hoisting-？">如果沒有宣告提升 (Hoisting) ？</h2>
<ol>
<li>變數必須先宣告再使用</li>
<li>函式必須先宣告再使用<br>
在設計階段，會希望將預執行函式名先寫出來，再來補齊函式中間的運作，對於執行的脈絡會更加清晰，如果沒有宣告提升，必須先等完成函式再呼叫，版面上可能就會有凌亂。</li>
<li>函式做不到互相呼叫 <strong>(非常重要)</strong><br>
A 要呼叫 B 時 ，B 根本還沒被創造<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">average</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">add</span>(a,b)/<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">average</span>(<span class="number">1</span>,<span class="number">2</span>)) <span class="comment">//1.5</span></span><br></pre></td></tr></table></figure>
若沒有宣告提升，是不能執行的<br>
在 <code>average</code> 呼叫 <code>add</code> 時就會出錯</li>
</ol>
<h2 id="JavaScript-的宣告提升怎麼運作？">JavaScript 的宣告提升怎麼運作？</h2>
<p>了解宣告提升非常重要<br>
接下來要了解如何運作？<br>
可以來看看 ECMAScript 怎麼說 JavaScript 的運作方式</p>
<blockquote>
<p>ECMAScript 是 JavaScript 的實作守則<br>
可以先參考底層是如何被定義的</p>
</blockquote>
<p>主要跟兩個東西有關連<br>
一是執行環境 (Execution contexts)<br>
二是作用域 (Scope)</p>
<h2 id="執行環境-Execution-contexts">執行環境 (Execution contexts)</h2>
<p>Execution contexts 執行環境(以下簡稱 EC)<br>
ECMA 的解釋是:</p>
<blockquote>
<p>Evaluation of global code or code using the eval function (15.1.2.1) establishes and enters a new execution context. Every invocation of an ECMAScript code function (13.2.1) also establishes and enters a new execution context, even if a function is calling itself recursively.</p>
</blockquote>
<p>剛開始執行前也會生成 global 的 EC<br>
每當呼叫函式時也會生成一個新的 EC</p>
<p>所以 EC 有兩種</p>
<ol>
<li>
<p><strong>Global Execution contexts</strong><br>
全域物件會在這邊產生<br>
產生的有包含最外層的宣告變數、函式、還有<code>this</code><br>
而 this 在不同的環境會有不同的值</p>
<ul>
<li>在瀏覽器上，是 <code>window</code></li>
<li>在 node.js 上， 是一種 global 物件</li>
</ul>
</li>
<li>
<p><strong>Function Execution contexts</strong><br>
呼叫 function 時形成，除了內部中宣告變數、函式會產生外，如果有參數的話，<strong>參數</strong> 也會被算進儲存物件中。<br>
function 中的儲存物件叫 <strong>Arguments Object</strong>，function 執行完後都會消失。</p>
<blockquote>
<p>閉包除外，閉包更像是回收的機制，雖然已經執行完畢，但是儲存的物件仍然存在且外部可以使用。</p>
</blockquote>
</li>
</ol>
<p>EC 會層層堆疊 (Execution contexts stack)，最上層的是 <strong>正在執行</strong> 的函式，函式執行結束後就會被 pop 掉。</p>
<p>因為 JavaScript 是單線程(同步)，在執行時會一行行往下跑，跑完的 function 就會釋放記憶體空間。</p>
<ul>
<li>堆疊 (EC stack)<br>
<img data-src="https://i.imgur.com/cUWijRw.gif" alt="function 包 function EC 示意圖"></li>
</ul>
<h3 id="EC-儲存的狀態物件">EC 儲存的狀態物件</h3>
<p>上面不斷提到儲存物件，到底是存在哪裡？<br>
又存了什麼？</p>
<p>EC 會包含三種的狀態物件</p>
<ol>
<li><code>Lexical Environment</code> (詞語環境): 在 <strong>創造</strong> 階段就已經宣告的變數或函式陳述式所存放的環境，看的是程式碼的物理位置。</li>
<li><code>Variable Environment</code> (變量環境): 跟 Lexical Environment 很像，已經宣告的變數或函式陳述式在 <strong>執行</strong> 階段所存放的環境，這個環境跟實際在執行程式的物理位置也有關係。</li>
<li>ThisBinding : <code>this</code> 關鍵字。</li>
</ol>
<p>ECMAScript 新版的定義更不一樣 @@ ，這邊先已 ECMAScript 262 5.1 為主。</p>
<p>可以注意到</p>
<blockquote>
<p>The LexicalEnvironment and VariableEnvironment components of an execution context are always Lexical Environments.<br>
When an execution context is created its LexicalEnvironment and VariableEnvironment components initially have the same value.</p>
</blockquote>
<p>在最初還沒跑程式碼的時候這兩個是一樣的， <code>Lexical Environment = Variable Environment</code><br>
這邊其實我有點搞混了，既然是一樣的，那複製母體是誰 ?<br>
<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/#lexical-environment">這篇文章</a> 給了很好的解釋</p>
<blockquote>
<p>Variable Environment 是 Lexical Environment 的複製藍圖。<br>
這也會解釋到 Scope Chain 的原理</p>
</blockquote>
<h3 id="Lexical-Environments">Lexical Environments</h3>
<p><code>10.2 Lexical Environments</code></p>
<blockquote>
<p>A Lexical Environment consists of an <code>Environment Record</code> and a possibly null reference to an outer Lexical Environment.</p>
</blockquote>
<p>這段可以知道完整的 Lexical Environments 其實還有一個外部參考環境。<br>
這個外部環境，其實跟 scope 很有關係，後面會提到為什麼有 <code>scope chain</code> 的概念，正是因為還有外部參考環境，在內部找不到的值，可以往外部尋找。</p>
<p>根據這段可以來看 <strong>外部參考環境</strong> 的定義</p>
<blockquote>
<p>The outer environment reference is used to model the logical nesting of Lexical Environment values. The outer reference of a (inner) Lexical Environment is a reference to the Lexical Environment that logically surrounds the inner Lexical Environment.</p>
</blockquote>
<p>簡單來說外部參考 (reference) 是 Lexical Environment 指向的鄰近的 Lexical Environment。<br>
對 global 來說是最外層，所以是外部參考環境是 <code>null</code>。</p>
<p>再說一次 Lexical Environment 指的是程式碼物理的位置。<code>這邊的外部參考環境跟函式在哪裡呼叫無關，跟程式碼放在哪裡關。</code></p>
<p>往下繼續看…</p>
<blockquote>
<p>An <code>Environment Record</code> records the identifier bindings that are created within the <code>scope</code> of its associated Lexical Environment.</p>
</blockquote>
<p>從這邊可以知道 Scope 是包含 Environment Record 紀錄宣告的綁定的值，而且跟 Lexical Environments 有相關。<br>
(恕我的破破英文翻譯)</p>
<p>不過這個 <code>Environment Record</code> 是什麼咧？</p>
<h3 id="Environment-Records">Environment Records</h3>
<p><code>10.2.1 Environment Records</code></p>
<blockquote>
<p>For specification purposes Environment Record values can be thought of as existing in a simple object-oriented hierarchy where Environment Record is an abstract class with two concrete subclasses, <code>declarative environment record</code> and <code>object environment record</code>.</p>
</blockquote>
<p>在 ECMAScript 262 5.1 是叫  <code>Environment Record</code> 可以想像成一般的 object，會記錄不同類型的變數以及函式<br>
。<br>
<code>declarative environment record</code> 是宣告環境紀錄來仔細看一下包含哪些東西。</p>
<h3 id="Declarative-Environment-Records">Declarative Environment Records</h3>
<p><code>10.2.1.1 Declarative Environment Records</code></p>
<blockquote>
<p>Each declarative environment record is associated with an ECMAScript program scope containing variable and/or function declarations. A declarative environment record binds the set of identifiers defined by the declarations contained within its <code>scope</code>.</p>
</blockquote>
<p>在定義的部分，scope 跟 Declarative Environment Records 紀錄的變數以及函式陳述式有關。<br>
我們把關係一層層剝開，發現 scope 指的是 EC 中的環境紀錄宣告變數與函式的總和範圍。</p>
<p>我試著描出上面說的架構</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">EC</span>&#123;</span><br><span class="line">	<span class="title class_">Lexical</span> <span class="title class_">Environments</span>:&#123;</span><br><span class="line">		<span class="title class_">Environment</span> <span class="title class_">Records</span></span><br><span class="line">	&#125;</span><br><span class="line">	[[ref.<span class="property">outerEnv</span>]]:&#123;</span><br><span class="line">		surroundEC.<span class="property">Lexical</span> <span class="title class_">Environments</span>:&#123;</span><br><span class="line">			<span class="title class_">Environment</span> <span class="title class_">Records</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="title class_">Variable</span> <span class="title class_">Environment</span>:&#123;</span><br><span class="line">		<span class="title class_">Environment</span> <span class="title class_">Records</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不過新版已經不再是以 Lexical Environments 來說明，而是 Environment Records。(這有待專研 @@)</p>
<h2 id="作用域-Scope">作用域 (Scope)</h2>
<p>作用域 (Scope) 也就是 <strong>變數生存的範圍</strong><br>
外部的不能取內部的值，內部可以取外部的值<br>
會依循作用域鏈 (Scope Chain) 一層層往上找</p>
<p>Scope 有兩種</p>
<ol>
<li>Global Level Scope : 全域作用域<br>
這邊的值在哪裡都可以存取，也是最外層的。</li>
<li>Local Level Scope : 區域作用域
<ol>
<li>Function Level Scope<br>
<code>var</code> 的變數生存範圍就是以 function 為限，如果在 function 以外來取得在 function 宣告的 var 變數，會錯誤。</li>
<li>Block Level Scope<br>
在 ES6 中，<code>let</code> 跟 <code>const</code><br>
的生存範圍是以 <code>&#123; &#125;</code>為限，也就是大括號括起來的 block，脫離 block 要取得值就會失敗。</li>
</ol>
</li>
</ol>
<p>這邊先不討論 let 跟 const。<br>
回到 scope chain 上，我們知道跟 <code>外部參考環境</code> 有關，上面有提到 <code>外部參考環境</code> 其實就是鄰近的 Lexical Environment。</p>
<p>綜合上面的概念， 在 function 中的外部環境 Lexical Environment 又是從<br>
Variable Environment 複製過來的，所以 function 呼叫時的 scope 其實就是來自正在上一層 EC 傳入的 Variable Environment</p>
<p>在 <code>13 Function Definition</code> 這個定義中可以找到結果</p>
<blockquote>
<p>Return the result of creating a new Function object as specified in 13.2 with parameters specified by FormalParameterListopt, and body specified by FunctionBody. <code>Pass in the VariableEnvironment of the running execution context as the Scope.</code> Pass in true as the Strict flag if the FunctionDeclaration is contained in strict code or if its FunctionBody is strict code.</p>
</blockquote>
<p>講起來真的蠻抽象的，來看看例子。</p>
<h3 id="範例一-3">範例一</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">//2.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> c=<span class="number">2</span></span><br><span class="line">	<span class="title function_">b</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">//3.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">//1.</span></span><br><span class="line"><span class="keyword">var</span> c=<span class="number">3</span></span><br><span class="line"><span class="title function_">a</span>()</span><br></pre></td></tr></table></figure>
<p>答案是多少呢？</p>
<p>答案是</p>
<ol>
<li><code>undefined</code></li>
<li>3</li>
<li>2</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">b.<span class="property">EC</span>&#123;</span><br><span class="line">	<span class="title class_">Lexical</span> <span class="title class_">Environments</span>:&#123;</span><br><span class="line">		<span class="title class_">Environment</span> <span class="title class_">Records</span>:&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	[[ref.<span class="property">outerEnv</span>]]: &#123;</span><br><span class="line">		<span class="variable language_">global</span>.<span class="property">EC</span>.<span class="property">Variable</span> <span class="title class_">Environment</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="title class_">Variable</span> <span class="title class_">Environment</span>:&#123;</span><br><span class="line">		<span class="title class_">Environment</span> <span class="title class_">Records</span>:&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.<span class="property">EC</span>&#123;</span><br><span class="line">	<span class="title class_">Lexical</span> <span class="title class_">Environments</span>:&#123;</span><br><span class="line">		<span class="title class_">Environment</span> <span class="title class_">Records</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">c</span>: <span class="literal">undefined</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	[[ref.<span class="property">outerEnv</span>]]: &#123;</span><br><span class="line">		<span class="variable language_">global</span>.<span class="property">EC</span>.<span class="property">Variable</span> <span class="title class_">Environment</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="title class_">Variable</span> <span class="title class_">Environment</span>:&#123;</span><br><span class="line">		<span class="title class_">Environment</span> <span class="title class_">Records</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			c : <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">global</span>.<span class="property">EC</span>&#123;</span><br><span class="line">	<span class="title class_">Lexical</span> <span class="title class_">Environments</span>:&#123;</span><br><span class="line">		<span class="title class_">Environment</span> <span class="title class_">Records</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			b : <span class="title function_">func</span>()</span><br><span class="line">			a : <span class="title function_">func</span>()</span><br><span class="line">			c : <span class="literal">undefined</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	[[ref.<span class="property">outerEnv</span>]]: &#123;<span class="literal">null</span>&#125;,</span><br><span class="line">	<span class="title class_">Variable</span> <span class="title class_">Environment</span>:&#123;</span><br><span class="line">		<span class="title class_">Environment</span> <span class="title class_">Records</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			c : <span class="number">3</span> </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一個 console 是 <code>undefined</code>，因為 global EC 建立時，環境 (Lexical Environments) 將變數、函式陳述式的宣告先存放起來，會長這樣</p>
<ol>
<li>b : func()</li>
<li>a : func()</li>
<li>c : undefined</li>
</ol>
<p>Variable Environment 跟 Lexical Environments 還沒執行時是一樣的，執行後 Variable Environment 就會有變化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">global</span>.<span class="property">EC</span>&#123;</span><br><span class="line">	<span class="title class_">Lexical</span> <span class="title class_">Environments</span>:&#123;</span><br><span class="line">		<span class="title class_">Environment</span> <span class="title class_">Records</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			b : <span class="title function_">func</span>()</span><br><span class="line">			a : <span class="title function_">func</span>()</span><br><span class="line">			c : <span class="literal">undefined</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	[[ref.<span class="property">outerEnv</span>]]: &#123;<span class="literal">null</span>&#125;,</span><br><span class="line">	<span class="title class_">Variable</span> <span class="title class_">Environment</span>:&#123;</span><br><span class="line">		<span class="title class_">Environment</span> <span class="title class_">Records</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			b : <span class="title function_">func</span>()</span><br><span class="line">			a : <span class="title function_">func</span>()</span><br><span class="line">			c : <span class="number">3</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>當 <code>var c =3</code>，Variable Environment 中的 c 才會賦值 3。</p>
<p>可以看到 b 即使在 a 函式中被呼叫，b 的外部參考環境其實是 global，因為這跟 Lexical Environment 有關。</p>
<h3 id="範例二-3">範例二</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> c=<span class="number">2</span></span><br><span class="line">	<span class="title function_">b</span>()</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">//2.</span></span><br><span class="line">		c = <span class="number">3</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">//3.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">//1.</span></span><br></pre></td></tr></table></figure>
<p>答案是</p>
<ol>
<li><code>c is not defined</code></li>
<li>2</li>
<li>3</li>
</ol>
<p>a 的外部參考環境 是 global。<br>
b 的外部參考環境是 a + global，因此 c 是 a 函式中的變數，而<code>c=3</code>，沒有重新宣告下，b 函式找不到 c，所以是找 a 函式中的 c，並改變成 <code>c=3</code>。</p>
<p>如果把 b 函式中的 c =3 ，改為 <code>var c=3</code>，答案會變為</p>
<ol>
<li><code>c is not defined</code></li>
<li><code>undefined</code></li>
<li>2</li>
</ol>
<h2 id="小結-6">小結</h2>
<ol>
<li>Exection Context : 執行上下文，會形成 Exection Context Stack，最下層是 global，呼叫到 function 就會再往上疊加 EC</li>
<li>Lexical Environment : <strong>創造</strong> 階段儲存的環境</li>
<li>Variable Environment : <strong>執行</strong> 階段儲存的環境</li>
<li>Environment Records : 像是一個物件，儲存宣告的變數、函式陳述式，以及函式中的參數。</li>
<li>Scope : 作用域，變數生存的範圍。</li>
<li>Scope Chain : 作用域鏈，由 EC 的 Lexical Environment，以及其外部的 Lexical Environment 組成，其外部的 Lexical Environment 就是上一層 EC 的 Variable Environment 複製過來的。</li>
</ol>
<h2 id="超級比一比">超級比一比</h2>
<p>了解 Scope 後，就要來了解如果有相同名稱的三個變數，Javascript 會如何來判斷順序，像是 function a、變數 a、參數 a ，三個都同名，那誰會被蓋掉誰呢 ?<br>
重複的宣告又會怎麼處理呢 ?<br>
可以根據 <a href="https://262.ecma-international.org/5.1/#sec-10.5">10.5 Declaration Binding Instantiation</a> 規則來看</p>
<blockquote>
<p>10.5.4 在呼叫的 function 裡面</p>
</blockquote>
<ol>
<li>如果有同名的 function、參數、變數，function 會先被儲存</li>
<li>如果內部有同名的參數與變數
<ol>
<li>引數的數量 &gt; 1，內部變數初始值會變成 undefined，變數如果有重新賦值，可能會是第 n 個參數的值</li>
<li>如果有傳入引數，那麼傳入的引數就是函式的參數初始值</li>
<li>如果沒有傳入引數，但有參數，參數的初始值是 undefined，再依照內部執行程式碼賦值</li>
</ol>
</li>
</ol>
<blockquote>
<p>10.5.5 函式陳述式</p>
</blockquote>
<p>a~d : 如果有函式被重複宣告，以後面新宣告的函式為主</p>
<p>e : 在 global 會是全域的物件<br>
宣告變數跟宣告的函式名同名，如果變數宣告了但沒賦值，同名的就會是先儲存 function 物件</p>
<p>我寫大概的意思而已，文件上定義的很明確。</p>
<blockquote>
<p>10.5.8 宣告或未宣告的變數</p>
</blockquote>
<ol>
<li>已宣告的變數，後面重複宣告都已第一個為宣告主 (dn -&gt; d)</li>
<li>已宣告且賦值的話，重複宣告又賦值以後面的值為主 (值 = dn)</li>
<li>未宣告變數
<ol>
<li>往上找 Scope Chain 有宣告的變數，新賦值為主</li>
<li>如果往上找 Scope Chain 沒有宣告的變數，就會直接報錯</li>
</ol>
</li>
</ol>
<p>這邊只列出幾個，原諒我破破的英文翻譯，大概是這樣<br>
10.5 列出各種會碰到的情況，只是這邊有很多代名詞，要再往回看一下定義。</p>
<h2 id="狀況劇">狀況劇</h2>
<p>雖然上面大約了解內部執行與儲存的狀況，試著來驗證常見的狀況是不是這樣</p>
<h3 id="重複宣告變數">重複宣告變數</h3>
<p>先來個簡單的重複宣告的問題，有變數以及函式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="keyword">var</span> a </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br></pre></td></tr></table></figure>
<p>結果應該要等於 1，不會是 undefined<br>
根據 ECMA 寫的宣告有賦值的話，以 d 為主<br>
執行一下是 <code>a=1</code></p>
<h3 id="重複宣告函式">重複宣告函式</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hey!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>()</span><br></pre></td></tr></table></figure>
<p>結果應該要等於 hey!，不會是 hi!<br>
函式重複宣告是以 fn 為主<br>
執行一下是 <code>hey!</code></p>
<p>跟著引擎發動沒錯吧 :D<br>
再來 !</p>
<h3 id="global-同名變數-v-s-function">global 同名變數 v.s function</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br></pre></td></tr></table></figure>
<p>可以拆做兩個步驟，第一個是創造之前，因為 var a 一開始是 undefined，但是 a 會被優先儲存成 function 物件<br>
直到執行階段，<code>a =10</code>，a 這個物件被賦值為數字 10，a 已經不是 function 物件，被呼叫時會報錯</p>
<p>但是如果是這個情況</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 這個結果</span></span><br><span class="line"><span class="title function_">a</span>()</span><br></pre></td></tr></table></figure>
<p>根據上面的步驟跟規則，結果會是 <code>[function a]</code>，印出 function 本身</p>
<h3 id="function-內同名-function-v-s-參數">function 內同名 function v.s 參數</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a</span>)&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">456</span>)</span><br></pre></td></tr></table></figure>
<p>根據規則， function 內部如果同名，宣告的 function 會先優先，所以結果是 <code>[function a]</code>，印出 function 本身</p>
<h3 id="function-內同名-變數-v-s-參數">function 內同名 變數 v.s 參數</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a</span><br><span class="line">  a+=<span class="number">2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">456</span>)</span><br></pre></td></tr></table></figure>
<p>正當你以為 <code>a = undefined 或是 NaN</code>，不，結果是 458 ，根據規則，參數有傳入引數就是該值，而且變數 a 已存在，所以 <code>var a</code> 並不會覆蓋，由此可知參數的順序比變數來的優先。</p>
<p>如果沒有傳入參數呢 ?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a</span>)&#123;</span><br><span class="line">  	<span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  	a+=<span class="number">2</span></span><br><span class="line">	<span class="keyword">var</span> a</span><br><span class="line">  	<span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>()</span><br></pre></td></tr></table></figure>
<p>第一個是 undefined，來自參數 a 已宣告但是為賦值<br>
第二個 a 是 <code>NaN</code>，是因為 undefined +2 ，本來就不是數字</p>
<blockquote>
<p>由此可知 function 內的提升順序，<strong>function &gt; 參數 &gt; 變數</strong><br>
Global 的提升順序，<strong>function &gt; 變數</strong></p>
</blockquote>
<h2 id="總結-26">總結</h2>
<p>如果有誤歡迎告訴我，有時候寫到有點茫了…<br>
整理的過程中也讓我更清楚知道，變數、參數、函式為什麼會宣告提升，以及怎麼被提升，基本上遇到該類型的題目保持一樣的邏輯跟引擎一起動就好 :D</p>
<p>這篇尚未提及 ES6 的 let 跟 const 宣告提升問題，下一篇會做討論</p>
<hr>
<p>參考 :</p>
<ol>
<li><a href="https://262.ecma-international.org/5.1/#sec-10.3">ECMAScript 262.5.1</a></li>
<li><a href="https://www.udemy.com/course/javascriptjs/">JavaScript 全攻略：克服 JS 的奇怪部分</a></li>
<li><a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/#structure-of-execution-context">dmitrysoshnikov ES5 關於 EC 的結構細節</a></li>
</ol>
]]></content>
      <categories>
        <category>2022</category>
        <category>01</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>紀錄 | DIY 架站 - 安裝 LAMP Server + phpMyAdmin  並且部屬在 AWS EC2 主機</title>
    <url>/2022/02/02/lanch-website.html</url>
    <content><![CDATA[<h2 id="前言-47">前言</h2>
<p>前端跟後端學點皮毛，想要自己架站看看，雖然有免費的 github pages 可以放靜態網站，但遇到資料庫就不支援了，php 檔放到 github pages 只能當純文字而已，於是自己使用虛擬主機跟買網域來架 :D</p>
<p>這次是要安裝 LAMP Server + phpMyAdmin 在 Linux 系統上架站，主機是使用虛擬主機 (AWS EC2)， AWS 提供免費一年就來試試看，網域的話從 <a href="https://www.gandi.net/zh-Hant">Gandi</a> 購買一年份，我才知道域是有分級的，不同的網域價錢真的差很多…</p>
<h2 id="設置">設置</h2>
<p>主要都是參考這篇好文章 =&gt; <a href="https://github.com/Lidemy/mentor-program-2nd-yuchun33/issues/15">部署 AWS EC2 遠端主機 + Ubuntu LAMP 環境 + phpmyadmin)</a><br>
接下來 Let’s GO !</p>
<h3 id="設定-AWS-EC2">設定 AWS EC2</h3>
<p>註冊完 AWS 帳號，登入用 <code>Root user</code>(管理員)，設定上才不會有太多限制。</p>
<p>不過官方還是建議創建 <code>IAM user</code>，在往後日常操作比較適合，我想應該是怕去動到原始設定，或者建議組織架構將權限分散。<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mf8DngFOVKM87YZaaJg_A14Y8pog_C_Hbotg4kAt2JPM7Svs7ebIjUWjdA1uAWlTtVLNnorxd1-1cm8zFbfGI1f45TOng_tiu6bTMQse6HJwXLFozcCQpRIjMq6wan9QCZ88bzbG8I1JGi4Zut53DOE_c-4HBS2P7V3l5Llz_N1EbSj4OUM1Wt9jI2rG1ZKJ2?width=980&amp;height=632&amp;cropmode=none" alt="登入"></p>
<p>登入後會有不同服務方案，選 <code>EC2</code><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4m3ZaSFwn_k99MGTLJskQ0mT7J-RKzcHbNQKpa1BlyqoCstPIcYaOkZNQQ29SJWz1tb0h8vltystPhHyUjiZ9ivknXvFjFjF-MdMbev5fq0MhXgiQ_ZPEhaCUKsPx0UvTCCLFcIqP6fQHwLbqdSBcARYFZKwEFGs37gfajwp35J3dA_ztKa-6dvo_t_u8IG6Js?width=2730&amp;height=1545&amp;cropmode=none" alt="EC2"></p>
<h4 id="Step-1-選虛擬主機">Step 1 : 選虛擬主機</h4>
<p>我選 <code>Ubuntu Server 18.04 LTS (HVM)</code><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mcZYCAzid00O2SXv3_F77FWOcJja7Yrr-fJgevek5LPWFdqxVB1UrYiJDAHCTZwbdjixL24xVXT2wfS2rGiATqDK5dQXmF32Qa4XmpNbEvQHSVllNU-5S607UqWGp7p3GCiNAI4q-HzLi8HWXx45eM4zB2FEkMp8sR6K7WqO-500kCnd09bty9azCLfLEoFAN?width=2735&amp;height=1565&amp;cropmode=none" alt="Ubuntu Server"></p>
<p>中間有好幾部可以略過，也可以自行更改，沒什麼要動可以直接跳到第六步</p>
<p>第二步是選擇伺服器的類型，免費預設類型就很夠用了。<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mUj0tw8Hg-PkgDB91mcYYHevrZpgvbDAl0vJTVeaywND3vwSTuFq-it4bCHSciyhcRsrbYB6UDSovtMyNJ1G14cSpxQnndJI2Y6dCMRJcylEboTYH7X_3iFu6oLTRFnETRRzCh564HZh0DV4PAOprW5bB1YrsxLQOgMUYTWeoJ4-byY6PQCwwZowe6t4Vp5aI?width=2408&amp;height=1376&amp;cropmode=none" alt="選主機類型"><br>
第三步是伺服器設定的細節<br>
第四步是記憶體容量設定，預設是 8 GB<br>
第五步是跟容量有關係的設定 (看不太懂…)</p>
<h4 id="Step-2-第六步-Configure-Security-Group">Step 2 : 第六步 Configure Security Group</h4>
<p>設定網路通道跟安全，只要先新增 HTTP 跟 HTTPS ，才能使用網頁連線，再按 <code>Review and Lanch</code>，最後一步是全面步驟的總和而已<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mq2kdMSDZmkJbh1bArHYZmR-YD8MfcpFkh-SI9D41krI7xiNPfeNEP0eZkpO6YwMIPgcLzm-BoaYfb-stJGi0Za-U54-_7GXYpvoixprGZ7kH1xzN3k6Fchw7xL5ZOrQpR6hZ3Xbc2JPdMc5BQnmRbup9I8tJd_2GaMizMnFA7aB33pQCh_a42lAzErvuKGhw?width=2735&amp;height=1312&amp;cropmode=none" alt="Configure Security Group"></p>
<h4 id="Step-3-配對金鑰">Step 3 : 配對金鑰</h4>
<p>因為要透過 SSH 連線，必須要有金鑰，<code>RSA</code> 是常見的非對稱加密法。</p>
<p>下拉選單會有三個選項，第一次使用 <code>create</code>，下面是檔案名稱，會產生 <code>&lt;filename&gt;.pem</code> 的檔案，等等連線會用到<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mfUwE7kl8QCWfs1FyTwVLWGf0surxUO4Gy2ypz51DkRyidK1x_ba_y3UZoGKMoJRA5Btj3GE9e7Og5n2FC9Ui-0D3lR3Bz3oSv_O9EtAt2Ukakfi8WZJ1cMfAGlmOa36vlrHWuggCkGA2YAKa3Qg5yUplIvGWI4VfPe0Ff2r4Punh0Qqsr_DquNx2RSexPMq0?width=2408&amp;height=1376&amp;cropmode=none" alt="下載金鑰"></p>
<h4 id="Step-4-記下-IPv4">Step 4 記下 IPv4</h4>
<p>回到 EC2 儀錶板，會有主機的狀態訊息，選擇剛剛開起來正在執行的<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4m3ZJghMG-GmoRrtVNdLOp_xOr8AEQ35BhoCKrzSPbCyG7RYKKF_U6N-CrjkhcMNBvLk_3tzHP8-QaRveiWr-rxs7W6H1h4VD9tyRqN-k0NF_FIrkuOFNg9C4JSKwr9poJM29KLxXCqk2DjA-fctK0btph1HgC9UXcN3fpw63q_KtMvgWuHwqL5oL561k2sYx5?width=2408&amp;height=1376&amp;cropmode=none" alt="EC2 儀錶板"></p>
<p>點一下正在執行的個體，下面會有概要，記下公有 <code>IPv4</code><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mOjbTxzVsSeLt_jimxUFsqt6Q-P-TQ87TmsNKzunm3WEff2KXdhzavkrCFkBepOY33-vUTXsXT6S1nU9cQY2BJwpUxIy8l4FBJfEJM3n6fFOTD2lN5vAukmZJQ93i8bkte6EdZPGDCg3a0Y5oi3CDQNWAgA5VP12ckOVPuJF6vTmpuq1b8bYJHomOtS6Z191s?width=2408&amp;height=1376&amp;cropmode=none" alt="IPv4"></p>
<p>到這步就有一個只有作業系統的主機，接著再把環境給裝起來</p>
<h3 id="設定-LAMP-環境">設定 LAMP 環境</h3>
<ul>
<li><strong>L</strong>inux : 作業系統</li>
<li><strong>A</strong>pache : 網頁伺服器</li>
<li><strong>M</strong>ariDB or <strong>M</strong>ySQL : 資料庫</li>
<li><strong>P</strong>HP : 可以編寫動態網頁的程式碼</li>
</ul>
<h4 id="Step-5-連上虛擬-遠端-主機">Step 5 連上虛擬(遠端)主機</h4>
<p>剛剛下載的金鑰，跟記下的 IPv4 派上用場<br>
金鑰如果跟 cmd 目錄不同，記得加上相對路徑</p>
<p>打開 cmd 輸入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -i &lt;file.pem&gt; ubuntu@&lt;IPv4&gt;</span><br></pre></td></tr></table></figure>
<p>例 : <code>ssh -i ~/Desktop/key.pem ubuntu@123.11.22.3</code><br>
問 :  <code>Are you sure you want to continue  connecting (yes/no)?</code><br>
答 : <code>y</code><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mn3vALzZNWp-Acn_mxNele8w-LVujJTvzr30apsQsRuUis-cs-UCn3AVE5gGcg3_GUIOmHRTHDufaHNwW93B5TWDwbpKGkM2fYkiDc4QFZL_NdhXERBpNXhnN758xE48g023o9Nvz_szUsqfsrVDL-7bKdd9AaSvYOwQy0DpWfPGNhMT2JUu3kLsqjhB3SRD4?width=1925&amp;height=1142&amp;cropmode=none" alt="登入遠端主機"></p>
<p>前面變成主機位置就是登進去了</p>
<h4 id="Step-6-系統更新">Step 6 : 系統更新</h4>
<p>裝伺服器之前系統更新一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt dist-upgrade</span><br></pre></td></tr></table></figure>
<p>問 : 是否繼續下載 ?<br>
答 : y</p>
<ul>
<li><strong>apt</strong> (Advanced Packaging Tool) : 套件管理器工具，可以做套件的查找、升級、安装、刪除，執行必須要有 <code>root</code> (超級管理員)的權限</li>
</ul>
<p>所以這邊都會用 <code>sudo</code></p>
<h4 id="Step-7-好用的套件-tasksel">Step 7 : 好用的套件 tasksel</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install tasksel</span><br></pre></td></tr></table></figure>
<p>tasksel 是已經幫你整理好成一組的工具，包含 LAMP 伺服器<br>
輸入 <code>sudo tasksel</code> 看到的安裝介面，可以一次選好幾個，打包成一組安裝<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mnt-7tjSuj7EUF7qdsQXy43btYrwRq84uk4ZxfGJfFMHh5BpAArgfUZopHq6IngtePnB8s2RyVTG-49PJt1uiNbLdhDAud3GoVRmWhftui7LL3O4MqGb7cjizJEcS6M80Orrida7n0fFV0uVmjAFhPoeohQjw8ls3X_p6VY7iAO6VQvztquBnCuau_PVj2hoj?width=1905&amp;height=1675&amp;cropmode=none" alt="tasksel 安裝包"></p>
<h4 id="Step-7-安裝-LAMP-server">Step 7 : 安裝 LAMP server</h4>
<p>也可以直接打入指令直接安裝，不用再到介面選擇</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tasksel install lamp-server</span><br></pre></td></tr></table></figure>
<p>會跳一下紫色視窗代表安裝，在網頁打上 IPv4 的網址，就會出現 apache 起始頁面代表成功<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mnfxBZr0dvNkHq_dKRmxzdzCheXNg77h9mjJd7jMRFfJPYslmw53w4REgiHf8lb3LXHLoY82NHDfCPj7Qp4CwWTzCPM2f8s0jWkVP1hDq8WrcpDke6BzM8eYGHNxXdc3RtHgtGJdBAUHBuT5y2Roulmu1yCL3BKI9n2D0xb-tQ5L-a5PH2v8rIkPPUTwb0hQ0?width=2679&amp;height=1537&amp;cropmode=none" alt="成功連上的畫面"></p>
<h3 id="設定-phpmyadmin">設定 phpmyadmin</h3>
<p>phpmyadmin 是 mySQL 管理的介面軟體，不用下載軟體就可以在網頁連上資料庫。</p>
<p>後續我也會使用 <code>MySQL Workbench 8.0 EC</code> 桌上軟體來管理資料庫。</p>
<h4 id="Step-8-安裝-phpmyadmin">Step 8 : 安裝 phpmyadmin</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install phpmyadmin</span><br></pre></td></tr></table></figure>
<p><img data-src="https://dsm01pap006files.storage.live.com/y4mLZKbUP3LkaBCAIM6PKtuBVQ7_zF7hu4uNXPod28KcInO3uuPjaIovOMk4980mfsHPLu5oYyJ-HP2JViGignoFy0VZOYMOi96QX9EbPch5Tt2Sg3k60lGRvser2az_NGR7WLi8ECRPVoxXrcbcVvLDvYltfT8Ok0vMpEGvRG7JC-g1lw5J4qJBHItThHCP8mP?width=1892&amp;height=1687&amp;cropmode=none" alt="連接 apache"><br>
記得要按一下空白鍵，出現星號才是選定，讓 phpmyadmin 連接到 apache2，不然後面會無法連上，我第一次就沒有按到導致輸入網址是沒辦法連上的 (已解決  [[#解決問題 網址連不上]])</p>
<p>問 : 是否設定 dbconfig-common<br>
答 : Y</p>
<p>會建立一個新的 MySQL 使用者來操作運行 phpmyadmin 額外需要用到的資料表。預設使用者名稱為 <code>phpmyadmin</code>，接著要設定 phpmyadmin 這個 MySQL 使用者的密碼</p>
<p>記得這裡是新的 user 設定 phpmyadmin 操作， root 還沒有</p>
<h4 id="Step-9-設定-phpmyadmin-登入">Step 9 : 設定 phpmyadmin 登入</h4>
<p>預設 MySQL root 密碼是空的，但沒辦法使用密碼來登入(因為驗證方式是 <code>auto_socket</code>)。<br>
為了讓 phpmyadmin 可以用 root 帳號管理，就要先設定 MySQL 本身的 root 帳號，變成可以透過帳號密碼來登入</p>
<p>透過 root 帳號進到 <code>mysql</code> 這個資料庫</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mysql -u root mysql</span><br></pre></td></tr></table></figure>
<p>進到 MySQL 的 shell，加入讓 root 啟用<br>
<code>mysql_native_password</code> 插件，在來一定要刷新權限表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> plugin<span class="operator">=</span><span class="string">&#x27;mysql_native_password&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>記得尾巴一定要有分號，才是完整的斷句</p>
<p>再來離開 mysql  <code>exit</code></p>
<h4 id="Step-10-設定-MySQL-的-root-密碼">Step 10 : 設定 MySQL 的 root 密碼</h4>
<p>剛剛只是開啟功能，接下來要真的設定密碼，輸入  :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>
<p>開啟 <code>VALIDATE PASSWORD</code> 插件，密碼驗證，幫忙檢查 root 的密碼安全性，會問是否啟用， 答 <code>y</code></p>
<p>再來會問密碼複雜度</p>
<ul>
<li>0 (Low) : 長度大於等於 8</li>
<li>1 (Medium) : 長度大於等於 8，包含大小寫和一個特殊字元</li>
<li>2 (Strong) : 長度大於等於 8，包含大小寫和一個特殊字元，包含字典檢查 (???)</li>
</ul>
<p>直接選 2 就好，再來要輸入兩次密碼，後面會詢問幾項問題</p>
<ul>
<li>確認密碼輸入無誤 : y</li>
<li>移除匿名使用者的資料 : y</li>
<li>可以禁止從遠端使用MySQL的root帳號來登入MySQL : y</li>
<li>移除測試用的資料庫 : y</li>
<li>重新載入權限表 : y</li>
</ul>
<p>都給他 y 下去就是了。到最後就 ok 了，接著打開瀏覽器輸入 <code>&lt;IPv4&gt;/phpmyadmin</code> 看到登入頁面就可以使用了<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4muMsNIJeduUG0E5NPBPq4IJWIhaSOSpG3q51AO5s6Hvj1iiCPcr1XGPpAe_eQCIu6zWV1bt09EJamYRnLspgQFHFmEzHj6feXlmVnprFR6Tu5COkNSEOFy6op49B82xyGc5T1bUruuwckI2FCrz1RDzk-YV0GjH2XyoruE5i8G8D1PpKeDG2c2mPfdqN2Yg_O?width=2408&amp;height=1376&amp;cropmode=none" alt="/phpmyadmin"></p>
<h5 id="解決問題-網址連不上">解決問題 : 網址連不上</h5>
<p>直到再網址上打 <code>/phpmyadmin</code> 都連不上，重新安裝後 MySQL 顯示是 OK 的，<code>show databases</code> 也有看到 phpmyadmin 的 schema，但不知道為什麼都連不上 QQ</p>
<ul>
<li>
<p>方法一 : 重新再設定<br>
一樣會跳回第一次選擇連接的伺服器口</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg-reconfigure phpmyadmin</span><br></pre></td></tr></table></figure>
<p>dpkg 也是處理安裝套件的一種管理指令，跟 apt 很像，但差別在 <code>dpkg</code> 安裝套件並不包含依賴關係。</p>
</li>
<li>
<p>方法二 : 手動把檔案連結起來</p>
</li>
</ul>
<ol>
<li>
<p>先確定連結的檔案存不存在</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file /etc/apache2/conf-enabled/phpmyadmin.conf</span><br></pre></td></tr></table></figure>
<p>如果有會出現<br>
<code>/etc/apache2/conf-enabled/phpmyadmin.conf: symbolic link to ../conf-available/phpmyadmin.conf</code><br>
沒有的話就會報錯</p>
</li>
<li>
<p>手動連結</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /etc/phpmyadmin/apache.conf /etc/apache2/conf-available/phpmyadmin.conf</span><br><span class="line">sudo a2enconf phpmyadmin</span><br><span class="line">sudo systemctl reload apache2</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ln</code> : 會把兩個檔案連結起來</li>
<li>第二個是重新設定</li>
<li>第三個是系統重載入 apache2</li>
</ul>
</li>
</ol>
<h4 id="Step-11-把網頁放上來">Step 11 : 把網頁放上來</h4>
<p>網頁檔案要放在 <code>/var/www/html</code> 底下<br>
先移到資料夾底下 <code>cd /var/www/html</code>，建立一個網頁 <code>vi index.html</code>，打個 html，到網址打上位址，出現內容代表 OK 了 :D</p>
<ul>
<li>使用 <code>git clone</code><br>
失敗的原因是權限，那對 <code>/var/www/html</code> 更改權限  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> ubuntu /var/www/html</span><br></pre></td></tr></table></figure>
再使用一次 git clone 就沒問題了
<ul>
<li><code>chown &lt;&gt;</code></li>
</ul>
</li>
</ul>
<h3 id="網域設置">網域設置</h3>
<p>我在 gandi 買了自己的網域，打開域名設定<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mWOHsaEFsldsxUXYVnt4AAC_qHEDpom6VjiExv8gUu3TPFBQ-01EnSY3ZcJhUqjCAa_seueuDv6babkELzu_W8W7RVjEXUsbD4SJYsZjBVo6rtRs0HY20FjqioD_7bIfOUCWOUKqKOYPEQNwUFs9Gu0hVSn2sVjQvgGjpJiQyUO2nVFstN-RbU4kjiv1Etqk9?width=2735&amp;height=1573&amp;cropmode=none" alt="DNS 轉址設定"><br>
更動這個 <code>A</code> 的值改成 <code>IPv4</code> 也就是虛擬主機的 IP，對應到 IPv4 的 32 位元位址</p>
<ul>
<li><code>A</code> : 將DNS網域名稱對應到IPv4的32位元位址</li>
<li><code>CNAME</code> : 同一部主機設定許多別名</li>
</ul>
<p>等大概一會兒，在打上自己買的網域，就會連到 IPv4 看到的畫面，後面可以在新增自己的子網域</p>
<h3 id="補充-把資料庫連線到-MySQL-Workbench">補充 : 把資料庫連線到 MySQL Workbench</h3>
<p>雖然有 phpmyadmin 了，之前我都是用 workbench 來管理，來換一下吧</p>
<p>這時候直接新增 connection 會被擋掉，根據這篇 <a href="https://lidemy5thwbc.coderbridge.io/2021/07/27/webserver-set/">文章</a> 做設定</p>
<ol>
<li>
<p>遠端主機的防火牆<br>
防火牆會擋住外來的連線，這時候要到 EC2 安全性設定打開 MySQL 通道<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mGvlCum2TSup9BLc0Pz6uHBCW5s3dikyxRLRjscvgkgJd4goDhU-i4tneFJ7WOQ_3EphoMuBLY79U6sSnDnv61KkKkCfFdZnUFlJvBfHs3CDKUqPhH-4gDxwOMYZWUMfBjl7WRJbz0w01xmxAhcZUDyF2jWVfvEU204PZ3Y7AdXX7-CEESrgbuS-uGDXMklW-?width=2408&amp;height=1376&amp;cropmode=none" alt="防火牆設定"><br>
按下編輯後會列出所有規則，在最下面新增一個 MySQL port 3306，然後儲存<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mLdtiE_1fwss9MHgYjXweRxDnCZiVswDaexi_8Y91KM-JVydwdt29pszdUwoIbgSm_hXnlH1y8-3mL93q2fCRwfmnYWEda09G7MMUKYzVOKK8D1CD41GLZQoDBHWKzont0vtYdLrVLD1mf76XAM1O0dHp828CTocVbTAqt77iePJcSQ8tNt-ipL9krJd1jZem?width=2408&amp;height=1032&amp;cropmode=none" alt="設定 MySQL"></p>
</li>
<li>
<p>MySQL 同意遠端連線<br>
預設是只能連線本機，但軟體是裝在我的電腦上，而不是遠端的主機，所以也要設定 MySQL 連線問題</p>
<p>連線到遠端主機</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -i ~/key.pem ubuntu@&lt;IPv4&gt;</span><br></pre></td></tr></table></figure>
<p>修改 MySQL 設定檔</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>
<p>找到 <code>bind-address</code> ，原本會是 <code>127.0.0.1</code>，只允許本機，改成 <code>0.0.0.0</code> 或者註解掉這行也可以<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4muXJECe6tXKTdZargY3Puf_nhNra6cV_3c2B1KtAZzI8kAT6K-rNjN-A9up6aO9JE6arHtYFMBLl3Ys_8DmsseSQWRSjSzUoInN4mIWtLWn7dGk0_SO9J4KmbpQ-Ut5b7BFEvH44hpOrQferqTqYyu5J9g0czooL1GkeGUrhHmSJrzUM-IomyQD9Dtp2aK3h7?width=1917&amp;height=1670&amp;cropmode=none" alt="允許外部連接"></p>
<p>最後重新啟動 MySQL ，讓設定寫入</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>phpmyadmin 解除個別使用者的遠端連線限制<br>
用 root 連線到 phpmyadmin，到 <code>使用者帳號</code>，點擊 <code>編輯權限</code><br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mfv_hg8buRnf-GBShL_zMPOz0DkSf7kErvTLBwqJ5_-lsG_VlnYh3ceyIYSiEuvwQjWCFpNiLarRonbIDzCGwCXPtdCLkmTT6hKwELsqgu7wAW4t3TpZit1hBaq6DUQ0tsttUowm5xzCxvnUuTleRGFnesu3C0ebWpN28McgVHbBg_f8Bsyn2f0HY0fHkwzrg?width=2408&amp;height=2021&amp;cropmode=none" alt="編輯權限"><br>
跳到 <code>登入資訊</code> ，把主機名稱改為任意主機。<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mI5KlKXpxlvV1Cbko1UPT4WnzBUPvzilV5zxmi31ymj4gDM46DuSzqY3z5y0vOxL5F2yYri2Jl3Dbk0HqgoC-axND4ESiX-jzwTScDfqztPKxI69EVbq1HoRdPzb3yJ-hxYTJpe_OZMBfjtTYTThdBc8xeqiHBjzkxEmwcvdtZVyAuN7D4zNwBIaVX4sbLJIh?width=2408&amp;height=1976&amp;cropmode=none" alt="修改登入資訊"><br>
最後回到 mysql CLI 打更新權限</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES</span><br></pre></td></tr></table></figure>
<p>大功告成 QQ，至此所有的封印都解除了，回到 MySQL Workbench 新增一筆新的連線<br>
搭拉 ! 成功<br>
<img data-src="https://dsm01pap006files.storage.live.com/y4mTaT_SAlbQeh09auWSIkVUd77ntYREr4HeKgJlWNOrLFIlwNylxz4KD7Vm92HChqkxcI2VLAbv9nNAUIFbNuxbFU9XHsScWWtJ9XxhHbGobfaR9YTYo2IMpWCCj2AujdYS4oaE4mxmwxtX9yTVpDL7kdUVVmJ48ZSRywv8puKRL_po2kuBsXhPEGFDzu-6XIP?width=2735&amp;height=1825&amp;cropmode=none" alt="Workbench 測試連線"></p>
</li>
</ol>
<h2 id="結語-16">結語</h2>
<p>歷經千辛萬苦終於架好了，沒有想到架站步驟是這麼的複雜，必須突破一層層關卡，像是雖然打開了虛擬主機外部連線問題，但 MySQL 也是要更改權限問題，不然也還是不成功的。</p>
<p>另外比較印象深刻的大概是買網域的部分，當時挑很久，在思考不同網域名的差別。我才知道網域是有分級的，<code>.shop</code> 這個字尤其價值不斐。不過轉念想想，好的網域名，在使用者輸入更好記，會記住這個網頁的用途，SEO 自然就會比較好。</p>
<p>再來就是虛擬主機的部分，裡面大多都是我看不懂的東西，大多都是偏向是硬體，因為我本身沒有接觸硬體，之後會想多了解一些…</p>
<hr>
<p>參考 :</p>
<ul>
<li><a href="https://github.com/Lidemy/mentor-program-2nd-yuchun33/issues/15">部署 AWS EC2 遠端主機 + Ubuntu LAMP 環境 + phpmyadmin)</a></li>
<li><a href="https://magiclen.org/lamp/">安裝 LAMP Server + phpMyAdmin 在 Linux 系統上輕鬆架設網站 | MagicLen</a></li>
<li><a href="https://lidemy5thwbc.coderbridge.io/2021/07/27/webserver-set/">網頁伺服器架站流程 (coderbridge.io)</a></li>
<li><a href="https://drive.google.com/file/d/1ZymwmKb3MaX3F5YMQb77AC_wrUsX_ljS/view">Install phpMyAdmin with Apache (LAMP) on Ubuntu.txt</a> : phpmyadmin 連接 apache 問題</li>
<li><a href="http://dns-learning.twnic.net.tw/bind/intro6.html">DNS資源紀錄(Resource Record)介紹 (twnic.net.tw)</a></li>
</ul>
]]></content>
      <categories>
        <category>2022</category>
        <category>02</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>phpMyadmin</tag>
        <tag>LAMP</tag>
      </tags>
  </entry>
  <entry>
    <title>心得 | Foresea畢業專題(III)─《Finalfinal.docx》</title>
    <url>/2021/06/06/Foresea-bookreport-III.html</url>
    <content><![CDATA[<h2 id="閱讀前注意">閱讀前注意</h2>
<p>文長慎入，純心得，就當作看一個很長的故事吧。<br>
我的文筆也沒有很好，若看不下去請自行左上角離開<br>
其中個人主觀意識較重，若不喜勿入<br>
如果你只想知道校外展我遇到了什麼事，可以到<strong>開花時刻</strong>這個快速連結<br>
6/6 是表定的畢業典禮日期，疫情打亂了所有秩序😵，一年前誰能想到如此情況呢?<br>
在家寫寫最後一篇廢文，這篇是大學的最後一篇。</p>
<span id="more"></span>  
<h2 id="正篇">正篇</h2>
<p>將分享我從 <strong>找組員 ⇒ 專題期間 ⇒ 專題結束後 ⇒ 校外展覽</strong> 的心路歷程。</p>
<h3 id="播下美好的理想種子">播下美好的理想種子</h3>
<p>團隊合作理想上是件美好的事，實際上是非常要命的。<br>
除了有共同的目標，後續的團隊經營更是關鍵，相信大家都有體會過。<br>
畢業專題，就是個魔王大挑戰。一年下來，情誼不是更加牢固，就是散掉👿</p>
<blockquote>
<p>還有 <strong>專案管理</strong> 請好好學</p>
</blockquote>
<h4 id="落地生根的地方">落地生根的地方</h4>
<p>說到分組，我想大家<code>**&quot;預設&quot;**</code>應該是自己的好朋友，這是最正常不過的答案了<br>
不管能力、共識默契，都無須重新培養，是最佳的選擇。<br>
而我，眾所皆知是個邊緣人🤪，預設是 null (空值)，只有兩條路 被撿 跟 自己找。</p>
<h4 id="栽種的實力">栽種的實力</h4>
<p>我認知自己的能力是普通且算平均的，在遊戲程式、網頁、動畫這些方面還堪用<br>
加上當時想法只有 <strong>我想做一個互動作品</strong>。<br>
起初我有向一些人談論過我的想法，但從未正式談論&quot;成組&quot;這件事。<br>
因為一開始我在消極被動等待，等待有人撿我🥺<br>
但最終…沒人撿😵，所以我自己成組去尋找人了。</p>
<blockquote>
<p><strong>題外</strong> | 有時候我會好奇，大家會怎麼選擇…</p>
</blockquote>
<ul>
<li>🙉 現是蔡逼八，左看有潛力<s>但戰力還不穩</s></li>
<li>🕵️‍♂️現有點實力與戰力<s>但是會吃老本</s><br>
考量的中間因素有很多，例如 專案時程、個人特質、團隊性質等等，並沒有一個正確答案。</li>
</ul>
<h4 id="鋪上土壤"><strong>鋪上土壤</strong></h4>
<p>慶幸的是，在升大三的暑假結束時，我順利找到3位組員。<br>
當時不少人對我找的人有點疑惑，連組員們各自也不例外，都覺得很奇妙。</p>
<blockquote>
<p>為什麼會找她呢 ? 而不是…</p>
</blockquote>
<p>這三位確實是沒什麼合作過，4人也完全沒有在同一組過<br>
如果問我當時在想什麼，可能是被附身了吧。</p>
<ul>
<li>沒啦 ! 我當然是有跟3位好好說清楚找他們的原因。<br>
我的專案所需的職位，分別是
<ul>
<li>遊戲程式</li>
<li>網頁</li>
<li>美術</li>
<li>動畫</li>
</ul>
</li>
</ul>
<p>企劃則是所有人共寫，找人的標準來自上面的<strong>題外話</strong></p>
<ul>
<li>潛力者*2 + 戰力者*2</li>
</ul>
<p>當然我是潛力者🥴，程式菜逼八。<br>
綜合起來，需要在各方面是有互補的。<br>
目標一致，但各自思考的面相是非常獨立的<br>
不會太常出現<code>毫無理由</code>或<code>附和通過意見</code>的問題。</p>
<p>實際上到成組這期間，我等待回覆是非常煎熬。<br>
當時最大的困難，是讓<strong>兩兩好友</strong>拆在不同組這個問題。</p>
<p>無時不刻，讓我覺得自己像卡通裡的個反派🕵️<br>
如我上面所說的，普遍的<strong>預設值</strong>是好朋友。我並不是刻意將其拆散，單純是找符合我需求的<br>
在邀請第一個人的時候，我意識到這個問題，並去詢問多個局外人，有的人說 :</p>
<blockquote>
<p>「很不道德，你應該找兩個人討論，找一個這麼做是在破壞人家的友誼」<br>
「為什麼兩個都不找進來 ? 問題不就解決了 ?」</p>
</blockquote>
<p>也有人說 :</p>
<blockquote>
<p>「即使是朋友，目標也可能各自不同，選擇是個人自由，沒什麼問題」</p>
</blockquote>
<p>中間，我不斷地告訴其中兩位，希望各自可以跟好朋友談談，要拒絕我也沒關係。<br>
這個問題，在理想跟愧疚之間，糾結我整個暑假🥴。</p>
<h4 id="種子驚喜包">種子驚喜包</h4>
<p>壞事是這樣的全新團隊需要磨合的點更多，只能祈禱這樣的組合一路順利。<br>
好事是這裡將 從0共同成長，0偏頗、0規則，可塑性更高(我不確定是不是這樣講)<br>
傳統來說就是新活力新氣象🥴<br>
我想這3位都應該有預設心理:</p>
<blockquote>
<p>投資一定有風險，<strong>團隊組成有凱也有雷</strong>，組成前應詳閱公開說明書。</p>
</blockquote>
<p>很抱歉，我沒有給3位詳閱說明書的機會，不過非常謝謝她們答應當時的我<br>
票選出主題、決定好指導老師，大家抱著美好的理想起步了<br>
不過卻也是另一個噩夢的正式開始…</p>
<blockquote>
<h5 id="分組題外話-綜觀大學生涯"><strong>分組題外話 | 綜觀大學生涯</strong></h5>
</blockquote>
<p>坦白講，每次組隊就像是在玩踩地雷，但我踩得蠻歡樂的<br>
不過記住同時<strong>自己對別人也是顆地雷</strong>。<br>
每一堂的團體作業，我的組員組成都不會一樣。<br>
<s>如果不喜歡驚喜，建議不要這樣。</s><br>
大學團體作業很多，可以跟朋友、跟能力強的、跟混分的等等，但先取決於自己的角色定位<br>
四年裡，我加入過許多不同的團體組合裡，很好玩也很刺激<br>
不談&quot;合作愉不愉快&quot;，跟平時不同群的人交流，讓我知道更多不同面向需要思考。<br>
如果還有團體作業，我蠻建議跳脫平時的組，不過後果請自行負責。</p>
<h3 id="發育不良的樹">發育不良的樹</h3>
<blockquote>
<p><strong>理想很美滿，現實很骨感。</strong></p>
</blockquote>
<p>樹苗的成長，沒人保證能長得又大又直<br>
專案的時程，沒人有十足把握在準確的時間完成😭</p>
<h4 id="陸上颱風警報">陸上颱風警報</h4>
<p>除了專題外，同時還有畢業展覽的事務正在進行。<br>
我與組內的另一位組員分別擔任總、副召，要讓工作跟專題達平衡非常困難 😵<br>
展覽籌備前期有很長時間都在討論與規劃，更棘手的是事務涉及多個組。<br>
溝通與合作在磨合期是相當花費時間的。<br>
若有重大事件，幾乎是要將我的專題停擺，先將另一邊止血。<br>
這樣的問題，發生不少次，但也沒辦法，該解決就需要解決。<br>
但每次專題一停擺，我很想跟專題組員切腹謝罪去了</p>
<h4 id="瘦弱的樹苗"><strong>瘦弱的樹苗</strong></h4>
<p>在升大四的暑假，我就已經陸續在寫遊戲中的程式<br>
組內的大家也如火如荼的進行各自的進度。<br>
偶爾會與指導教授定期的專案進度討論，但每每到這個環節，我很緊張也很尷尬。<br>
因為我總是 是那個 <code>進度沒有達標</code> ，而且會說「<strong>相信我會完成</strong>」的人。<br>
(什麼熱血笨蛋啦!)<br>
說這句話的同時，我想讓大家安心，另外也是在為自己打氣，雖然聽起來很唬爛。</p>
<blockquote>
<p>結果是什麼呢?</p>
</blockquote>
<p>當然是我成了投資中最大的風險，成了團隊之雷，更成了一個打臉自己的人😰</p>
<center>
<p><img data-src="https://chi01pap001files.storage.live.com/y4mKsiKYyPeJlzwV7CX1cucK-W1yrWxB7UMDdHDDRZ1YUtZ4HVTwKmHqplY8i1LM4m-9jWGwMSJO8A-XZvQowN4_RitKSKr4D6sUklWxjrpStu0ymf0kn31zDMszPG5XJIQUjkx9hwR6-tJdUGqZmjZAZH-af_d3QALcqKdlENtWz44OYMugCHgCwDamgAVDaGz?width=256&amp;height=256&amp;cropmode=none" alt=""></p>
</center>   
<p>當看到其他組員拿出一堆的進度，而我有時候因為程式問題卡住很長一段時間<br>
大家不斷地在成長，只有我還在原地。我心裡開始迷惘，不知所措。<br>
因為程式會寫就是會寫，按下執行就知道了，跑不出來就是寫的人的問題。<br>
無疑地，當時超級菜雞般的程式能力，是完全無法支撐起整個專案。<br>
即使我學習再學習，練習再練習，常常還是跑出令人絕望的 Error 與 BUG。</p>
<center>  
<p><img data-src="https://chi01pap001files.storage.live.com/y4mQV5G4B0IOVO5ESIMw1byLnoLNxteeWCaJpbfiH1hHi7iDWytdwQYwbyABQ2PXAWiEVgqJ80W68t8faBQDfnovvsaEMli2KKblFrMKmXVdC4rOykE9L3wG-TbgtKga_ZUweHjd7g8DpnqRfHcjXX83f4shg4axqWnYSc4B-2vw2cz82eoKUqmWGC0MisIoka8?width=256&amp;height=174&amp;cropmode=none" alt=""></p>
</center> 
大家非常包容，知道我身兼畢展總召與擔任程式的部分比較繁重，都說沒關係  
老實說，到最後我已經不知道大家是真的相信我，還是被我逼到不得不相信我了。  
不論如何，專案時程不能變成無底洞，所以我告訴自己，一刻都不能怠惰。  
至此，我開始跟日出報到:D...。  
<h4 id="不間斷的夏秋季颱風"><strong>不間斷的夏秋季颱風</strong></h4>
<p>之前聽做專題的學長姊都說好幾天會做到日出。<br>
我思考了一下🥴，Umm…年輕人，我還行啦👍<br>
第一次做到看日出，我心想 :<br>
「真感動，我認真到日出，程式修好就順了吧，日出再見了」</p>
<blockquote>
<p><strong>沒想到，這一再見，真的每天再見面。</strong></p>
</blockquote>
<p>製作專題的當年9至12月，我每天都在看日出，少說也有3.5個月<br>
日夜顛倒加上畢展總總事務，心理與生理狀況都開始亮起了紅燈。<br>
我的焦慮值<strong>MAX</strong> ! 躁鬱值<strong>MAX</strong> ! 體重<strong>MAX</strong> !<br>
生理期直接Bang不見🎉 !<br>
經歷幾次的狂風暴雨，盆栽倒了，而我也被吹倒了🥀</p>
<h4 id="長歪的樹"><strong>長歪的樹</strong></h4>
<blockquote>
<p><strong>早上八點，晚安</strong>🌑**；早上十一點，早安**⛅</p>
</blockquote>
<p>不僅是專題的程式的問題，畢展的事同時也讓人心煩。<br>
日復一日的熬夜，我開始對專題變得有點消極。<br>
會對組員說 :<br>
「<strong>我們可以提出概念性的東西，做出一兩關就好，不一定要完全做完…blabla</strong>」<br>
到了專案進度討論，大家會告訴我，先去完成其他的關卡比較重要，小東西之後再細修<br>
很不巧，A關卡與B關卡中間機制需要連動。當我完成A，再去完成B，換成A有問題了</p>
<p>◢▆▅▄▃ 崩╰(〒皿〒)╯潰 ▃▄▅▆◣</p>
<p>寫不出來，崩潰挾帶氣憤，我就會說「不然你來寫啊 !」<br>
<s>阿…容我回到過去揍自己一拳</s><br>
氣憤中更多的是對自己做不到目標而感到失望。<br>
最不幸的大概是家裡的娃娃們，全變成我的出氣筒，橫屍遍野。<br>
早期對專題懷抱的熱情，已經被消磨成灰了。</p>
<h3 id="滿地枯葉">滿地枯葉</h3>
<p>ˍ(:з」∠) 我…想…躺著休息</p>
<h4 id="用力吸收水分的根"><strong>用力吸收水分的根</strong></h4>
<p>專題總共有4次報告，我一共上台3場。<br>
最後2場，都是前一天熬滿夜把程式硬是弄出來，勉強弄好3-4關(但我們一共有6個關卡哦🥴)<br>
組員們在報告前10分鐘，都還在幫忙我弄報告的大大小小事，非常感激不離不棄😭<br>
因為遊戲進度是掌握在我手上，其他人是不太好說明遊戲新產出的部分<br>
所以我報告是最適合的，我知道我才能把這邊的進度好好說明。<br>
我想最緊張的不是我，而是指導教授跟組員們，每次都是在現場打開驚喜包🎁</p>
<center> 
<p><img data-src="https://chi01pap001files.storage.live.com/y4mMZgrK4sHXixsgQLTeCBVabRw0CPchkWizOj7WWxq8hivFiGPteNC2fxfW-aEwaNQRsJpNZ_3jTnNrvpZNDEpPrU4xQRYmNtUID4Y33HzwB_ERuYEA_RV7f9Z7xmA4wN7cCQQykhpTXWMXU-ad9tHCJzHY4Zv0rvX0mY3FbsjTkpwAsEJGtRSUs0E_oVPTjJv?width=256&amp;height=145&amp;cropmode=none" alt=""></p>
</center> 
<ul>
<li>大家心臟有沒有越變越大顆呢?</li>
</ul>
<p>報告的結果，想當然爾，非常之差💩。<br>
有一場，回想起來我都覺得很尷尬，因為沒有獲得什麼新回饋。<br>
都是之前提過的，「美術很棒」、「網頁很棒」。<br>
當下我在想我的部份是 <strong><code>無藥可救</code></strong> 了? 還是 <strong><code>出乎意料</code></strong> 呢?<br>
不管怎樣，我知道我搞砸了。<br>
無聲的回饋，間接說明我努力的還不夠。<br>
最後一場更是慘不忍睹😢，因為遊戲沒有做完，僅有4關的試玩的影片片段。<br>
組內成品還好還有網頁跟動畫。</p>
<center>   
<p><img data-src="https://chi01pap001files.storage.live.com/y4m0Uxbx4G-Qpga3ZmbeaieLwy7-KWgS1l-MkPwVvICU2jdhRXq8vuWpHkHRPg29sHCKulQ0Vcd8Pv4aI1wc9ryicXDknqIKfMGUa2BdRJIW5lS-PURXmhp0KTGLAryvaLWU-BWd_sdZeBX60cGbjnKBpnt7tUz65KkyaA00OM8n5DTQNC6bM-lDhTIsxucS7FQ?width=256&amp;height=256&amp;cropmode=none" alt=""></p>
</center>   
<ul>
<li>當時被問到我是回答 :<br>
黑丟，還沒做完 🙈 ，瞬間冷場。</li>
</ul>
<h4 id="溺死的根"><strong>溺死的根</strong></h4>
<blockquote>
<p><strong>努力≠有結果</strong></p>
</blockquote>
<p><img data-src="https://chi01pap001files.storage.live.com/y4mKcfCrbkRMCaopIkNsDbQIgg1Y4-ezX4RFUSL8PRkmzz18gtPLsYpxpI5RRizytEQIuJFHEkGxfY2q_lInJdVmNvpJtlNPZW945yANIIg3PSRhqodcgqONnhsdSwrBTFvaEh2eFhXZz3VzPrjWjiDOljlKrhdOEQQ8dg5untwmPzQLLsqFGaNVfLAlcvNmnSA?width=660&amp;height=440&amp;cropmode=none" alt=""></p>
<ul>
<li>學習經驗曲線</li>
</ul>
<p>大家都懂這個曲線，學習最難的，就是一開始陡~~~到攀不過的顛坡。<br>
投入大量的時間與努力，獲得的成果卻是不如預期。<br>
從我寫程式開始，毫無意外也遇到這個問題。<br>
越寫不是越有成就，而是失望。</p>
<p>每天熬夜讀文件、看教學、反覆修修改改，執行後卻還是出BUG。<br>
順利的話，1天可以寫出一關。遇到問題時，都可能要修到1個禮拜，甚至更久。<br>
隨著時間，坐在電腦前已經不知道自己在做什麼了，會覺得這有什麼意義呢?<br>
期間我推掉很多的社交活動，窩在家學習、學習、還是學習。</p>
<p>以前開電腦，很開心。現在開電腦，我只會想砸壞電腦。<br>
一開機，我會問自己還要繼續嗎 ? 隨時放手，就一路爛也沒人能奈何了我💩</p>
<center>
<p><img data-src="https://chi01pap001files.storage.live.com/y4mpRtrZKORO9rXvUtd4tm5-jhN5j27y0fiZAbcWEnbwsTKbGTNh2x16j3cKHajzxBTbvgtdZJlmClfnS0s8EjZJFXAebjHx0QnIxB48IlSgtecYllYxC9e0Kmi3obDdeEFRcMi2YHJXg6QMq5SaODO5i2VDIcigQDG-zASVtanwEvgEfgrtvlR5LHRETy5wo9L?width=256&amp;height=256&amp;cropmode=none" alt=""></p>
</center>
<p>大家也爛 d(`･∀･)b</p>
<blockquote>
<p><strong>要，當然要繼續。責任心告訴我不能就這樣。</strong></p>
</blockquote>
<p>堅持這樣的心情，一路到校內展，讓我做出第一版的  Foresea<br>
不過是歪七扭八的Foresea<br>
如果你在校內展玩到，我跟你說聲抱歉，你玩到一個非常失敗的遊戲。<br>
當時的Foresea是一個跑不順，機制上一堆bug，架構鬆散的作品。</p>
<ul>
<li>
<p><strong>關於Foresea ver1.0</strong><br>
美術、動畫、網站這些產出可以說相當的好。</p>
<p>我會覺得校內展Foresea遊戲失敗的原因，<br>
在於我的能力沒辦法完好地展現企劃中的玩法與流程<br>
在11月的時候，我就做不下去了</p>
<p>因為心裡始終無法認同自己做出來的作品<br>
更覺得自己浪費了這些美術圖，組員辛苦畫出來，而我沒有能力去展現出來。</p>
</li>
</ul>
<h4 id="軟爛的泥土"><strong>軟爛的泥土</strong></h4>
<p>因某些因素，當時有討論到<strong>要不要將專題報告延長兩周</strong>左右<br>
但我知道再怎麼延，我還是無法完好地呈現出來<br>
加上我的精神上非常抗拒，我想把報告結束、展覽結束，結束長久下來的熬夜。<br>
當最後一場報告結束，</p>
<blockquote>
<p><strong>「結束了，成品怎樣也沒關係吧?」<br>
「即使有BUG，或瑕疵，再修也不會有什麼改變」</strong></p>
</blockquote>
<p>這些想法不斷湧現<br>
但結果是我又一路從報告結束修到校內展，至少讓展覽可以順利展出幾關的原型。<br>
校內展覽結束，本是專題的終點。<br>
但對我來說，卻只是中繼點。</p>
<h3 id="新芽">新芽</h3>
<p>一個新開始，不難；中斷的重新開始，更難。</p>
<h4 id="殘枝"><strong>殘枝</strong></h4>
<p>五月初是校外展，四月中旬是競賽報名截止，代表我必須在這之前將作品完成。<br>
另外，我還有展覽總召的身分，越快到展日，這段期間是也是不能閒的🤯。<br>
這幾個月，我每天都會打開電腦，開啟Unity，接著跑去躺在床上，看著娃娃，對自己說 :</p>
<blockquote>
<p><strong>你這廢物，去工作，快去電腦前坐好</strong></p>
</blockquote>
<p>這是我每天的例行公事，我不是對自己喊加油、喊要堅持下去<br>
我也不是斗M，沒有喜歡被罵的癖好。<br>
一番精神喊話後，我會把Unity關掉，開啟Youtube開始看迷因，讓自己開心點。<br>
我知道自己腦袋亂糟糟的，沒有動力做下去，也不知道從哪裡下手。</p>
<center>
<p><img data-src="https://chi01pap001files.storage.live.com/y4menHF2FwISc3qcsoKFfru0O3K4WnXG2sKH7YQf3DlgWHz7e7vX9SKqmkEnHWGlCtag_KgxWQlTRtH2XnB1jvSzoS4Ok0sdQW0MRaT45C72HUxmz8glJtmb0gRNeJaaRAMDnZli5MFocePYBkPNCmz6ZmaF6TB4i3h7oceMwtn5LqHfmaSOX9An81-M3Kwf80y?width=371&amp;height=660&amp;cropmode=none" alt=""></p>
</center>
<center>Indeed. ┐(´д`)┌ 阿還真的就打出來了。</center>
<p>3月，這個模式還是繼續，只是對自己說的話更狠了。<br>
期間我不只看大量的迷因，之前訂閱很多程式教學跟遊戲開發者的頻道，我也看了不少<br>
偶爾看完，靈感一來就會重新釐清思緒，將遊戲的內容文件重新整理、修改<br>
卡住了，又返回到床上，說一樣的話，再滾回到電腦前執行例行公事</p>
<h4 id="養分"><strong>養分</strong></h4>
<p>吸收新的知識，我的程式能力有逐漸成長，實際上到3月我還沒正式修改到遊戲的程式<br>
大多是開新檔案練習。</p>
<p>準備的差不多後，我下定決心把遊戲中的程式碼全都砍了<br>
就是把遊戲互動的部份全都歸零。這時候離競賽截止點還有一個月半。<br>
我知道風險很高，況且我沒有多大的把握能做完，但我知道我必須做。</p>
<p>如果你還記得上一篇分享提到的<strong>程式耦合問題</strong>，我正是要解決這個問題<br>
否則這個作品還是會中途運作崩潰、遊玩不順利，總總都會影響遊玩體驗。<br>
更別說展覽3天，每天8小時。除了基本求能運作外，更要兼顧穩定。</p>
<h4 id="重新發芽"><strong>重新發芽</strong></h4>
<p>一天天的特殊精神喊話，老實說也不是沒用處。<br>
越喊會對自己的能力很氣憤，氣憤到很不甘心，不想只有這樣結束😠。<br>
帶著這份不甘心，我每天瘋狂打著鍵盤，從早打到晚</p>
<p>因為住在家裡，要照顧好家裡的大小事，所以天天見日出的模式是不行的<br>
4月初，我把原本的進度補回。(這麼快速的原因，回想一下學習經驗曲線)<br>
因為要上繳競賽成品，一邊請組員幫我試玩，當然還是少不了很多的Bug。<br>
平時學習的反饋在我製作上的錯誤，是越來越少，程式運作也變更流暢</p>
<h4 id="豪雨後的蟲災"><strong>豪雨後的蟲災</strong></h4>
<p>離繳件剩兩個禮拜，這時候，不幸的事情發生了。<br>
在家準備晚飯，接到一通家人出車禍的電話，雖然沒有大礙，我依然失落了好幾天。<br>
低落的心情，也影響我在製作上的速度，但我的手還是沒有停止。</p>
<p>直到繳件當日傍晚，剩餘一個關卡的BUG還沒修完，其餘的都能正常運作，<s>正當我以為。</s><br>
我稍微放心地收拾書包，從圖書館騎車回家，趕緊洗完澡完成剩下的部分。<br>
除了主程式外，還有企畫書，我事先有準備好文件，剩下一些急忙委託組員協力完成<br>
晚上十點組員試玩到有出現嚴重的BUG，我不斷地測試，但始終想不到問題。</p>
<blockquote>
<p>可怕的BUG，在第一關出現了。</p>
</blockquote>
<p>總不能剛開始玩就出現BUG吧 !!!<br>
我拋棄維修另一個關卡，瘋狂般的不斷測試與修改第一關的BUG<br>
幾經測試都行不通，我開始崩潰了，發給組員 : <strong>我好想放棄</strong> 的訊息</p>
<center>
<p><img data-src="https://chi01pap001files.storage.live.com/y4myqNuZwO1Lkh-WrEskpxQv17jgiR4x_fseebiLuEFCoZXz_2mkLLVm0F24iRaZiIyQyFzcyX6TB9MeN9Bv2Zd-9E8Y5Vi6wd0ehxgB0ZbLnj4RRaVBsQthX_pimMOTACjvdd9IaxvMYdUuwFASPwAA1LWwJ4BpCFkt3mopbP3DDhd7d8TF9X-ORT7kTny-JyJ?width=256&amp;height=144&amp;cropmode=none" alt=""><br>
WTF</p>
</center>
<p>後來冷靜了一會，終於把該死的BUG解決了。<br>
其實Foresea這時依然不是完整的，我還是將它打包繳件去了<br>
其中放視企畫書有一項可說明<code>未完成的部分</code>我詳實填上。<br>
組內的其他作品都已經登陸完成，只剩遊戲的部分。</p>
<h4 id="雨後陽光"><strong>雨後陽光</strong></h4>
<p>最後一天，晚上十一點五十五分，最後一步了，我將企畫書上傳，始終無法成功<br>
原因是官方的伺服器被塞爆了，最後一刻，全台各地的同學也正拼命地上傳。</p>
<p>五十八分，還是<strong>失敗</strong>。<br>
五十九分，依然是<strong>失敗</strong>。<br>
整點十二點，<strong>失敗</strong>。</p>
<p><img data-src="https://chi01pap001files.storage.live.com/y4mKkIyZW8L8QaxhJSAjyR3MCYMR6YOK9vVc7n-ynHVNkNmhG3QHv01S3hEWWvux-r1RmoOXRvuFprp0HNqeo5HH9i-LJmuPSlzH-ikDLolCXkWF4ExQ0a6dBdi4zqY28mkZeZWm5EwAsY4JUQk_7YsAeB4shfxGQ5cp9ST-Esl-w46aoICsoY8hkCDDuuvgxZe?width=600&amp;height=338&amp;cropmode=none" alt=""></p>
<center>絕望ing</center>  
<p>我跟組員告訴這壞消息，遊戲組的項目是沒有參加了，我非常抱歉。<br>
同時我也不放棄的將瀏覽器切到上一頁<br>
反覆重試繼續上傳<br>
直到十二點零五分</p>
<blockquote>
<p>??? ，我發現上傳%數還會動</p>
</blockquote>
<p>沒多久，上傳成功。<br>
我急忙按送出，看見欄位狀態是完成的。</p>
<p>以為我累壞眼花了，我又反反覆覆刷新頁面20次，看到狀態依舊是完成。<br>
我告訴組員，好像…報成功了。<br>
關上電腦，我安心的吃起晚餐。<br>
這一餐即使冷掉，還是很美味😌</p>
<h3 id="往更高處"><strong>往更高處</strong></h3>
<p>樹枝不會乖乖挺直往上生長，<br>
可能躺得長、坐者長、趴著長，還是<s>八仙…</s><br>
總之，一切就是出乎意料的發生。</p>
<h4 id="特級肥料"><strong>特級肥料</strong></h4>
<p>很匆忙又不完整的狀態下，我知道得獎或入圍機率很低<br>
但我還是沒有停止修改Foresea。<br>
繳件讓我獲得短暫的休息，隔天起床我還是跟往常一樣，嘎啦嘎拉地打著鍵盤<br>
把握在展覽前完成Foresea，包含一些細節上的優化。</p>
<p>四月底，組員第一時間貼出我們入圍消息，我不敢置信，<s>因為我被暴雷了</s>。<br>
完全出乎我意料之外，網頁入圍就很棒了，我不敢相信的是遊戲竟然也入圍。</p>
<p>開心了幾小時，我又回到電腦面前繼續修改。<br>
這個消息把修BUG到快沒電的我，換上新的強勁電池，滿電開始運作。</p>
<h3 id="開花時刻"><strong>開花時刻</strong></h3>
<p>展覽前3日，扛著行李到高雄，準備展前布置。<br>
白天到展場幫忙，傍晚我馬上回到旅館，打開電腦又敲起鍵盤<br>
一敲又是到早上六點，八點又趕到會場布置。</p>
<p>直至展覽前一天，我還是沒睡，除了修遊戲之外，也在準備來客導覽的內容。<br>
完成主程式輸出後，把預備用的電腦充飽電，等待著明天上戰場。</p>
<p>展覽第一天，我的電腦中邪了。<s>絕對不是毒。</s><br>
前一天檢查還好好的電腦，早上拔掉充電線重新檢查檔案<br>
電腦開機卻不斷進入藍屏，修復作業也無用，眼看都要八點了<br>
我緊急叫上組員的預備機，才解決這件事。展覽前組內就有準備2-3台電腦</p>
<p>好消息是<br>
我以為要幫服役5年的電腦舉辦喪禮了，經過CPR(重灌作業)起死回生了🥴</p>
<p>God，能讓我稍微輕鬆一些嗎OTZ。</p>
<p>第一天，首發導覽是我，為了提神，灌了咖啡就上陣了<br>
展覽這段期間，遇見很多有趣的人，像是</p>
<ul>
<li>👨‍🎓同樣是學生，會交流製作心得與校際之間的差別等等</li>
<li>👨‍💻遇到開發者，會給予很有用的回饋建議，解惑我的問題</li>
<li>👾遇到遊戲論壇廠商，提供後續成品的發展建議</li>
</ul>
<blockquote>
<h4 id="關於學生"><strong>關於學生</strong></h4>
</blockquote>
<p>遇到科系性質很像的學校，像是中教大的數位<br>
非常活潑的跑來交流，說著我們系的教程是他們的基底😆<br>
互相吐槽著學習遇到的好笑的事<br>
後來還來個校際外交，邀請對方去的攤位做客XDD。<br>
也有遇到很多厭世大學生，看著看著就會開始談心的也很多😆</p>
<p>既然是性質很像，不免去逛逛，交流一下。<br>
中教大的作品目標導向非常明確，通常是專注在某種議題上去發想<br>
成品也蠻完整的，種類也很多，有桌遊、電腦遊戲、網頁、平面等等<br>
結合議題延伸的成品，讓內容很充實。<br>
如果未來有什麼聯展，我覺得也是不錯的經驗。</p>
<blockquote>
<h4 id="關於開發者"><strong>關於開發者</strong></h4>
</blockquote>
<p>當時被問到 :</p>
<ul>
<li>製作這個專題對你的意義是什麼 ? 遇到最困難的是什麼 ?</li>
<li>作品往後的發展你們是怎麼想的 ?</li>
<li>議題只是為專題而生? 還是有什麼企圖心 ?</li>
</ul>
<p>我知道可以很滑溜的說，會將作品提供給某某單位做教學使用、更新成手機板供大眾用等等的<br>
但我卻誠實地說 :</p>
<p><strong>「對，專題一結束，這個作品也走向終點了。」</strong></p>
<p>因為我也想知道 <strong>同屆學生裡之間的差別</strong> 到底在哪。</p>
<blockquote>
<p>講解得很詳細，專題也很完整，但就是少了 <strong>商業化</strong> 的思考</p>
</blockquote>
<p>對方舉例了很多他自己怎麼將作品商業化的例子，<br>
像是 推出季更DLC 、找網紅推廣試玩等等<br>
這邊比較像是行銷面，開發方面就不細講了，比較吃團隊創意😵。</p>
<p>後來我才知道 他也是個學生同時也是個開發者。<br>
但不難看出，在各展覽競賽獲獎的作品，行銷面確實也做得不錯，<br>
甚至很早就覺得 <strong>這一定會得獎</strong></p>
<p>很快的一天就結束了，展覽過程中也少不了BUG的存在😵<br>
導覽時幾乎都被我搞笑地呼攏過去。整體來說導覽很好玩，甚至我都忘了我沒睡這件事。</p>
<p>這幾天嗑了很多的咖啡因，都是處在完全亢奮的狀態<br>
其中一天我意識到我快不行了，於是就休息了一下。<br>
<s>就跟著跑去唱卡拉OK桑一下，主要讓自己的精神緩緩😵</s><br>
每天回到旅館後，第一件事就是坐在床上修起BUG。<br>
沒錯，又熬到天荒地老。<br>
在展覽最後一天，修到剩下不影響運作的小BUG🥳</p>
<h3 id="高處"><strong>高處</strong></h3>
<p>最後一天，因為有入圍，下午就前往頒獎典禮看開獎。<br>
如果你是未來想創業、想獲得獎項、獲得廠商青睞，我非常建議你去看頒獎典禮，是自由參加</p>
<p>頒獎時，會請不同領域的專家以及公司創始人來頒獎<br>
同時也會講解 <strong>評比的方向、目前市場所需、以及他們最想要看見的(現今作品欠缺的是什麼)</strong><br>
不少獎項是有從缺的，代表當屆是沒有到水準的，但就是會有那一兩個脫穎而出無疑是金獎的</p>
<p>這裡，會聽到 <strong>自己跟別人有多大的差別OTZ</strong>，不會只有是校系問題，有很多小校系也是有得獎<br>
總之大家都是有機會的，取決於 <strong>你是不是有做到那些面向。</strong></p>
<p>評審最常講到<strong>商業化</strong>這件事，以<a href="https://gnn.gamer.com.tw/detail.php?sn=214633"><strong>遊戲組金獎</strong></a>為例好了<br>
劈頭說 <strong>這直接可以賣了</strong>，除了完整度很高，架構穩，Idea也是不可少的，更重要的是發展性<br>
這類型的遊戲性高，往後更新的方向是非常廣的。</p>
<p>當然，不同類型有他獨特的地方，我想教育遊戲也是有自己的一片天，看要怎麼發展而已。<br>
有興趣的話可以查查看歷屆獲獎作品。</p>
<p>這天，我覺得自己的能力很弱，看著頒獎，比不上這些優秀的同學，我很失落<br>
但我也知道自己欠缺了什麼，之後會更加地努力💪。<br>
三天的展覽，跟著回程搭的末班車一同結束了。</p>
<h2 id="結語-17">結語</h2>
<p>完整看完的人給你拍拍手👏👏👏<br>
雖然沒有100%將時間投入製作，因為同時3-4月我在考駕照，還有準備5月初的多益~~(職場預備用)~~<br>
製作Foresea幾乎占滿我大學最後一年的生活，不過幸好我活過來了。<br>
還好駕照過了，可惜英文最後近乎裸考上陣，考了個不是很滿意的分數，應該夠用啦🥴。<br>
但我還是不會後悔啦。</p>
<p>沒有這些歷程，就不會有第二篇的程式分享文<br>
更不會有雙入圍或校外評分獲獎那些結果。<br>
最主要的還是組員們非常可靠，才有這些成就👍，危難時都能立即神救援。</p>
<p>雖然很多時刻，我只能跟別人說</p>
<blockquote>
<p><strong>抱歉，我真的笑不出來</strong></p>
</blockquote>
<p>很多心情，並沒有告訴組員、朋友、甚至是父母<br>
我不太想讓人去跟著操心，這些 <strong>需要從自己改變的事</strong>。<br>
這不是好方法，我知道😕，但這就是我。<br>
有人告訴我，這種什麼都沒講的人很容易出事<br>
放心啦我還在貼 memes 代表我沒事0v0b</p>
<p>曾經有人問我為什麼所有事情都要拼命做到100分 ? 有些事情根本不值得。</p>
<blockquote>
<p><strong>是啊。我也很想知道到底是什麼驅使我這麼做。</strong></p>
</blockquote>
<p>有些一看，就知道我拼命的結果不會是滿意的，但我還是會做。<br>
像是繪畫這件事，並不是我的專長，我曾熬夜花好幾天去完成一個作業<br>
結果理所當然還是比設計強項的同學差個十萬八千里<br>
但如果不做，我就不會知道自己極限到哪裡，也看不清楚自己。</p>
<p>還記得某堂課有抽彩虹卡，我抽到</p>
<blockquote>
<p><strong>「I am Me,and I am okay.」</strong></p>
</blockquote>
<center>
<p><img data-src="https://chi01pap001files.storage.live.com/y4mdzIhAuXcAQuWuA69j7sXX5tId3C6_zCrp6xIZ8bwjmO423wbh6Sz5b3wrPDifwBIRIScg0_O61AXgf5TRJLBIIG0GpL3nH1xCK3Ng3awd1jnGLyvEWolPX8uhGaWK1NLmjNxuByu7AvEKEQRG9EJoq2aVWD3OixoT7oLPhBLq7_eIxRA9yxMNuMo4riMW1X0?width=256&amp;height=172&amp;cropmode=none" alt=""></p>
</center>
<p>網路上的圖，我的忘記收在哪了<br>
但我一直記得這句話<br>
現在再看到真是一言難盡。</p>
<p>分享這些事，希望你也別遇到同樣的問題<br>
要是遇到時也別氣餒，至少還有我這個<strong>廢出新高度</strong>的極端例子<br>
讓你不會那麼快放棄🥴<br>
好的，各位，掰掰了~ (´◓Д◔`)</p>
]]></content>
      <categories>
        <category>2021</category>
        <category>06</category>
      </categories>
      <tags>
        <tag>畢業專題</tag>
      </tags>
  </entry>
  <entry>
    <title>心得 | Foresea畢業專題(II) ─《菜雞在 Unity 裡的漫長旅程》</title>
    <url>/2021/05/05/Foresea-bookreport-II.html</url>
    <content><![CDATA[<h2 id="前言-48"><strong>前言</strong></h2>
<p>若你在專題團隊裡擔任 <strong>遊戲程式設計</strong>，可以留步<br>
若你在專題團隊裡擔任 <strong>美術設計</strong> 負責遊戲素材<br>
可以直達 <strong>問題大雜燴</strong><br>
我將會分享 製作畢業專題一年學習程式的資源<br>
希望這些資訊可以幫助任何人的專題運作更順利</p>
<span id="more"></span>  
<h2 id="正式開始前的準備"><strong>正式開始前的準備</strong></h2>
<p>我不會講到遊戲企劃架構等等的，網路上文章大神非常多<br>
可以用Google大神找到參考。<br>
這篇著重在一個程式菜雞(非理工背景)從短期學習程式到完成一個專題的經驗分享。<br>
在我的畢業專題 《Foresea》中，我是擔任遊戲程式設計<br>
如果你/妳和我一樣，是程式小白(程式基礎薄弱)，可以參考我的經驗。</p>
<h3 id="與時間賽跑"><strong>與時間賽跑</strong></h3>
<h4 id="正在做專題的人"><strong>正在做專題的人</strong></h4>
<p>又剛好只有在課堂上碰過Unity，沒有更多的接觸<br>
但你的程式理解力 <s>看到程式碼不會頭痛</s> 是組內還不錯的人🤟<br>
<strong>我會建議:</strong><br>
專題主題想好後，類型會決定「以什麼方式呈現」<br>
進而決定你要有什麼樣的「功能」<br>
並且透過重新組合排列來完成專題。</p>
<p>你可以試著… :</p>
<ol>
<li><strong>拆解功能</strong><br>
例如 : 我想做 <font color=teal><strong>3D 第一人稱 射擊遊戲</strong></font>，那你會要有
<ul>
<li>瞄準</li>
<li>子彈庫</li>
<li>敵人 …等等功能</li>
</ul>
</li>
</ol>
<blockquote>
<p>功能詳細分解，以 <strong>瞄準</strong> 為例</p>
<ol>
<li>啟動準心要透過<strong>按鍵</strong>來觸發</li>
<li>透過<strong>射線</strong>來偵測物體的位置</li>
<li><strong>確定</strong>你瞄準到的是<strong>目標</strong></li>
</ol>
</blockquote>
<ul>
<li>綜合起來你這個功能裡會需要的技術
<ul>
<li>按鍵偵測</li>
<li>物理射線</li>
<li>碰撞</li>
</ul>
</li>
</ul>
<p>很多教學其實都有一次到位，但如果你在某些功能想要追加時，拆解就可以清楚需要的技術<br>
2. <strong>做穩定功能的延伸</strong><br>
例如: 拼圖 + 抽卡系統…等等<br>
創意不一定要全部無中生有，結合也是種創意</p>
<h4 id="準備做專題的人"><strong>準備做專題的人</strong></h4>
<ol>
<li>可以動手做小project ，如果你有idea可以先規劃遊戲框架、基礎功能等等。
<ul>
<li><strong>試著練習小專案</strong><br>
之前花了一天隨興做的劇情小遊戲<br>
主要練習 <strong>整合應用</strong>與<strong>滑順換場</strong><br>
當中對話框是用Assest store的資源後來就忙畢業專題，就沒繼續了…🥴</li>
<li>要是懶的製作美術素材，可以使用Unity 商店提供的一堆素材包來組合成自己的遊戲。<br>
可參考這位youtuber <strong><a href="https://www.youtube.com/channel/UCaoqVlqPTH78_xjTjTOMcmQ">Miziziziz</a></strong><br>
四人以同一包資源，做出四種不同玩法的遊戲</li>
</ul>
</li>
<li>多看Devlog(開發日誌)，作者製作中會記錄心得與技巧<br>
像是這位靠遊戲製作起家的<a href="https://www.youtube.com/channel/UCIabPXjvT5BVTxRDPCBBOOQ"><strong>Dani</strong></a><br>
創作的遊戲也有在steam上，也有將製作與心得做成影片。</li>
</ol>
<h3 id="認清自己">認清自己</h3>
<p>學習基礎的開始，你將會碰到大量的英文跟一些數學(?)</p>
<ol>
<li>如果你本身超討厭英文，那很可惜，你的學習資源將會被侷限</li>
<li>如果你本身超討厭數學，那更可惜，程式運用邏輯判斷與數學相輔相成，做起來更快速<br>
<strong>Q:</strong>  我怎麼知道自己英文好到可以看國外的教學學習?<br>
<strong>A:</strong>  如果你聽1分鐘的英文非常很吃力了，我就建議你就用中文資源學習<br>
不然你會變<strong>練英文聽力</strong>，而不是學習程式。</li>
</ol>
<ul>
<li>Try it ! 試試看<br>
看這支<a href="https://youtu.be/1aGjMIUgVTU">影片</a>，如果你能聽得懂大多語句，就代表你還OK啦!<br>
不能接受兩點，其實你還是能做遊戲，目前中文教學資源越來越多了</li>
<li>若遇到問題，可以發問到
<ol>
<li>👍 <strong><a href="https://www.facebook.com/groups/UnityFrontier/">Unity 應用領域</a></strong></li>
<li><strong><a href="https://forum.gamer.com.tw/B.php?bsn=60602">巴哈Unity3D引擎版</a></strong><br>
最近網路上也出現很多新興論壇與討論群也可以加入</li>
</ol>
</li>
<li>寫程式超級苦手<br>
可以用視覺化程式工具來打造整個專案，這邊列舉三個常見的</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>Fungus</strong></th>
<th style="text-align:center">PlayMaker</th>
<th style="text-align:center">bolt</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img data-src="https://chi01pap001files.storage.live.com/y4mkfhN24Lbc49rFFaLHFFlzmnSh8Zuv_hBQBnX5bhf6ZoUfuBitk2LWvZUjoddAfWinO0xPJYmKcHxLLGjdv2G4Xj5P7vCeelxUtd8_RKjbOnPqi9VBJ08QPkF-1kA-8Oc46pNIWtvN8hmOtUvc9BXtvDG3w1z00ZouUJeOYgIfV_7oqXYzX4LcWlDHyi5Rrpf?width=64&amp;height=128&amp;cropmode=none" alt="Fungus"></td>
<td style="text-align:center"><img data-src="https://chi01pap001files.storage.live.com/y4mpgpEnb_uv7folt3ZpcsTYMtqqqo_T-YoEybEGKP-ksmMLfyqSVXZH9O9Cd-2p63exqjtaF2SZLiNfMoXubHQj2J1rtZ3dL50WWsfF_noVQBHUYv8vqGRddYj38E2e34HdSNFHpuS7QWnihbJpD9gsWrzymekydAhcbJhQeTOlsaXYugV_4-RpTR0BA70KTD-?width=64&amp;height=128&amp;cropmode=none" alt="PlayMaker"></td>
<td style="text-align:center"><img data-src="https://chi01pap001files.storage.live.com/y4m7J5a0UmNmKPGIrzwNoo0oWBDVkMBy2o939beWfQ_ap7zSKutxnKgq8T0qFZ52LDHmBzGOp8LCLQ_gOGS0-X-yEDv8_40WWvDM3k191Jm5AVXLSohQQOkwNyvqT2bUidkRnAeL_MWXGFBaeFW4ch-JzZbTZ49Q4Dhv5jNgYJN6zXvlgr6Agn6iX8AISstt0F8?width=64&amp;height=128&amp;cropmode=none" alt="bolt"></td>
</tr>
<tr>
<td style="text-align:center"><strong>不需要撰寫任何程式</strong></td>
<td style="text-align:center">不需要撰寫任何程式</td>
<td style="text-align:center">不須撰寫程式，但也可以混著C#寫</td>
</tr>
<tr>
<td style="text-align:center"><strong>免費</strong></td>
<td style="text-align:center">必須<strong>氪金</strong>💵</td>
<td style="text-align:center"><strong>免費</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>⭐歷屆最常用</strong></td>
<td style="text-align:center">教學資源豐富</td>
<td style="text-align:center">教學資源算豐富</td>
</tr>
<tr>
<td style="text-align:center">很方便的對話系統</td>
<td style="text-align:center">中文學習資源不少</td>
<td style="text-align:center">近年發展快速</td>
</tr>
<tr>
<td style="text-align:center">缺點是有點制式</td>
<td style="text-align:center"><strong><a href="https://hutonggames.com/showcase.html">用過都說讚</a></strong></td>
<td style="text-align:center">Unity官方有教學</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong><code>至於我推不推視覺化工具呢?</code></strong><br>
其中 <strong><a href="https://www.youtube.com/watch?v=OqHM0ZNtZ_4">&lt;PlayMaker?bolt?&gt;</a></strong> 影片留言區提到，我覺得非常中肯。</p>
<blockquote>
<p>If you are an artist without coding experience, visual scripting is a bliss but if you are a coder, visual scripting could be a curse.</p>
</blockquote>
<p>我有試用過bolt，對我來說簡直災難，直接用C#寫舒服多了。<br>
如果寫腳本算順，建議就不要載bolt，會適應不良🤢。</p>
</li>
</ul>
<h3 id="其他製作引擎的選擇">其他製作引擎的選擇</h3>
<p>如果你是大三以下，上過課覺得 Unity 介面超難懂很複雜<br>
可以試著使用Godot或Construct 2(3)等引擎<br>
如果你是要做純RPG遊戲，也可以使用 RPG製作大師</p>
<table>
<thead>
<tr>
<th>應用程式</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://godotengine.org/">Godot</a></td>
<td>近年興起的開源遊戲引擎， 也有不少人從Unity 跳槽到這裡</td>
</tr>
<tr>
<td><a href="https://www.construct.net/en">Construct 2 (3)</a></td>
<td>可以線上編輯。據我所知有些國內大學是使用這個。</td>
</tr>
<tr>
<td><a href="https://store.steampowered.com/app/363890/RPG_Maker_MV/">RPG製作大師</a></td>
<td>下載要<code>$$</code>，發展悠久網路上資源很豐富，但就是只能做純正的RPG啦。</td>
</tr>
</tbody>
</table>
<h2 id="正篇-2">正篇</h2>
<p>我進步的不二法門，<strong>多看 多學 多實作</strong>。</p>
<h3 id="第一步-大問題拆解小問題"><strong>第一步 : 大問題拆解小問題</strong></h3>
<p>很廢話I Know~，不論是哪個領域，拆解都是遇到問題的第一步<br>
網路上通常不會有現成剛好你要的功能，你要達成的功能就要自己組合運用。<br>
功能拆好後，做不出來的就是 <strong>學習觀摩 ⇒ 實作 ⇒ 修改</strong></p>
<h4 id="推薦我常學習的管道">推薦我常學習的管道</h4>
<p>網路上學習資源非常多，這邊稍微列舉我常看的</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Youtube</strong></th>
<th style="text-align:center">中/英</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://www.youtube.com/channel/UCzmz_uFDw73m0JDI5ILmA3A">阿空的遊戲部屋</a></td>
<td style="text-align:center">中</td>
<td>多為2D，概念從頭講起，非常清楚</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.youtube.com/channel/UCbZ34gnooSIHXAZUW1_wvgQ">yasuHs</a></td>
<td style="text-align:center">中</td>
<td>功能重點教學，操作非常清楚</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.youtube.com/c/%E9%99%B3%E9%96%93%E6%99%82%E5%85%89%E5%B7%A5%E4%BD%9C%E5%AE%A4/videos">陳間時光</a></td>
<td style="text-align:center">中</td>
<td>有教學Fungus，C#基礎概念等等，講解非常清楚，影片略長</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.youtube.com/c/%E7%99%BD%E7%B1%B3%E9%A3%AF/videos">白米飯</a></td>
<td style="text-align:center">中</td>
<td>有bolt教學以及應用教學</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.youtube.com/c/MStudioUnity/featured">M Studio</a></td>
<td style="text-align:center">中</td>
<td>教學種類繁多，講解清楚</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.youtube.com/user/Brackeys">Brackeys</a></td>
<td style="text-align:center">英</td>
<td>內容含 2D&amp;3D、Unity功能，講解非常詳細，首推! <s>可惜他不做影片了</s></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.youtube.com/c/CodeMonkeyUnity/featured">Code Monkey</a></td>
<td style="text-align:center">英</td>
<td>很多功能性教學，非常推薦，講解非常詳細</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.youtube.com/c/AlexanderZotov/featured">Alexander Zotov</a></td>
<td style="text-align:center">英</td>
<td>功能重點教學，操作清楚，省時間學習大推👍</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.youtube.com/channel/UC9Z1XWw1kmnvOOFsj6Bzy2g">Blackthornprod</a></td>
<td style="text-align:center">英</td>
<td>2D為主，單功能性教學，講解詳細，也有很多Devlog</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.youtube.com/c/samyam/videos">samyam</a></td>
<td style="text-align:center">英</td>
<td>以單功能教學為主，講解非常清楚。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>論壇</strong></th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://stackoverflow.com/">Stack Overflow</a></td>
<td>所有難題都在這裡解決，踏入程式圈一定要知道的</td>
</tr>
<tr>
<td><a href="https://forum.unity.com/">Unity官方論壇</a></td>
<td>可以更精準找到跟你有一樣問題的串。</td>
</tr>
<tr>
<td><a href="https://forum.gamer.com.tw/B.php?bsn=60602">巴哈 Unity3D 遊戲引擎哈拉版</a></td>
<td>你懂得。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>網頁</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://godstamps.blogspot.com/">胡亂說‧隨便寫</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://jerrard-liu.blogspot.com/">【Unity遊戲製作】勇者拉德小酒館</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="http://sammaru.blogspot.com/search?updated-max=2017-11-25T21%3A14%3A00%2B08%3A00&amp;max-results=10#PageNo=2">山姆遊戲</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.douduck08.com/">鴨仔開發日記</a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">FB社團</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://www.facebook.com/groups/UnityFrontier/">Unity 應用領域</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.facebook.com/groups/IndieGameDevs/">Indie Game Developers IGD</a></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>C#基礎加強</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://www.youtube.com/channel/UCmumrs_hb9s6eoVI29gLBgA/featured">小山的教學平台</a></td>
<td>C#好幫手，對於基礎加強可以從這裡開始</td>
</tr>
</tbody>
</table>
<h4 id="加強搜尋力">加強搜尋力</h4>
<p>若剛好都沒你要的，請發揮強大的搜尋力，尤其是用「英文」，破英文也可以👌</p>
<ul>
<li>
<p><strong>我怎麼搜尋</strong><br>
有時候不太知道正確的關鍵字，但可以從搜尋出來的字眼<code>**找連結詞**</code>，幫助增加搜尋速度<br>
<strong>例如</strong> :</p>
<blockquote>
<p>我想讓<code>角色滑順地移動</code>，可能會在搜尋列打 <em><code>&quot;How to move smoothly in Unity?&quot;</code></em></p>
</blockquote>
<p><img data-src="https://chi01pap001files.storage.live.com/y4mC4TPIW5ABZI0G8jx_cv7O63vukxuNZ1UUvYIU4WD1iT2BD2YT7V_rwCMWbzaYJg4KO22LTIs5xieCtIllnDhceGNTzC5Ecquhvi9dM0pjOE9oClra7APf8e-zPcyR_m5xwOrCuERV34OMhdsSeJNCj1eQWcuVH5E4s_Wi7TE6F371Q1UiogCuVmmphND0CAF?width=660&amp;height=516&amp;cropmode=none" alt=""></p>
</li>
<li>
<p>你會發現有人不少人跟你問一樣的問題，<strong>關鍵字你有發現什麼嗎?</strong></p>
<ul>
<li><strong>解析搜尋到的關鍵字</strong><br>
移動的主體<strong>是誰</strong>?例如 : Player、Enemy 或是 UI物件。下方圖片出現</li>
<li>using Vector Lerp <code>**看起來是種&quot;方法&quot;**</code><br>
沒錯!這正是要的答案，恭喜你找到<strong>Lerp</strong>這個重要的關鍵字，接著就能更精準的搜尋</li>
</ul>
<blockquote>
<p>Player move using lerp in Unity</p>
</blockquote>
<p>會找到相關Unity Scripting API 的說明，以及 lerp的相關應用教學<br>
推回用中文找 <strong>Unity lerp 教學</strong> 也是可以</p>
</li>
</ul>
<h3 id="第二步-讓程式昇華"><strong>第二步 : 讓程式昇華</strong></h3>
<p>程式基礎都修過，最基礎的<code>Array</code> 、<code>if-else</code> 、<code>for</code>、<code>foreach</code> 、<code>while-do</code> 、 <code>switch(case break)</code> 等等的都很夠用<br>
在Unity裡遇到看不懂的東西，除了直接google，也可到<a href="https://docs.unity3d.com/ScriptReference/">官方文件</a>搜尋<br>
很推薦官方給的範例，清楚明瞭。</p>
<blockquote>
<p>Unity版本的差異會影響一些方式的寫法，記得先找到自己開發的版本</p>
</blockquote>
<h4 id="程式基礎-Unity功能-快速補帖"><strong>程式基礎&amp;Unity功能 快速補帖</strong></h4>
<p>一些我覺得能加速製作的好概念 ，下面我提的都只是冰山一角，有興趣可以再自己Google</p>
<blockquote>
<p><strong>C#</strong></p>
</blockquote>
<ul>
<li><strong>List</strong>
<ol>
<li>📄 <a href="https://docs.microsoft.com/zh-tw/dotnet/api/system.collections.generic.list-1?view=net-5.0"><strong>List<T> 類別</strong></a></li>
<li>📺 <a href="https://www.youtube.com/watch?v=EOnWTaN472g"><strong>Unity C# 程式 教學 情場教戰手冊 (Array + List + Foreach)</strong></a></li>
<li>📺 <a href="https://www.youtube.com/watch?v=0WdWiF_Si4I"><strong>C# Lists and Dictionaries in Unity! - Intermediate Scripting Tutorial</strong></a></li>
</ol>
<blockquote>
<p>📕<strong>延伸閱讀</strong><br>
📄 <a href="http://sharecoder.blogspot.com/2012/10/arraylist.html"><strong>Array與List</strong></a> ⇒非常清楚解釋兩者差異<br>
📺 <a href="https://www.youtube.com/watch?v=uWI3JEBRMiA"><strong>Data Structures For Game Devs: Arrays vs. Lists | Unity Tutorial (Part 1)</strong></a>⇒泛型類別解說</p>
</blockquote>
</li>
<li><strong>Dictionary</strong>
<ol>
<li>📄<a href="https://docs.microsoft.com/zh-tw/dotnet/api/system.collections.generic.dictionary-2?view=net-5.0"><strong>Dictionary&lt;TKey,TValue&gt; 類別</strong></a></li>
<li>📺 <a href="https://www.youtube.com/watch?v=3wbDx90A9T4"><strong>2020輕鬆學Unity做遊戲: Dictionary &amp; List — 11</strong></a></li>
</ol>
</li>
<li><strong>Singleton (單例模式)</strong>
<ol>
<li>📄 <a href="https://kendevlog.wordpress.com/2018/08/14/unity%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AF%A6%E7%8F%BEsingleton/">Unity學習筆記：如何實現Singleton</a> ⇒非常詳細👍</li>
<li>📄 <a href="https://douduck08.wordpress.com/2017/05/08/difference-of-four-singleton-practicing/"><strong>[C#/Unity] 回顧所使用過的 Singleton 實作方式</strong></a>
<blockquote>
<p>📕<strong>延伸閱讀</strong><br>
📺<a href="https://www.youtube.com/watch?v=SpuqhqoiheM&amp;t"><strong>Unity 切換場景 保留物件不被刪掉 DontDestroyOnLoad + SceneManager 教學 場景切換</strong></a></p>
</blockquote>
</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>Unity</strong></p>
</blockquote>
<ul>
<li>
<p><strong>Coroutine (協程) (必知👍)</strong></p>
<ul>
<li><strong>教學資源</strong></li>
</ul>
<ol>
<li>📄 <a href="https://medium.com/feis-studio/%E6%B7%BA%E8%AB%87-unity-coroutine-%E7%9A%84%E9%81%8B%E8%A1%8C%E6%96%B9%E5%BC%8F-c3d5b52e1a0d">淺談 Unity Coroutine 的運行方式</a></li>
<li>📄 <a href="https://dev.twsiyuan.com/2017/05/unity-coroutine.html"><strong>Unity Coroutine 使用筆記</strong></a></li>
<li>📺 <a href="https://www.youtube.com/watch?v=z1myiS1z7Ek"><strong>【阿空】Unity 協程Coroutine！？大解析！</strong></a></li>
<li>📺 <a href="https://www.youtube.com/watch?v=5L9ksCs6MbE">C# Coroutines in Unity! - Intermediate Scripting Tutorial</a>
<blockquote>
<p>📕<strong>延伸閱讀</strong><br>
📄 <a href="https://medium.com/feis-studio/%E5%9C%A8-unity-%E8%A9%B2%E7%94%A8-coroutine-%E9%82%84%E6%98%AF-update-654cce35737e"><strong>在 Unity 該用 Coroutine 還是 Update() ?</strong></a><br>
📺 <a href="https://www.youtube.com/watch?v=O_rya8qmQkw"><strong>Unity3D - 2 Ways to Start &amp; Stop Coroutines (the good &amp; bad ways)</strong></a></p>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong><code>你可能會覺得</code></strong></p>
</blockquote>
<ul>
<li>😯<strong>阿移動為什麼不用動畫呢? 不是比較快嗎?</strong><br>
如果是<code>複雜性</code>高的動作就使用動畫，相對來的簡單可以用程式來達成<br>
如果今天有上百個東西需要動畫，動畫就會讓效能會降低，更白話來講就是會掉楨</li>
</ul>
</li>
<li>
<p><strong>ScriptableObject (必知👍)</strong></p>
<ul>
<li><strong>教學資源</strong><br>
ScriptableObject的用途非常廣，網路非常多例子，也有些缺點</li>
</ul>
<ol>
<li>📄 <a href="https://blog.csdn.net/candycat1992/article/details/52181814"><strong>【Unity】ScriptableObject的介绍</strong></a></li>
<li>📄  <a href="https://kendevlog.wordpress.com/2017/11/10/unity%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%988-scriptable-object%E4%BD%BF%E7%94%A8%E9%A0%88%E7%9F%A5/">**Unity學習筆記#8 : Scriptable Object使用須知</a>**</li>
<li>📺 <strong><a href="https://www.youtube.com/watch?v=0nW5PhQTWbQ">【阿空】Unity的可編程物件：ScriptableObject！</a></strong></li>
<li>📺  <strong><a href="https://www.youtube.com/watch?v=aPXvoWVabPY">SCRIPTABLE OBJECTS in Unity</a></strong></li>
</ol>
</li>
<li>
<p><strong>ObjectPool (物件池) (需要複製多物件必知👍)</strong></p>
<ul>
<li><strong>教學資源</strong></li>
</ul>
<ol>
<li>📄 <a href="https://learn.unity.com/tutorial/introduction-to-object-pooling#">Introduction to Object Pooling</a></li>
<li>📄 <a href="https://douduck08.wordpress.com/2017/08/01/practicing-of-object-pool/"><strong>[Unity] 物件池的實現 – Practicing of Object Pool</strong></a></li>
<li>📺 <a href="https://www.youtube.com/watch?v=tdSmKaJvCoA"><strong>OBJECT POOLING in Unity</strong></a></li>
<li>📺 <a href="https://www.youtube.com/watch?v=7UswSdevSpw"><strong>Unity3D Object Pooling - How to use them &amp; why you should</strong></a>
<blockquote>
<p>📕<strong>延伸閱讀</strong><br>
📄 <a href="https://www.raywenderlich.com/847-object-pooling-in-unity">Object Pooling in Unity</a><br>
📄 <a href="https://harrison-dev.github.io/2018/08/17/Game%20Programming/Object%20pooling/">Object pooling - 基本物件池與應用</a></p>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong><code>你可能會覺得</code></strong></p>
</blockquote>
<ul>
<li>😯<strong>使用生成(Instantiate)不好嗎 ?</strong><br>
⇒生成一個物件再摧毀，Destory 並不代表完全刪除，依然會占用記憶體<br>
當你生成越多，效能會更卡頓 ⇒ 可以參考上方延伸閱讀的地方</li>
</ul>
</li>
<li>
<p><strong>Lerp (線性插值)</strong></p>
<ul>
<li><strong>教學資源</strong></li>
</ul>
<ol>
<li>📄 <strong><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC">線性插值，維基百科，自由的百科全書</a></strong></li>
<li>📄 <a href="https://docs.unity3d.com/ScriptReference/Vector3.Lerp.html">**Unity官方api Vector3.Lerp</a>**</li>
<li>📄 <strong><a href="http://www.victsao.com/blog/97-unity/426-unity-script-lerp">Unity腳本：使用Lerp 線性插值製作滑順效果</a></strong></li>
<li>📺 <a href="https://www.youtube.com/watch?v=cD-mXwSCvWc"><strong>Modulating values with Lerp - Unity Official Tutorials</strong></a></li>
<li>📺 <a href="https://www.youtube.com/watch?v=WNoizdtEPA4"><strong>[Unity] The Essence of Lerp</strong></a>
<blockquote>
<p>📕<strong>延伸閱讀</strong><br>
📄 <a href="https://gamedevbeginner.com/the-right-way-to-lerp-in-unity-with-examples/"><strong>The right way to Lerp in Unity (with examples)</strong></a></p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="問題大雜燴"><strong>問題大雜燴</strong></h3>
<p>製作中我也磕磕撞撞的，遇到不少問題，分享一下</p>
<h4 id="美術素材"><strong>美術素材</strong></h4>
<ul>
<li>
<p><strong>圖片規則 (For 美術)</strong></p>
<ol>
<li><strong>命名好習慣</strong><br>
讓開發者更好去搜尋需要的東西，不要 <strong><code>&quot;圖層1&quot;、&quot;圖層2&quot;</code></strong><br>
設計者快速方便，但對於輸出應用的人<strong>簡直是悲劇</strong>。(甚至是做動畫的)</li>
<li><strong>整合</strong><br>
如果是要做動畫，會建議製成連續圖，丟到Unity 去切<br>
如果是很多相同大小的物件或UI，也可以這麼做，減少GPU耗能的問題<br>
給程式之前，要想好哪些要切，哪些不切。</li>
</ol>
<blockquote>
<p><strong><code>跟買雞排一樣，先講</code></strong></p>
</blockquote>
</li>
<li>
<p><strong>保持乾淨</strong></p>
<ol>
<li><strong>減少多餘空白</strong><br>
刪除多餘的空白，減少體積。<br>
開發時Unity也會算入渲染裡，甚至會遮蔽其他東西，如果有射線問題，可能會無法偵測到</li>
</ol>
<blockquote>
<p>參考<br>
📕 <a href="https://forum.gamer.com.tw/C.php?bsn=60602&amp;snA=2268"><strong>Unity輸出後檔案過大的問題</strong></a></p>
</blockquote>
<ol start="2">
<li><strong>建立管理的資料夾</strong><br>
在程式製作時，常常會為了方便而塞入Assest最外層資料夾<br>
別怕因為要一直好幾層而懶得建資料夾<br>
合宜的管理，在找素材替換時就會很方便</li>
</ol>
</li>
<li>
<p><strong>善用工具 (For 程式)</strong></p>
<ul>
<li><a href="https://youtu.be/b2bIh8WPsi4"><strong>Psd Importer</strong></a><br>
最近整合到Unity插件中，可以直接使用PS檔案  偶爾需要微調圖檔可以快速使用，避免跳出視窗一張張抓到PS修改而浪費時間</li>
</ul>
</li>
</ul>
<blockquote>
<p>📕<strong>關於美術&amp;程式的延伸閱讀</strong><br>
1.<a href="https://www.itread01.com/content/1547481793.html">Unity專案中UI同學需知的程式相關要點</a><br>
2.<a href="https://home.gamer.com.tw/creationDetail.php?sn=4469955">[Unity] 停止摧毀你家美術的像素風素材 - 巴哈姆特</a></p>
</blockquote>
<h4 id="腳本執行序"><strong>腳本執行序</strong></h4>
<ul>
<li>
<p><strong>編輯時沒有Bug，執行時一堆Null</strong> 😵<br>
⇒ 腳本執行順序，導致某些腳本順序被排在後，結果沒有吃到值<br>
可以先了解 Unity 基本的執行順序 <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html"><strong>Order of execution for event functions</strong></a><br>
對於在寫判斷時也非常有幫助。</p>
<blockquote>
<p><strong>延伸閱讀</strong><br>
📕 <a href="https://kendevlog.wordpress.com/2018/09/26/unity%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98%EF%BC%9A%E8%85%B3%E6%9C%AC%E7%9A%84%E9%A0%86%E5%BA%8F-execution-order/"><strong>Unity開發筆記：腳本的順序 (Execution Order)</strong></a></p>
</blockquote>
<ul>
<li><code>解決方式</code><br>
<strong>功能列 : <code>Edit</code>  &gt; <code>Project Setting</code> &gt;  <code>Script Execution Order</code></strong><br>
<a href="https://www.youtube.com/watch?v=JyxqvaUeXeQ" title="Quick Tip: Script Execution Order (Unity Tutorial)"><img data-src="https://res.cloudinary.com/marcomontalbano/image/upload/v1627186371/video_to_markdown/images/youtube--JyxqvaUeXeQ-c05b58ac6eb4c4700831b2b3070cd403.jpg" alt="Quick Tip: Script Execution Order (Unity Tutorial)"></a></li>
</ul>
</li>
</ul>
<h4 id="程式耦合"><strong>程式耦合</strong></h4>
<p>新手最常犯的錯，不外乎我也犯了😢。<s>(展覽前我幾乎將所有腳本重寫過)</s><br>
<code>腳本之間依賴性過高</code>，出Bug簡直悲劇<br>
因此在下手打程式前你可以思考一下這個問題，<code>**不要踏上我的路了**</code></p>
<blockquote>
<p><strong>延伸閱讀</strong><br>
📕<a href="https://rstargames.com/2021/04/19/unity-%E8%A7%A3%E8%80%A6%E5%90%88%E8%A8%AD%E8%A8%88-%E4%BA%8B%E4%BB%B6%E9%A9%85%E5%8B%95%E6%9E%B6%E6%A7%8B/">Unity 解耦合設計 - 事件驅動架構</a></p>
</blockquote>
<h4 id="輸出-編輯-差異"><strong>輸出 &amp; 編輯 差異</strong></h4>
<ul>
<li>
<p>編輯執行OK，但執行正式應用程式時沒有跑出預期的效果</p>
<ul>
<li><strong>關於Bug</strong></li>
</ul>
<blockquote>
<p><strong>延伸閱讀</strong><br>
📕 <a href="https://kendevlog.wordpress.com/2018/10/19/unity%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%97%A5%E8%AA%8Clogging/"><strong>Unity開發筆記：如何使用日誌&quot;Logging&quot;</strong></a></p>
</blockquote>
<p>輸出的時候，可能是<code>執行序</code>的問題導致物件是null值或是…<br>
我也不知道的問題，但如果有Bug執行檔是不會出現…</p>
<ul>
<li>
<p><strong>我的解決方式</strong></p>
<p>我們需要透過log找出到問題點，把<strong>Development Bulid</strong>按下去<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mz9QW-N4NHpMk3cbWWor8rYraRJueHkzgvQcuUkdgkx8iCsvk4sLTOY7xVWa2wV1tg8QS6qcVa3g9yvM3ZFKmh_-0FJoHRT7fnnn5wNcekYF8VrFU3VCu6sfMUMk753P4qacEoupSeR0rPGjupEPnZzWWSosqIP2cukIA-3KJTqEP2AguAcWDhgmFvVMqh-FO?width=660&amp;height=638&amp;cropmode=none" alt=""><br>
⇒接著在遊戲視窗內如果有bug就會出現在**左下角訊息視窗<code>Open Log file</code>下去，就會看到報告，接著就是跟在editor一樣了<br>
<img data-src="https://chi01pap001files.storage.live.com/y4m9CANqW-2u-0M4-EPZJl5B1gBEZ0loUt27RU1fCzqw8QhyQAQGWQyaJNzPWFbpbjQCCBZsT1S07DyhKnx-8br6ZfJUKYZ4bUB509-BFQ7q7VQbqN12Xkh4EJTw-D7WlnHp9iwCKl8vPPvNvcnwmrV7sQgFl1MCSMio7fMsnA3uEbOMxy9gZ1Q3odwUXtDt9nb?width=256&amp;height=202&amp;cropmode=none" alt=""><br>
<strong>接著開始歡樂的修Bug~</strong> 🤧</p>
</li>
</ul>
</li>
<li>
<p><strong>Editor與輸出顯示差異</strong><br>
尤其是Canvas裡的UI，如果你是開發手機遊戲<br>
你就得考慮不同比例下的UI顯示問題，所幸Unity官方有一個解方<br>
<a href="https://www.youtube.com/watch?v=PLQ4ywB13eg" title="Creating adaptive UI in Unity with Device Simulator! | Unite Now 2020"><img data-src="https://res.cloudinary.com/marcomontalbano/image/upload/v1627187330/video_to_markdown/images/youtube--PLQ4ywB13eg-c05b58ac6eb4c4700831b2b3070cd403.jpg" alt="Creating adaptive UI in Unity with Device Simulator! | Unite Now 2020"></a></p>
</li>
</ul>
<h3 id="知識補充"><strong>知識補充</strong></h3>
<blockquote>
<p><strong>Design Patterns (設計模式)</strong></p>
</blockquote>
<p>可以探索一下，<a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">設計模式</a> 並非只有在開發遊戲，在軟體設計上是非常重要的概念<br>
google上有非常多資源，有興趣的話可以多搜尋一下</p>
<ol>
<li>📕<a href="https://douduck08.wordpress.com/2016/08/10/when-i-first-time-use-design-pattern/">初探 23種 設計模式 - when I first time use design pattern</a></li>
<li>📺<a href="https://www.youtube.com/watch?v=hQE8lQk9ikE">The 6 Design Patterns game devs need?</a></li>
</ol>
<h2 id="結語-18">結語</h2>
<p>每當寫一篇分享，時間，咻! 一下子就過了😌<br>
本來的篇幅只有短短學習管道的部分<br>
但一寫起來回想起這一年好多事，就都寫上了🥴<br>
謝謝你閱讀完<br>
如果有幫助到你，那我會很開心的<br>
一年下來，我依舊覺得自己是菜雞<br>
越學越覺得自己不懂的太多<br>
雖然好幾次很想放棄<br>
但坎跨過之後，收穫都是自己的了🎉</p>
<blockquote>
<p>題外</p>
</blockquote>
<p>還記得我大二的時候，一位大四學長來分享VR的製作技術<br>
隨後我問起他怎麼學的，那麼厲害<br>
他淡淡地回答 : <code>**時間到你就會了**</code><br>
<s>大四的我，是悟出那句話了</s></p>
]]></content>
      <categories>
        <category>2021</category>
        <category>05</category>
      </categories>
      <tags>
        <tag>畢業專題</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | 初探 Git</title>
    <url>/2021/07/07/LearnAboutGit.html</url>
    <content><![CDATA[<h2 id="前言-49">前言</h2>
<p>新增一個新檔案的時候<br>
你會好好命名放進資料夾理嗎?<br>
還是就<code>「未命名-1」</code>先放著在桌面呢?</p>
<span id="more"></span>  
<p>檔案或資料夾囤積幾乎是習慣了<br>
久而久之硬碟容量還不夠用<br>
即使命名了，也可以透過內建搜尋找到檔案<br>
所以索性就不整理了<br>
想想這還真是個壞習慣</p>
<p>我還在大學時，是設計與程式雙併行的情況下<br>
每個人的電腦都是從final~final-final…一直下去<br>
桌面或資料夾在期中、期末不用講就是…</p>
<blockquote>
<p>塞爆它!</p>
</blockquote>
<p><img data-src="https://i.imgur.com/T5ftLuH.gif" alt=""></p>
<p>然後期末結束才再整理<br>
想起之前真是可怕<br>
光是程式專案，複製來複製去<br>
想呈現在網頁上<br>
又只會開 github 網頁版把東西先打包丟上去<br>
感覺非常沒效率</p>
<p>回到程式，版本控制無所不在<br>
可以加強團隊合作的問題<br>
使開發效率更加快速<br>
這麼好用的東西，不學嗎？</p>
<h3 id="檔案囤積症">檔案囤積症</h3>
<p>來看看常發生的問題：</p>
<ul>
<li>不想每次都重新打包再上傳</li>
<li>不想覆蓋掉舊版本，之後又瘋狂按ctrl Z</li>
<li>產生超多個版本檔案，導致很畫面雜亂</li>
</ul>
<p>4 年間，我曾經遇過好幾位同學跟我說<br>
「為什麼硬碟容量又爆了呢 ?」</p>
<p>其實繪圖軟體的檔案容量也是不容小覷<br>
一堆 Final 丟桌面，也沒定時清理磁碟暫存<br>
休怪程式丟給你 :<br>
「安安，這裡裝不下我了，跟你 saygoodbye 了」</p>
<p>既然一直 copy paste ，都只是同個檔案上的小變更</p>
<blockquote>
<p>可不可以像多線存檔一樣<br>
在不同時刻存個檔呢?</p>
</blockquote>
<p>彼時我還不知道 git 怎麼用…</p>
<h2 id="手動式的版本控制">手動式的版本控制</h2>
<p>發現問題之後，來看看之前是怎麼做的<br>
這樣才知道用 git 有什麼幫助</p>
<ul>
<li>
<p>個人<br>
想要一個新變更又保留之前的舊檔案<br>
會這麼操作：</p>
<ol>
<li>複製 <code>01.txt</code></li>
<li>貼上 <code>01(copy).txt</code>，並更改名稱為 <code>02.txt</code></li>
<li>以此類推</li>
</ol>
<blockquote>
<p>久而久之，檔案流水號編號下去</p>
</blockquote>
</li>
<li>
<p>團隊<br>
透過一包一包的傳送檔案</p>
<ol>
<li>A同事把所有檔案共同打包成壓縮檔</li>
<li>上傳到共同空間</li>
<li>B 同事下載下來，覆蓋或者手動替換變更的地方</li>
<li>以此類推</li>
</ol>
</li>
</ul>
<p>不管哪種，我們可以看到做法步驟變得蠻多的<br>
尤其是團隊的處理，非常不俐落</p>
<h2 id="為什麼要用到-Git">為什麼要用到 Git ?</h2>
<p>從個人專案來觀察<br>
或許使用手動更改版本號好像還好~~(?)~~<br>
常常也會忘記哪個才是真正要的<br>
<img data-src="https://pbs.twimg.com/media/DOLGOOoUMAA8RRj.jpg" alt=""></p>
<p>但如果是團隊合作呢？<br>
檔案在本地，但在遠端要同步時</p>
<ul>
<li>誰才是正本呢？</li>
<li>誰修改了檔案？</li>
<li>修改前修改後長怎樣？</li>
<li>臨時想修改，可不可以不要動到原本的檔案？</li>
</ul>
<p>Git 就是幫我們解決這些問題<br>
當然很多都是用在程式上<br>
多屬文字上的變更<br>
不過 PS、AI 等等設計軟體最近也有支援<br>
感覺快到 <strong><code>凡是皆可Git</code></strong> 的境界了</p>
<h2 id="認識Git">認識Git</h2>
<p>Git 是一個版本控制的軟體<br>
在 git 中，被儲存的是檔案的 <strong><code>狀態</code></strong><br>
不是被建立新的地方或真的複製一個檔案來存放<br>
網路上我看了看有不同的說法<br>
個人覺得 <strong><code>狀態</code></strong> 我比較理解 XD<br>
偷懶拿別人的圖 QQ<br>
<img data-src="https://zlargon.gitbooks.io/git-tutorial/content/file/status/git_file_status.jpg" alt=""><br>
圖來自這個<a href="https://zlargon.gitbooks.io/git-tutorial/content/file/status.html">網頁</a></p>
<p>簡單來說 :</p>
<ul>
<li>加入版本追蹤 前後 (untracked)
<ul>
<li><code>新檔案</code>產生會在這，沒有加入追蹤的。</li>
<li>透過 <code>git add</code> 就會到 staged</li>
</ul>
</li>
<li>該版本修改 後  (staged)
<ul>
<li>已經追蹤過的檔案，修改過後的會出現在這</li>
<li>這裡等著被推往下一個版本</li>
</ul>
</li>
<li>推往下一個版本   (commit)
<ul>
<li>已經是最新的版本狀態</li>
</ul>
</li>
</ul>
<p>透過 <code>git status</code> 查看，介面上 git 會告訴你是什麼樣的狀態</p>
<p>這個是我理解，如有誤，煩請在留言區指教</p>
<h2 id="git常用指令">git常用指令</h2>
<p>一些常用指令，當然指令是要實際看狀況而用<br>
網路大神常在講 Git</p>
<blockquote>
<p>易學難精，有用到再去查就好</p>
</blockquote>
<p>把握基本的指令，在工作上應該綽綽有餘了</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#init">init</a></td>
<td>初始化。告訴這個專案加入git的版控功能</td>
</tr>
<tr>
<td><a href="#status">status</a></td>
<td>查看狀態。沒事有事可以點一下</td>
</tr>
<tr>
<td><a href="#add">add</a></td>
<td>加入版本控制的行列。新檔案一定要打一下</td>
</tr>
<tr>
<td><a href="#commit">commit</a></td>
<td>建立新的版本。</td>
</tr>
<tr>
<td><a href="#log">log</a></td>
<td>查看歷史紀錄。</td>
</tr>
<tr>
<td><a href="#checkout">checkout</a></td>
<td>查看指定的檔案版本狀態，或是切到該分支</td>
</tr>
<tr>
<td><a href="#branch">branch</a></td>
<td>開一個新分支</td>
</tr>
<tr>
<td>merge</td>
<td>把別的分支 <strong><code>合併進來</code></strong> 所在的分支</td>
</tr>
</tbody>
</table>
<h2 id="名詞解釋">名詞解釋</h2>
<p>會遇到git相關的單詞，這邊由 git 麻瓜(我)來稍稍解釋</p>
<h3 id="gitignore">.gitignore</h3>
<blockquote>
<p>a.k.a 不用理的邊緣人</p>
</blockquote>
<p>可以新增一個<code>.gitignore</code>檔案<br>
裡面可以放與專案相關性較低的資料。</p>
<ul>
<li><strong><code>.gitignore</code></strong> 是一個文字檔</li>
<li>輸入想被忽略的檔案名稱</li>
</ul>
<blockquote>
<p>看看ignore實際運作 :<br>
註 : <code>vi</code> 是進入 vim 編輯器</p>
</blockquote>
  <figure class="video_container">
  <video controls="true" allowfullscreen="true" poster="">
    <source src="https://zxbleg.ch.files.1drv.com/y4pcK5d35Bg18fyUs7mGnIELhvWO2MmTFGJX65VNnd0KOUL7wEhZ7t5aLFIJgT4E55iGaKlTvc8APUqKmLuOg7XoR5y_clL2JBJ6jd26vz_9emSQSxlyvhT_m2jIyaxgSmXWY-7BGqQe-gG53lB4LIzylocCKxz57_JzO3-QCpka9qBoE5JZazennqxUpgqLZUimv-aa8LNfjumx25vxOW_H9wpLUGgU-pH9nTlfK_mQsg/ignore.webm?psid=1" type="video/webm">
  </video>
</figure>  
<blockquote>
<p>我在做什麼 :</p>
<ol>
<li>新增一個檔案 <code>456.txt</code></li>
</ol>
<blockquote>
<p>這個檔案即將要拿來被忽略</p>
</blockquote>
<ol start="2">
<li><code>status</code> 一下，被 git 列入 <code>Untracked</code> 行列</li>
<li>新增一個 <code>.gitignore</code> 檔</li>
<li>打開 ignore 文字檔案中，加入想無視的 <code>456</code></li>
</ol>
<blockquote>
<p>跟 git 說 : 「不要理 456 啦」。</p>
</blockquote>
<ol start="5">
<li>又 <code>status</code> 一下，發現 <code>456</code> 不見了</li>
</ol>
</blockquote>
<p>這就是被忽略的過程(泣)<br>
想要通通忽略某種檔案<br>
可以加入 <code>*.檔名</code> ，一次就通通忽略掉了。</p>
<h3 id="branch-分支">branch (分支)</h3>
<blockquote>
<p>a.k.a 平行宇宙</p>
</blockquote>
<p>一般在新增版本號通常是<code>單支線</code><br>
透過 branch 可以在不影響原本版本的狀況<br>
多支線去開發其他功能<br>
最後在 merge 在一起成最後的公布版本</p>
<ul>
<li>例子 :<br>
假如 清單 APP 已經有
<ul>
<li>新增任務</li>
<li>刪除任務 等等功能</li>
</ul>
</li>
</ul>
<p>但是我想加入 <code>日期</code> 與 <code>提醒</code> 功能<br>
那就會新開一個 branch 開發這些新功能<br>
在完成時，和原本穩定的清單 APP merge 起來</p>
<ul>
<li>圖解 :<br>
<img data-src="https://chi01pap001files.storage.live.com/y4m0UdMQjFtoRYCvGBx9YvCgFCGujZ60DBR_LBjubAY_iNDvK5f-9pkgSCgzO9I8lTb8183venzbc5LGjSEJwaU5JbNvauYgIn5BGmXPRsME6dkAZxZXnA0quPROTtshUPLXX0qk2bkT39Cr46wMLxL8Xkhz0-xcYH_Q1_7PMcYGGa0m7mRS9YIp0AgNOwRmi37?width=660&amp;height=372&amp;cropmode=none" alt=""></li>
</ul>
<p>要注意的一點是，<strong><code>New branch</code></strong> 並不是完全空的<br>
像是 <code>複製</code> &gt; <code>貼上資料夾繼續動作</code><br>
New branch 出去的，是上一個版本的狀態延續</p>
<blockquote>
<p>練習操作 :</p>
</blockquote>
  <figure class="video_container">
  <video controls="true" allowfullscreen="true" poster="">
    <source src="https://licczq.ch.files.1drv.com/y4pdYb64sLm5R__suIWW6WYGTVIYRP17RAxfr8CHfDVoICyNokREw2wJkRH8knYqyfO2zZ07FcSAzFONymigmmdoWRaXEGy-84aOFOLJeUxg7pTi7xRJbL2gG_XfRBzkCY-VbUnkXmA-9ylARw0fsbfK30A_FiJaNqAVIbLJ7c8mYnvC_IBy2ZbfTVLlWer-FHbPYqS-zyaonuxdtUezjeebnU-BQ-biKOn-fxtIFf36AY/Screen%20Recording%20-%20Made%20with%20RecordCast.webm?psid=1" type="video/webm">
  </video>
</figure>  
<p>旁邊是小抄 XD，我怕思考拖長影片了<br>
預先想好指令運作</p>
<blockquote>
<p>我在做什麼 :</p>
<ol>
<li>用 <code>git branch -v</code> 來查看現在有多少分支</li>
</ol>
<blockquote>
<p>一開始只有master</p>
</blockquote>
<ol start="2">
<li>用 <code>git log</code> 來知道 master 的版本狀態</li>
</ol>
<blockquote>
<p>先前 commit 了一次，有一個紀錄</p>
</blockquote>
<ol start="3">
<li>接著我新增了一個檔案 <code>456.txt</code></li>
<li>新增了一個 branch 叫 <code>Newfeature</code></li>
<li><code>git checkout Newfeature</code> 切換到這個分支底下操作</li>
<li>查看 Newfeature 的 <code>log</code></li>
</ol>
<blockquote>
<p>這邊可以知道是把 master 的版本套過來<br>
commit 記錄依然保留</p>
</blockquote>
<ol start="7">
<li><code>git add 456.txt</code> 加入控制行列</li>
<li><code>git commit -m &quot;456&quot;</code> 紀錄訊息456這個更新</li>
<li>接下來是看 branch 之間的差異</li>
</ol>
</blockquote>
<ul>
<li>注意 : 新檔案要<code>add</code>哦，不然不能 commit<br>
到這邊還沒 marge 哦哦!</li>
</ul>
<h3 id="conflict-衝突">conflict (衝突)</h3>
<blockquote>
<p>a.k.a 來決定最後存活者</p>
</blockquote>
<ul>
<li>
<p>為何有衝突？</p>
<blockquote>
<p>合作時，如果 A、B 改了同一份文件<br>
涵蓋的範圍又一樣的時候<br>
回傳時，電腦要判定誰是正確的？</p>
</blockquote>
<p>這時候我們必須 <strong><code>手動</code></strong> 去解決衝突<br>
Git 會告訴你 : 「哦!這裡有一個衝突!」<br>
這時候把檔案打開解決就行了</p>
</li>
<li>
<p>圖解<br>
<img data-src="https://chi01pap001files.storage.live.com/y4m9Da_EJ6sKwLc097hF5pHF5m7tZkXD55mMJ4G7lFeQg4tRCXamb4Q8oO25f2KLV1zCCIejRWwdABSJNZhNA2N5KZBpIPUaZfzDv-ICw7xuAZr6SnfBGE2sG0nLcpbp0SPR7YSXH3G8r5w-Ob3ZBoVGrz8Lzi-3KpTAt6y-cdHTGHL0cn9R1laBXLTOqM8GXkm?width=660&amp;height=372&amp;cropmode=none" alt=""></p>
</li>
</ul>
<blockquote>
<p>練習操作 :</p>
</blockquote>
<p>老實說我也沒遇過衝突，這是小小的範例而已</p>
  <figure class="video_container">
  <video controls="true" allowfullscreen="true" poster="">
    <source src="https://zxbleg.ch.files.1drv.com/y4pLco_Ji8QyZ8Y0L_CI1_LEj6VX4T0lgGx8WZPxX5ThUSkcuCrOKYsboPTQkDfDPv7DVmpR8OnY_wAgPD72Obmk-KdlqOl3tF6KxnSiROxKlEfl4PFwNbI1tOFlqDS1IoNOBKmRoU6cLdrOkE7fojQB7F23MRxJ6hMVuf50IbHM3SkAxWNaoiMWqlq423_3V3Tm0TWRUjWxUl2ySXqG2dQBkl3wOe_aqgMOaHjy9eWuBg/conflict.webm?psid=1" type="video/webm">
  </video>
</figure> 
<p>可以發現我在兩個 branch 同時都改動了 第二行<br>
在 merge 時，git 顯示這邊有 <code>conflict</code><br>
把衝突的檔案打開來修正就OK囉!<br>
另外我們可以發現其實 commit 出去的都還在<br>
還多一個 merge 處理 conflict 的 commit 。</p>
<h2 id="Git-指令應用">Git 指令應用</h2>
<h3 id="init">init</h3>
<ul>
<li>你要使用 git 的功能，對著要版本控制的資料夾
<ul>
<li><code>git init</code></li>
</ul>
</li>
</ul>
<p>目錄下會新增一個叫 <code>.git</code> 的資料夾<br>
代表你要開始版本控制囉！<br>
.git 裡有很多設定，這邊就先不談了</p>
<h3 id="status">status</h3>
<ul>
<li>當你想知道檔案的狀態，就可以輸入一下
<ul>
<li><code>git status</code></li>
</ul>
</li>
</ul>
<p>git 會告訴你需不需要 add ，哪些 modify 了。</p>
<h3 id="add">add</h3>
<ol>
<li>加入檔案至 <strong><code>tracked</code></strong> 狀態
<ul>
<li><code>git add [檔案名稱]</code></li>
</ul>
</li>
<li>加入所有檔案(好用)
<ul>
<li><code>git add .</code></li>
</ul>
</li>
</ol>
<ul>
<li>[X] 記住，加入版本控制，新檔案必須先 <code>add</code> 再 <code>commit</code></li>
</ul>
<h3 id="commit">commit</h3>
<ol>
<li>新增檔案版本，把檔案推到 <strong><code>Staged</code></strong> 狀態
<ul>
<li><code>git commit -m &quot;訊息&quot;</code><br>
<code>-m</code> 是 message ，後面接你想打的紀錄訊息</li>
</ul>
</li>
<li>一次新增(好用)
<ul>
<li><code>git commit -am &quot;訊息&quot;</code><br>
<code>a</code> 是 ALL 的意思</li>
</ul>
</li>
<li>改變 commit 出去的訊息
<ul>
<li><code>git commit --amend</code><br>
通常改最後 commit 的那個</li>
</ul>
</li>
<li>後悔 commit 想刪掉或更改<br>
有三個方法，但各自的代表不同意思
<ul>
<li><code>git reset Head^ --[不同模式] </code>
<blockquote>
<p>HEAD 指向現在所在的版本<br>
^ 是指上一個；上上個是 <code>~</code> 波浪號</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<ul>
<li>mixed<br>
預設模式。刪掉上一個 commit 與 add<br>
<strong><code>但保留修改的內容</code></strong>。
<ul>
<li>退回 <code>add</code> 與 <code>commit</code>的狀態<br>
版本的內容一樣是新版的</li>
</ul>
</li>
<li>soft<br>
回到 commit 前，但版本的內容一樣是新版的
<ul>
<li>退回已經 <code>add</code> 但<code>尚未 commit </code>的狀態<br>
這邊會看到檔案標示 <code>modified</code></li>
</ul>
</li>
<li>hard<br>
版本跟上一版一樣，新版的修改就沒有保留了。
<ul>
<li>退回 commit、add 與 modified 的狀態<br>
完全回到上一個版本</li>
</ul>
</li>
</ul>
<p>有點霧沙沙 XD<br>
可以參考 <a href="https://ithelp.ithome.com.tw/articles/10187303">這篇文章</a></p>
<h3 id="log">log</h3>
<ul>
<li>你到底 commit 了什麼，來看一下詳細的歷史紀錄
<ul>
<li><code>git log</code></li>
<li>想要離開 log ，就輸入 <code>q</code> 代表 quit。</li>
</ul>
</li>
<li>顯示更精簡的內容
<ul>
<li><code>git log --oneline</code></li>
</ul>
</li>
</ul>
<p>這就是歷史紀錄<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mxhyPRSBSJ0DtpgC6pOq09kdav9fsPm3WfcjzKSj8geWtNRX-gR6Br7WliZ1aWMeFI7I2qp2BV0FreSN1AARa8gJgMMLRtowBzA14TESysuilfRhqIzI-f68bbLWGnmS1HOt4F8x4ECIlVSA6MjxnG-POOI3CiB_KewZC0OaZGHIDySbUc8VZymK5uE108gux?width=660&amp;height=456&amp;cropmode=none" alt=""></p>
<blockquote>
<p>解析 :</p>
</blockquote>
<ol>
<li>commit 後面有一串自動產生的亂碼<br>
代表版本號，每一個版本都有獨特對應的字串<br>
這樣也不會出現重疊的情形<br>
想查詢該版本的內容，可以複製字串 <code>checkout</code> 一下</li>
<li><code>Author</code> 可以看見是誰建立了這個版本</li>
<li><code>Date</code> 建立的時間</li>
<li><code>(HEAD -&gt; master)</code> 指目前所在分支、目前的版本</li>
</ol>
<h3 id="checkout">checkout</h3>
<ol>
<li>查看某個版本內容
<ul>
<li><code>git checkout [版本號]</code></li>
</ul>
</li>
</ol>
<ul>
<li>看看版本運作</li>
</ul>
  <figure class="video_container">
    <video controls="true" allowfullscreen="true" poster="">
    <source src="https://zxbleg.ch.files.1drv.com/y4pkzvhn1h7ZuS5j0vNxDkzGaM-oHG7DxjPInp-KNn7m89w_1hrhVr57OMoHxNDfn-nPvk8Q4rpT8cWgQlN6bkPFMXGXmEnZCFvOotKL9zNhSSlmtbEH-qgfxuZL00dDOgpeKf6E1FEX5Y2qidEcQJrfOjf405CSAc10XLgIM_wLICilUblq_IQsISmfUD-mr3wqd15AhTv2MiNaspONR3snvkGGJHdPC0mI5jWHaYclJE/checkoutOrder.webm?psid=1" type="video/mp4">
    </video>
  </figure> 
<p>是不是很奇異~<br>
到這邊就可以知道 git 有多好用了:D</p>
<ol start="2">
<li>切換到某某分支
<ul>
<li><code>git checkout [分支名]</code></li>
</ul>
</li>
</ol>
<p>checkout 的用途蠻廣的。</p>
<h3 id="branch">branch</h3>
<ol>
<li>創建新分支
<ul>
<li><code>git branch [新的分支名稱]</code></li>
</ul>
</li>
<li>刪除分支
<ul>
<li><code>git branch -d [分支名]</code></li>
</ul>
</li>
<li>改變分支名稱
<ul>
<li><code>git branch -m [重新命名的分支名]</code><br>
<strong>要先到那個分支哦!</strong></li>
</ul>
</li>
<li>抓遠端的 branch<br>
比如遠端這邊有 branch 叫 <code>Newfeature</code><br>
本地端沒有，透過
<ul>
<li><code>git checkout [你想要的branch]</code></li>
</ul>
</li>
</ol>
<p>就會自動有這個 branch 了。</p>
<p>一般預設的會是 <code>master</code><br>
其他 branch 是從主分支在延伸<br>
回到現在最新版本 checkout 回去就行了</p>
<h2 id="Git-與-Github">Git 與 Github</h2>
<p>Git 跟 Github 兩個並不相同<br>
前者是是版本控制的「軟體」<br>
後者是平台</p>
<ul>
<li>[X] Github 一定要配 Git</li>
<li>[ ] Git 一定要配 Github</li>
</ul>
<p>大概是這樣的感覺<br>
平台提供 Resposity (儲存庫)<br>
透過 git push 來把資料同步上去<br>
當然也可以把最新檔案 pull 下來</p>
<p>大家常聽到 Github ，此外也有其他類似的平台<br>
像是 <code>Gitlab、Bitbucket</code><br>
不管是哪個平台，在 Git 的操作是一樣的<br>
所以你學會了 Git ，遊走江湖至少不會重練啦</p>
<h2 id="Github">Github</h2>
<p>這邊解釋一些常見的東西，以及與 git 相關的指令</p>
<h3 id="repository">repository</h3>
<p>又稱「<code>儲存庫</code>」，可以放檔案用<br>
也可以用 <code>靜態網站</code> 的方式顯示專案結果<br>
github 的 repository 有分 public 、 private</p>
<ul>
<li>private 要錢，有的公司會購買來使用，畢竟專案不能亂公開</li>
<li>public 一般大家都在使用，大家都看的到專案內容</li>
</ul>
<h3 id="如何開始">如何開始?</h3>
<p>新建完 repository，頁面下面會有告訴你怎麼連接<br>
通常我用第二個，將原有的檔案上傳上來<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mKwQ_9Ir3-1Nas5uX9KqnYrlk8lp1g-Ms1T8f3_LHOrScO4NvLTpVAeY-n9gDVxTqvYzASVonAt0K1rIPsdCIcyk0ADYJGhdJYsLEnxfLsetdFgVh_uReUK_pVVWg4KcYQplpvjuF2LvUKszBI3O1roTxFD2ambTOKJ4IK15vU1_OFY9WSPI6OzE2ilfcoVJp?width=660&amp;height=378&amp;cropmode=none" alt=""></p>
<p>在 GitBash 直接複製上去那幾行就行了~</p>
<h3 id="clone">clone</h3>
<ul>
<li>
<p>目前本地沒有檔案，想下載遠端的資料<br>
在 github ，按下這個綠綠的<br>
<img data-src="https://chi01pap001files.storage.live.com/y4mg80z42pM_kRWFRbweTgcM1_Ymn1ZniDkb1V2m4lfkWBiprmR8zJU9PiQ1vvpSP8M5zqdmF4hWylJHhiAFtPiDCKF42BEbUWYlVvqbH2oFPaqjSGFAM1kdVkPkOa2G1WJd2yss4jTfxliwxG1IkPjktJLLzM-dGSCFj4sHbHM2AOan59kGo3CEXo-HnEZ73xb?width=256&amp;height=38&amp;cropmode=none" alt=""><br>
會有不同的方式，通常有 <code>https</code> 跟 <code>ssh</code><br>
看自己想用哪個。</p>
<ul>
<li><code>git clone [github給的路徑]</code></li>
</ul>
<p>在目錄底下就會看見檔案了</p>
</li>
</ul>
<h3 id="push">push</h3>
<ul>
<li>
<p>把 <strong><code>本地</code></strong> 的資料同步到 repository 裡</p>
<ul>
<li><code>git push origin [分支名]</code></li>
</ul>
<p>* <code>origin</code> 通常在 clone 時會自動幫你建立。<br>
指向的地方就是 <code>伺服器</code> 那端。</p>
</li>
</ul>
<p>稍微查了一下，原來這個原樣貌長這樣<br>
<code>git push origin [本地分支名]:[在那端新建立的分支名]</code><br>
翻譯機 :<br>
上傳 branch 至伺服器 (origin) 後建立新的 branch 儲存。<br>
我這個麻瓜非常需要翻譯機 QQ。</p>
<h3 id="pull">pull</h3>
<ul>
<li>已經有遠端的資料，但本地不是最新的<br>
所以把遠端的 <code>repository</code> 同步到自己的資料
<ul>
<li><code>git pull origin [遠端的分支]</code></li>
</ul>
</li>
</ul>
<h3 id="fork">fork</h3>
<p>把 <code>A repository</code> 複製到 <code>B repository</code><br>
可以 fork 別人的專案，再來修改<br>
也可以 pull resquest 去詢問原專案作者是否要 merge<br>
<img data-src="https://chi01pap001files.storage.live.com/y4m06-A5i7dDD3CNkWRriRtSmcLbOKtnGgip0Po34L7zWkdMs51ciCFISJglLCfB4I8m_XwtsvkoHDPKWeA3KlkQBSjGh84iLD8Ks6HNuxOVIBm7uta4SW_3x3J16PjyiiLFlPYX4U_qvab0ODWu2WjwesV8xfTPY7u8fDoia6hNuSa8uxObNLJbo4accwWgRS6?width=660&amp;height=364&amp;cropmode=none" alt=""></p>
<h3 id="pull-resquest"><strong>pull resquest</strong></h3>
<p>umm… 因為我也還沒用到，也有點模糊</p>
<p>意思是請求合併，在開源的專案會互相貢獻很常見<br>
github 上可以看見很多專案有不少的 resquest<br>
如果我們想要貢獻，可以發 <code>pull resquest</code><br>
專案的擁有者會收到請求，作者可以決定要不要 merge</p>
<p>如果是所屬的同一個團隊，發出 resquest<br>
可以讓團隊裡的其他人一起討論<br>
確定後再 <code>merge</code></p>
<p>常常看到 <code>PR</code> 這個字，現在稍微理解一點了 XD<br>
可以閱讀 <a href="https://github.com/twtrubiks/Git-Tutorials/tree/master/pr-tutorial#github-pr-pull-request-%E6%95%99%E5%AD%B8">這篇文章</a> 詳細了解</p>
<h2 id="結語-19">結語</h2>
<p>經過學習後再到 <a href="https://learngitbranching.js.org/?locale=zh_TW">這個網站</a> 使用模擬<br>
就清楚多了<br>
git 雖然知道怎麼用<br>
實戰上還是有使用到才比較了解<br>
不過個人專案懂指令後也是超方便的 XD</p>
<p>這次資訊算蠻多的<br>
不過現在學到的都只是冰山一角<br>
路還長(ㄔㄤˊ)著咧 QQ<br>
為自己加油 !</p>
<blockquote>
<p><strong>補充資料</strong> :</p>
<ol>
<li><a href="https://www.slideshare.net/pokaichang72/git-42427674">很棒的簡報</a></li>
<li><a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1?fbclid=IwAR2qlaZYCG1mXsdy2aoUYvtHJN8UtG7VCFI-LZ7P81Z1eQghflKVpoXJI6I">很酷的圖解 git</a></li>
<li><a href="https://gitbook.tw/interview">git 常見問題</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>2021</category>
        <category>07</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | React - render props</title>
    <url>/2022/07/React/Render-props.html</url>
    <content><![CDATA[<blockquote>
<p>文章來自 :</p>
<ol>
<li><a href="https://zh-hant.reactjs.org/docs/render-props.html">Render Props – React</a></li>
<li><a href="https://gist.github.com/heygrady/f9bf3b6dd93fe3d87ba87430fd3c20d5">Avoiding HOC; Favoring render props · GitHub</a></li>
</ol>
</blockquote>
<h2 id="摘要-5">摘要</h2>
<ol>
<li>什麼是 render props</li>
<li>render props 的應用範例</li>
<li>render props 與 HOC (higher order component) 的差別</li>
</ol>
<span id="more"></span>
<h2 id="什麼是-render-props">什麼是 render props</h2>
<p>render props 是一種把 props 當作 render function 的概念。<br>
擁有 render props 的 Component 不會執行自己的 render 邏輯，或是可以想成把 children 當成 function 呼叫後回傳一個 <code>React.Element</code> 。</p>
<ul>
<li>這是一種 : 但是不見得一定要用 <code>props.children</code></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">AComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        /* 把 children 寫成 function 帶入*/</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>實際上只要 props 是 function ，而且在 render function 內部被呼叫</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">AComponent</span>(<span class="params">props</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">Wrapper</span> <span class="attr">render</span>=<span class="string">&#123;props</span> =&gt;</span> &#123;	</span></span><br><span class="line"><span class="language-xml">			/* 直接把 function 拆開來，可以直接接收 AComponent 的 state 與 props*/</span></span><br><span class="line"><span class="language-xml">			</span></span><br><span class="line"><span class="language-xml">		&#125;&#125;/&gt;</span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接把 props.render 在內部呼叫</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Wrapper</span>(<span class="params">props</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		&#123;props.render(props)&#125;</span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>叫不叫 <code>render</code> 都沒關係，這是種命名上的慣例而已。</p>
<p>如果使用過 <a href="https://blog.rosa.tw/2022/07/React/React-Context">Context Consumer</a>，Consumer 的另一個型態就是 :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">	<span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">Context.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		&#123;props =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">			/* 放在這裡面的 Component 都能透過 props 拿到 context value*/</span></span><br><span class="line"><span class="language-xml">		&#125;&#125;</span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">Context.Consumer</span>&gt;</span></span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>好處是可以同時擁有多個 Provider 來使用，優點就顯示在動態上的資料結構。</p>
<h2 id="render-props-的結構">render props 的結構</h2>
<p>把 props 當作 function 直接傳入 <code>(props)=&gt; &lt;Component &#123;傳入想要的 props 與 state&#125;/&gt;</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">somethingwithToggle</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">render</span>=<span class="string">&#123;(props)</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">			return (</span></span><br><span class="line"><span class="language-xml">				<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">					&#123;/* ✅在這裡就可以直接接收到資料，不用再經過另外的 Container 包住*/&#125;</span></span><br><span class="line"><span class="language-xml">					<span class="tag">&lt;<span class="name">AnthorComponent</span> <span class="attr">somevalue</span>=<span class="string">&#123;value&#125;</span> <span class="attr">someprop</span>=<span class="string">&#123;props.OOO&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			)</span></span><br><span class="line"><span class="language-xml">		&#125;&#125;/&gt;</span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我自己看作 <strong>直接在 props 把 function 結構打開</strong> 到父元件直接使用，在內部的 Element 可以直接接收到 props 與 state。跟 HOC 比較而言，在使用結構上更一目了然。</p>
<p>由於 HOC 是將 Component 用 function 包起來，邏輯包在 function 內部 (封裝起來)，如果要知道傳入的 props name 還要把 HOC 所在的腳本打開來看。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 看不出來 Toggle 裡面傳什麼東西給 Navbar </span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NavbarwithToggle</span>  = <span class="title function_">withToggle</span>(<span class="title class_">Navbar</span>)</span><br></pre></td></tr></table></figure>
<p>另一個是動態與靜態的關係，render props 的 render 部分可以想填入任何結構的 JSX，而 HOC 類似 <strong>固定的模板</strong> (Container)，只能按照定義的格式填入。</p>
<ul>
<li>HOC</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最簡單的 HOC，這邊只能回傳被包住的結構</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">withToggle</span> = (<span class="params">Component</span>)=&gt; <span class="function">(<span class="params">props</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="comment">// 產生出來的結構 👉 </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Navbar</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>render props</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ToggleComponent</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span> <span class="attr">render</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">			(<span class="attr">props</span>)=&gt;</span>(</span></span><br><span class="line"><span class="language-xml">				<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">					// 任何結構，一個也可以</span></span><br><span class="line"><span class="language-xml">					<span class="tag">&lt;<span class="name">OnlyComponent</span> <span class="attr">open</span>=<span class="string">&#123;props.open&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">					// Nested 也行</span></span><br><span class="line"><span class="language-xml">					<span class="tag">&lt;<span class="name">NestedContainer</span> &#123;/*<span class="attr">也可以插入</span> <span class="attr">props</span> */&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">						<span class="tag">&lt;<span class="name">Component</span> <span class="attr">open</span>=<span class="string">&#123;props.open&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">					<span class="tag">&lt;<span class="name">NestedContainer</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			)</span></span><br><span class="line"><span class="language-xml">		&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">	)</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="實際範例-2">實際範例</h2>
<p>可以先複習 HOC 的部份，會改寫來自 <a href="https://blog.rosa.tw/2022/07/React/Higher-Order-Component">HOC 實作練習</a>。</p>
<p>接下來我要做的 :</p>
<ol>
<li>將 <code>withToggle</code> 改成 render props 格式，叫 <code>&lt;Toggle/&gt;</code></li>
<li>用 <code>&lt;Toggle/&gt;</code> 把 Navbar 與 Accordion 包起來</li>
<li>實作 Push Canvas Navbar</li>
</ol>
<p>其實在 HOC 時有一種 Navbar 不太好做到，那就是向整個畫面推的 Navbar，因為 HOC 將結構給綁住了，結果只能控制 Component 本身，雖然可以用判斷的方式 (conditional rendering)，但會使得結構攏長 😵，接著會使用 <strong>render props</strong> 創建 Push Canvas Navbar。</p>
<p>在寫這篇的同時，我也在 HOC 也有補上 Push Canvas Navbar 的寫法 👉 <a href="https://codepen.io/shan473/pen/WNzjdmJ">React - HOC practice</a></p>
<h3 id="掰掰-withToggle-👋">掰掰 withToggle 👋</h3>
<p>通通砍掉 HOC 的部分，改成 Component 的形式</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. props.render 是一個 function，render children</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Toggle</span>(<span class="params">&#123;render&#125;</span>) &#123;</span><br><span class="line">	<span class="comment">// 2. 類似邏輯的 open 與 togglehandler</span></span><br><span class="line">  <span class="keyword">const</span> [open, setOpen] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">togglehandler</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setOpen</span>(<span class="function">(<span class="params">prevOpen</span>) =&gt;</span> !prevOpen);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/* 3. 👇 重點在這裡 render 是一個 function 負責渲染 React Element，參數是帶給 Element </span></span><br><span class="line"><span class="comment">  的 props</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;render(&#123; open, togglehandler &#125;)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>參數使用 object 比起使用 array ，用解構時不用管順序的問題。</p>
<h3 id="加上客製化的-Navbar">加上客製化的 Navbar</h3>
<p>基本上兩個元件的結構並沒有動到，而是將 HOC 中的 <code>withNavbarType</code> 改成 <code>&lt;CustomNavbar/&gt;</code>，並且改成傳入的 type 來判斷 <code>width</code> 的值</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CustomNavbar</span>(<span class="params">&#123; type &#125;</span>) &#123;</span><br><span class="line">	<span class="comment">// 1. displayName 是幫助 devtool 辨名稱，但是這裡有 BUG 😵😵😵，下面會說明</span></span><br><span class="line">  <span class="title class_">CustomNavbar</span>.<span class="property">displayName</span> = type + <span class="string">&quot;Navbar&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">	  <span class="comment">// 2. 把 Toggle 元件 render function 展開，並且把 props 直接傳給 Navbar</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">render</span>=<span class="string">&#123;(props)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">        return <span class="tag">&lt;<span class="name">Navbar</span> <span class="attr">type</span>=<span class="string">&#123;type&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    /&gt;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其實有點多此一舉，不過我原本是想要加上 displayName ，但這邊出 BUG 😵</p>
<h3 id="組合">組合</h3>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	  &#123;/* 1. 兩種 Navbar */&#125;</span></span><br><span class="line"><span class="language-xml">      Overlay:</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">CustomNavbar</span> <span class="attr">type</span>=<span class="string">&quot;Overlay&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      FullNavbar:</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">CustomNavbar</span> <span class="attr">type</span>=<span class="string">&quot;Full&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 2. Accordion */&#125;</span></span><br><span class="line"><span class="language-xml">        &#123;Array.from(&#123; length: 3 &#125;).map((_, i) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          return (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Toggle</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">key</span>=<span class="string">&#123;i&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">render</span>=<span class="string">&#123;(props)</span> =&gt;</span> <span class="tag">&lt;<span class="name">Accordion</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">index</span>=<span class="string">&#123;i&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">            /&gt;</span></span><br><span class="line"><span class="language-xml">          );</span></span><br><span class="line"><span class="language-xml">        &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其實 Navbar 也可以一起拆開，因為只有包住 Navbar 而已。如此一來，在結構上就可以看的出來在做什麼</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	    &#123;/* 1. 透過 Navtype 直接取 name 生成，由於 Push Navbar 處理方式不一樣就另外用*/&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;Object.keys(Navtype).map((name, i) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        if (i === 2) return null;</span></span><br><span class="line"><span class="language-xml">        return (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;name&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Toggle</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">key</span>=<span class="string">&#123;name&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">render</span>=<span class="string">&#123;(props)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                return <span class="tag">&lt;<span class="name">Navbar</span> <span class="attr">type</span>=<span class="string">&#123;name&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="language-xml">              &#125;&#125;</span></span><br><span class="line"><span class="language-xml">            /&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">	      &#123;<span class="comment">/* 2. 這裡的 Accordion 沒什麼差別，但比 HOC 少一層包裝 */</span>&#125;</span><br><span class="line">        &#123;<span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;).<span class="title function_">map</span>(<span class="function">(<span class="params">_, i</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">key</span>=<span class="string">&#123;i&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">render</span>=<span class="string">&#123;(props)</span> =&gt;</span> <span class="tag">&lt;<span class="name">Accordion</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">index</span>=<span class="string">&#123;i&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">            /&gt;</span></span><br><span class="line">          );</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最後效果跟 HOC 一樣，不過 render props 是在結構上就很清楚看見自己在做什麼👌(看 devtools 的地方)<br>
<img data-src="https://i.imgur.com/YJChQnc.gif" alt="|420x400"></p>
<h3 id="Push-版本的Navbar">Push 版本的Navbar</h3>
<p>Push 版本需要把 <em>整個畫面往右推</em>，在結構上是長在 <code>root Element</code> 的鄰居，所以必須透過 <strong>Portal</strong> 來幫我們直接在 <code>root</code> 以外的節點生成 DOM 。</p>
<p>首先在 <code>html</code> 加上要長出的 <code>container</code>，叫 <code>push-navbar</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;push-navbar&quot;</span>&gt;</span>Push:<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只有 Push 的 Navbar 結構不同，我希望把它獨立出來</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1. 拿到 Container 的 DOM */</span></span><br><span class="line"><span class="keyword">const</span> pushEl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;push-navbar&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">PushNavbar</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">/* 2. ReactDOM.createPortal 可以在指定的 Container 生成 element */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">render</span>=<span class="string">&#123;(props)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">	      /* 4. 根據 open 讓 root 往右推移。我選擇不在 Navbar 裡面判斷，把它提到這裡 */</span></span><br><span class="line"><span class="language-xml">        React.useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          if (props.open) &#123;</span></span><br><span class="line"><span class="language-xml">            document.getElementById(&quot;app&quot;).style.marginLeft = &quot;250px&quot;;</span></span><br><span class="line"><span class="language-xml">          &#125; else &#123;</span></span><br><span class="line"><span class="language-xml">            document.getElementById(&quot;app&quot;).style.marginLeft = 0;</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">          /* 5. 記得加上 dependencies */</span></span><br><span class="line"><span class="language-xml">        &#125;, [props.open]);</span></span><br><span class="line"><span class="language-xml">        </span></span><br><span class="line"><span class="language-xml">		    /* 6. render props Navbar ，並且把 Toggle 的資料塞回去，一樣要加上 type */</span></span><br><span class="line"><span class="language-xml">        return <span class="tag">&lt;<span class="name">Navbar</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">type</span>=<span class="string">&quot;Push&quot;</span> /&gt;</span>;</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    /&gt;</span>,</span><br><span class="line">    <span class="comment">/* 3. 第二個參數放 Container */</span></span><br><span class="line">    pushEl</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最後把他加在 <code>&lt;App/&gt;</code> 裡面，雖然在裡面， Portal 只會在指定的 Container 生成。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	    &#123;/* 在這裡加上 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">PushNavbar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* ... 略 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果 :<br>
<img data-src="https://i.imgur.com/zh8X6fB.gif" alt="|580x400"></p>
<h3 id="遇到的問題-CustomNavbar-的-displayName-錯誤">遇到的問題 :  CustomNavbar 的 displayName 錯誤</h3>
<p>因為 CustomNavbar 是用在只有固定移動寬度的 Navbar 上，為了方便 debug 加上了 displayName ，但是永遠只會顯示排在最後面改過名的 Navbar ，我用 console 印出 displayName 是兩個不同的，不過在 React devtools 卻顯示一樣的😵 ，實際上我也不知道發生什麼問題…</p>
<blockquote>
<p>如果有解答的大神，煩請寫信告訴我😢</p>
</blockquote>
<p><img data-src="https://i.imgur.com/2X0ATS6.png" alt="600x280"></p>
<h2 id="注意-render-props-使用在-Pure-Component">注意 : render props 使用在 Pure Component</h2>
<p>props 放入 function，Object Type 放在 render 會導致每次 re-render ，這在 [[…/React - 巢狀 Component 優化 &amp; anti-pure Pattern | Component 優化的問題]] 有提過，所以使用 render props 的方式，在 render 展開的 function 本身就不會是 Pure 的，如果裝有 render props 的元件要變成 Pure Component 可以把傳入 function 提出來，而不是每次 re-render 產生新的 function。</p>
<blockquote>
<p>簡單來說 : <code>&#123; &#125; !== &#123; &#125;</code></p>
</blockquote>
<p>把 render function 永遠指向相同的 function，以  <code>&lt;Toggle/&gt;</code> 為例</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 把 render function 提出來，🤔 是不是跟 HOC 有 87% 像</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderNavbar</span>(<span class="params">type</span>) &#123;</span><br><span class="line">	<span class="comment">// 2. 這邊回傳的是一個 function 不是 element，因為我們要把 type 跟 props 同時帶進去</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Navbar</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">type</span>=<span class="string">&#123;type&#125;/</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 把這個帶 type 的 function 記起來</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FullwithToggle</span> = <span class="title function_">renderNavbar</span>(<span class="string">&quot;Full&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CustomNavbar</span>(<span class="params">&#123; type &#125;</span>) &#123;</span><br><span class="line">  <span class="title class_">CustomNavbar</span>.<span class="property">displayName</span> = type + <span class="string">&quot;Navbar&quot;</span>;</span><br><span class="line">	<span class="comment">// 4. ✅ 記住傳進去的是一個 function ，不是 &quot;呼叫的&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span> <span class="attr">render</span>=<span class="string">&#123;FullwithToggle&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不能這樣，因為傳入的還是回傳新的 function，</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CustomNavbar</span>(<span class="params">&#123; type &#125;</span>) &#123;</span><br><span class="line">  <span class="title class_">CustomNavbar</span>.<span class="property">displayName</span> = type + <span class="string">&quot;Navbar&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span> <span class="attr">render</span>=<span class="string">&#123;renderNavbar(type)&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我準備兩個一樣的介面，一個 Toggle 傳入的 function 有被記憶起來，另一個沒有。<br>
用 devtools 來看，App  state 改變 ，<code>&lt;CustomNavbar/&gt;</code> 也會 re-render。當 render props 的 function 被提出來， <code>&lt;Toggle/&gt;</code> 這邊不會進行 re-render，只會顯示 <code>parent render</code>；另一組則是會寫 <code>props changed(render)</code>。<br>
<img data-src="https://i.imgur.com/DB2jLnQ.png" alt=""><br>
我覺得這樣的方法很類似 HOC ，結構上沒有太大的延展性， render 裡面的結構變成固定的，不過依然比 HOC 好一點。</p>
<h2 id="HOC-render-props-的組合技">HOC + render props 的組合技</h2>
<p>當然也可以使用 HOC 包住 render props 的方式，<strong>但反之是不行的</strong>，這也是為什麼 HOC 逐漸不備受用，而大部分推從 render props 的原因。</p>
<p>在 <strong>react-router v5</strong> 的<code> withRouter</code> 就採取 HOC 包住 render props 的方式，HOC 包出去的是 Pure Component 。在 <code>withRouter</code> 的部份，會改變 historyAPI 也就是顯示的網址 (SPA 並非真的執行跳轉的行為，而是改變 url 的長相)</p>
<p><code>withRouter</code> 的結構<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withRouter</span> = (<span class="params">Component</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">C</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; wrappedComponentRef, ...remainingProps &#125; = props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">render</span>=<span class="string">&#123;routeComponentProps</span> =&gt;</span> (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...remainingProps</span>&#125; &#123;<span class="attr">...routeComponentProps</span>&#125; <span class="attr">ref</span>=<span class="string">&#123;wrappedComponentRef&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;/&gt;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>但在 v6 後 <code>withRouter</code> 就消失了，現今都改成 Hooks 版本，因為 Hooks 很香阿 (X</p>
<h2 id="render-props-v-s-HOCs">render props v.s HOCs</h2>
<p>當我學習 HOC 時，很多文章指出 render props 是比 HOC 更好的實作方式，從上面的實作大略知道超越的優點，接著要來深入更具體的原因。</p>
<p>根據這篇文章<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，來釐清幾個 HOC 的問題</p>
<h2 id="HOC-被淘汰的原因">HOC 被淘汰的原因</h2>
<ol>
<li>HOC 廣泛的被濫用，造成任何結構相同都得用來包。有些包裝成 HOC 卻<strong>沒有實行傳遞 props 或 method 的功能</strong>，失去它的核心意義。</li>
<li>造成 React tree 變得更複雜。這個概念就是 function 裡面不斷包 function，Call Stack 不斷往上疊加，加重效能上的負擔。</li>
<li>需要額外的動作兼容原始 Component 的行為。
<ol>
<li>ref 的問題。不能直接加在 HOC 產生的 Component 上，必須透過 <strong>forwardref</strong> 承接 ref，再多包一層往下傳遞至 <code>WrappedComponent</code></li>
<li>Class Component 的 method 不會被傳遞，必須提升靜態 (static) 的 function 到 HOC 上來擴充。</li>
</ol>
</li>
</ol>
<p>這些缺點都有在 React 官方被提及<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>，也都有補救的方式。<br>
更簡單來說，使用 HOC 要像補丁一樣，東補西補把它回還原成原本 Component 應有的東西，在有些時候多此一舉了。</p>
<ul>
<li>以文章的 <code>Row</code> 為例</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">import</span> hoistStatics <span class="keyword">from</span> <span class="string">&#x27;hoist-non-react-statics&#x27;</span></span><br><span class="line"><span class="keyword">import</span> classnames <span class="keyword">from</span> <span class="string">&#x27;classnames&#x27;</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./row.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getDisplayName</span> = (<span class="params">WrappedComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">WrappedComponent</span>.<span class="property">displayName</span> || <span class="title class_">WrappedComponent</span>.<span class="property">name</span> || <span class="string">&#x27;Component&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">row</span> = (<span class="params">&#123; backgroundColor, className, style &#125;</span>) =&gt; <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 產生合併的 Component</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">Row</span> = (<span class="params">&#123; wrappedComponentRef, ...otherProps &#125;</span>) =&gt; (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#123;classnames(styles.row,</span> <span class="attr">className</span>)&#125; <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">backgroundColor</span>, <span class="attr">...style</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">ref</span>=<span class="string">&#123;wrappedComponentRef&#125;</span> &#123;<span class="attr">...otherProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. displayName，因為由 HOC 包出來的元件通常不具名</span></span><br><span class="line">  <span class="title class_">Row</span>.<span class="property">displayName</span> = <span class="string">`Row(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 定義型別 : forward refs </span></span><br><span class="line">  <span class="title class_">Row</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">wrappedComponentRef</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 把 WrappedComponent 靜態的方法提升並繼承過來</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">hoistStatics</span>(<span class="title class_">Row</span>, <span class="title class_">WrappedComponent</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> row</span><br></pre></td></tr></table></figure>
<p>HOC 變得要遵守額外許多規則，因為本身突破 React 的基礎規定，導致要花其他的功能幫忙把 React 的功能補回去😵😵😵。</p>
<p>不如直接使用 <code>&lt;Row&gt;</code> 元件包裹裡面的東西</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Somewhere</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;/* ✅ 邏輯直接在這裡拆開，不用刻意包裝到 HOC，直接少一層結構 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Row</span> <span class="attr">backgroundColor</span>=<span class="string">&quot;green&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyThing</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Row</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>亦或者改成 render props :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MyThing</span> = (<span class="params">&#123; className, name, style &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Row</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">backgroundColor</span>=<span class="string">&#x27;green&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">className</span>=<span class="string">&#123;className&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">style</span>=<span class="string">&#123;style&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &#123;/* <span class="attr">render</span> */&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">render</span>=<span class="string">&#123;(&#123;</span> <span class="attr">visible</span> &#125;) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">      if (!visible) &#123;</span></span><br><span class="line"><span class="language-xml">        return null</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">      return `Hello, $&#123;name&#125;!`</span></span><br><span class="line"><span class="language-xml">    &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  /&gt;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>不過 <code>visible</code> 在那裏判斷 <code>null</code>，我感覺不太好🤔，應該在 <code>Row</code> 還沒 return 之前就要直接跳出了，在裡面判斷會導致 <code>Mything</code> 已經 <code>mount</code> 又多一次渲染 <code>unmout</code> 掉。</p>
<h2 id="小結-7">小結</h2>
<p>我覺得這篇還有提到一個有趣的問題，<strong>React-redux <code>connect</code> 為什麼不改為 render props ?</strong>， 因為 connect 內部還是 HOC ，因此有人發起討論希望可以改成 render props ，用 Component 的方式包裝，但是被駁回了<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>。主要當時 Hooks 的興起，團隊比較傾向改為 Hooks ，另外關鍵的點在於 render props 不是 Pure 的，會導致每次 re-render 都產生新的 <code>connect</code> ，造成效能問題，之後有時間再慢慢破解內部的 funciton 。</p>
<h2 id="總結-27">總結</h2>
<ol>
<li>傳入的 props 是一個 function，並且 render React Element，等同於 <code>props.children</code> 作為 function 並且傳入 props  為參數。</li>
<li>render props 要謹慎使用 Pure Component，因為 props 放入 function 每次 re-render 都是新 function ，本身就不 Pure。</li>
<li>render props &gt; HOCs。 React  composition Design Pattern 的選擇是 <strong>Hooks &gt; render props &gt; Hocs</strong></li>
</ol>
<p>HOC 與 render props</p>
<ul>
<li><strong>HOC</strong> : 一個 function 包住要擁有功能的 Component，並且產生新的加強版 Component。</li>
<li><strong>render props</strong> : 一個 Component 直接將其中一個 props 作為 function，並帶上 props 作為參數給內部使用。</li>
</ul>
<h2 id="補充閱讀">補充閱讀</h2>
<ol>
<li>React 關於 Design Pattern 的歷史補充 : <a href="https://segmentfault.com/a/1190000018811476?utm_source=sf-similar-article">【React深入】从Mixin到HOC再到Hook - SegmentFault 思否</a></li>
<li>一些關於 render props 常見的問題 : <a href="https://kentcdodds.com/blog/answers-to-common-questions-about-render-props#question-1-performance">Answers to common questions about render props</a></li>
</ol>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://github.com/remix-run/react-router/blob/v5.3.3/packages/react-router/modules/withRouter.js#L11">react-router/withRouter.js at v5.3.3 · remix-run/react-router · GitHub</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://gist.github.com/heygrady/f9bf3b6dd93fe3d87ba87430fd3c20d5">Avoiding HOC; Favoring render props · GitHub</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://zh-hant.reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over">Higher-Order Components – React</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://github.com/reduxjs/react-redux/issues/799">Render props version of connect · Issue #799 · reduxjs/react-redux · GitHub</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>Front-end</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | React - Higher Order Component (HOC)</title>
    <url>/2022/07/React/Higher-Order-Component.html</url>
    <content><![CDATA[<blockquote>
<p>文章來自 :</p>
<ol>
<li><a href="https://zh-hant.reactjs.org/docs/higher-order-components.html">Higher-Order Components – React</a></li>
</ol>
</blockquote>
<h2 id="摘要-6">摘要</h2>
<ol>
<li>了解 HOC 的運作原理，以及意義</li>
<li>HOC 的架構與實作</li>
<li>HOC 應用上的注意事項</li>
</ol>
<span id="more"></span>
<h2 id="什麼是-Higher-Order-Component">什麼是 Higher Order Component  ?</h2>
<p>HOC 是一個 function，把另一個元件的邏輯包起來，產生新的 <strong>加強版</strong> 元件， 使元件內部的邏輯可以重複使用。而且不會動到原本 Component 的結構，而是加上 HOC 帶來的功能。</p>
<p>被共用的邏輯是封裝在裡面，大部分第三方 library 都是這麼使用。<br>
例如 : react-redux 裡 <code>connect()</code> 就是一個 HOC。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">NewComponent</span> = <span class="title function_">connect</span>(<span class="title class_">StoreProp</span>,<span class="title class_">StateProps</span>)(<span class="title class_">Component</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>HOC 的重點是減少類似功能元件的 <strong>重複邏輯</strong>，提高元件的重用性 (reusable)。</p>
</blockquote>
<p>舉個實際例子，todolist 具有 toggle 功能，也很多個 button 也有 (切換背景顏色啦等等)，兩者具有 <code>open State</code> 並且 <code>setOpen</code> 只負責切換 true &amp; false 。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 這一段邏輯不斷的重複撰寫，把它提出來 做成 withToggle，把 toggle 功能封裝</span></span><br><span class="line"><span class="keyword">const</span> [open,setOpen] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleToggle</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">	<span class="title function_">setOpen</span>(<span class="function">(<span class="params">prevOpen</span>)=&gt;</span> !prevOpen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>toggle 這個邏輯要被抽成可重複性的邏輯，所以 HOC 可以是一個叫 <code>withtoggle(&lt;Component/&gt;)</code>，又稱具有 toggle 功能, 的 Component。</p>
<h2 id="HOC-的架構">HOC  的架構</h2>
<p>最基本的架構是包裹著另一個 Component，回傳的是一個新的 Component。其他參數可以自訂，也可以傳入想要共同使用 data。</p>
<blockquote>
<p>HOC 是一個 pure function (same input ,same output)，不具有副作用 (side effects)</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">NewComponent</span> = <span class="title function_">higherFunction</span>(<span class="title class_">WrappedComponent</span>);</span><br></pre></td></tr></table></figure>
<p>HOC <strong>不是用繼承的方式</strong> 來產生新的 Component ，而是 <strong>composed</strong> (重組)。<br>
可以看是一個新容器 (Container)。其參數是不限的，另外 HOC 不管資料的來源出處，它只是負責開一個通道，讓被包住的 Component 省去做重複動作。</p>
<p>functional Component</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">EnhancedComponent</span> = (<span class="params">WrappedComponent</span>) =&gt;&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">props</span>)&#123;</span><br><span class="line">		<span class="comment">// 記得把 props 還回去</span></span><br><span class="line">		<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class Component</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">EnhancedComponent</span> = (<span class="params">WrappedComponent</span>) =&gt;&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span>&#123;</span><br><span class="line">		<span class="keyword">return</span>()&#123;</span><br><span class="line">			<span class="comment">// 一樣要把 props 還回去</span></span><br><span class="line">			<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這裡的 <code>&#123;...props&#125;</code> 是 <code>&lt;NewComponent&gt;</code> 傳入的 props。</p>
<p>例 : <code>&lt;WithToggleCompoent index=&quot;1&quot;/&gt;</code> 像是 index 這個 props，在不影響原本 <code>&lt;WrappedComponent/&gt;</code>情況下把 <code>props</code> 都塞回去。如果沒有 <code>&#123;...props&#125;</code> 這步驟，就不會接收到 HOC 包裹的效果。</p>
<h2 id="橫切關注點-Cross-cutting-concern">橫切關注點 (Cross-cutting concern)</h2>
<p>邏輯是透過 HOC 攜帶的，並不是硬生生嵌入在某元件的程式碼中，有助於 <strong>橫切關注點</strong>。</p>
<p>範例情境 :</p>
<ol>
<li>有一 a 元件需要附帶 A 功能，功能 A 被開發，由於目前只有 a 元件需要，直接將邏輯寫死在 a 元件上。</li>
<li>某一天 a 元件需要被更新改成 b 元件，其中 A 功能需要被保留，其餘都不要，這時候需要挖出 A 功能的代碼並進行重構。</li>
<li>那如果某天 b 元件又不要 A 功能呢 ?</li>
</ol>
<blockquote>
<p>導致元件的代碼就會一直被重構😵，是很糟的行為</p>
</blockquote>
<p>橫切關注點的概念使得 A 功能被抽取出來，並採用 <strong>添加</strong> 的方式加到需要的元件身上。邏輯被分開的狀況，如果突然不想要 A 功能隨時都抽取掉，原本的元件也不會被受影響。</p>
<p>HOC 之所以說是加強版的元件，它追加新的功能在原本的元件上，但也不影響原本的元件。</p>
<h2 id="實作練習">實作練習</h2>
<p>codepen 👉 <a href="https://codepen.io/shan473/pen/WNzjdmJ">React - HOC practice</a></p>
<p>凡是有操作開開關關的 Component ，包成 <code>withToggle</code> 的 HOC，把同樣的 <strong>開關邏輯</strong> 抽出來。以 W3school 的 <a href="https://www.w3schools.com/howto/howto_js_sidenav.asp">Navbar</a> 與 <a href="https://www.w3schools.com/howto/howto_js_accordion.asp">Accordion</a> 為例。</p>
<h3 id="HOC-withToggle">HOC withToggle</h3>
<ul>
<li>建立一個 HOC - <code>withToggle</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withToggle</span> = (<span class="params">Component</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [open,setOpen] =<span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">togglehandler</span> = (<span class="params"></span>)=&gt; &#123;<span class="title function_">setOpen</span>(<span class="function"><span class="params">prevOpen</span> =&gt;</span> !prevOpen)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">open</span>=<span class="string">&#123;open&#125;</span> <span class="attr">togglehandler</span>=<span class="string">&#123;togglehandler&#125;</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span> </span><br><span class="line">    )</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 </span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AccordionWithToggle</span> =  <span class="title function_">withToggle</span>(<span class="title class_">Accordion</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NavbarWithToggle</span> = <span class="title function_">withToggle</span>(<span class="title class_">Navbar</span>);</span><br></pre></td></tr></table></figure>
<p>主要傳入的 props 是 <code>open</code> 的 state ，與 <code>togglehandler</code> 這個 method</p>
<h3 id="Accordion">Accordion</h3>
<p>基本的 Accordion (手風琴)，手風琴最重要的就是改變 <code>maxheight</code> 讓內容伸縮。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Accordion</span>(<span class="params">&#123;open,togglehandler,index&#125;</span>)&#123;</span><br><span class="line">	<span class="comment">// 1. 內容的高度資料</span></span><br><span class="line"> <span class="keyword">const</span> [panelheight,setPanelHeight] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment">	 2. 使用 callback ref，透過 ref 拿到 DOM 內容的高度，並根據 開關 open 來決定高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">const</span> panelref = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="function">(<span class="params">node</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(node!==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!open)&#123;</span><br><span class="line">          <span class="title function_">setPanelHeight</span>(node.<span class="property">scrollHeight</span>)</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="title function_">setPanelHeight</span>(<span class="number">0</span>)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,[open])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">  &#123;/* 3. 填入 HOC 傳入的 togglehandler */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;accordion&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;togglehandler&#125;</span>&gt;</span>Section &#123;index+1&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">		&#123;/* 4. 改變 maxHeight */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;panel&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;panelref&#125;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">maxHeight:</span> <span class="attr">panelheight</span>+&#x27;<span class="attr">px</span>&#x27;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Navbar-fullwidth">Navbar fullwidth</h3>
<p>重點是改變 <code>width</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Navbar</span>(<span class="params">&#123;open,togglehandler,type&#125;</span>)&#123;</span><br><span class="line">	<span class="comment">// 1. width 的 state </span></span><br><span class="line">  <span class="keyword">const</span> [width,setWidth] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 監聽 open 的變化</span></span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(open)&#123;</span><br><span class="line">      <span class="title function_">setWidth</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="title function_">setWidth</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,[open])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	   &#123;/* 3. 改變 width */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;sidenav&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">width</span> <span class="attr">:</span> <span class="attr">width</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span> <span class="attr">className</span>=<span class="string">&quot;closebtn&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;togglehandler&#125;</span>&gt;</span><span class="symbol">&amp;times;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Services<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Clients<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 4. 填入 HOC 傳入的 togglehandler */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;togglehandler&#125;</span>&gt;</span>open<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="效果">效果</h3>
<p><img data-src="https://i.imgur.com/6tr37Nj.gif" alt=""><br>
如此一來我們只要幫元件包上 <code>withToggle</code> 都可以擁有開開關關的功能。<br>
看到 w3school 的 Navbar 範例有很多款，我決定再來實作可以依照不同類型產生客製化的 Navbar😎。</p>
<h3 id="再包裝-Navbar-withNavbarType">再包裝 Navbar : withNavbarType</h3>
<p>不同的 type ， width 不一樣。一開始新增 type 的參數來達成效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用 Object bracket notation 的特性，帶字串當索引</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Navtype</span> = &#123;</span><br><span class="line">  <span class="title class_">Full</span> : <span class="string">&#x27;100%&#x27;</span>,</span><br><span class="line">  <span class="title class_">Overlay</span>: <span class="string">&#x27;250px&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">withNavbarType</span> =(<span class="params">CoreComponent,type</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">CoreComponent</span> <span class="attr">type</span>=<span class="string">&#123;Navtype[type]&#125;</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FullNavbar</span> = <span class="title function_">withNavbarType</span>(<span class="title function_">withToggle</span>(<span class="title class_">Navbar</span>,<span class="string">&#x27;Full&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>但又覺得這樣很不優雅😵，想變成 <code>const FullNavbar = customNavbar(type)</code> ，讓每次輸入都只剩一個參數 (柯里化)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Navtype</span> = &#123;</span><br><span class="line">  <span class="title class_">Full</span> : <span class="string">&#x27;100%&#x27;</span>,</span><br><span class="line">  <span class="title class_">Overlay</span>: <span class="string">&#x27;250px&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 讓 type 成為最後一個參數，只要添入對應字串就好</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">withNavbarType</span> =(<span class="params">CoreComponent</span>)=&gt; <span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">CoreComponent</span> <span class="attr">type</span>=<span class="string">&#123;Navtype[type]&#125;</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 把原本的功能加一加，變成 客製化的 Navbar</span></span><br><span class="line"><span class="keyword">const</span> customNavbar = <span class="title function_">withNavbarType</span>(<span class="title function_">withToggle</span>(<span class="title class_">Navbar</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 帶入想要的 style string 就可以產生對應的 Navbar</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FullNavbar</span> = <span class="title function_">customNavbar</span>(<span class="string">&#x27;Full&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OverlayNavbar</span> = <span class="title function_">customNavbar</span>(<span class="string">&#x27;Overlay&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>接著修改 <code>&lt;Navbar/&gt;</code> 的其中一個部份</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(open)&#123;</span><br><span class="line">		<span class="comment">// 改成按照 prop 傳入的 type 改變 width</span></span><br><span class="line">		<span class="title function_">setWidth</span>(type)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">setWidth</span>(<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,[open])</span><br></pre></td></tr></table></figure>
<p>搭啦 ! 就可以擁有不同的客製化 Navbar。<br>
<img data-src="https://i.imgur.com/Hq7kYZg.gif" alt=""><br>
好處是 <strong>不用在原本的 Navbar 元件內判斷 type 是什麼才做不同的 width 變化</strong> ，只要專注在 Navbar 的功能就好。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 我覺得不是很好的 pattern</span></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	<span class="comment">// 😵 如果沒有抽出來，在元件裡面判斷</span></span><br><span class="line">	<span class="keyword">let</span> finallywitdh;</span><br><span class="line">	<span class="keyword">switch</span>(type)&#123;</span><br><span class="line">		 <span class="keyword">case</span> <span class="string">&#x27;Full&#x27;</span>:</span><br><span class="line">			 finallywitdh = <span class="string">&#x27;100%&#x27;</span></span><br><span class="line">			 <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;Overlay&#x27;</span>:</span><br><span class="line">			finallywitdh = <span class="string">&#x27;250px&#x27;</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(open)&#123;	</span><br><span class="line">		<span class="title function_">setWidth</span>(finallywitdh)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">setWidth</span>(<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,[open])</span><br></pre></td></tr></table></figure>
<p>在這個 Navbar 例子中，我使用 HOC 在包裹著另一個 HOC，讓元件可以往上追加想要的資料或功能。</p>
<h2 id="慣例-使用-HOC-傳遞不相關的-props">慣例 : 使用 HOC 傳遞不相關的 props</h2>
<p>慣例是 React 官方建議的操作習慣。<br>
<a href="https://zh-hant.reactjs.org/docs/higher-order-components.html#convention-pass-unrelated-props-through-to-the-wrapped-component">🔗章節連結</a></p>
<p>有些 props 傳進來可能是 <strong>作為運算使用</strong>，傳入的 props 並非全部都要傳進 <code>&lt;WrappedComponent/&gt;</code> 而是經過一些運算後留下 <code>&lt;WrappedComponent/&gt;</code> 需要的。</p>
<p>通常會傳給 <code>&lt;WrappedComponent/&gt;</code> 的 props 通常是 state 或是在 HOC 定義的 method。</p>
<blockquote>
<p>重點在於 <strong>只關注想要的資料</strong>，可以在 HOC 傳入不相關的沒關係，HOC 的 props 傳至 <code>&lt;WrappedComponent/&gt;</code> 之前可以篩選出哪些 props 要繼續傳下去。</p>
</blockquote>
<p>這樣的好處是讓 HOC 更加彈性化。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">	  props 傳進來的不一定跟 WrappedComponent 有直接關係，HOC 是一個容器，將關注於想要的資料傳給 WrappedComponent</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">const</span> &#123; extraProp, ...passThroughProps &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">	  特別提出要被傳入的 props，通常是 state 或是 methods </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">const</span> injectedProp = someStateOrInstanceMethod;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用 props 傳給 WrappedComponent</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">injectedProp</span>=<span class="string">&#123;injectedProp&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &#123;<span class="attr">...passThroughProps</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以官方的例子來說，HOC 包含資料，但是資料在 A 元件中只要 a 部分，B 元件中只要 b 部分，但他們的 <strong>來源都是同一個資料</strong>。</p>
<p>這時候可以透過傳入的 prop 拿出不同的資料，傳進 <code>&lt;WrappedComponent/&gt;</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withData</span> = (<span class="params">Component,data</span>)=&gt;&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="comment">// 1. 不同的 props 抽出來</span></span><br><span class="line">		<span class="keyword">const</span> &#123;dataType,...restprops&#125; = props</span><br><span class="line">		<span class="comment">// 2. 按照 type 再來取出不同的 data</span></span><br><span class="line">		<span class="keyword">const</span> needData = data.<span class="title function_">filter</span>( <span class="function"><span class="params">x</span> =&gt;</span> x === dataType)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">data</span>=<span class="string">&#123;needData&#125;</span> &#123;<span class="attr">...restprops</span>&#125;/&gt;</span></span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一開始我有點看不懂這個例子，想不到應用的例子。原本只知道可以 <strong>加功能</strong>，但沒有想過類似分類篩的概念，經過幾次的實作突然就悟了😂。</p>
<h2 id="慣例-最大化的可組合性-Maximizing-Composability">慣例 : 最大化的可組合性 (Maximizing Composability)</h2>
<p>HOC 的寫法可以只回傳一個參數，也可以回傳好幾個參數。HOC 並沒有特別限制傳遞的參數量，但是那顯得很冗長，盡可能讓 HOC 只接收一個參數。</p>
<p>像 React-redux，使用 <code>connect()()</code> 這樣呈現</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ConnectedComment</span> = <span class="title function_">connect</span>(commentSelector, commentActions)(<span class="title class_">CommentList</span>);</span><br></pre></td></tr></table></figure>
<p>把上面的分開解析 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// connect 是一個 function ，功能是回傳另一個 function</span></span><br><span class="line"><span class="keyword">const</span> enhance = <span class="title function_">connect</span>(commentListSelector, commentListActions);</span><br><span class="line"><span class="comment">// 回傳的是一個 HOC，是跟 Redux store 連結的 Component</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ConnectedComment</span> = <span class="title function_">enhance</span>(<span class="title class_">CommentList</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>簡單來說 : HOC 包住另一個 HOC</p>
</blockquote>
<p>如果 HOC 數量一多，寫起來就會變得很冗長，這時候可以運用 compose (組合) 的概念</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 😵 不應該一層包一層</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">EnhancedComponent</span> = <span class="title function_">withRouter</span>(<span class="title function_">connect</span>(commentSelector)(<span class="title class_">WrappedComponent</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以運用一個 function 將傳入的 HOC 打包成捆，compose 是別處地定義組合 function 的方法</span></span><br><span class="line"><span class="keyword">const</span> enhance = <span class="title function_">compose</span>(</span><br><span class="line">  <span class="comment">// 這邊的 HOC 只接收一個參數</span></span><br><span class="line">  withRouter,</span><br><span class="line">  <span class="title function_">connect</span>(commentSelector)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">EnhancedComponent</span> = <span class="title function_">enhance</span>(<span class="title class_">WrappedComponent</span>)</span><br></pre></td></tr></table></figure>
<p>也有其他的 library 可以幫助把 HOCs 打包成捆，例如 :</p>
<ul>
<li>lodash.flowRight</li>
<li>Redux</li>
<li>Ramda</li>
</ul>
<h2 id="慣例-用-displayName-取名字幫助-Debug">慣例 : 用 displayName 取名字幫助 Debug</h2>
<p>HOCs 是 Container 的概念，如果結構上是使用 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withToggle</span> = (<span class="params">WrappedComponent</span>)=&gt; <span class="function">(<span class="params">props</span>)=&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名的 arrow function，在 Debug 會傻傻搞不清楚。</p>
<p>從實作範例打開 devtool 來看，用 HOC 包過的元件都只顯示 <strong>Anonymous</strong><br>
<img data-src="https://i.imgur.com/V4Uk0fb.png" alt="|200x250"></p>
<p>Navbar 有 <code>Full</code> 跟 <code>Overlay</code> 兩種，但在這邊是看不出來的。主要原因就是上面提到的結構，重點是 <strong>讓內部的 function 擁有名字</strong>，必須獨立出來。可以先把它一步步給解開來</p>
<ul>
<li>在內部取名 :</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withToggle</span> = (<span class="params">WrappedComponent</span>)=&gt; &#123;</span><br><span class="line">	<span class="comment">// 第一種 : 直接寫成 function statements</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">newComponent</span>(<span class="params">props</span>)&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第二種 : 寫成 function expressions</span></span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">newComponent</span> = (<span class="params">props</span>)=&gt;&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 1. 讓被包成 HOC 的元件拿到原本 WrappedComponent 的名稱(例如 : &quot;Navbar&quot;)</span></span><br><span class="line">	newComponent.<span class="property">displayName</span> = <span class="string">`withNavbarType(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class="line">	<span class="keyword">return</span> newComponent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 官方寫法 : 讀取到被包裹的元件原名稱 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDisplayName</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">WrappedComponent</span>.<span class="property">displayName</span> || <span class="title class_">WrappedComponent</span>.<span class="property">name</span> || <span class="string">&#x27;Component&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>外部命名 : 直接替生產出來的 HOC 命名</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一種 : 直接附加屬性</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AccordionwithToggle</span> =  <span class="title function_">withToggle</span>(<span class="title class_">Accordion</span>);</span><br><span class="line"><span class="title class_">AccordionWithToggle</span>.<span class="property">displayName</span> = <span class="string">&quot;withToggleAccordion&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二種 : Object.assign，物件上 + 物件屬性</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AccordionwithToggle</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title function_">withToggle</span>(<span class="title class_">Accordion</span>),&#123;</span><br><span class="line">	<span class="attr">displayName</span>: <span class="string">&#x27;withToggleAccordion&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img data-src="https://i.imgur.com/e3103Wo.png" alt="|250x250"><br>
<code>withToggle</code> 我沒有在內部命名，而是在 <code>Accordion</code> HOC 上命名，所以自然在 <code>Navbar</code> withToggle 會看到匿名。</p>
<p>displayName 這個屬性是 React 提供我們替 Component 取不同的名稱時，在 devtools 上觀察，方便 Debug。<br>
如果有使用 Context API ，其實也是同個概念，Context 中的 Provider 可以放在 APP 以下的樹狀位置，也可能出現複數個，這時候可以替 Context 命名方便查看。</p>
<p>在內部取名就是讓 function 露出名字，雖然 <code>function expressions</code> 對於內部是匿名的，但我們只在乎最外部 function 的名稱。</p>
<p>另外像上面寫的 <code>withNavbarType()</code> 這樣包裹起來，括號以外的會在外部 (圖中灰色方塊區)，類似 Component 的附加訊息，但被括號包裹住的最裡面才是顯示元件的 displayName。</p>
<h2 id="注意-不要直接修改到原本的-Component">注意 : 不要直接修改到原本的 Component</h2>
<ul>
<li>
<p>假如我們要操作有關元件的生命週期，不應該直接修改元件的 prototype</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 壞透了</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logProps</span>(<span class="params">InputComponent</span>) &#123;</span><br><span class="line">  <span class="title class_">InputComponent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">componentDidUpdate</span> = <span class="keyword">function</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Current props: &#x27;</span>, <span class="variable language_">this</span>.<span class="property">props</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Previous props: &#x27;</span>, prevProps);</span><br><span class="line">  &#125;;</span><br><span class="line">	<span class="comment">// InputComponent 本身已經被改變</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">InputComponent</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EnhancedComponent will log whenever props are received</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">EnhancedComponent</span> = <span class="title function_">logProps</span>(<span class="title class_">InputComponent</span>);</span><br></pre></td></tr></table></figure>
<p>導致所有傳進來的 Component  被改變，<code>componentDidUpdate</code> 這個方法都被 修改/覆寫 了，HOC 不能被重複使用，因為 function component 並沒有生命週期的方法。</p>
</li>
<li>
<p>利用 composition 的概念</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ composition</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logProps</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">	<span class="comment">// 用新的 Component 包裹傳入的 Component，不去影響到原本的 Component</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Current props: &#x27;</span>, <span class="variable language_">this</span>.<span class="property">props</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Previous props: &#x27;</span>, prevProps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="注意-不要在-render-function-使用-HOC">注意 : 不要在 render function 使用 HOC</h2>
<p>function 是 Object 的一種，每次 re-render 都是新的 function (object)，造成效能上的浪費。所以要在外部產生 HOC 再帶入新的 Component 中。</p>
<blockquote>
<p>簡單來說 : <strong>{ } !== { }</strong>，要避免這種情況發生</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 這是 ok 的，AccordionwithToggle 不會因為 App re-render 而改變</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AccordionwithToggle</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title function_">withToggle</span>(<span class="title class_">Accordion</span>))</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">AccordionwithToggle</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123; setCount(count+1) &#125;&#125;&gt;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 每次 App re-render 都是重新呼叫 function,產生新的 Accordion，React 會將全部替換，因為跟上一次的 Accordion 不一樣。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="comment">// 每次都是新的</span></span><br><span class="line">	<span class="keyword">const</span> <span class="title class_">AccordionwithToggle</span> = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="title function_">withToggle</span>(<span class="title class_">Accordion</span>),[])</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">AccordionwithToggle</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123; setCount(count+1) &#125;&#125;&gt;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>codepen 中預設的引入的 React script 是 production mode，是不能使用 React 的 profiler… 的。<br>
要麼改成 development，在 html 添加這兩行，並且把編輯器的 <code>External Scripts/Pens</code> 取消。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@18/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@18/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>in render<br>
<img data-src="https://i.imgur.com/GgF9oDS.gif" alt="|600x350"></li>
<li>outside<br>
<img data-src="https://i.imgur.com/j4Uec3j.gif" alt="|600x350"></li>
</ul>
<p>以肉眼來看，當 App 的 state 改變，進行 re-render，如果是在 render 產生的 <code>&lt;Accordion/&gt;</code>會閃一下，因為對 App 來說 <code>&lt;Accordion/&gt;</code> 是新物件，等同於產生新的 DOM 節點 並且 repaint 。放在外部的話，就沒有這個問題。</p>
<h2 id="注意-refs-並不會被傳遞">注意 : refs 並不會被傳遞</h2>
<p><strong>refs</strong> 不是 props 的一種，就像 <code>key</code>，是由 React 來控制的。就像你不能在子元件中拿到 <code>❌props.key</code>。如果在 HOC 使用 ref，接收到 ref 的不會是 WrappedComponent，而是 HOC 本身。</p>
<p>要使 WrappedComponent 能夠接收 ref ，必須使用 <code>React.forwardRef</code><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。</p>
<p><code>React.forwardRef</code> 包住的 Component 可以接收 <strong>ref</strong> (這裡的 ref 是 forwardRef 刻意為之)。</p>
<ul>
<li><code>withtoggle</code> 為例，改成 <strong>withToggle2</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withToggle2</span> = (<span class="params">Component</span>) =&gt; &#123;</span><br><span class="line">	<span class="comment">/* 接住上層傳下來的 ref */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [open, setOpen] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">togglehandler</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="title function_">setOpen</span>(<span class="function">(<span class="params">prevOpen</span>) =&gt;</span> !prevOpen);</span><br><span class="line">    &#125;;</span><br><span class="line">	    <span class="comment">/* 😵 Wrapped Component 不能使用 ref 這個字眼接 ref ，要取別名接 */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">open</span>=<span class="string">&#123;open&#125;</span> <span class="attr">togglehandler</span>=<span class="string">&#123;togglehandler&#125;</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardRef</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App 產生新的 ref</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">SpecialRef</span> = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 使用 ref 直接傳 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">AccordionwithToggle2</span> <span class="attr">index</span>=<span class="string">&quot;special&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;SpecialRef&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Wrapped Component 從 prop 接收 ref </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Accordion</span>(<span class="params">&#123; open, togglehandler, index,forwardRef &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(forwardRef) <span class="comment">// 結果 hello</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">	  <span class="comment">//...略</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，只有在產生 Ref 的同一層可以直接使用 ref ，例如 :</p>
<ul>
<li>App 在這裡 <code>createref / useRef</code> 👉  <code>&lt;AccordionwithToggle2 ref=&#123;✅&#125; /&gt;</code></li>
<li>HOC 裡面的 <code>&lt;WrappedComponent/&gt;</code> 不能使用 ref 傳，要取別名。 HOC 👉<code>&lt;WrappedComponent ref=&#123;❌&#125; forwardref=&#123;✅&#125; /&gt;</code></li>
</ul>
<h2 id="總結-28">總結</h2>
<p>關於 HOC 的特點</p>
<ol>
<li>是一個 Design Pattern ，可以提高 Component 重複性</li>
<li>是一個 function ，包裹另一個 Component，回傳新的 Component，又稱 <strong>加強版 Component</strong>，並且不會影響到包住的 Component 。</li>
</ol>
<p>HOC 最常比較的還有 render props 這個 Pattern，差別可以參考</p>
<ul>
<li><a href="https://medium.com/frochu/hoc-%E8%88%87renderprops-%E8%AB%87%E6%88%91%E5%BE%9E%E5%A5%B9%E5%80%91%E8%BA%AB%E4%B8%8A%E5%AD%B8%E5%88%B0%E4%BB%80%E9%BA%BC-2681ab4cc453">HOC 與Render Props，談我從她們身上學到什麼. 前言 | by Wendell Liu | Frochu | Medium</a></li>
<li><a href="https://gist.github.com/heygrady/f9bf3b6dd93fe3d87ba87430fd3c20d5">Avoiding HOC; Favoring render props · GitHub</a></li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">補充 HOC 的 ref 問題 : <a href="https://zh-hant.reactjs.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components">傳送 Ref – React</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>Front-end</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | React - ref 與 callback ref</title>
    <url>/2022/08/React/ref-and-callback-ref.html</url>
    <content><![CDATA[<blockquote>
<p>文章來自 :</p>
<ol>
<li><a href="https://zh-hant.reactjs.org/docs/refs-and-the-dom.html">Refs 和 DOM – React</a></li>
<li><a href="https://medium.com/hannah-lin/react-hook-%E7%AD%86%E8%A8%98-useref-c628cbf0d7fb">React Hook 筆記 useRef. useRef 神奇的地方除了可以在不 re-render… </a></li>
<li><a href="https://www.linkedin.com/pulse/imperative-vs-declarative-programming-javascript-yehuda-margolis">Imperative vs Declarative Programming in JavaScript</a></li>
</ol>
</blockquote>
<h2 id="摘要-7">摘要</h2>
<ol>
<li>什麼是 ref ?</li>
<li>ref 使用的時機</li>
<li>ref 的另一種型態 callback ref</li>
</ol>
<span id="more"></span>
<h2 id="什麼是-ref">什麼是 ref ?</h2>
<p>ref 提供 React 資料流以外的操作方式，讓我們可以改變 React Component 的 instance (實例)，或者它來來操作 DOM 元素。</p>
<p>ref 可看作是一個普通的 JavaScript 物件，內部具有 current 的屬性的東西，可以直接 (mutable) 改變它。 React 保證它在生命週期 (render) 循環中永遠都指向同一個位址。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = &#123;current : ... &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="不過度使用-ref">不過度使用 ref</h2>
<p>使用 ref 的第一直覺上，我們可能會想說 ref <strong>要在哪裡發生</strong> ( 像是 state 會放到需要用到的元件內)，ref 不單單是拿來存放不會影響 re-render 的值，不應該被過度使用操作有關 React 資料流的部分。這時候應該使用 state，並且考慮 <strong>哪個 component 應該擁有狀態</strong>，如果是要共同擁有的 state 要做的是 <em>提升 state</em>。</p>
<h2 id="使用-ref-的時機">使用 ref 的時機</h2>
<ol>
<li>focus、選擇文字或影音媒體播放等等</li>
<li>觸發即時的動畫</li>
<li>與第三方 DOM 函式整合</li>
</ol>
<blockquote>
<p>如果操作可以用宣告式 (declarative) 操作，避免使用 ref</p>
</blockquote>
<p>例如 : 對話視窗我們可以不用暴露 <code>open()</code> 或 <code>close()</code> 方法 ，而是使用 <code>isOpen</code> 作為 props 來操作。 我們不用告訴某元件要怎麼做 (HOW) ，而告訴其結果 (WHAT) 就好。</p>
<h2 id="補充-Declarative-v-s-Imperative-in-JavaScript">補充 : Declarative v.s Imperative in JavaScript</h2>
<h3 id="Declarative-宣告式">Declarative 宣告式</h3>
<p>著重於 WHAT (想要拿到的結果是什麼)，比較抽象的流程，多使用表達式 (expression)，特色是單純運算且具有回傳值。像是 functional programming。</p>
<p><strong>特色 :</strong></p>
<ul>
<li>Stateless : 專注內部算式，並不會直接改變原本傳入的值，單純輸入與輸出。</li>
<li>無副作用 (side effect)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函式表達相乘</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiple</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr.<span class="property">length</span>===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="comment">// 回傳相乘後的結果，其 state 又被塞進內部回傳新的結果</span></span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x*<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiple</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure>
<p>將其 function 名稱代表回傳的意義會使程式碼比較了解，也可以說 <strong>定義 OO 是什麼</strong>。</p>
<h3 id="Imperative-命令式">Imperative 命令式</h3>
<p>著重於 HOW (目標到底要怎麼做)，具體表示應該怎麼做來達到目標，一步步按照步驟，常使用 statement 流程控制 (if , while , for , switch) 等。像是 OOP。</p>
<p><strong>特色 :</strong></p>
<ul>
<li>Stateful :  state 是互相有關連性的。</li>
<li>常會有副作用 side effect 發生</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">multiple</span> = array =&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(array.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;array.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    result.<span class="title function_">push</span>(array[i]*<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiple</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure>
<h3 id="小結-8">小結</h3>
<p>從例子來看，兩種方式都能達到結果，在 Imperative 中可以很清楚看見 state 是 “如何變化” 的，經過一步步的流程控制得出結果；在 Declarative 中資料的變化都被藏到內部另一個函式中 (邏輯被抽象化)，我們看到的是 “結果”。</p>
<p>JavaScript 使我們可以用兩種方式來實作，其各有優缺 :<br>
<strong>Imperative :</strong></p>
<ul>
<li>優點 :
<ol>
<li>語法對於開發人員比較好掌握。</li>
<li>在流程控制上都是在同一個區塊操作，包含停止或暫停 loop 都可以根據想要的操作。</li>
<li>在某些情況下，效能會比較好。</li>
</ol>
</li>
<li>缺點 :
<ol>
<li>程式碼通常較冗長，原因是邏輯都寫在同一塊</li>
<li>比較難以閱讀</li>
</ol>
</li>
</ul>
<p><strong>Declarative :</strong></p>
<ul>
<li>優點 :
<ol>
<li>程式碼通常都很短，而且整潔、易讀</li>
<li>很適合用在 JavaScript 一些框架上，像是 React 與狀態管理的 redux</li>
</ol>
</li>
<li>缺點 :
<ol>
<li>運行的比較慢一點，但在小型的應用程式不是太明顯。</li>
</ol>
</li>
</ul>
<h2 id="建立-ref">建立 ref</h2>
<p>在 class component 可以在建立 (constructor)  時新建 ref，可以是代表屬於某個 instance 的屬性，或者透過屬性 (attribute) 依附在 React element，在整個 component 裡面被參考。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="comment">// 1. 用 createRef() 建立</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 2. 使其用 attr 依附在 node 上，透過 this.myRef 就可以操作 DOM 元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 function component 用 Hooks 可以直接在內部建立 ref</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = <span class="title function_">useRef</span>(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// ref = &#123; current : 0&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>useRef</code> 比一般的 ref 更有用，它可以很方便地持有任何 mutable 的值 (<code>useRef</code> 可以是任何的值)，跟 class 中的 instance field 類似。</p>
<p>除非做延遲初始化<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，避免在 render 時設定 ref ，造成非預期的行為，所以我們應該 <strong>在 event handler 和 effect 中修改 ref</strong>。</p>
<h2 id="存取-ref">存取 ref</h2>
<p>Ref 的值會根據節點的類型而有所不同：</p>
<ol>
<li>建立的 ref 用在 html 元素上的屬性，等同於取得 DOM 元素本身作為 current 屬性。</li>
<li>客製化的 class component 使用 ref 時，ref 等同於此 component mount 之後的實例(instance) 當作 current。 (簡單來說 ref 可以直接傳給 class component 中的子元件，但 functional component 不行)</li>
<li>不能在 functional component 上使用 ref，因為他們沒有實例 (instance)。</li>
</ol>
<h3 id="在-DOM-Element-加上-Ref">在 DOM Element 加上 Ref</h3>
<p>在 DOM Element 加上 ref，利用 ref 來儲存對於 DOM 節點的參考：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomTextInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="comment">// 產生一個可以儲存 textInput DOM element 的 ref</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">focusTextInput</span> = <span class="variable language_">this</span>.<span class="property">focusTextInput</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// focus 方法，直接對 DOM 元素操作</span></span><br><span class="line">  <span class="title function_">focusTextInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span>.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &#123;/* <span class="attr">在</span> <span class="attr">mount</span> <span class="attr">的時候將</span> <span class="attr">DOM</span> <span class="attr">element</span> <span class="attr">賦值到</span> <span class="attr">current</span> <span class="attr">屬性</span>*/&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&#123;this.textInput&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&quot;Focus the text input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onClick</span>=<span class="string">&#123;this.focusTextInput&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 會在 component mount 的時候將 DOM element 賦值到 current 屬性，並在 unmount 時將它清空回 null 。 ref 的更新發生在生命週期 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 之前。</p>
<h3 id="在-Class-Component-加上-Ref">在 Class Component 加上 Ref</h3>
<p>如果我們想在父元件 mount 之後，自動做 <code>focus</code> 這件事，可以透過父元件的 ref 拿到 <code>textInput</code> 實例本身 (也可以直接使用內部的方法)，並在 <code>componentDidMount</code> 呼叫。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoFocusTextInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在元件 mount 之後自動做這件事 </span></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// focusTextInput() 是來自 CustomTextInput 本身 </span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span>.<span class="property">current</span>.<span class="title function_">focusTextInput</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">CustomTextInput</span> <span class="attr">ref</span>=<span class="string">&#123;this.textInput&#125;</span> /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意這 <strong>只適用於利用 class 來宣告</strong> <code>CustomTextInput</code> 的情形：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomTextInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Ref-和-Function-Component">Ref 和 Function Component</h3>
<p>不能用 function component 使用 ref ，因為本身沒有 instance ，不能像 class component 直接將 ref 傳給 child component。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 沒有這東西 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Input</span>(<span class="params">&#123;ref&#125;</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* ❌不行， Input 沒有 instance，不能接收 ref */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要不就在 child component 直接使用 <code>useRef</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Input</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// ✅ 這樣可以</span></span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在父元件真的想將 ref 交遞給其他 function component ，React 會建議使用 <strong>傳送 ref</strong> (<code>forwardRef</code>) 的方式，<strong>傳送 Ref 使得 component 能夠選擇要不要把 child component 的 ref 當作自己的 ref</strong> 。不過這樣的方法不太建議，因為會破壞 component 的封裝。但有時候觸發 focus 或測量 child 的 DOM 節點的大小、位置是很有用的。</p>
<h2 id="實務上的-ref">實務上的 ref</h2>
<ol>
<li>計算 render 次數 (少)</li>
<li><strong>用 Imperatively 方法改變 DOM 跟 Child Component (最常)</strong></li>
<li>想抓 Previous 的值 (少)</li>
</ol>
<h3 id="計算-render-次數">計算 render 次數</h3>
<p>如果用 state 來計算，這個例子會導致無窮迴圈， <code>setState</code> 導致 re-render ，做 <code>setRenderCount</code> 又一而再地觸發，沒完沒了。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [renderCount,setRenderCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次 render 就 ++</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">setRenderCount</span>(<span class="function"><span class="params">r</span> =&gt;</span> r+<span class="number">1</span>) </span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;count&#125;</span></span><br><span class="line"><span class="language-xml">      render : &#123;renderCount&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這時候很適合使用 <code>useRef</code> ，因為它不會觸發 re-render。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [count,setCount] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> countRef = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次 render 就 ++</span></span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    countRef.<span class="property">current</span> +=<span class="number">1</span> </span><br><span class="line">  &#125;,[count])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;count&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setCount(count+1)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      render : &#123;countRef.current&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用-Imperatively-方法改變-DOM-跟-Child-Component">用 Imperatively 方法改變 DOM 跟 Child Component</h3>
<p>Imperative 的意思在 <a href="https://blog.rosa.tw/2022/08/React/ref-and-callback-ref#%E8%A3%9C%E5%85%85-Declarative-v-s-Imperative-in-JavaScript">補充 Declarative v s Imperative in JavaScript</a> 章節解釋過。如果使用<br>
state 的思路來看，會利用 focus state 來控制元件的狀態，基於好奇，我也就實作了 state 版本。</p>
<h4 id="實作-使用-state-來控制-autofocus">實作 : 使用 state 來控制 autofocus</h4>
<p>利用 key 的特性，讓 React 換掉節點，為什麼用 key 後面會解釋</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [autoFocus, setAutoFocus] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">key</span>=<span class="string">&#123;Number(autoFocus)&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autoFocus</span>=<span class="string">&#123;autoFocus&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setAutoFocus((f) =&gt; !f)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        關注</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 render 之後自動 Focus 也可以使用 <code>useEffect</code> 再多做一次的 render</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">setAutoFocus</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure>
<p>還記得 key 是拿來判斷 DOM 節點是否替換的一種指標嗎 ? 我們最常使用在 array 上，但其實也可以單獨拿出來使用，尤其對於大區塊的更動。</p>
<p>這部分時原本採取這樣的寫法，結果發現雖然 state 有改變，但是 <code>input</code> 沒有被 focus :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> autoFocus=&#123;autoFocus&#125; /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setAutoFocus((f) =&gt; !f)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">  關注</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>阿 ! 結果忘了 React 怎麼去渲染這件基本的事，記得嗎😵它會做淺比較，既然 input 節點沒有改變，它只會修改屬性。在來說說 <code>autofocus</code> ，它的觸發點是在 DOM 節點被放在上面之後才會做 <code>focus()</code>，那上面這段我們確實可以把 <code>autoFoucs</code> 透過 state 變化添加上去，但是 input 本身是沒有重新建立這件事，因為 React 淺比較自動幫我們做渲染上的優化，所以我透過 key 幫直接重新產生 input 。</p>
<p>原本是透過替換不同的 html tag，實作 <code>autoFocus</code> 成功，但這不是正確的答案，又突然想到 key 的作用，結果就出來了。</p>
<h4 id="使用-ref">使用 ref</h4>
<p>回到 ref ，建立 ref 綁在 DOM element 上，使我們可以直接操作 DOM，比上面的簡單多了。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    inputRef.<span class="property">current</span>.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;,[])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣的方式在表單很常使用，在 React 中分成 controlled component 和 uncontrolled component， 前者依賴 state 來操作，後者是透過 ref 直接讀取 DOM。</p>
<blockquote>
<p>ref 並不會出現在 <code>devtool</code> 的檢查視窗上，實際看到的只會是  <code>&lt;input type=&quot;text&quot;/&gt;</code></p>
</blockquote>
<h3 id="抓-Previous-的值">抓 Previous 的值</h3>
<p>function component 因為 closure 的關係，只會記住當次 render 的 state 或 props 甚至是任何東西，我們沒辦法拿到上一次 render 的值。而透過 ref  來建立不會隨 render 而改變的盒子，讓我們可以在下一次 effect 呼叫之前先記住上一次的值。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [value,setValue] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">const</span> prevValue =<span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    prevValue.<span class="property">current</span> = value</span><br><span class="line">  &#125;,[value])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span>=&gt;</span> setValue(e.target.value)&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>previous: &#123;prevValue.current&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>實際跟著跑一次 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次 render</span></span><br><span class="line">  value = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">// JSX(UI顯示)</span></span><br><span class="line">  input value =<span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">previous</span>:</span><br><span class="line"><span class="comment">// effect 執行</span></span><br><span class="line">  prevValue.<span class="property">current</span> = value = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用者輸入 &quot;1&quot; re-render</span></span><br><span class="line">  value = <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="comment">// JSX(UI顯示)</span></span><br><span class="line">  input value =<span class="string">&quot;1&quot;</span></span><br><span class="line">  <span class="attr">previous</span>:</span><br><span class="line"><span class="comment">// effect 執行，但是改變 ref 並不會造成 re-render，此時沒有更新停留在 previous:</span></span><br><span class="line">  prevValue.<span class="property">current</span> = value = <span class="string">&quot;1&quot;</span> </span><br></pre></td></tr></table></figure>
<p>實際上 <code>prevValue.current</code> 等於 <code>value</code>，但是 render 是停留在第二次，並沒有刷新 UI，因此在畫面上看起來 <code>prevValue</code> 停留在前一次的 render，使我們可以拿到 previous 值。<br>
<img data-src="https://i.imgur.com/H2K46gT.png" alt="300x180"></p>
<h2 id="callback-ref">callback ref</h2>
<p>ref 還有另一種形式，不是將 <code>createRef()</code> 所產生的 ref 傳遞下去，而是把一個 function 往下傳 (function 也是一種 Object)。 function 會將 React component 的實例 (instance) 或 HTML DOM 作為它的參數，儲存之後在別的地方使用。</p>
<ul>
<li>class component</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomTextInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="comment">// 1. 儲存 callback ref 取得的 node 或 instance 的空間</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 2. 參數是 html DOM 或是 component 實例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setTextInputRef</span> = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">textInput</span> = element;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">focusTextInput</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 利用原生的 DOM API 來 focus 文字輸入</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">textInput</span>) <span class="variable language_">this</span>.<span class="property">textInput</span>.<span class="title function_">focus</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在 mount 的時候自動 focus 輸入</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">focusTextInput</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &#123;/* <span class="attr">ref</span> <span class="attr">儲存參考</span> */&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&#123;this.setTextInputRef&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">value</span>=<span class="string">&quot;Focus the text input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onClick</span>=<span class="string">&#123;this.focusTextInput&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 會在 component render 時用 DOM element 呼叫 ref callback，然後在 unmount 時用 null 呼叫它。</p>
<blockquote>
<p>Ref 被保證在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 觸發時能夠維持在最新的狀態。</p>
</blockquote>
<h3 id="有-ref-effect-為什麼還需要-callback-ref">有 ref + effect 為什麼還需要 callback ref</h3>
<p>ref 建立/更新的時間點是在 render 階段，且在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 觸發時能夠維持在最新的狀態 (在裡面獲取 state 是最新的)，換成 Hooks 是 <code>setState</code> 當下能拿到最新值，並且在 effect 執行之前發生。這避免在還沒獲取到 DOM 元素之前拿到 null 來操作。以往我們直接在 html tag 加上 ref 在 effect 操作 ref 時就已經拿到 <code>ref.current</code> 存取的 DOM 元素本身。</p>
<p>到這裡好像都沒問題，但如果是 <strong>子元件的條件式渲染</strong> 呢 ? 在子元件巢狀結構中，父元件並不知道子元件的巢狀元件是否存在 (或是存在於第一次 render )，導致 render 之後在父元件的 ref 不知道有沒有抓到就執行 effect，而導致錯誤。</p>
<blockquote>
<p>範例來自 : <a href="https://tkdodo.eu/blog/avoiding-use-effect-with-callback-refs#focus-with-an-effect">Avoiding useEffect with callback refs | TkDodo’s blog</a></p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 🚨 ref.current 永遠是 null，這行會報錯 </span></span><br><span class="line">    ref.<span class="property">current</span>?.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;, [])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Form</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [show, setShow] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(true)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        show</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      /* </span></span><br><span class="line"><span class="language-xml">      ref 附加在 input 上。</span></span><br><span class="line"><span class="language-xml">      但這是條件是渲染，ref.current 在 show = false 並沒有抓到 input DOM</span></span><br><span class="line"><span class="language-xml">      */</span></span><br><span class="line"><span class="language-xml">      &#123;show &amp;&amp; <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我後來在想這個例子好不好🤔，其實提升 state 就可以解決問題了。但想一想我搞錯了😵，目的是 <strong>Form 本身去判斷 input 出現就 autofocus</strong>，應該把功能跟 Form 綁在一起，並非透過外部的元件來控制，這樣會使 APP 跟著 re-render ，是不必要的，所以應該是 Form 元件本身 state 改變， input 執行 <code>onfocus</code>。</p>
<p>補 : 後來我又想了想，應該是指 ref 傳下去不知道是不是有抓到該值，由於 ref 是可以直接改變的，如果在 render 期間改變，會造成結果不同🤔。</p>
<p>第二次嘗試，直覺上我們會在 Form 元件用 state 透過 effect 來操作，這也是可以的 :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// ❌ 不需要 effect 了</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Form</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [show, setShow] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用 effect 來補這個問題</span></span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(show)&#123;</span><br><span class="line">      ref.<span class="property">current</span>?.<span class="title function_">focus</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,[show]) <span class="comment">// 當按下按鈕就顯示，執行 focus</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(true)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        show</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;show &amp;&amp; <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>恩…雖然這可以解決問題，但 effect 其實不必這樣檢查 show ，何況 button 只觸發一次的 <code>setShow</code>🤔，難道不能讓它產生的時候自己  focus 嗎 ? 當 input <code>mount</code> 就自己 focus 。</p>
<p>另一個著手點就是把 <code>autoFocus</code> 裝上去， input 做 <code>mount</code> 又 <code>unmout</code> 對 React 來說都是新的節點誕生 :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;show &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">autoFocus</span>/&gt;</span></span>&#125;</span><br></pre></td></tr></table></figure>
<p>不過衍生問題就在 <a href="https://blog.rosa.tw/2022/08/React/ref-and-callback-ref#%E8%A3%9C%E5%85%85-Declarative-v-s-Imperative-in-JavaScript">實作 使用 state 來控制 autofocus</a><br>
的部分有討論過，如果在 input 是 “已出現” 的狀況下透過按鈕來控制 <code>autoFocus</code> ，由於 React 的淺比較優化導致元件僅修改屬性，而  <code>autoFocus</code> 只會在元件 mount 執行。</p>
<p>最後一個解決的問題就是靠 <strong>callback ref</strong> 自己去判斷 Element node 是否存在去執行邏輯 :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Form</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Form</span> = (<span class="params">props</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> [show, setShow] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(true)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        show</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;show &amp;&amp; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          // <span class="attr">ref</span> <span class="attr">接收的是一個</span> <span class="attr">function</span>，<span class="attr">參數會是</span> <span class="attr">DOM</span> <span class="attr">節點本身</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&#123;(node)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            if (node) &#123;</span></span><br><span class="line"><span class="language-xml">              node.focus();</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>檢查 node 是否存在再呼叫，因為 ref 是在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 拿到最新值，簡單來說就是 render 階段執行，在我們 <code>setShow</code> 改變 show 為 true 進到 render 階段，如果沒有加上判斷，會導致 <code>unmout</code> 時執行錯誤。</p>
<p>如果我們不判斷 node 是否存在，執行順序上是這樣 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次 render</span></span><br><span class="line"><span class="keyword">const</span> show = <span class="literal">false</span></span><br><span class="line">input callback ref 不會執行</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用者按下按鈕觸發 setShow re-render</span></span><br><span class="line"><span class="keyword">const</span> show = <span class="literal">true</span></span><br><span class="line"><span class="comment">// input ref function 執行， function(node) 參數是該 DOM 元素</span></span><br><span class="line">node.<span class="title function_">focus</span>() <span class="comment">// ✅ 執行成功，node 不是 null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再按一次按鈕 setShow re-render </span></span><br><span class="line"><span class="keyword">const</span> show = <span class="literal">false</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  input unmout，ref function 執行，ref 回到 null 代表節點消失，元素消失了 node = null </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">node.<span class="title function_">focus</span>() <span class="comment">//😵 執行失敗</span></span><br></pre></td></tr></table></figure>
<p>callback ref 會在 component  <code>mount</code> 跟 <code>unmout</code> 都各執行一次，但 <code>unmount</code> 那次就不會抓到參數本身，因為 ref 回傳的是 null。</p>
<p>寫成 inline 的方式就會使元件 re-render 也跟著重新建立 function，可以用 <code>useCallback</code> 把 function 記起來，避免不必要的 render :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Form</span> = (<span class="params">props</span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> [show, setShow] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// 1. 建立 function</span></span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="function">(<span class="params">node</span>)=&gt;</span>&#123;</span><br><span class="line">    node?.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;,[])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(true)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        show</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;show &amp;&amp; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          // <span class="attr">2.</span> <span class="attr">填入</span> <span class="attr">function</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="callback-ref-的使用時機">callback ref 的使用時機</h2>
<ol>
<li>節點會消失又出現，需要動態的控制元件本身</li>
<li>測量 DOM 的位置、大小</li>
</ol>
<p>callback ref 提供動態的方式讓我們取得 DOM 節點，並且在 browser painting 之前可以做一些事。從上面 <code>autofocus</code> 可以讓元件建立又做 DOM 的 <code>focus()</code>。</p>
<h3 id="小實作">小實作</h3>
<p>Accordion 的內容會按照 <code>open</code> 開關影響高度，我們只要在 <code>open</code> 觸發 re-render 時，一併把樣式改變就可以輕鬆做到功能。<br>
👉<a href="https://codepen.io/shan473/pen/MWVxzPX">Collapsibles/Accordion React callback ref</a></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Accordion</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 開關控制</span></span><br><span class="line">  <span class="keyword">const</span> [open,setOpen] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="comment">// 2. callback ref node 存在且 open = true</span></span><br><span class="line">  <span class="keyword">const</span> panelRef = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="function">(<span class="params">node</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(node &amp;&amp; open)&#123;</span><br><span class="line">        node.<span class="property">style</span>.<span class="property">maxHeight</span> =node.<span class="property">scrollHeight</span> +<span class="string">&#x27;px&#x27;</span></span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node &amp;&amp; !open)&#123;</span><br><span class="line">        node.<span class="property">style</span>.<span class="property">maxHeight</span> =<span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,[open])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;accordion&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setOpen(open =&gt; !open)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Section</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">className</span>=<span class="string">&quot;panel&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">ref</span>=<span class="string">&#123;panelRef&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do</span></span><br><span class="line"><span class="language-xml">          eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad</span></span><br><span class="line"><span class="language-xml">          minim veniam, quis nostrud exercitation ullamco laboris nisi ut</span></span><br><span class="line"><span class="language-xml">          aliquip ex ea commodo consequat.</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>當然這樣的方式也可以使用 <code>useRef</code> 搭配 <code>useEffect</code> 來實作 :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> panelRef = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"> panelRef.<span class="property">current</span>.<span class="property">style</span>.<span class="property">maxHeight</span>= open ? panelRef.<span class="property">current</span>.<span class="property">scrollHeight</span> +<span class="string">&#x27;px&#x27;</span> : <span class="number">0</span></span><br><span class="line">&#125;,[open])</span><br></pre></td></tr></table></figure>
<p>目前還想不到實際上的差異，但論時間點來說，useEffect 會在 render 之後才執行，很可能畫面會造成一瞬間的閃爍，這時候我們可能會用 <code>useLayoutEffect</code> 來處理，在 painting 之前就執行結束，像是樣式的更新，這不會讓使用者看到畫面突然閃一下變化。</p>
<p>通常 ref + <code>useEffect</code> 都可以做到 callback ref 做到的事。但  <code>useEffect</code> 具有 clean up function，假如元件具有監聽事件且 <code>unmount</code> 時，需要做清除的動作 (clean up function)，effect 使時我們拿到的 <code>ref.current</code> 依舊是上一次 render ，對 <code>ref.current</code> 取消監聽事件是可以的，但是 callback ref 在 unmount 時會把 node 回歸到 null，不能對 null 取消監聽事件。</p>
<h3 id="注意-3">注意</h3>
<p>如果 callback ref  是被 inline function 所定義的，會在更新的時候被呼叫兩次。render 一次，mount 一次。第一次用 null 然後再用 DOM element 呼叫一次。這是因為新的 function 的 instance 是在每次 render 的時候被產生，所以 React 需要將舊的 ref 清掉然後設定新的。</p>
<p>可以定義 callback ref 為 class 上的一個 bound method (<code>method.bind</code>) 來避免這種情形，但在大多情況下他並沒有任何影響。</p>
<blockquote>
<p>簡單來說 function 不要隨 render 每次都產生新的，將其給記住。</p>
</blockquote>
<h2 id="ref-、-effect-與-layouteffect">ref 、 effect 與 layouteffect</h2>
<p>👉 <a href="https://codepen.io/shan473/pen/BarbEWJ?editors=0011">Box moving / multiple ref test with show null</a> 我試做 <code>ref + useEffect</code> 、 <code>ref + uselayoutEffect</code>  ，來看看這三者的時間點。</p>
<p>根據範例印出 <code>render</code> 、<code>mount</code>  以及 <code>unmout</code> 時間 :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// render</span></span><br><span class="line">callback ref call <span class="literal">undefined</span> (不管有沒有 node)</span><br><span class="line">callback ref call <span class="literal">null</span> node <span class="literal">undefined</span></span><br><span class="line">callback ref render <span class="literal">undefined</span></span><br><span class="line">render effect <span class="literal">null</span></span><br><span class="line">render layout <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mount </span></span><br><span class="line">callback ref call (不管有沒有 node)</span><br><span class="line">  &lt;div <span class="keyword">class</span>=​<span class="string">&quot;box one&quot;</span> style=​<span class="string">&quot;top:​ 100px;​&quot;</span>&gt;​callback ref​&lt;/div&gt;​</span><br><span class="line">callback ref call <span class="keyword">in</span> node </span><br><span class="line">  &lt;div <span class="keyword">class</span>=​<span class="string">&quot;box one&quot;</span> style=​<span class="string">&quot;top:​ 100px;​&quot;</span>&gt;​callback ref​&lt;/div&gt;​</span><br><span class="line"><span class="keyword">in</span> effect layout </span><br><span class="line">  &lt;div <span class="keyword">class</span>=​<span class="string">&quot;box three&quot;</span> style=​<span class="string">&quot;top:​ 100px;​&quot;</span>&gt;​layout effect​&lt;/div&gt;​</span><br><span class="line"><span class="keyword">in</span> effect </span><br><span class="line">  &lt;div <span class="keyword">class</span>=​<span class="string">&quot;box two&quot;</span> style=​<span class="string">&quot;top:​ 100px;​&quot;</span>&gt;​effect​&lt;/div&gt;​</span><br><span class="line"></span><br><span class="line"><span class="comment">// unmount</span></span><br><span class="line">callback ref call <span class="literal">null</span> (不管有沒有 node)</span><br><span class="line">callback ref call <span class="literal">null</span> node <span class="literal">null</span></span><br><span class="line">clean up layout </span><br><span class="line">  &lt;div <span class="keyword">class</span>=​<span class="string">&quot;box three&quot;</span> style=​<span class="string">&quot;top:​ 100px;​&quot;</span>&gt;​layout effect​&lt;/div&gt;​</span><br><span class="line">clean up effect <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<ol>
<li>callback ref 在 render 時 call 再 mount 時又 call</li>
<li><code>layoutEffect</code> 在 unmount 時 ref 還沒消失🤔</li>
</ol>
<p>網路上已經有人把它製成表格，而且還有 updating 😄<br>
<img data-src="https://blog.thoughtspile.tech/images/react-ref-order-f455246e4b65dcd8bad4434384f2460e.png" alt="|400x180"></p>
<blockquote>
<p>圖源自 : <a href="https://blog.thoughtspile.tech/2021/05/17/everything-about-react-refs/">So you think you know everything about React refs</a></p>
</blockquote>
<p>effect 在 unmount 讀取 node 也會消失，但可以利用 closure 的特性，建立變數先將 node 給記住，在 <code>unmout</code> 呼叫 clean up function 時取消監聽事件。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 刻意記住，因為 boxRef 是會變動的</span></span><br><span class="line">  <span class="keyword">const</span> keepRef = boxRef.<span class="property">current</span></span><br><span class="line">  boxRef.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, changeColor);</span><br><span class="line">  boxRef.<span class="property">current</span>.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&quot;100px&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// null , box two 本身</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(boxRef.<span class="property">current</span>,keepRef.<span class="property">current</span>)</span><br><span class="line">    keepRef.<span class="property">current</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;click&quot;</span>, changeColor);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>
<p>那 <code>layoutEffect</code> 可以直接在清除執行取消監聽嗎 ? 雖然 <code>ref.current</code> 依舊存在，但還是不安全的，最好是像 effect 一樣，利用 closure 的方式來取消監聽事件。</p>
<h2 id="callback-ref-的-clean-up-function">callback ref 的 clean up function</h2>
<blockquote>
<p>官方討論串 :  <a href="https://github.com/facebook/react/issues/15176">React callback ref cleanup function · Issue #15176 · facebook/react · GitHub</a></p>
</blockquote>
<p>在 React 18 釋出以前已經有探討 callback ref clean up 的問題，上面有提到當 callback ref 在 <code>unmount</code> 呼叫時是 null，因此註銷監聽事件是不容易的，因此有人提出一些解決方案，未來也可能出現新的 API 來解決此問題🤔，大概看完 RFC 目前應該是沒有打算建立新 API ，結尾都指出這樣的改變可能導致新舊會產生衝突。</p>
<p>不過這部分我還沒詳讀😵，先記錄起來，之後會再寫文章來研究研究🤔</p>
<ol>
<li>Dan 大有提到，useCallback 如果回傳 function ，等同於做出新的行為，就不會有呼叫到 null 得的問題，🤔。 <a href="https://github.com/reactjs/rfcs/pull/205">RFC: Callback Ref Cleanup by KurtGokhan · Pull Request #205</a></li>
<li>我覺得很玄的問題， 改變 ref 不 re-render ，但是這個需求卻要求 ref 要跟 state 做一樣的事🤔，不過最後也是提到 <code>return ()=&gt;&#123;&#125;</code> clean up function 。<a href="https://github.com/facebook/react/issues/21903">React 18 let’s make ref.currant to be reactive value · Issue #21903 </a></li>
<li>這一串討論 Custom Hooks 將 ref 外傳，然後 <code>useEffect</code> 的 deps 是放入 <code>ref.current</code> 這件事。聽起來有點反設計，因為 ref 不會觸發 re-render ，但是卻把它放在 deps 中監聽是否有改變再隨 re-render 重新呼叫🤔 <a href="https://github.com/facebook/react/issues/16154">Accessing state/props in callback ref with hooks · Issue #16154</a></li>
<li>根據第三點官方提出的解決辦法 : <a href="https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback">Hooks FAQ – How to read an often-changing value from useCallback?t</a></li>
</ol>
<p>以上都是處理邊際條件 (edge case) 的討論。</p>
<h2 id="總結-29">總結</h2>
<ol>
<li>ref 可以看做是一個普通 JavaScript 物件，帶有 <code>current</code> 屬性，React 確保改變它不會造成 re-render，也不會隨生命週期改變 。</li>
<li>不能使用 <code>useRef</code> 替代 <code>useState</code>。 <code>useRef</code> 不會觸發 re-render ，操作後不保證能同步 UI (資料改了但是 React 不會刷新畫面，參見 : <a href="https://blog.rosa.tw/2022/08/React/ref-and-callback-ref#%E8%A3%9C%E5%85%85-Declarative-v-s-Imperative-in-JavaScript">抓 Previous 的值</a>。</li>
<li>最好在 effect 或是 event handler 裡面更新 ref ，因為 ref 的建立與更新的時間點。</li>
<li>最常拿來直接操作 DOM 元素。</li>
<li>callback ref 常用來測量 DOM 的大小</li>
</ol>
<p>過程中差點忘記主要目的是認識 ref 的用途，一不小心挖太深🤓，同時也看到原來 callback ref 有這麼多可擴展的方式，我一開始不太能理解 callback ref 要怎麼使用 ，因為 <code>useEffect + ref</code> 都能解決大部分的問題，只是麻煩了點🤔。後續 ref 的部份會再寫一篇再深入 ref 的文章。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">延遲初始化是指初始值需要經過計算而來，我們只需要在 render 一次建立就好</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>Front-end</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記 | React - 重新了解 useEffect</title>
    <url>/2022/08/React/react-useEffect-about-everythings.html</url>
    <content><![CDATA[<blockquote>
<p>文章來自 : <a href="https://overreacted.io/zh-hant/a-complete-guide-to-useeffect/">useEffect 的完整指南 — Overreacted</a></p>
</blockquote>
<h2 id="摘要-8">摘要</h2>
<ol>
<li>useEffect 的基礎概念</li>
<li>useEffect dependencies array 的使用方式</li>
</ol>
<p>大部分都是來自原文的再翻譯，我有些比較不懂的部分就用自己的方式去解釋，也會用原始的 JS 實作的方式，跟著一步步編譯。</p>
<p>更重要的是，要用 React 的思維來去了解 <code>useEffect</code> 的內涵。</p>
<span id="more"></span>
<h2 id="React-的渲染機制">React 的渲染機制</h2>
<p>了解 useEffect 之前，先來了解 <code>setState</code> 的時候會發生什麼事。<br>
當我們 <code>setState</code> 時，React 會重新呼叫 Component function，並更新其值，接著<br>
React 把我們最新的值更新到 DOM 上。</p>
<p>而 <code>useEffect</code> 執行的時間點在 render 之後，為什麼 <code>useEffect</code> 會拿到舊的 state 跟 props ?</p>
<blockquote>
<p>每一次都渲染都保有自己的 state 跟 props</p>
</blockquote>
<p>我們試著把每次 render 拆開來</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// useState </span></span><br><span class="line"><span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 1 次 render 是這樣</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">0</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第 2 次 render</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">1</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次 render 重新呼叫 <code>Counter()</code> ，把 count 每次重新賦值，每次 render state 都會是獨立的。</p>
<p>什麼意思呢？🤔 就是你在一周目看到的資料，既然你在一周目取資料，那也只會拿到一周目的資料。並不能直接取二、三周目的東西。</p>
<p><code>useEffect</code> 雖然是渲染後執行的，但他其實還是待在同一個時間線的渲染 (也就是同步的)，並不是真正意味上的「渲染 <strong>後</strong>」，別被文字搞混了。</p>
<h2 id="render-function-內的-function">render function 內的 function ?</h2>
<p>文中<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>範例順序是</p>
<ol>
<li>把 state 加到 3</li>
<li>按下 <code>alert</code> 按鍵 ( <code>setTimeout</code> for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span> seconds , and 顯示 state )</li>
<li>馬上把 state 加到 5，最後顯示是 ?</li>
</ol>
<blockquote>
<p>結果是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span> ，這裡是抓到 (capture) 按下按鈕的 <strong>當下</strong></p>
</blockquote>
<p>可以想像成聊天 app ，跟 A 聊天送出訊息，接著馬上切換跟 B 輸入訊息，確實是 A 收到訊息，並不是 B 收到。<br>
在 class Component 跟 functional Component 兩種解決不同的問題 (閉包)</p>
<h3 id="function-內部所引用的-state-關係">function 內部所引用的 state 關係</h3>
<p>從最根本的 JavaScript 來看，例子是從文章來的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">person</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = person.<span class="property">name</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Hello, &#x27;</span> + name);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someone = &#123;<span class="attr">name</span>: <span class="string">&#x27;Dan&#x27;</span>&#125;;</span><br><span class="line"><span class="title function_">sayHi</span>(someone);</span><br><span class="line"></span><br><span class="line">someone = &#123;<span class="attr">name</span>: <span class="string">&#x27;Yuzhi&#x27;</span>&#125;;</span><br><span class="line"><span class="title function_">sayHi</span>(someone);</span><br><span class="line"></span><br><span class="line">someone = &#123;<span class="attr">name</span>: <span class="string">&#x27;Dominic&#x27;</span>&#125;;</span><br><span class="line"><span class="title function_">sayHi</span>(someone);</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>person.name</code> 一開始是 ‘Dan’，但是每次 <code>sayHi</code> 都會經歷以下步驟 :</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第 1 次 </span></span><br><span class="line"><span class="keyword">name</span> = Dan </span><br><span class="line">setTimout 拿到的 <span class="keyword">name</span> 是外部的 <span class="keyword">name</span> = Dan</span><br><span class="line"><span class="comment">// 第 2 次</span></span><br><span class="line"><span class="keyword">name</span> = Yuzhi</span><br><span class="line">setTimout 拿到的 <span class="keyword">name</span> 是外部的 <span class="keyword">name</span> = Yuzhi</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>用 JavaScript 來說就是閉包 (closure) 的概念，Call Stack 到 <code>setTimeout()</code> 的時候，<code>sayHi</code> 裡面宣告的變數會被儲存下來，存在內部，並沒有被回收掉，因此 <code>setTimeout()</code>  當下拿到的值是 <strong>內部已經計算完且被記錄起來的值</strong>，才會是捕獲 (capture) 當時的值。</p>
<blockquote>
<p><code>setTimeout</code> 拿到的值會是當下執行完所記錄下的值，這也說明了為什麼 useEffect 會拿到舊的 state : <strong>當下的 <code>setTimeout()</code> 是拿閉包的值。</strong></p>
</blockquote>
<h3 id="回頭看-React-的-render-內部的-function">回頭看 React 的 render 內部的 function</h3>
<p>已經知道 <code>setTimeout</code> 會記錄下當次 render 的值，不管哪一次的 render ，它當次的 state 與 props 都會是一樣的。如果是不同次的 render ，它的 state 和 props 是獨立的，在事件 (event handler) 或事件內的非同步 (async/await) 事件也都是一樣的原則。</p>
<p>範例用 <code>inline function</code> 是安全的 (button 的 click 事件)，因為 state 的 count 不會每次都被變動 (意思應該是 <strong>產生新的記憶體空間</strong>，指跟 object type 的差別)，如果 state 是 object type 的類型，必須確保 object 是用 <strong>Immutable</strong> 的方式改變。</p>
<p>文中提到 <code>setState(newObj)</code> 是合理的，為什麼這麼說呢 ?<br>
只要<strong>記住每次 render 都有自己的 state 或 props</strong> ，直接改改成 <code>newObj</code>是沒問的，對於前一次的 render 也是完整的值。<br>
👉  <a href="https://codepen.io/shan473/pen/jOzeWEb?editors=0011">codepen 簡易範例，請看 useRef 變化</a></p>
<p>例如 : 結構類似，但是巢狀內部有部分改變</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假如原本的 state</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  a : &#123;</span><br><span class="line">    b : <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newState = &#123;</span><br><span class="line">  a : &#123;</span><br><span class="line">    b : <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ✅ 刷新整筆資料，這樣沒問題</span></span><br><span class="line"><span class="title function_">setState</span>(newState)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 直接對值內部些微調整，React 根本察覺不到，不會 re-render</span></span><br><span class="line"><span class="title function_">setState</span>(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">  prevState.<span class="property">a</span>.<span class="property">b</span> = newState.<span class="property">a</span>.<span class="property">b</span></span><br><span class="line">  <span class="keyword">return</span> prevState</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>當我們要觸發 <code>setState</code> 時，React 會先經過 state 的淺比較 (shallow comparison)，如果直接改變並不會 re-render。</p>
<h2 id="每一次-render-都它自己的-Effect">每一次 render 都它自己的 Effect</h2>
<p>React 會記住每個 <code>useEffect</code>，觸發的時間點是每次改變 DOM 之後與 browser 渲染完之後才會呼叫。</p>
<p>概念上來說，effect 是這次 render 後的結果 (render 後才執行的)，但 effect 其實也跟上面提及的 [[#回頭看 React 的 render 內部的 function]] 章節一樣的概念，其 state 跟 props 是都是屬於當次 render 的，effect 也是。</p>
<h2 id="每一次-render-保有它的所有東西">每一次 render 保有它的所有東西</h2>
<p>範例<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 。<br>
已經知道 function 每一次的 render 會計下 <code>useEffect</code>，並且拿到內部 <code>local state</code> 的值。</p>
<p>跟著 <code>setTimeout</code> 跑一次 :</p>
<ul>
<li>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 次 render
<ol>
<li>state 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span></li>
<li>React 記下 effect : 3 秒之後 You clicked 0 times</li>
<li><code>Counter</code> 回傳提交 UI 給 React</li>
<li>React 跟 DOM 溝通並且瀏覽器渲染了畫面</li>
<li><code>useEffect</code> 這時候呼叫 React 所記下的 effect ，等到 3 秒之後 : 印出 You clicked 0 times</li>
</ol>
</li>
</ul>
<p>接著按下 button 觸發 <code>setCount</code> 讓 count + 1，React 重新呼叫 <code>Counter()</code> ，進行第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 次渲染</p>
<ul>
<li>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 次 render
<ol>
<li>state 變成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></li>
<li>React 記下 effect : 3 秒之後 You clicked 1 times</li>
<li><code>Counter</code> 回傳提交 UI 給 React</li>
<li>React 跟 DOM 溝通並且瀏覽器渲染了畫面</li>
<li><code>useEffect</code> 這時候呼叫 React 所記下的 effect ，等到 3 秒之後 : 印出 You clicked 1 times</li>
</ol>
</li>
</ul>
<p>後面以此類推。<br>
function component 是這樣操作，但是 class Component 在處理 effect 時卻不是這樣的。</p>
<h3 id="跟-class-Component-的差別">跟 class Component 的差別</h3>
<p>範例<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup><br>
凡有關 effect 的操作會放在 <code>componentDidUpdate</code> 這裡，意思是  <strong>state 或 props 變更之後要做什麼事</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`You clicked <span class="subst">$&#123;<span class="variable language_">this</span>.state.count&#125;</span> times`</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這裡的 <code>this.state.count</code>  都會是現在的 count，也就是按到 5 <code>setTimeout</code> 抓到的都會是 5 ，而不是 <strong>當下</strong> 觸發的 count。</p>
<p>每一次 render 都是呼叫內部的 <code>render()</code> function ， state 永遠是指像實例的 state。</p>
<p>複習一下 class component 的 React 生命週期是</p>
<blockquote>
<ol>
<li><strong>Mouting</strong> : constructor 👉 render 👉 capture refs and DOM 👉DidMount</li>
<li><strong>Updating</strong> : render 👉 capture refs and DOM 👉DidUpdate</li>
</ol>
</blockquote>
<p>跟著 <code>setTimeout</code> 跑一次 :</p>
<ul>
<li>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 次 render <strong>(Mounting)</strong>
<ol>
<li><code>constructor</code> 初始化 ，state = 0</li>
<li><code>render</code> 觸發 Counter 內部的 render ，並提交 UI 給 React</li>
<li><code>capture refs and DOM</code> React 跟 DOM 溝通並且瀏覽器渲染了畫面</li>
<li><code>DidMount</code> 被呼叫，印出 : You clicked 0 times</li>
</ol>
</li>
</ul>
<p>接著按下 button 觸發讓 count + 1，React 重新呼叫 Counter 的 <code>render()</code> ，進行第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 次渲染</p>
<ul>
<li>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 次 render <strong>(Updating)</strong>
<ol>
<li>此時 state 的 count = 1，<code>setState</code> 等同於執行到 <code>Counter.state.count = 1</code> (注意 : 但開發者不能直接在元件內部這樣做，React 幫我們做 )</li>
<li><code>render</code> 觸發 Counter 內部的 render ，並提交 UI 給 React</li>
<li><code>capture refs and DOM</code> React 跟 DOM 溝通並且瀏覽器渲染了畫面</li>
<li>Counter 呼叫 <code>componentDidUpdate</code>，3 秒之後 Counter state 是 1，印出 You clicked 1 times</li>
</ol>
</li>
</ul>
<p>好，這邊看起來沒問題🤔。</p>
<blockquote>
<p>那麼不間斷按了 5 次，而且不等每次 <code>setTimeout</code> 的秒數跑完呢 ?</p>
</blockquote>
<p>等於 <code>Event Loop</code> 中的 Call Stack 還在排隊的情況，會一值重複 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span> 這個動作，但是到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">4</span></span></span></span> !!!</p>
<blockquote>
<p>Counter 呼叫  <code>componentDidUpdate</code>，3 秒之後此時的 State 是 ???</p>
</blockquote>
<p>這時候 main thread 上的 Call Stack 跑完，Event Loop 的 stack 開始執行，此時的 <code>Counter.state.count =  5</code>，執行時印出 <strong>You clicked 5 times</strong> 並且依序印出 5 次</p>
<p>要解決此問題很簡單，把當下的 <code>this.state.count</code> 取下來包給 <code>setTimeout</code> ，其實等同於 <strong>closure</strong> 的方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>當非同步進入 <code>Event Loop</code> 跑去排隊的時候，這邊的 <strong>count 已經被記起來了</strong>，所以當 <code>setTimout</code> 到 Call Stack 的時候，就會是當次 render 的 count。</p>
<p>Closures 很好用，當我們把值關在內部，即使它脫離了 function ，下次再呼叫 function 時其值還是會被保留住不會改變。可以想成把它想成雷同 <code>const</code> 常數。</p>
<h2 id="如何拿取最新的-state">如何拿取最新的 state ?</h2>
<p>把握上面所提及的原則，<strong>每一次 component 執行 render function，包含 事件、effect 甚至 timeouts 或是其他 API 都會記住當次定義的 props 或 state。</strong></p>
<p>這兩個範例其實是一樣的 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">//📍 等到 render 之後才讀取 counter</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">counter</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 📍 一開始把 counter 存起來</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = props.<span class="property">counter</span>;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(counter);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不管是先還是後去讀取值，拿到的 state 是相同的<br>
<code>useEffect</code> 已經記住當時的 state<br>
state 跟 props 是不會變的</p>
</blockquote>
<p>如果我們試圖在上一次的 render function 取得最新的 props 或 state，這樣是逆流而上 (文章這麼說的🤔)。</p>
<p>有時候我們會需要在 effect 中拿到最新的值，而不是當下 render 所記住的值，這並不是什麼錯誤的操作，但我們可以使用 refs 達成目的。</p>
<p>refs 不會促使 React re-render，因為 React 確保它是不會被改變的(指不會因 render 產生新的記憶體位址，每次都指向同一個實體)。也可以想成 React 幫我們建立一個全域的物件，我們都是對同一個物件進行直接操作。</p>
<blockquote>
<p>然而逆流而上是什麼意思呢 ? 🤔</p>
</blockquote>
<p>functional component 是利用閉包 (closure) 的概念，從 JS 的基礎概念來看，執行完 function 後由於裡面的變數還是存在於 function 內部 (沒有被回收)，但是存在內部的變數外部不能直接操作。</p>
<p>回到 <code>setState</code> 會觸發 re-render，重新呼叫 component function ，但在 effect 中仍是屬於上一次 render 的，當我們想在 effect 取得最新的資料來操作就像在外部對 closure 內部拿某變數，這是不行的，因為值被封裝在內部。除非我們像在外部先建立好一個全域變數，並且直接拿其值進行操作，沒錯，這就等同於 refs 的概念了😲</p>
<h2 id="使用-ref-來取得最新值">使用 ref 來取得最新值</h2>
<p>已經知道 [[#跟 class Component 的差別|class component 的行為]] 會拿到最新的值，而 function component 則不會，要怎麼用 function component 復刻 class 的行為呢 ?</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> latestCount = <span class="title function_">useRef</span>(count);</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拿到最新的 count</span></span><br><span class="line">  latestCount.<span class="property">current</span> = count;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 讀取最新的 count</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`You clicked <span class="subst">$&#123;latestCount.current&#125;</span> times`</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如此一來，連按 5 次，就會呈現最後通通印出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span></span></span></span> 的結果。<br>
<strong>ref</strong> 就像在外部建立一個盒子，寄放不會被改變的值</p>
<p>這樣的方式不能保證每次 function call 的那個期間，state 是正確的 (state 不屬於那個當下的時間點)。由於每次都被直接改變 (class component 做的事)，拿到的就會是最新的。<br>
這也是為什麼 React 預設不是 ref 的操作，而是選擇性的。</p>
<p>這裡可以比較 functional component 跟 class  component 對於 render 意義的不同之處 :</p>
<ul>
<li>class component 將每次 render 分成不同階段來決定發生哪些事，也就是生命週期。在 A 階段變化到 B 階段的過程，資料也會隨時間發生變化。</li>
<li>functional component 則是把每次的 render 是獨立的來看，這次 render 只關注這次資料的變化，並且同步一切的東西。</li>
</ul>
<h2 id="談談-clean-up">談談 clean up</h2>
<blockquote>
<p>clean up 的是舊的 props 還是當下的 props ?</p>
</blockquote>
<p>先釐清 <code>clean up</code> 的執行時間，在畫面渲染之後，在下一個 effect 執行之前，會執行 clean up effect。<br>
<img data-src="https://raw.githubusercontent.com/donavon/hook-flow/master/hook-flow.png" alt="|400x500"></p>
<p>意思是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 2️⃣ 在 return 之後才會做</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 1️⃣ 這裡會先執行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>情境 : 有一個 state 從 10 改變成 20</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(props.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(props.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一開始可能會這麼想 :</p>
<ol>
<li>React 先清除 (clean up) 帶有 <code>id = 10</code> 的訂閱</li>
<li>state 更新至 20，React 提交 UI 給瀏覽器渲染</li>
<li>React effect 執行帶有 <code>id = 20</code> 的訂閱</li>
</ol>
<p>🤔這不是正確的，Why ?</p>
<p>回到 Flow 那張圖，可以知道 effect 執行的時間點是 <strong>瀏覽器將元素放上 DOM (browser painting)</strong> 之後，為什麼 React 要這麼設計 ? 🤔</p>
<blockquote>
<p>才不會阻攔螢幕的更新</p>
</blockquote>
<p>effect 很常處理 AJAX 取資料的事情， 如果取資料這件事不是安排到 effect 中處理，而是同步處理呢 ? 瀏覽器就必須等到資料回傳再去做 painting 的工作，如果回傳時間拉長，螢幕就會像被卡住、動彈不得。</p>
<p>React 才會把 effect 執行的時間點放在瀏覽器 painting 之後，以不阻擋螢幕更新率的情況下，提升 UI 體驗。而 <strong>Effect 的 clean up function 也會被延遲</strong>。</p>
<p>所以上面真正的情境順序</p>
<ol>
<li>state 更新至 20，React 提交 UI 給瀏覽器渲染</li>
<li>瀏覽器渲染了，使用者看見 20 出現在螢幕上</li>
<li>React 清除 effect ， <code>id = 10</code></li>
<li>React 執行 effect ，<code>id =  20</code></li>
</ol>
<p>奇怪的是，為什麼可以在 <code>id = 20</code> 的情況下，去清除 <code>id = 10</code> 的值呢 ? 🤔</p>
<blockquote>
<p>每一個在 render 內部呼叫的 function (包含 handlers 、effect 等瀏覽器 APIs )，都會拿到當下定義的 state 。</p>
</blockquote>
<p>實際上清除與執行 effect 的 state 都是來自當次 render 的資料，<strong>effect 執行的並不會拿到最新的資料</strong> ，而是舊 (當下)的。</p>
<p>What !?🤷</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅實際上是這樣的</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(<span class="number">10</span>, handleStatusChange);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(<span class="number">10</span>, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不是這樣的，我們在想像的 clean up 雖然清除的時間點 state 已經改變成 20，但仍然是屬於 id = 10 那次 render 的</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(<span class="number">20</span>, handleStatusChange);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(<span class="number">10</span>, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>clean up 是延後執行，並不代表是屬於下次的 render。 React 把 effect 相關操作是在瀏覽器渲染之後的原因，目的讓執行比預設的還要快。</p>
<p>而在 clean up function 被呼叫時，舊的 props 永遠都存在，以防我們需要用到它。</p>
<p>例如監聽事件，如果某按鍵元素消失於畫面，我們應該將它的監聽事件註銷掉，但是在 render 之後元素早已經從畫面消失，我們要怎麼註銷一個已經不在 DOM 上的元素監聽事件呢 ?  clean up function 讓我們把舊的 state 或 props 還存在著，在 effect 呼叫之前，我們就可以把它註銷掉。</p>
<h2 id="同步執行但不是生命週期">同步執行但不是生命週期</h2>
<p>在使用 <code>useEffect</code> 要跳脫生命週期的思考方式，運用同步的概念。</p>
<blockquote>
<p>一切都是跟結果有關，而不是過程</p>
</blockquote>
<p>這跟 JQuery 先呼叫 <code>addClass</code> 又呼叫 <code>removeClass</code> <strong>過程派別</strong> 是不同的 (意思是 DOM 新建立東西，又給它刪除這樣的行為)，這也是為什麼 React 的 CSS class 必須放在 render 程式碼之中 (只在乎結果，並不是從 A 變 B 的過程經歷了什麼。判斷樣式都是看最終的結果，並非隨時間而改變)</p>
<p>React 根據當下的資料是同步處理 DOM (資料跟 UI 是同步的) ，在 function component 中 render 的  <code>mount</code> 跟 <code>updating</code> 是沒有區別的。這樣使 <code>useEffect</code> 讓我們可以根據 props 或 state 同步 React 樹狀以外的東西。</p>
<p>假如有一個 state 從 10 變到 20，跟一開始就賦予它 20 ，最終都會是 20。跟 call API 拿資料一樣，最後的結果都會是一樣的。我們看到的 UI 跟資料是同步的，也只會顯示最後資料的結果。</p>
<p>但是如果每次都 re-render 是很沒效率的，甚至導致無限循環。</p>
<h2 id="告訴-React-不同-effect-之間的差別">告訴 React 不同 effect 之間的差別</h2>
<p>避免每次不必要的資料都跟著 re-render，必須告訴 React 那些要 re-render。 (可以想想 render 之後的步驟順序)</p>
<ol>
<li>state 改變，render 新的 UI</li>
<li>React render ，提交 UI 給 DOM</li>
<li>DOM 更新，經過一系列操作，最後放上畫面 (這也為什麼說 操作 DOM 很昂貴，因為牽涉到太多畫面的 reflow、repaint，尤其是 reflow)</li>
</ol>
<p>React 避免 DOM 昂貴的操作，只會更新 DOM 確實有改變的地方。</p>
<p>React Element 是一個 Object 裝載各種屬性。假如有一個元件指改動了 <code>props.name</code> (不包含 state 的操作) ，也就是文字的部分僅有 children 改變了，React 只會改動 <code>domNode.innerText</code> 的部份而已 (做淺拷貝比較 shallow comparison，這跟 React 的 Recoil 有關)</p>
<p>範例來自 Dan 大的文章 :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> oldProps = &#123;<span class="attr">className</span>: <span class="string">&#x27;Greeting&#x27;</span>, <span class="attr">children</span>: <span class="string">&#x27;Hello, Dan&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> newProps = &#123;<span class="attr">className</span>: <span class="string">&#x27;Greeting&#x27;</span>, <span class="attr">children</span>: <span class="string">&#x27;Hello, Yuzhi&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>那 React 也會在 <code>useEffect</code> 幫我們檢查嗎 ?</p>
</blockquote>
<p><strong>不會。</strong> React 對於沒有呼叫的 function，是沒辦法幫我們檢查、比較。</p>
<p>React 為了避免一直重複執行 effect 有關的操作，提供 <strong>dependency array</strong> (也稱 <strong>deps</strong> ) ，讓我們加入要關注的資料給 <code>useEffect</code> 判斷。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Hello, &#x27;</span> + name;</span><br><span class="line">&#125;, [name]); <span class="comment">// 👈 deps</span></span><br></pre></td></tr></table></figure>
<p>透過這個 array 告訴 React ，這裡面</p>
<blockquote>
<p>只有包含 array 的資料改變了才要執行，其餘的資料跟我無關，不要叫我謝謝。</p>
</blockquote>
<p>React 每次 re-render 會檢查 array 中的資料，如果前後都長的一樣，就會跳過 <code>useEffect</code>  。</p>
<p>只要放入 array 中的資料，即使只有 1 個改變，也會重新執行 effect ，React 就會知道這是不能跳過的，因為 React 會同步所有事情。</p>
<p>所以不要把毫無相關的放在一起，<strong>關注會改變而重新呼叫的資料。</strong></p>
<h2 id="不要對-dependencies-說謊">不要對 dependencies 說謊</h2>
<p>function Component 中沒有生命週期，如果我們只想要在 <code>mount</code> 執行一次就好，通常會把 dependencies array 寫成空的。</p>
<p>例如 : 載入資料</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 載入資料</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ajax 是 side effect 把它擺在 useEffect 執行</span></span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, []); <span class="comment">// 👈 放入空陣列 </span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起來合理嗎 ? 如果有牽涉到其他的 props 或 state 這裡就會有問題。</p>
<h3 id="dependencies-說謊了會發生什麼問題">dependencies 說謊了會發生什麼問題 ?</h3>
<p>如果以計時功能 (<code>setInterval</code>) 在 class component 中的寫法思維，在 function Component 就要改變這個想法。 <code>setInterval</code> 雖然在基礎的 JS 建立一次，瀏覽器會持續記住直到刪除 id 為止，但在 function Component 每一次都擁有自己的 scope ，所以必須針對每次呼叫 render 時，如果要改變的資料具有副作用要先刪除，再重新產生，不然就會一直往上疊加，造成問題。</p>
<p>在 class Component 中，有關副作用的問題會在 <code>Mount</code> 監聽與 <code>Unmout</code> 註銷監聽，如果在使用 <code>useEffect</code> 也是同一個思維模式去思考， 把 dependencies array 當作是 mount 的行為，將 array 設為空的，但內部如果使用到有關 props 或 state ，effect 只會在 render 執行一次後就不會再直行了。</p>
<h3 id="誠實以對-dependencies，把有關的放入-array-中">誠實以對 dependencies，把有關的放入 array 中</h3>
<p>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 種方式就是把所有相關資料放入 <code>useEffect</code> 的 array 中，讓 effect 按照資料改變就同步改變。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, [count]); <span class="comment">//👈 用到了 count 放入 array</span></span><br></pre></td></tr></table></figure>
<p>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 種是改變 effect 裡面的結構，不需要每輪 render 都要比較 array 中的資料，減少依賴性，往下會說明怎麼減少依賴性。</p>
<h2 id="有效率的使用-useEffect">有效率的使用 useEffect</h2>
<blockquote>
<p>如果我們不想把 state 放入 dependencies array 呢 ?</p>
</blockquote>
<blockquote>
<p>這不是叛不叛逆或是刻意操作<br>
而是 <strong>React 一定需要透過依賴陣列去比較這筆資料嗎 ?</strong>   effect 所執行的是具有副作用的操作。而 React 都能知道當次 render 的所有資料，有必要每次都去特別告訴 React 這筆是否具有變化呢 ?</p>
</blockquote>
<p>可以先提問自己 <strong>這筆資料的是為了什麼 ?</strong><br>
例如 Counter 中每秒做 <code>setCount(count + 1)</code>，但<strong>其實我們根本不需要比較每次 render 的 count 是多少</strong>，之後再 <code>+1</code> 。</p>
<p>Why ? 🤔</p>
<p>因為 React 可以幫我們拿出前一次的 state，而 <code>setInterval</code> 每次是仰賴 <strong>前一次的 state 再 <code>+1</code></strong> ，那麼可以使用 <code>setState</code> 的第二種方式，<code>setState</code> 裡面使用 callback function 拿到最新的 state 並回傳新 state。</p>
<blockquote>
<p><code>setState((previousState)=&gt; return state)</code></p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 參數 c 會拿到前一次的 count，回傳 count+1 的結果</span></span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, []); <span class="comment">//👈 這裡就不用放依賴陣列</span></span><br></pre></td></tr></table></figure>
<p>即使不告訴 React  正確的 dependencies array，<code>setInterval</code> 在第一次 render 後都會存在 (也就是會不斷的執行)，因為 <code>setInterval</code> 是屬於 <code>window</code> 也就是 browser 的 method。</p>
<p>只有在 Component 本身 <code>unmout</code> 會停下來，也就是上面 <code>return</code> 的部份。</p>
<p>試著跑一次 :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// effect 第一次會被執行，它會在第一次 render 後都存在</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="number">0</span> =&gt; <span class="number">0</span> + <span class="number">1</span>); <span class="comment">// 所以這邊是 setCount(1)</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次 render </span></span><br><span class="line"><span class="keyword">const</span> count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// useEffect 不執行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// setInterval() 這個還是會執行，因為它存在於 browser  而不是每次 render function</span></span><br></pre></td></tr></table></figure>
<p>文中稱是 <strong>否定式依賴關係</strong> (false dependencies)，因為 React <strong>知道每次 render 的 state 值</strong>，而範例中 <code>setCount</code> 做的事只有回傳 <code>count + 1</code>，React 並不用特別去檢查前後兩次的 count state 是否一樣，再去執行。</p>
<p>可以看做告訴 React :</p>
<blockquote>
<p>總之幫我把  <code>c=&gt;c+1</code> 的結果回傳給我 ，不論 c 是什麼，React 是知道的。</p>
</blockquote>
<p>就像指示，這種  <code>function setState</code>  的方式如同批次 (batch) 更新一樣。</p>
<p>我們確實移除 count 減少依賴性，但並不是對 deps 說謊，只是我們的 effect 沒有讀取來自 render 的範圍裡面的 count。</p>
<h3 id="試著拆解並了解">試著拆解並了解</h3>
<p>我用自己的話解釋這段，一開始看的時候真的很吃力😵</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先回味一下原始長相，我要開始幫它變身囉😲</span></span><br><span class="line"><span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="number">0</span> =&gt; <span class="number">0</span> + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure>
<p>上面說到 <code>setInterval</code> 其實可以看做把 function 提到外部，因為 <code>useEffect</code> 只 render 一次，代表內部的 function 是不會變隨 render 重新呼叫 (改變) 的，等同於把 function 提到外面存在來。</p>
<p>由於 <code>setCount</code> 本身就是透過 <code>updater function</code> 回傳新的 state  就我們按照他的架構回傳。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setIterval 的 callback function 看作把東西寫在 render function 以外</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">countSomething</span> = (<span class="params">setCount</span>) =&gt; &#123;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>把提出的 function 塞回去，並不會影響原本的操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 放回去</span></span><br><span class="line"><span class="keyword">const</span> [count,setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 塞回去一樣可以執行</span></span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">countSomething</span>(setCount);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;,[]) <span class="comment">// 👈 依賴陣列是空的</span></span><br></pre></td></tr></table></figure>
<p>來按照步驟來人體 render 看看，按照 React 每次 render 都同步資料來看</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次 render</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. count = 0 </span></span><br><span class="line"><span class="keyword">const</span> count  = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 3. 進行 effect</span></span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">countSomething</span>(setCount);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 這邊先 clean ，但第一次的 id 是 null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次 render</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 雖然 useEffect 不會執行 </span></span><br><span class="line"><span class="comment">  但內部的 setInterval 會繼續執行，直到被清除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不是這樣 function 一直被呼叫，而是內部的 setInterval 間隔觸發它的 callback function</span></span><br><span class="line"><span class="title function_">countSomething</span>(setCount);</span><br></pre></td></tr></table></figure>
<p><code>setInterval</code> 不管在哪裡呼叫，由於它是屬於 window (瀏覽器) 底下的 api，如果沒有清除，那麼 <code>window</code> 一樣會每間隔 x 秒呼叫。這個例子證明不論放在 render function 內部或是外部，<code>setInterval</code> 都會風雨無阻的執行。</p>
<blockquote>
<p>注意<br>
我們讀取的 count 值已經不是來自於 render 範圍的</p>
</blockquote>
<p>這是什麼意思呢 ? 🤔</p>
<p>經由上面的變化史，已經知道脫離了 render function 依然可以執行，那這裡的 <code>setCount (c=&gt;c+1)</code> 裡面的 <strong><code>c=&gt; c+ 1</code></strong> 又是另一個 callback function，那 <code>c</code> 這個參數來自誰重要嗎 ?  我們有必要填入這個 c 值才能計算嗎 ? (意思是一定要寫<code>setCount(anotherfunction(c))</code> 才能執行嗎 ?  )</p>
<p>我再把 <code>setCount</code> 裡面的 callback function 又拆出 render 以外，叫 <code>plusOne</code>，並且我把這個 <code>plusOne</code> 看做我們要對 <code>setCount</code> 做某事的藍圖。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">countSomething</span> = (<span class="params">setCount</span>) =&gt; &#123;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(plusOne);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 告訴 React 資料要做的事</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">plusOne</span>(<span class="params">c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> c + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>👉  <a href="https://codesandbox.io/s/mystifying-williamson-s4799j?file=/src/index.js"> <code>codsandbox</code> 範例</a></p>
<p>在把這串放回去，一樣可以執行。<code>setState</code> 如果是使用 callback function 的方式使用，內部其實是呼叫 <strong>updater function</strong><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>，它會保證拿到最新的 state，而我們的 <code>plusOne</code> 只是 updater function 的另一種表達方式。</p>
<p>回到 React render 的概念 : <strong>每次 render 都保有自己的資料</strong>，所以我們不用特別放入 deps 來告訴 React ，因為 React 就已經知道當次的 state。</p>
<p>這段有點饒口，但幫助我釐清到底為什麼不用加入 deps 內依然可以執行這個問題。</p>
<h2 id="從-Google-文件的更新了解-function-updater">從 Google 文件的更新了解 function updater</h2>
<p>如上面的範例，知道可以使用 <code>setCount(c =&gt; c + 1)</code>  避開 deps 填入 state ，但 :</p>
<ol>
<li>為什麼使用呢 ?</li>
<li>跟原本 <code>setCount( c + 1)</code> 差別在哪 ?</li>
</ol>
<p>文章中舉例 Google 文章是雲端編輯。修改的時候，並不是每次都傳送整個頁面的內容給伺服器，文章如果檔案大，那樣傳送覆蓋太沒效率了。那怎麼溝通給後端讓它記住新增或修改的部分呢 ?</p>
<blockquote>
<p>透過傳遞 <strong>定義好的表達方式</strong></p>
</blockquote>
<p>其實如果使用過 redux 就知道 dispatch 與 action 的發號施令的概念，只有已經定義到的 action type 對應 actions 才能對資料內容進行變動。那也可以想像 Google 文章在編輯時也是如此，<em>使用者點擊某個按鈕，後端再做動作</em>。</p>
<p>如此一來達到 <strong>找出最小化的資料來改變這個 component</strong> ，如同 Google 文件不會送整頁資料出去改變文件。</p>
<p>這種方式跟是 React 所建議的原則 : <strong>尋找最小化但完整的 state</strong> 的概念 (意思是有些資料是可以透過計算出來的，不一定所有資料都得是內部的 state，例子補充在後面)，差別是這是 update 的。</p>
<p>最小化且完整的 state 舉例 :<br>
以 todo list 為例，有存放所有 todo 的陣列 state ，但我想要存取 todo 的長度，並不需要另外儲存的 state</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 不用這樣</span></span><br><span class="line"><span class="keyword">const</span> [length,setLength] = <span class="title function_">useState</span>(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>因為可以從 <code>state.todos.length</code>  取得，這筆資料是可以通過計算取得。<br>
這也是為什麼上面說  <code>c =&gt; c + 1</code> 是一個藍圖，因為它傳達的是個資料的表達方式。</p>
<p>那為什麼 <code>setCount(c =&gt; c + 1)</code> 比較好呢 ? 🤔</p>
<p>在於 <strong>它沒有直接改變 count 本身</strong> (沒有汙染到變數)，這個例子用最原始的 JavaScript 來看。由於本次的 count 是 primitive type，這邊並不討論 object type (React 之所以會建議解構 object type 是有原因的)。</p>
<ul>
<li><code>c =&gt; c+1</code> : 並沒有改變到原始的 count</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">plusOne</span>(<span class="params">count</span>)&#123;</span><br><span class="line">  count =  count + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newCount = <span class="title function_">plusOne</span>(count) <span class="comment">// 用變數接起來</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newCount) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>c + 1</code> : 直接對 count 進行操作😵</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">plusOne</span>(<span class="params"></span>)&#123;</span><br><span class="line">  count = count + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newCount = <span class="title function_">plusOne</span>() </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newCount) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>不直接操作資料也是避免非預期的結果發生。</p>
<p>這種方式保證更新多個來源 (事件或是具有副作用的操作等等) 都可以被合併成 <strong>可預測的正確操作</strong>。然而 <code>setCount(c =&gt; c + 1)</code> 並不是最佳解法，遇到以下的情境，可能會產生奇怪的問題 :</p>
<ol>
<li>執行 effect 同時依賴多個 state</li>
<li>透過 props 計算新的 state</li>
</ol>
<p>這時候可以使用 <code>useReducer</code> 來幫我們解決問題。</p>
<p><code>useReducer</code> 可以看做加強版的 useState，而事實上 <code>useState</code> 也是 <code>useReducer</code> 簡化過來的，有興趣可以參考這篇 <a href="https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/react-hooks-usestate-vs-usereducer-b14966ad37dd">React Hooks | 既生 useState 何生 useReducer ? | by Airwaves | 手寫筆記 | Medium</a></p>
<h2 id="將資料更新與操作分離">將資料更新與操作分離</h2>
<p>範例中 count 是被 step 影響，我們也確實將正確的 deps 放進去。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [step, setStep] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + step);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, [step]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;step&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> setStep(Number(e.target.value))&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用白話文解釋 : 當 step 改變時， effect 會先清除上一個計時器，接著產生新的計時器。</p>
<blockquote>
<p>但是如果不想要改變 step 就重啟 interval 重新計時呢 ? 如果想要動態的改變 step 又能持續計時呢 ?</p>
</blockquote>
<p>那麼就必須把 step 從 deps 移除，避免 step 改變也清除 effect 又產生新的 <code>setInterval</code> 重計。</p>
<p>這種情況是多個資料互相依賴 <code>(count ⇒ step)</code>，而且是 A 資料跟 B 資料現在的值有關。(count 每秒增加的值，跟 step 的值有關)</p>
<p>可以改使用 <code>useReducer</code> 管理複雜的資料流。<code>useState</code> 通常只能對著一筆資料操作，如果有很多筆，可能會建立多個 <code>useState</code>。或是發覺操作資料是 <strong>根據於前一次的資料</strong>，這時候很適合換成 <code>useReducer</code>。</p>
<blockquote>
<p>reducer 可以讓我們透過 <strong>action type 對應 action 再去更新資料</strong> ，而且也可以同時對多筆資料操作。</p>
</blockquote>
<p>什麼意思呢 ? 那 <code>useState</code> 不能做這樣的事嗎 ?<br>
可以，但是非常麻煩，會使邏輯變得複雜🤔。</p>
<p>我試著復刻這兩種方式的操作 :</p>
<ol>
<li>照舊分開的兩個資料，同時更新</li>
<li>由於兩個是相依性的，把它放在同一個資料物件中。</li>
</ol>
<p>另外多出來的是嘗試其他種方式。</p>
<ol>
<li>原始範例 : <a href="https://codesandbox.io/s/zxn70rnkx">Dan 大提供的 CodeSandbox</a></li>
<li>實作範例 : <a href="https://codesandbox.io/s/zealous-monad-rco7nx?file=/src/index.js">我複製改過的 CodeSandbox</a>，範例會看到多個不同的寫法，以下會一個個說明。</li>
</ol>
<h3 id="實驗-分開的兩筆資料更新">實驗 : 分開的兩筆資料更新</h3>
<p>首先要釐清改變其值的變因，count 是依賴著 step，但是 step 是手動輸入值所改變的，因此 step 雖然改變了，但是 count 不能拿到最新的 step。</p>
<ul>
<li>透過上面說過的 updater function，我們可以知道 <code>(c =&gt; c)</code> 這樣可以拿到最新值。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> [step, setStep] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setStep</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 最新的 step</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 那這裡的 step 呢 ? 🤔</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;step in count&quot;</span>, step);</span><br><span class="line">        <span class="keyword">return</span> c + step;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>
<p>其他部分跟原範例一樣沒有更改。</p>
<blockquote>
<p>當然結果是不行的。</p>
</blockquote>
<p>試著用 <code>setStep</code> 拿到最新的 step，並不代表當下取得的 step 會是最新的。React 新手最常陷入的陷阱是執行 <code>setState</code> 後馬上讀取 state 值，state 不會是新的。<br>
這跟 <code>setState</code> 是非同步的有關係。</p>
<p>回到那句話 : <strong>每一次 render 都擁有它專屬的 state 或 props</strong> 。<br>
所以  <code>setCount</code> 裏頭的 step 還停留在第一次 render ，<code>step = 1</code>。即使修改 input 的值，雖然 <code>setStep</code> 那行可以拿到最新的 step，但沒辦法在 <code>setCount</code> 裡面拿到。</p>
<h3 id="實驗-再某筆資料內部拿到最新">實驗 :  再某筆資料內部拿到最新</h3>
<p>那在 <code>setStep</code> 中拿到最新 step 在傳給 <code>setCount</code> 總可以了吧🤔</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setStep</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;step in count&quot;</span>, step);</span><br><span class="line">        <span class="keyword">return</span> c + s;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>
<p>變得越來越複雜了，認真拆解的話就是 callback hell 了。同上面說的如果 deps 是空的，state 再也不是取自 render function 裡面，同樣可以把這些 method 看作寫在外部。</p>
<ul>
<li>上面就像 :</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拆解再拆解</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">countSomething</span> = (<span class="params">setCount</span>) =&gt; <span class="function">(<span class="params">setStep</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// callback 再 callback</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setStep</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> c + s);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"> <span class="keyword">const</span> id = <span class="title function_">countSomething</span>(setCount)(setStep);</span><br><span class="line"> <span class="keyword">return</span> <span class="function">()=&gt;</span> <span class="title function_">cleanInterval</span>(id)</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure>
<p>看起來還行🤔，但我認為這樣的架構不好被擴展，除非裡面又再拆，不過同時也讓我想到 HOC (Higher Order Component)，這樣的方法會有效能上的問題。</p>
<h3 id="實驗-object-type-的-state">實驗 : object type 的 state</h3>
<p>我認為這個例子是最接近 <code>useReducer</code> 的，同時必須把結構大改，並且用 immutable 的方式改變資料。</p>
<ul>
<li><code>useState</code> 設為 object :</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 把所有相關的 state 放入同一個容器中</span></span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">     <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">     <span class="attr">step</span>: <span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 一樣使用 updater function 拿到最新值</span></span><br><span class="line">    <span class="title function_">setValue</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> (&#123; ...v, <span class="attr">count</span>: v.<span class="property">count</span> + v.<span class="property">step</span> &#125;));</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 3. step 也要修改 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;value.step&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setValue(&#123; ...value, step: Number(e.target.value) &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好像比上面都更來的精簡，只是改變 state 變成很囉唆😵</p>
<h3 id="實驗-把-input-變成-uncontrolled-component">實驗 : 把 input 變成 uncontrolled component</h3>
<p>在 [[#使用 ref 來取得最新值]] 這章節已經有提到，搭配上表單的控制，可以讓我們不 re-render 的情況下，依然拿到 input 的最新值。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stepRef = <span class="title function_">useRef</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> c + <span class="title class_">Number</span>(stepRef.<span class="property">current</span>.<span class="property">value</span>));</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改成</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;stepRef&#125;</span> <span class="attr">defaultValue</span>=<span class="string">&#123;1&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="回到-useReducer">回到 useReducer</h2>
<ul>
<li>按照文章中提供的 <code>useReducer</code> 範例</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始值</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">step</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="comment">// 解構 state</span></span><br><span class="line">  <span class="keyword">const</span> &#123; count, step &#125; = state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根據不同的 action type 來改變 state，如果 type 一多用 switch case</span></span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;tick&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: count + step, step &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;step&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; count, <span class="attr">step</span>: action.<span class="property">step</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// useReducer </span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br><span class="line">  <span class="comment">// 解構值</span></span><br><span class="line">  <span class="keyword">const</span> &#123; count, step &#125; = state;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// dispatch 一個 action</span></span><br><span class="line">      <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;tick&#x27;</span> &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, [dispatch]); <span class="comment">//👈 deps 放入 dispatch</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;step&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">        // 一樣 dispatch action</span></span><br><span class="line"><span class="language-xml">        dispatch(&#123;</span></span><br><span class="line"><span class="language-xml">          type: &#x27;step&#x27;,</span></span><br><span class="line"><span class="language-xml">          step: Number(e.target.value)</span></span><br><span class="line"><span class="language-xml">        &#125;);</span></span><br><span class="line"><span class="language-xml">      &#125;&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那這有比較好嗎 ? 意思是 deps 放入 dispatch 不是會回到 <code>setInterval</code> 又重新的狀況嗎 ?</p>
<p>事實上可以這麼做是因為 <strong>React 保證 dispatch 永遠被不會改變</strong>，所以它不會讓 state 改變又重新啟動計時。由於 dispatch 不會改變，所以 <code>prevDispatch === nextDispatch</code>。</p>
<p><code>useEffect</code> 的 deps 可以忽略</p>
<ol>
<li><code>dispatch</code></li>
<li><code>setState</code></li>
<li><code>useRef</code> 容器值 : 指 <code>ref.current</code></li>
</ol>
<p>因為 React 保證他們是靜態的，不會被改變。不過指定他們也不會怎麼樣。</p>
<p>回到優點的部分，比起在 effect 裡面直接讀取 <code>state</code>，<strong>dispatch acition</strong> 給予一個資料表達的方式，並且在外部的 reducer 按照 action type 操作資料。讓 effect 把 step 這個 state 分開來看待，count 跟 step 的依賴性就不會因在 render function 導致不同步的問題。</p>
<p>effect 不關注怎麼更新 state，而是什麼動作要發生，並在 reducer 集中處理這些資料邏輯。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count, step &#125; = state;</span><br><span class="line">  <span class="comment">// 收到 tick，reducer 定義 tick 對資料做某件事，回傳 count : count + step</span></span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;tick&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: count + step, step &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;step&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 收到 step，對 step 資料做重新賦值</span></span><br><span class="line">    <span class="keyword">return</span> &#123; count, <span class="attr">step</span>: action.<span class="property">step</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="為什麼-useReducer-是-Hooks-的作弊方式">為什麼 useReducer 是 Hooks 的作弊方式 ?</h2>
<p>文中提出一個情境</p>
<blockquote>
<p>如果是 step 透過 props 傳下來的值呢 ?</p>
</blockquote>
<ul>
<li>文中範例</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在父元件把 step 往下傳 </span></span><br><span class="line">&lt;<span class="title class_">Counter</span> step=&#123;<span class="number">1</span>&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params">&#123; step &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, dispatch] = <span class="title function_">useReducer</span>(reducer, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 因為 step  是 props ，要把 reducer 搬進來才能讀取到</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;tick&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state + step;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 這邊都沒變</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;tick&#x27;</span> &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, [dispatch]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這個範例有優化上的問題，不要當作合理的使用方式。(我覺得是 reducer function 不斷新產生的問題，通常會用 <code>useCallback</code> 避免每次 render  重新產生。)</p>
<p>這個範例 dispatch 依然不會改變，所以 effect 裏頭並不會 re-render。因為 step 不屬於 <code>useReducer</code>  的 state，<code>reducer</code> 怎麼知道 props 產生變化而拿到最新的 props 呢 ?</p>
<p>由於 effect 不會再執行，React 會記住 dispatch 中的 action，但這依然會在下次 re-render (state 或是 props 改變) 呼叫 reducer 。這時候 props 是新的，reducer 接收到的 props 也是新，但不是在 effect 拿到。</p>
<p>這也就是為什麼 Dan 大說 <code>useReducer</code> 像是 Hooks 的作弊模式，因為<strong>把描述事情跟更新邏輯操作分開了</strong>。另外一方面，可以移除一些 effect 中不需要的 deps，避免不必要的 re-render。</p>
<h3 id="白話翻譯機">白話翻譯機</h3>
<p>先確定幾件事 :</p>
<ol>
<li>effect 是不會重新呼叫，因為 dispatch 永遠都是同一個</li>
<li>dispatch 發送的只是一個 <code>action</code>，而且也不會改變。而 reducer 是接收 action type 來對 state 操作。</li>
<li>reducer 在 render function 範圍內，按照原本每一個 render 都有它的 state 或 props ，也就是當 Counter 因 state 或 props 改變而 re-render ，reducer 也會產生新的 function ，也會拿到當前 render  範圍的 props。</li>
<li><code>setInterval</code> 依然間隔秒數執行。</li>
</ol>
<p>如果用 redux 的想法來思考，會看過這張經典的圖，比較容易理解，dispatch 接收一個物件，並再傳給 reducer 處理最後返回 state。<br>
<img data-src="https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif" alt="|300x230"></p>
<p>卡住的話，再試著一步步拆解。<br>
把 dispatch 看作放在外部的 function 接收 action，並且內部呼叫 reducer<br>
👉 <a href="https://codepen.io/shan473/pen/mdxKvYj?editors=0010">嘗試用 <code>codepen</code> 並用 Vanilla JS 復刻 </a></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假的 dispatch 👉 不在 render function 裡面</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakedispatch</span>(<span class="params">action</span>) &#123;</span><br><span class="line">  <span class="comment">// 都呼叫來自 component 中的 reducer，更新目前的 state</span></span><br><span class="line">  component.<span class="title function_">fakereducer</span>(component.<span class="property">state</span>,action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Counter component : 由於 React Element 是一個 Object，所以我轉換成簡化一些 Object 結構。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> step = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> component = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// props 模仿是由外部傳入的 props</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params">props = <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 是不是第一次 render</span></span><br><span class="line">  <span class="keyword">if</span>(component)&#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">state</span> = component.<span class="property">state</span>;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">props</span> = props || component.<span class="property">props</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = count;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">props</span> = props || &#123;step : step&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把 React Element 看成一個 Object</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, &#123;</span><br><span class="line">    <span class="attr">state</span>: <span class="variable language_">this</span>.<span class="property">state</span>,</span><br><span class="line">    <span class="attr">props</span>: <span class="variable language_">this</span>.<span class="property">props</span>,</span><br><span class="line">    <span class="comment">// 😲 fakereducer，放在 render function 內部</span></span><br><span class="line">    <span class="attr">fakereducer</span>: <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&quot;tick&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> += <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">step</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(action.<span class="property">type</span> === <span class="string">&quot;reset&quot;</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Interval : 跟之前的在 <code>useReducer</code> 類似，只是在 dispatch 之後手動 re-render，因為我們改變了 state</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假裝等於 useEffect(()=&gt;&#123;&#125;,[]) ,deps 為空</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fakedispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;tick&quot;</span> &#125;);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改變一下 dispatch 內部</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakedispatch</span>(<span class="params">action</span>) &#123;</span><br><span class="line">  prev = component</span><br><span class="line">  <span class="comment">// 要跟 prev 比較的</span></span><br><span class="line">  <span class="keyword">let</span> temp = <span class="keyword">new</span> <span class="title class_">Counter</span>(prev.<span class="property">props</span>);</span><br><span class="line">  <span class="comment">// 更新 state</span></span><br><span class="line">  temp.<span class="title function_">fakereducer</span>(component.<span class="property">state</span>,action)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  假裝 setState 的概念，由於 state 不同，而re-render</span></span><br><span class="line">  <span class="keyword">if</span>(temp.<span class="property">state</span> !== prev.<span class="property">state</span>)&#123;</span><br><span class="line">    <span class="comment">// 重新呼叫 component 更新</span></span><br><span class="line">    component = temp  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新畫面</span></span><br><span class="line">    title.<span class="property">textContent</span> = component.<span class="property">state</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代表 re-render</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;re-render&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>處理 <code>&lt;Counter step=&quot;1&quot;/&gt;</code> props 改變時也 re-render，由於是 input 的值改變導致 props 改變 (re-render)，我們就模擬這個動作。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&quot;input&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="comment">// 檢查輸入是不是數字</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">Number</span>(e.<span class="property">target</span>.<span class="property">value</span>)))&#123;</span><br><span class="line">    result =<span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    result =<span class="title class_">Number</span>(e.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// re-render 並傳入 props</span></span><br><span class="line">  component = <span class="keyword">new</span> <span class="title class_">Counter</span>(&#123;<span class="attr">step</span>: result&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>執行</li>
</ul>
<h3 id="人體編譯">人體編譯</h3>
<p><code>useEffect</code> 在上面的章節說過，如果 deps 沒有任何東西，effect 只會 render 一次，其 資料已經不是來自於 render function 本身，可以把它看作拿到 render 外部一樣。<br>
所以我們製作假的 <code>useEffect</code> 是對應 <code>tick()</code>， 並且在 component 生成之後呼叫。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">component = <span class="keyword">new</span> <span class="title class_">Counter</span>(&#123;step&#125;);</span><br><span class="line"><span class="title function_">tick</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>編譯 : 這裡有兩種情境，(1) 本身 state 改變 ；(2) 傳入的 props 改變</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改變 Counter 的 state</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> step = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 產生 fakereudcer </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakereducer</span>(<span class="params">action</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&quot;tick&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> += <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">step</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(action.<span class="property">type</span> === <span class="string">&quot;reset&quot;</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tick() setInterval 每秒呼叫 dispatch 並送 action 給 fakereducer</span></span><br><span class="line"><span class="title function_">fakedispatch</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;tick&#x27;</span>&#125;) <span class="comment">//👉 count = 0 + 1 </span></span><br><span class="line"><span class="comment">// component state 改變，re-render 、畫面更新</span></span><br><span class="line">temp = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">1</span>);</span><br><span class="line">component = temp</span><br><span class="line">title.<span class="property">textContent</span> = component.<span class="property">state</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改變 props 的 step = 4，props 改變 re-render</span></span><br><span class="line">component = <span class="keyword">new</span> <span class="title class_">Counter</span>(&#123;<span class="attr">step</span>: <span class="number">4</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 產生新的 fakereducer</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fakereducer</span>(<span class="params">action</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&quot;tick&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 這次 render 1 += 4 = 5</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> += <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">step</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(action.<span class="property">type</span> === <span class="string">&quot;reset&quot;</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>後面都是周而復始。雖然不是很準確的模仿 React ，透過拆解的方式我比較好理解。我們可以知道 reducer 是因為拿取 props 的最新值，我們才把它放在 component 內部，但是會造成不管 props 是不是有改變都會產生新的 reducer 。我可能會用 <code>useCallback</code> 記憶起來，並加上 <code>props.step</code> 作為 deps。</p>
<p>藉由這個例子我們知道 dispatch 只要負責把 action 帶給 reducer 就好，我們不用在內部實作詳細邏輯，而是交給 reducer 處理，減少像 <code>setState</code> 直接在 effect 中把資料拆開又塞回去，而且如果是多組資料集中於一個 state，牽一髮動全身😵。</p>
<h2 id="把-function-移到-useEffect-中">把 function 移到 useEffect 中</h2>
<p><code>useEffect</code> 很常拿來做 call API 拿資料，也很常只做載入頁面的那一次。按照 effect 只執行一次，我們的 deps 會是空的。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(</span><br><span class="line">      <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=react&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面看起來是可行的，比較不好的點在於  <code>fetchData</code> 沒有依靠任何 state 或 props，每一次 render 都是長一樣的，但又會每次產生新的 function🤔。</p>
<blockquote>
<p>如果只用到函數內部的值，沒有依靠外部資料，把它放到 effect function 中</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 把 function 搬到 effect 內部</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=react&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(<span class="title function_">getFetchUrl</span>());</span><br><span class="line">    <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fetchData</span>();</span><br><span class="line">&#125;, []); <span class="comment">// ✅ deps 是空的也沒關係，因為沒有用到 state 或 props</span></span><br></pre></td></tr></table></figure>
<p>我們不用再擔心 deps 的問題，因為確確實實也沒有依賴任何外部資料。</p>
<p>但是當結構開始變的龐大，而且涉及 state 與 props，這時候如果當資料改變了，但 effect 並不會更新，依然只會停留在第一次 render 並且不會再執行了😵。</p>
<blockquote>
<p>那把 state 或 props 加入 deps 呢 ?</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(<span class="title function_">getFetchUrl</span>());</span><br><span class="line">    <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fetchData</span>();</span><br><span class="line">&#125;, [query]); <span class="comment">// ✅ 這樣是合理</span></span><br></pre></td></tr></table></figure>
<p>如此一來當 <code>query</code> 改變，effect 就會重新呼叫，我們拿到的資料也都會同步。</p>
<p>加入 deps 不只是讓 React 不要發出警告。而是去理解相關資料的變化，例如 : 拿取資料是依靠 <code>query</code> 字串的變化，把 query 放入 deps 可以讓我們拿到當次正確的資料。</p>
<p><code>useEffect</code> 強迫讓我們注意資料流應該要怎麼變化，也告訴我們也要讓 effect 一起同步更新，而不是忽略它，讓使用者處處碰到 bug😵</p>
<h2 id="不能把-function-移入-useEffect-怎麼辦">不能把 function 移入 useEffect 怎麼辦 ?</h2>
<p>如果有一個 function 在不同的 effect 中進行，那 function 在每次 re-render 都會被重新創造，如果加入 deps 會導致頻繁的更新。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 🔴 re-render 都會使 effect 重新產生並呼叫，況且還依附兩個😵</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params">query</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line">&#125;, [getFetchUrl]); <span class="comment">// 🚧 deps 是正確的但是改變的太頻繁</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">&#125;, [getFetchUrl]); <span class="comment">// 🚧 deps 是正確的但是改變的太頻繁</span></span><br></pre></td></tr></table></figure>
<p>絕對不會想把它複製貼到 effect 裡面😵。所以解決的方式有兩種 :</p>
<ul>
<li>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 種 : 如上面一直提及的一種方式，把它提到 render function 外部。如果忘記了可以回想一下  [[#有效率的使用 useEffect]] 章節，概念上資料來源是不屬於 render function 範圍的。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 提到外部，不會再被 render 內部的資料影響了</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params">query</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line">  &#125;, []); <span class="comment">// ✅ deps 空的是 OK 的</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">  &#125;, []); <span class="comment">// ✅ deps 空的是 OK 的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 種，把 function 給記起來，由於每次 re-render 都會新建立 function，可以使用 <code>useCallback</code> 記起來，並且按照傳入的 deps 再重新建立 function，選擇再有必要的情況再更新。如果有使用到相關的 state 或 props 就能同步更新。</li>
</ul>
<ol>
<li>類似把 function 提到外部的變化形態 :</li>
</ol>
  <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 跟把 function 提到外部類似，但是在 render function 內讓它不變</span></span><br><span class="line"><span class="keyword">const</span> getFetchUrl = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">query</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">&#125;, []);  <span class="comment">// ✅ callback deps 空的沒關係，因為它是靠帶入的參數來變化</span></span><br><span class="line">  </span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line">&#125;, [getFetchUrl]); <span class="comment">// ✅ deps 放入 getFetchUrl 沒問題，因為 getFetchUrl 建立後不會隨 re-render 重新建立</span></span><br><span class="line">  </span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">&#125;, [getFetchUrl]);  <span class="comment">// ✅ deps 放入 getFetchUrl 沒問題，因為 getFetchUrl 建立後不會隨 re-render 重新建立</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>依賴內部的 state 或 props</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ getFetchUrl 直到 query 有改變才會更新</span></span><br><span class="line"><span class="keyword">const</span> getFetchUrl = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">&#125;, [query]);  <span class="comment">// ✅ callback deps 根據 query state 改變而重新建立</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>();</span><br><span class="line">&#125;, [getFetchUrl]); <span class="comment">// ✅ deps 是 OK 的，跟 query 是同步更新</span></span><br></pre></td></tr></table></figure>
<p>而 <code>useCallback</code> 的方式也適用於父元件傳遞 function props 給子元件的操作 :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ✅ 直到 query 改變才重新建立 fetchData</span></span><br><span class="line">  <span class="keyword">const</span> fetchData = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">  &#125;, [query]);  <span class="comment">// ✅ callback deps 根據 query state 改變而重新建立</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 傳給子元件，記住 ! 這邊的 function 更新條件是 query，所以傳入的 fetchData 會一直是同一個 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;fetchData&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">&#123; fetchData &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [data, setData] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetchData</span>().<span class="title function_">then</span>(setData);</span><br><span class="line">  &#125;, [fetchData]); </span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  ✅ deps 是 OK，因為它也等 Parent 本身 query 改變才會重新呼叫，其餘的時候 Child 本身無法動到 effect 的，即使 setData 改變了，這裡也不會重新呼叫 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="function-是資料流的一種嗎">function 是資料流的一種嗎 ?</h2>
<p>這節提到 function 變成 props 傳遞給子元件要注意的點，另外凸顯 class component 跟 function component 之間的差別。</p>
<p><code>useEffect</code> 我們知道是在 render 之後才呼叫的，而且具有 3 種不同情境 :</p>
<ol>
<li>完全沒有 deps array，表示只要 re-render 之後就跟著執行</li>
<li>deps 為空，表示只在 mount (render) 之後只做一次</li>
<li>deps 放有相關資料，表示有關資料的改變就會重新呼叫 effect</li>
</ol>
<p>看起來 <code>useEffect</code> 是等同於 class component 生命週期中的 <code>componentDidMount</code> 以及 <code>componentDidUpdate</code> 🤔🤔🤔</p>
<p>在這之前，複習一下 class component 的生命週期圖 :<br>
<img data-src="https://i.imgur.com/cpFlaro.png" alt="|600x300"></p>
<ul>
<li>class component 中傳遞 function props，把上面的例子轉成 class 版本</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 等同於 const [query, setQuery] = useState(&#x27;react&#x27;);</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">query</span>: <span class="string">&#x27;react&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 定義了 fetchData 方法</span></span><br><span class="line">  fetchData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">query</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// function 透過 props 傳給 Child </span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;this.fetchData&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 等同於上面 let [data, setData] = useState(null);</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 在 render 之後執行</span></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 從 Parent 來的，我們像 functional component 一樣在 render 之後呼叫</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣在第一次 render 之後確實可以執行，但是沒辦法在 Parent props 改變時重新呼叫。</p>
<p>如果要重新呼叫 <code>this.props.fetchData</code>，就會在 <code>updating</code> 階段 render 完後呼叫 <code>componentDidUpdate</code> 來檢查前後的 props 是否有改變。確實跟 effect 很類似🤔</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">  <span class="comment">// ❌ 這個條件永遠不會成立</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">fetchData</span> !== prevProps.<span class="property">fetchData</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是 props 的比較不會成立，為什麼呢 ?</p>
<blockquote>
<p>class component 是每次都重新呼叫 <code>render()</code>而已，並不是 new 重新建立實例，已經被建立的 function 是靜態的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class component</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ComponentA</span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="title class_">ComponentA</span>.<span class="title function_">render</span>() <span class="comment">// re-render 是指呼叫 class 中的 render function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 👉 prev ComponentA.method 等於 next ComponentA.method</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// functional component</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ComponentB</span>  = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> ()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">re-render 是指呼叫 ComponentB() 本身，其內部的 function 都會重新建立。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">ComponentB</span>() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 👉 prevComponentB 不等於 nextComponentB</span></span><br></pre></td></tr></table></figure>
<p>如果把 <code>if</code> 條件拔掉，也是錯誤的。導致每次 re-render 都重新呼叫 <code>fetchData()</code> ，而且是不論 query 是不是有改變，這不是我們要的效果。</p>
<p>那讓我們的傳遞下去的 <code>fetchData</code> 是會跟著 query 變化的，使用 inline function，並且用 <code>bind</code> 綁定父層的 this ，避免傳到 Child 後用 this 導致指向不正確的問題。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;this.fetchData.bind(this,</span> <span class="attr">this.state.query</span>)&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣導致 <code>this.props.fetchData !== prevProps.fetchData</code> 始終成立，導致每次 re-render 都重新呼叫 <code>fetchData()</code> 。</p>
<p>解決問題的方法，就是 <strong>把 query 當 props 跟著傳下去</strong>，</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Parent Component</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;this.fetchData&#125;</span> <span class="attr">query</span>=<span class="string">&#123;this.state.query&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child Component</span></span><br><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">  <span class="comment">// 根據 props.query 決定</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">query</span> !== prevProps.<span class="property">query</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>function 可以被傳遞進去，但是 function 內部的改變與否是不能被看見的，它沒辦法直接拿來被比較。另一個原因是，props 傳來的方法封閉了 <code>this</code> (this 是看怎麼被呼叫，什麼意思呢 ? 看下面註解)，我們不能直接依賴它來決定是否更新。導致我們 <strong>必須傳遞內部相關所有的資料</strong>，就為了檢查是否有改變再決定要不要呼叫方法。</p>
<blockquote>
<p>對於 class component 來說， function props 不是屬於資料流的一部分。</p>
</blockquote>
<p>我們不知道 <code>this.props.fetchData</code> 從 Parent 傳過來是不是跟 state 有關，或是 state 是不是已經改變了。(這個 props 的 stateless 有關嗎 ? )</p>
<p>使用 <code>useCallback</code> 讓 function 可以加入資料流中，我們根據 function 的輸入值改變，代表 function 本身也要改變，反之亦然，輸入沒有變的話就也不會產生新的 function。有 <code>useCallback</code> 的協助，改變 props 的時候，<code>props.fetchData</code> 也會自動地傳遞下去，因為它本身是資料流的一部分。</p>
<h3 id="注意-4">注意</h3>
<p>把任何 function 都加上 <code>useCallback</code> 是一件很不 Ok 的事，這不是保證是效能上的優化。</p>
<p>雖然它是一個很有效的方法，對於同時傳遞給多個子元件，並且應用在子元件內部的 effect，是可以避免子元件做無意義 render 的問題。當然也可以包裹成 Hooks 避免多個 callbacks 傳遞整個 React 樹狀結構。</p>
<p>用上面的 <code>fetchData</code> 來試著寫成 <code>useFetchData</code> ，這裡可以搭配 <code>useContext</code>，使用 Provider 包住的元件可以根據 query 改變而更新資料包。<br>
👉 <a href="https://codesandbox.io/s/festive-fermi-1cms7c?file=/src/index.js">codesandbox 簡易查詢各國代碼 API</a></p>
<p>列出功能 :</p>
<ol>
<li>Provider 包住的元件，使用 <code>useFetchData</code> 就可以拿到回傳的資料。</li>
<li>當 query 改變時重新獲取資料</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext, useMemo, useState, useEffect, useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本網址</span></span><br><span class="line"><span class="keyword">let</span> baseurl = <span class="string">&quot;https://restcountries.com/v3.1/name/&quot;</span>;</span><br><span class="line"><span class="comment">// 建立 context，如此一來包住的元件都可以直接用 useFetchData 取的共享值</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Context</span> = <span class="title function_">createContext</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 修一下名字方便 debug</span></span><br><span class="line"><span class="title class_">Context</span>.<span class="property">displayName</span> = <span class="string">&quot;FetchDataContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 Provider 元件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DataProvider</span>(<span class="params">&#123; children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&quot;tw&quot;</span>);</span><br><span class="line">  <span class="comment">// 避免造成 value re-render ，把 value 記憶起來，直到改變 query</span></span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      query,</span><br><span class="line">      setQuery</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [query]);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom Hooks </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useFetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 這一段主要確認上方是否有 Provider 的防呆</span></span><br><span class="line">  <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">Context</span>);</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;useCount must be used within a CountProvider&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 確定有後把 context 解構比較好讀</span></span><br><span class="line">  <span class="keyword">const</span> &#123; query, setQuery &#125; = context;</span><br><span class="line">  <span class="comment">// 讀取回來的資料</span></span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// 錯誤處理</span></span><br><span class="line">  <span class="keyword">const</span> [message, setMessage] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (query) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(baseurl + query).<span class="title function_">then</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> r.<span class="title function_">json</span>());</span><br><span class="line">        <span class="comment">// 回傳不是 404 時判斷</span></span><br><span class="line">        <span class="keyword">if</span> (!data.<span class="property">status</span>) &#123;</span><br><span class="line">          <span class="title function_">setData</span>(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 回傳 status 為 404 設定錯誤資訊</span></span><br><span class="line">          <span class="title function_">setMessage</span>(data.<span class="property">message</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setMessage</span>(<span class="literal">null</span>); <span class="comment">// 清除錯誤資訊</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [query]); <span class="comment">// 👈 deps 放入 query</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回傳需要的值</span></span><br><span class="line">  <span class="keyword">return</span> &#123; data, query, setQuery, message &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包回傳</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">DataProvider</span>, useFetchData &#125;;</span><br></pre></td></tr></table></figure>
<p>寫成 Hooks 時在使用就很方便，只要在同一層共享的部份加上 Provider ，內部元件都使用 <code>useFetchData</code> 就能拿到想要的內容👍</p>
<p>當然這個例子可以再改進，例如 input 的部份可以改用 option，由第一次進入 app 先取得所有國家國碼，這樣使用者可以用選單的方式進行。</p>
<h2 id="談談競爭條件-race-condition">談談競爭條件 (race condition)</h2>
<p>什麼是競爭條件呢 ?</p>
<p>在 JavaScript 中跟競爭條件有關的是非同步的問題，如上面舉例的 <code>fetchData</code> 。<strong>如果在非同步操作的未完成的時候，中途改變 state 或 props 會導致非預期的事情發生。</strong><br>
👉 可以參考這篇文章 : <a href="https://toy9986619.medium.com/javascript-async-await-%E7%9A%84-race-condition-20927705569">JavaScript — async/await 的 race condition</a></p>
<blockquote>
<p>簡單來說跟執行順序有關</p>
</blockquote>
<p>以 <code>fetchData</code> 為例，我們用 async/await 簡化非同步的處理，內部的 fetch 是 Promise，如果在 pending 的時候又改變 state 重新獲取資料，就會發生問題。</p>
<p>例如 : 一開始搜尋 usa，在結果還沒返回時改成 peru，假設 usa 資料先回來並且顯示在畫面上，過一下子最終 peru 的 response 才會回來 。<strong>畫面等待 peru 資料回傳時顯示 usa 資料的時候 input 是 peru 呀 !</strong>  造成 UI 跟 state 對不上了😵。</p>
<p>如果要模仿此動作，可以到 devtool 的 network 並且自訂速度，這邊我訂了一個叫 <code>superslow</code>，把 Download 設為 1kb，讓回傳間隔變長就比較清楚問題。<br>
<img data-src="https://i.imgur.com/Hh8l045.png" alt="|400x220"></p>
<p>怎麼避免或是解決此狀況呢 ? 🤔</p>
<p>要知道 React 的 <code>useEffect</code> 並不會幫我們處理這個問題，最好的方式是可以讓非同步被中斷 (abort)，並且在 clean up 的階段取消。另外一個方法是，<strong>在把回傳資料放入 state 之前，用 <code>boolean</code> 檢查目前狀態是否要取消。</strong> 因為在執行下一個 effect 之前，會先執行 clean up function。</p>
<p>既然我們上面有實作，那就來改造上面的例子 :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 👉 建立當次 render 的 didCancel</span></span><br><span class="line">    <span class="keyword">let</span> didCancel = <span class="literal">false</span>;</span><br><span class="line">    (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (query) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(baseurl + query).<span class="title function_">then</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> r.<span class="title function_">json</span>());</span><br><span class="line">        <span class="comment">// 檢查是不是有取消 ?</span></span><br><span class="line">        <span class="keyword">if</span> (!didCancel) &#123;</span><br><span class="line">          <span class="title function_">setData</span>(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">setMessage</span>(data.<span class="property">message</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 在下一個 effect 執行前，確定取消</span></span><br><span class="line">      didCancel = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">setMessage</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [query]);</span><br></pre></td></tr></table></figure>
<p>情境 :</p>
<ol>
<li>顯示畫面後改搜尋 usa</li>
<li>資料還沒返回，改成 peru</li>
</ol>
<p>我們來執行看看，從第一次 render 完之後 :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// input 改成 usa</span></span><br><span class="line">setState query = <span class="string">&quot;usa&quot;</span></span><br><span class="line">re-render <span class="variable constant_">UI</span></span><br><span class="line"></span><br><span class="line">clean up 清除 tw 副作用</span><br><span class="line">  state query <span class="string">&quot;tw&quot;</span></span><br><span class="line">  didCancel = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">effect 執行</span><br><span class="line">  state query <span class="string">&quot;usa&quot;</span></span><br><span class="line">  didCancel = <span class="literal">false</span></span><br><span class="line">  🚀<span class="keyword">async</span> <span class="keyword">function</span> 執行，進入 pending 狀態</span><br><span class="line"></span><br><span class="line"><span class="comment">// input 改成 peru</span></span><br><span class="line">  setState query = <span class="string">&quot;peru&quot;</span></span><br><span class="line">  re-render <span class="variable constant_">UI</span></span><br><span class="line"></span><br><span class="line">clean up 清除 usa 副作用</span><br><span class="line">  state query <span class="string">&quot;usa&quot;</span></span><br><span class="line">  didCancel = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">effect 執行</span><br><span class="line">  state query <span class="string">&quot;peru&quot;</span></span><br><span class="line">  didCancel = <span class="literal">false</span></span><br><span class="line">  🚀<span class="keyword">async</span> <span class="keyword">function</span>  執行，進入 pending 狀態</span><br><span class="line"></span><br><span class="line">👉 usa 資料回來了</span><br><span class="line">  usa clean effect 已經被呼叫，此時 didCancel 是 <span class="literal">true</span> 😵</span><br><span class="line">  ❌ setData 不會被執行</span><br><span class="line"></span><br><span class="line">👉 最後 peru 資料回來了</span><br><span class="line">  didCancel 是 <span class="literal">false</span> </span><br><span class="line">  setData 會執行</span><br><span class="line">  顯示 peru 資料</span><br></pre></td></tr></table></figure>
<p>一開始從上面看起來 <code>usa</code> 資料回來為什麼 <code>didCancel = true</code> 🤔，明明 <code>peru</code> 的 effect 執行了 <code>didCancel = false</code>。回到順序問題，在 <code>usa</code> 這個 render 時，我們的 <code>didCancel</code> 最後是什麼 ?</p>
<p>我一開始覺得很微妙，所以再回去複習 [[#談談 clean up]] 這個章節。</p>
<blockquote>
<p>每一個在 render 內部呼叫的 function (包含 handlers 、effect 等瀏覽器 APIs )，都會拿到當下定義的 state 。</p>
</blockquote>
<p>單看在 <code>usa</code> 這次 render 執行順序應該是 :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">usa-didCancel = <span class="literal">false</span></span><br><span class="line">🚀<span class="keyword">async</span> <span class="keyword">function</span> 進行 fetch data</span><br><span class="line">  </span><br><span class="line">peru 的到來觸發了 use-clean up <span class="keyword">function</span></span><br><span class="line">  usa-didCancel = <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">usa 資料回來 data = ...</span><br><span class="line"><span class="keyword">if</span> (usa-didCancel = <span class="literal">true</span>)</span><br><span class="line">❌ setData 這行不會被執行</span><br></pre></td></tr></table></figure>
<p>在釐清概念的過程，我是使用 console 在每一個階段印出當時的 query ，幫助自己了解 effect 一值提到的 <strong>同步</strong> 概念</p>
<h2 id="用正確的心態對待-useEffect">用正確的心態對待 useEffect</h2>
<p><code>useEffect</code> 雖然很常被用在非同步讀取資料，但 <strong><code>useEffect</code> 是核心思想是來做同步的操作</strong>。 side effects 變成資料流的一部分，只要我們的當次 render 的資料同步，取得的資料也是一致的，對於邊際條件 (edge case) 的處理就會比較容易。</p>
<p>不過 React 在 18 版本對於處理非同步事件比較建議使用 <strong>Suspense</strong>。Suspense 是一個可以讓還沒準備好可以 render 的 UI 可以顯示預設的 Component ，主要要解決 2 個問題</p>
<ol>
<li>code splitting : 不用把一次所有 app 元件載下來，而是載必要的</li>
<li>data fetching : 解決像是上面提到的 race condition 問題</li>
</ol>
<p>不過 Suspense 我也還沒認真研究過 😵，先列入補坑大隊的名單吧</p>
<h2 id="總結-31">總結</h2>
<ol>
<li><code>useEffect</code> 是 render 與瀏覽器 painting 之後執行，目的是不阻攔螢幕的更新。</li>
<li><code>useEffect</code> deps array 如果是空的，僅執行一次，如果 array 有 state 或 props ，根據資料是否有改變，會跟著當次 render 之後重新呼叫。</li>
<li>每一次 render 都保有它所有的東西，包含 event handler、非同步 (async/await)、effect 或是 API ，以及當次 render 的 state 與 props。</li>
<li>想拿到最新的值可以使用 <code>refs</code>，refs 就像放在外部的盒子，React 確保它都指向同一記憶體位址，改變其值也不會造成 re-render。</li>
<li>clean up function 會在下一個 effect 呼叫之前先執行，注意 clean up 所清除的是上一次 render 的值。</li>
<li>不要欺騙 deps array，通常 lint 會提醒，但是遇到 object type 的值要小心，可能造成過度頻繁更新。</li>
<li><code>useEffect</code> 的 deps array 是否要放入相關 state 或 props ，可以視 effect function 中的 state 變化是否可由 <code>prevState</code> 推測出來，如果可以可使用 updater function 來更新。</li>
<li>useReducer 是可以讓資料跟邏輯分開操作的好方法。</li>
<li><code>useCallback</code> 是可以記住 render 內的 function，使其每次不應 re-render 而重新建立，或是透過 callback 的 deps array 來優化。如果不是 function 則可以使用 <code>useMemo</code> 記住某值。</li>
<li>function 在 function component 與 Hooks 中是一種資料流。它可以透過 props 來傳遞，也可以被判斷是否為 render 的條件之一。記住，此行為跟 class component 不一樣。</li>
<li>useEffect 是處理同步的操作，確保每一次 render  的 state 或 props 與 UI 具有一致性。</li>
</ol>
<p>本篇雖然著重於 <code>useEffect</code>  ，但對於新手一連貫認識 React 概念釐清很有幫助。讀完可以說是醍醐灌頂，從 class Component 到 function Component 的轉變，其解決的原因；function Component 使用的心智模型 (也就是核心概念)，更了解 Hooks 的思維與結合 JavaScript closure 的奧妙，讓人讀完有一種</p>
<blockquote>
<p>「原來是這樣的阿 !」</p>
</blockquote>
<p>雖然閱讀過程很艱辛😵，因為我是生啃英文版，沒有選擇中文是擔心無法領會翻譯者的意思，不是怕翻不好，而是擔心翻譯者水平太高，反而我看不懂🤣。幸好 Dan 大的文章本身對小白很友善，很值得用原文一讀👍</p>
<h3 id="題外話">題外話</h3>
<p>這段期間校正本篇文章時，FB 社團 <a href="https://www.facebook.com/groups/reactjs.tw/">ReactJS.tw</a>  也正好有大神做同樣的主題 <a href="https://slides.com/tz5514/useeffect-guide?fbclid=IwAR2VdZODJPO8Ex1Kd7PksCRA4dakIVvY-4aJ3X3ZtgfSwgq7hOGE6qHvcNc">都 2022 年了你還是可能不懂 useEffect</a>。整理出的脈絡清晰，也有提到 React 18 為什麼嚴格模式會執行兩次的問題。目前我還沒完全看完，但我認為看不同的人解釋同篇文章也是很有值得學習的地方，畢竟新手跟老手的認知起點不同😂，很慶幸正好在學習 useEffect  同時遇到大神的簡報與演講，遇到觀念卡住時，我也會翻到大神的簡報去彌補我不懂的地方。</p>
<p>有一度想以簡報的內容去重新整理文章，但想想這也我學習 useEffect 的原汁原味學習過程，就全保留了🤓。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">render 內部 function 的執行點 : <a href="https://codesandbox.io/s/w2wxl3yo0l">w2wxl3yo0l - CodeSandbox</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">function 版本 : setTimeout 之依序印出 state <a href="https://codesandbox.io/s/lyx20m1ol">lyx20m1ol - CodeSandbox</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">class 版本 : setTimeout 之全部同時一樣的 state <a href="https://codesandbox.io/s/kkymzwjqz3">kkymzwjqz3 - CodeSandbox</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://reactjs.org/docs/hooks-reference.html#functional-updates">Hooks API Reference – React – functional-updates</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>Front-end</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
</search>
